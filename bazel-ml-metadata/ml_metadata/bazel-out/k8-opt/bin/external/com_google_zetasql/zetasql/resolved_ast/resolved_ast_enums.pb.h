// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zetasql/resolved_ast/resolved_ast_enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
namespace zetasql {
class ResolvedAggregateHavingModifierEnums;
struct ResolvedAggregateHavingModifierEnumsDefaultTypeInternal;
extern ResolvedAggregateHavingModifierEnumsDefaultTypeInternal _ResolvedAggregateHavingModifierEnums_default_instance_;
class ResolvedArgumentDefEnums;
struct ResolvedArgumentDefEnumsDefaultTypeInternal;
extern ResolvedArgumentDefEnumsDefaultTypeInternal _ResolvedArgumentDefEnums_default_instance_;
class ResolvedAuxLoadDataStmtEnums;
struct ResolvedAuxLoadDataStmtEnumsDefaultTypeInternal;
extern ResolvedAuxLoadDataStmtEnumsDefaultTypeInternal _ResolvedAuxLoadDataStmtEnums_default_instance_;
class ResolvedBeginStmtEnums;
struct ResolvedBeginStmtEnumsDefaultTypeInternal;
extern ResolvedBeginStmtEnumsDefaultTypeInternal _ResolvedBeginStmtEnums_default_instance_;
class ResolvedCreateStatementEnums;
struct ResolvedCreateStatementEnumsDefaultTypeInternal;
extern ResolvedCreateStatementEnumsDefaultTypeInternal _ResolvedCreateStatementEnums_default_instance_;
class ResolvedDropStmtEnums;
struct ResolvedDropStmtEnumsDefaultTypeInternal;
extern ResolvedDropStmtEnumsDefaultTypeInternal _ResolvedDropStmtEnums_default_instance_;
class ResolvedForeignKeyEnums;
struct ResolvedForeignKeyEnumsDefaultTypeInternal;
extern ResolvedForeignKeyEnumsDefaultTypeInternal _ResolvedForeignKeyEnums_default_instance_;
class ResolvedFunctionCallBaseEnums;
struct ResolvedFunctionCallBaseEnumsDefaultTypeInternal;
extern ResolvedFunctionCallBaseEnumsDefaultTypeInternal _ResolvedFunctionCallBaseEnums_default_instance_;
class ResolvedGeneratedColumnInfoEnums;
struct ResolvedGeneratedColumnInfoEnumsDefaultTypeInternal;
extern ResolvedGeneratedColumnInfoEnumsDefaultTypeInternal _ResolvedGeneratedColumnInfoEnums_default_instance_;
class ResolvedImportStmtEnums;
struct ResolvedImportStmtEnumsDefaultTypeInternal;
extern ResolvedImportStmtEnumsDefaultTypeInternal _ResolvedImportStmtEnums_default_instance_;
class ResolvedInsertStmtEnums;
struct ResolvedInsertStmtEnumsDefaultTypeInternal;
extern ResolvedInsertStmtEnumsDefaultTypeInternal _ResolvedInsertStmtEnums_default_instance_;
class ResolvedJoinScanEnums;
struct ResolvedJoinScanEnumsDefaultTypeInternal;
extern ResolvedJoinScanEnumsDefaultTypeInternal _ResolvedJoinScanEnums_default_instance_;
class ResolvedMergeWhenEnums;
struct ResolvedMergeWhenEnumsDefaultTypeInternal;
extern ResolvedMergeWhenEnumsDefaultTypeInternal _ResolvedMergeWhenEnums_default_instance_;
class ResolvedNonScalarFunctionCallBaseEnums;
struct ResolvedNonScalarFunctionCallBaseEnumsDefaultTypeInternal;
extern ResolvedNonScalarFunctionCallBaseEnumsDefaultTypeInternal _ResolvedNonScalarFunctionCallBaseEnums_default_instance_;
class ResolvedOrderByItemEnums;
struct ResolvedOrderByItemEnumsDefaultTypeInternal;
extern ResolvedOrderByItemEnumsDefaultTypeInternal _ResolvedOrderByItemEnums_default_instance_;
class ResolvedRecursiveScanEnums;
struct ResolvedRecursiveScanEnumsDefaultTypeInternal;
extern ResolvedRecursiveScanEnumsDefaultTypeInternal _ResolvedRecursiveScanEnums_default_instance_;
class ResolvedSampleScanEnums;
struct ResolvedSampleScanEnumsDefaultTypeInternal;
extern ResolvedSampleScanEnumsDefaultTypeInternal _ResolvedSampleScanEnums_default_instance_;
class ResolvedSetOperationScanEnums;
struct ResolvedSetOperationScanEnumsDefaultTypeInternal;
extern ResolvedSetOperationScanEnumsDefaultTypeInternal _ResolvedSetOperationScanEnums_default_instance_;
class ResolvedStatementEnums;
struct ResolvedStatementEnumsDefaultTypeInternal;
extern ResolvedStatementEnumsDefaultTypeInternal _ResolvedStatementEnums_default_instance_;
class ResolvedSubqueryExprEnums;
struct ResolvedSubqueryExprEnumsDefaultTypeInternal;
extern ResolvedSubqueryExprEnumsDefaultTypeInternal _ResolvedSubqueryExprEnums_default_instance_;
class ResolvedWindowFrameEnums;
struct ResolvedWindowFrameEnumsDefaultTypeInternal;
extern ResolvedWindowFrameEnumsDefaultTypeInternal _ResolvedWindowFrameEnums_default_instance_;
class ResolvedWindowFrameExprEnums;
struct ResolvedWindowFrameExprEnumsDefaultTypeInternal;
extern ResolvedWindowFrameExprEnumsDefaultTypeInternal _ResolvedWindowFrameExprEnums_default_instance_;
}  // namespace zetasql
PROTOBUF_NAMESPACE_OPEN
template<> ::zetasql::ResolvedAggregateHavingModifierEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedAggregateHavingModifierEnums>(Arena*);
template<> ::zetasql::ResolvedArgumentDefEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedArgumentDefEnums>(Arena*);
template<> ::zetasql::ResolvedAuxLoadDataStmtEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedAuxLoadDataStmtEnums>(Arena*);
template<> ::zetasql::ResolvedBeginStmtEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedBeginStmtEnums>(Arena*);
template<> ::zetasql::ResolvedCreateStatementEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedCreateStatementEnums>(Arena*);
template<> ::zetasql::ResolvedDropStmtEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedDropStmtEnums>(Arena*);
template<> ::zetasql::ResolvedForeignKeyEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedForeignKeyEnums>(Arena*);
template<> ::zetasql::ResolvedFunctionCallBaseEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedFunctionCallBaseEnums>(Arena*);
template<> ::zetasql::ResolvedGeneratedColumnInfoEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedGeneratedColumnInfoEnums>(Arena*);
template<> ::zetasql::ResolvedImportStmtEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedImportStmtEnums>(Arena*);
template<> ::zetasql::ResolvedInsertStmtEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedInsertStmtEnums>(Arena*);
template<> ::zetasql::ResolvedJoinScanEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedJoinScanEnums>(Arena*);
template<> ::zetasql::ResolvedMergeWhenEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedMergeWhenEnums>(Arena*);
template<> ::zetasql::ResolvedNonScalarFunctionCallBaseEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedNonScalarFunctionCallBaseEnums>(Arena*);
template<> ::zetasql::ResolvedOrderByItemEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedOrderByItemEnums>(Arena*);
template<> ::zetasql::ResolvedRecursiveScanEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedRecursiveScanEnums>(Arena*);
template<> ::zetasql::ResolvedSampleScanEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedSampleScanEnums>(Arena*);
template<> ::zetasql::ResolvedSetOperationScanEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedSetOperationScanEnums>(Arena*);
template<> ::zetasql::ResolvedStatementEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedStatementEnums>(Arena*);
template<> ::zetasql::ResolvedSubqueryExprEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedSubqueryExprEnums>(Arena*);
template<> ::zetasql::ResolvedWindowFrameEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedWindowFrameEnums>(Arena*);
template<> ::zetasql::ResolvedWindowFrameExprEnums* Arena::CreateMaybeMessage<::zetasql::ResolvedWindowFrameExprEnums>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zetasql {

enum ResolvedSubqueryExprEnums_SubqueryType : int {
  ResolvedSubqueryExprEnums_SubqueryType_SCALAR = 0,
  ResolvedSubqueryExprEnums_SubqueryType_ARRAY = 1,
  ResolvedSubqueryExprEnums_SubqueryType_EXISTS = 2,
  ResolvedSubqueryExprEnums_SubqueryType_IN = 3,
  ResolvedSubqueryExprEnums_SubqueryType_LIKE_ANY = 4,
  ResolvedSubqueryExprEnums_SubqueryType_LIKE_ALL = 5
};
bool ResolvedSubqueryExprEnums_SubqueryType_IsValid(int value);
constexpr ResolvedSubqueryExprEnums_SubqueryType ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_MIN = ResolvedSubqueryExprEnums_SubqueryType_SCALAR;
constexpr ResolvedSubqueryExprEnums_SubqueryType ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_MAX = ResolvedSubqueryExprEnums_SubqueryType_LIKE_ALL;
constexpr int ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_ARRAYSIZE = ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedSubqueryExprEnums_SubqueryType_descriptor();
template<typename T>
inline const std::string& ResolvedSubqueryExprEnums_SubqueryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedSubqueryExprEnums_SubqueryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedSubqueryExprEnums_SubqueryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedSubqueryExprEnums_SubqueryType_descriptor(), enum_t_value);
}
inline bool ResolvedSubqueryExprEnums_SubqueryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedSubqueryExprEnums_SubqueryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedSubqueryExprEnums_SubqueryType>(
    ResolvedSubqueryExprEnums_SubqueryType_descriptor(), name, value);
}
enum ResolvedJoinScanEnums_JoinType : int {
  ResolvedJoinScanEnums_JoinType_INNER = 0,
  ResolvedJoinScanEnums_JoinType_LEFT = 1,
  ResolvedJoinScanEnums_JoinType_RIGHT = 2,
  ResolvedJoinScanEnums_JoinType_FULL = 3
};
bool ResolvedJoinScanEnums_JoinType_IsValid(int value);
constexpr ResolvedJoinScanEnums_JoinType ResolvedJoinScanEnums_JoinType_JoinType_MIN = ResolvedJoinScanEnums_JoinType_INNER;
constexpr ResolvedJoinScanEnums_JoinType ResolvedJoinScanEnums_JoinType_JoinType_MAX = ResolvedJoinScanEnums_JoinType_FULL;
constexpr int ResolvedJoinScanEnums_JoinType_JoinType_ARRAYSIZE = ResolvedJoinScanEnums_JoinType_JoinType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedJoinScanEnums_JoinType_descriptor();
template<typename T>
inline const std::string& ResolvedJoinScanEnums_JoinType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedJoinScanEnums_JoinType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedJoinScanEnums_JoinType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedJoinScanEnums_JoinType_descriptor(), enum_t_value);
}
inline bool ResolvedJoinScanEnums_JoinType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedJoinScanEnums_JoinType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedJoinScanEnums_JoinType>(
    ResolvedJoinScanEnums_JoinType_descriptor(), name, value);
}
enum ResolvedSetOperationScanEnums_SetOperationType : int {
  ResolvedSetOperationScanEnums_SetOperationType_UNION_ALL = 0,
  ResolvedSetOperationScanEnums_SetOperationType_UNION_DISTINCT = 1,
  ResolvedSetOperationScanEnums_SetOperationType_INTERSECT_ALL = 2,
  ResolvedSetOperationScanEnums_SetOperationType_INTERSECT_DISTINCT = 3,
  ResolvedSetOperationScanEnums_SetOperationType_EXCEPT_ALL = 4,
  ResolvedSetOperationScanEnums_SetOperationType_EXCEPT_DISTINCT = 5
};
bool ResolvedSetOperationScanEnums_SetOperationType_IsValid(int value);
constexpr ResolvedSetOperationScanEnums_SetOperationType ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_MIN = ResolvedSetOperationScanEnums_SetOperationType_UNION_ALL;
constexpr ResolvedSetOperationScanEnums_SetOperationType ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_MAX = ResolvedSetOperationScanEnums_SetOperationType_EXCEPT_DISTINCT;
constexpr int ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_ARRAYSIZE = ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedSetOperationScanEnums_SetOperationType_descriptor();
template<typename T>
inline const std::string& ResolvedSetOperationScanEnums_SetOperationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedSetOperationScanEnums_SetOperationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedSetOperationScanEnums_SetOperationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedSetOperationScanEnums_SetOperationType_descriptor(), enum_t_value);
}
inline bool ResolvedSetOperationScanEnums_SetOperationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedSetOperationScanEnums_SetOperationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedSetOperationScanEnums_SetOperationType>(
    ResolvedSetOperationScanEnums_SetOperationType_descriptor(), name, value);
}
enum ResolvedRecursiveScanEnums_RecursiveSetOperationType : int {
  ResolvedRecursiveScanEnums_RecursiveSetOperationType_UNION_ALL = 0,
  ResolvedRecursiveScanEnums_RecursiveSetOperationType_UNION_DISTINCT = 1
};
bool ResolvedRecursiveScanEnums_RecursiveSetOperationType_IsValid(int value);
constexpr ResolvedRecursiveScanEnums_RecursiveSetOperationType ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_MIN = ResolvedRecursiveScanEnums_RecursiveSetOperationType_UNION_ALL;
constexpr ResolvedRecursiveScanEnums_RecursiveSetOperationType ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_MAX = ResolvedRecursiveScanEnums_RecursiveSetOperationType_UNION_DISTINCT;
constexpr int ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_ARRAYSIZE = ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedRecursiveScanEnums_RecursiveSetOperationType_descriptor();
template<typename T>
inline const std::string& ResolvedRecursiveScanEnums_RecursiveSetOperationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedRecursiveScanEnums_RecursiveSetOperationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedRecursiveScanEnums_RecursiveSetOperationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_descriptor(), enum_t_value);
}
inline bool ResolvedRecursiveScanEnums_RecursiveSetOperationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedRecursiveScanEnums_RecursiveSetOperationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedRecursiveScanEnums_RecursiveSetOperationType>(
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_descriptor(), name, value);
}
enum ResolvedSampleScanEnums_SampleUnit : int {
  ResolvedSampleScanEnums_SampleUnit_ROWS = 0,
  ResolvedSampleScanEnums_SampleUnit_PERCENT = 1
};
bool ResolvedSampleScanEnums_SampleUnit_IsValid(int value);
constexpr ResolvedSampleScanEnums_SampleUnit ResolvedSampleScanEnums_SampleUnit_SampleUnit_MIN = ResolvedSampleScanEnums_SampleUnit_ROWS;
constexpr ResolvedSampleScanEnums_SampleUnit ResolvedSampleScanEnums_SampleUnit_SampleUnit_MAX = ResolvedSampleScanEnums_SampleUnit_PERCENT;
constexpr int ResolvedSampleScanEnums_SampleUnit_SampleUnit_ARRAYSIZE = ResolvedSampleScanEnums_SampleUnit_SampleUnit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedSampleScanEnums_SampleUnit_descriptor();
template<typename T>
inline const std::string& ResolvedSampleScanEnums_SampleUnit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedSampleScanEnums_SampleUnit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedSampleScanEnums_SampleUnit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedSampleScanEnums_SampleUnit_descriptor(), enum_t_value);
}
inline bool ResolvedSampleScanEnums_SampleUnit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedSampleScanEnums_SampleUnit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedSampleScanEnums_SampleUnit>(
    ResolvedSampleScanEnums_SampleUnit_descriptor(), name, value);
}
enum ResolvedOrderByItemEnums_NullOrderMode : int {
  ResolvedOrderByItemEnums_NullOrderMode_ORDER_UNSPECIFIED = 0,
  ResolvedOrderByItemEnums_NullOrderMode_NULLS_FIRST = 1,
  ResolvedOrderByItemEnums_NullOrderMode_NULLS_LAST = 2
};
bool ResolvedOrderByItemEnums_NullOrderMode_IsValid(int value);
constexpr ResolvedOrderByItemEnums_NullOrderMode ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_MIN = ResolvedOrderByItemEnums_NullOrderMode_ORDER_UNSPECIFIED;
constexpr ResolvedOrderByItemEnums_NullOrderMode ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_MAX = ResolvedOrderByItemEnums_NullOrderMode_NULLS_LAST;
constexpr int ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_ARRAYSIZE = ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedOrderByItemEnums_NullOrderMode_descriptor();
template<typename T>
inline const std::string& ResolvedOrderByItemEnums_NullOrderMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedOrderByItemEnums_NullOrderMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedOrderByItemEnums_NullOrderMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedOrderByItemEnums_NullOrderMode_descriptor(), enum_t_value);
}
inline bool ResolvedOrderByItemEnums_NullOrderMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedOrderByItemEnums_NullOrderMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedOrderByItemEnums_NullOrderMode>(
    ResolvedOrderByItemEnums_NullOrderMode_descriptor(), name, value);
}
enum ResolvedCreateStatementEnums_CreateScope : int {
  ResolvedCreateStatementEnums_CreateScope_CREATE_DEFAULT_SCOPE = 0,
  ResolvedCreateStatementEnums_CreateScope_CREATE_PRIVATE = 1,
  ResolvedCreateStatementEnums_CreateScope_CREATE_PUBLIC = 2,
  ResolvedCreateStatementEnums_CreateScope_CREATE_TEMP = 3
};
bool ResolvedCreateStatementEnums_CreateScope_IsValid(int value);
constexpr ResolvedCreateStatementEnums_CreateScope ResolvedCreateStatementEnums_CreateScope_CreateScope_MIN = ResolvedCreateStatementEnums_CreateScope_CREATE_DEFAULT_SCOPE;
constexpr ResolvedCreateStatementEnums_CreateScope ResolvedCreateStatementEnums_CreateScope_CreateScope_MAX = ResolvedCreateStatementEnums_CreateScope_CREATE_TEMP;
constexpr int ResolvedCreateStatementEnums_CreateScope_CreateScope_ARRAYSIZE = ResolvedCreateStatementEnums_CreateScope_CreateScope_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedCreateStatementEnums_CreateScope_descriptor();
template<typename T>
inline const std::string& ResolvedCreateStatementEnums_CreateScope_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedCreateStatementEnums_CreateScope>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedCreateStatementEnums_CreateScope_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedCreateStatementEnums_CreateScope_descriptor(), enum_t_value);
}
inline bool ResolvedCreateStatementEnums_CreateScope_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedCreateStatementEnums_CreateScope* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedCreateStatementEnums_CreateScope>(
    ResolvedCreateStatementEnums_CreateScope_descriptor(), name, value);
}
enum ResolvedCreateStatementEnums_CreateMode : int {
  ResolvedCreateStatementEnums_CreateMode_CREATE_DEFAULT = 0,
  ResolvedCreateStatementEnums_CreateMode_CREATE_OR_REPLACE = 1,
  ResolvedCreateStatementEnums_CreateMode_CREATE_IF_NOT_EXISTS = 2
};
bool ResolvedCreateStatementEnums_CreateMode_IsValid(int value);
constexpr ResolvedCreateStatementEnums_CreateMode ResolvedCreateStatementEnums_CreateMode_CreateMode_MIN = ResolvedCreateStatementEnums_CreateMode_CREATE_DEFAULT;
constexpr ResolvedCreateStatementEnums_CreateMode ResolvedCreateStatementEnums_CreateMode_CreateMode_MAX = ResolvedCreateStatementEnums_CreateMode_CREATE_IF_NOT_EXISTS;
constexpr int ResolvedCreateStatementEnums_CreateMode_CreateMode_ARRAYSIZE = ResolvedCreateStatementEnums_CreateMode_CreateMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedCreateStatementEnums_CreateMode_descriptor();
template<typename T>
inline const std::string& ResolvedCreateStatementEnums_CreateMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedCreateStatementEnums_CreateMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedCreateStatementEnums_CreateMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedCreateStatementEnums_CreateMode_descriptor(), enum_t_value);
}
inline bool ResolvedCreateStatementEnums_CreateMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedCreateStatementEnums_CreateMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedCreateStatementEnums_CreateMode>(
    ResolvedCreateStatementEnums_CreateMode_descriptor(), name, value);
}
enum ResolvedCreateStatementEnums_SqlSecurity : int {
  ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED = 0,
  ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_DEFINER = 1,
  ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER = 2
};
bool ResolvedCreateStatementEnums_SqlSecurity_IsValid(int value);
constexpr ResolvedCreateStatementEnums_SqlSecurity ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_MIN = ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED;
constexpr ResolvedCreateStatementEnums_SqlSecurity ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_MAX = ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER;
constexpr int ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_ARRAYSIZE = ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedCreateStatementEnums_SqlSecurity_descriptor();
template<typename T>
inline const std::string& ResolvedCreateStatementEnums_SqlSecurity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedCreateStatementEnums_SqlSecurity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedCreateStatementEnums_SqlSecurity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedCreateStatementEnums_SqlSecurity_descriptor(), enum_t_value);
}
inline bool ResolvedCreateStatementEnums_SqlSecurity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedCreateStatementEnums_SqlSecurity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedCreateStatementEnums_SqlSecurity>(
    ResolvedCreateStatementEnums_SqlSecurity_descriptor(), name, value);
}
enum ResolvedCreateStatementEnums_DeterminismLevel : int {
  ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED = 0,
  ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_DETERMINISTIC = 1,
  ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_NOT_DETERMINISTIC = 2,
  ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_IMMUTABLE = 3,
  ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_STABLE = 4,
  ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_VOLATILE = 5
};
bool ResolvedCreateStatementEnums_DeterminismLevel_IsValid(int value);
constexpr ResolvedCreateStatementEnums_DeterminismLevel ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_MIN = ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED;
constexpr ResolvedCreateStatementEnums_DeterminismLevel ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_MAX = ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_VOLATILE;
constexpr int ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_ARRAYSIZE = ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedCreateStatementEnums_DeterminismLevel_descriptor();
template<typename T>
inline const std::string& ResolvedCreateStatementEnums_DeterminismLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedCreateStatementEnums_DeterminismLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedCreateStatementEnums_DeterminismLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedCreateStatementEnums_DeterminismLevel_descriptor(), enum_t_value);
}
inline bool ResolvedCreateStatementEnums_DeterminismLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedCreateStatementEnums_DeterminismLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedCreateStatementEnums_DeterminismLevel>(
    ResolvedCreateStatementEnums_DeterminismLevel_descriptor(), name, value);
}
enum ResolvedGeneratedColumnInfoEnums_StoredMode : int {
  ResolvedGeneratedColumnInfoEnums_StoredMode_NON_STORED = 0,
  ResolvedGeneratedColumnInfoEnums_StoredMode_STORED = 1,
  ResolvedGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE = 2
};
bool ResolvedGeneratedColumnInfoEnums_StoredMode_IsValid(int value);
constexpr ResolvedGeneratedColumnInfoEnums_StoredMode ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_MIN = ResolvedGeneratedColumnInfoEnums_StoredMode_NON_STORED;
constexpr ResolvedGeneratedColumnInfoEnums_StoredMode ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX = ResolvedGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE;
constexpr int ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_ARRAYSIZE = ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedGeneratedColumnInfoEnums_StoredMode_descriptor();
template<typename T>
inline const std::string& ResolvedGeneratedColumnInfoEnums_StoredMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedGeneratedColumnInfoEnums_StoredMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedGeneratedColumnInfoEnums_StoredMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedGeneratedColumnInfoEnums_StoredMode_descriptor(), enum_t_value);
}
inline bool ResolvedGeneratedColumnInfoEnums_StoredMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedGeneratedColumnInfoEnums_StoredMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedGeneratedColumnInfoEnums_StoredMode>(
    ResolvedGeneratedColumnInfoEnums_StoredMode_descriptor(), name, value);
}
enum ResolvedDropStmtEnums_DropMode : int {
  ResolvedDropStmtEnums_DropMode_DROP_MODE_UNSPECIFIED = 0,
  ResolvedDropStmtEnums_DropMode_RESTRICT = 1,
  ResolvedDropStmtEnums_DropMode_CASCADE = 2
};
bool ResolvedDropStmtEnums_DropMode_IsValid(int value);
constexpr ResolvedDropStmtEnums_DropMode ResolvedDropStmtEnums_DropMode_DropMode_MIN = ResolvedDropStmtEnums_DropMode_DROP_MODE_UNSPECIFIED;
constexpr ResolvedDropStmtEnums_DropMode ResolvedDropStmtEnums_DropMode_DropMode_MAX = ResolvedDropStmtEnums_DropMode_CASCADE;
constexpr int ResolvedDropStmtEnums_DropMode_DropMode_ARRAYSIZE = ResolvedDropStmtEnums_DropMode_DropMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedDropStmtEnums_DropMode_descriptor();
template<typename T>
inline const std::string& ResolvedDropStmtEnums_DropMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedDropStmtEnums_DropMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedDropStmtEnums_DropMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedDropStmtEnums_DropMode_descriptor(), enum_t_value);
}
inline bool ResolvedDropStmtEnums_DropMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedDropStmtEnums_DropMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedDropStmtEnums_DropMode>(
    ResolvedDropStmtEnums_DropMode_descriptor(), name, value);
}
enum ResolvedBeginStmtEnums_ReadWriteMode : int {
  ResolvedBeginStmtEnums_ReadWriteMode_MODE_UNSPECIFIED = 0,
  ResolvedBeginStmtEnums_ReadWriteMode_MODE_READ_ONLY = 1,
  ResolvedBeginStmtEnums_ReadWriteMode_MODE_READ_WRITE = 2
};
bool ResolvedBeginStmtEnums_ReadWriteMode_IsValid(int value);
constexpr ResolvedBeginStmtEnums_ReadWriteMode ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_MIN = ResolvedBeginStmtEnums_ReadWriteMode_MODE_UNSPECIFIED;
constexpr ResolvedBeginStmtEnums_ReadWriteMode ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_MAX = ResolvedBeginStmtEnums_ReadWriteMode_MODE_READ_WRITE;
constexpr int ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_ARRAYSIZE = ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedBeginStmtEnums_ReadWriteMode_descriptor();
template<typename T>
inline const std::string& ResolvedBeginStmtEnums_ReadWriteMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedBeginStmtEnums_ReadWriteMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedBeginStmtEnums_ReadWriteMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedBeginStmtEnums_ReadWriteMode_descriptor(), enum_t_value);
}
inline bool ResolvedBeginStmtEnums_ReadWriteMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedBeginStmtEnums_ReadWriteMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedBeginStmtEnums_ReadWriteMode>(
    ResolvedBeginStmtEnums_ReadWriteMode_descriptor(), name, value);
}
enum ResolvedWindowFrameEnums_FrameUnit : int {
  ResolvedWindowFrameEnums_FrameUnit_ROWS = 0,
  ResolvedWindowFrameEnums_FrameUnit_RANGE = 1
};
bool ResolvedWindowFrameEnums_FrameUnit_IsValid(int value);
constexpr ResolvedWindowFrameEnums_FrameUnit ResolvedWindowFrameEnums_FrameUnit_FrameUnit_MIN = ResolvedWindowFrameEnums_FrameUnit_ROWS;
constexpr ResolvedWindowFrameEnums_FrameUnit ResolvedWindowFrameEnums_FrameUnit_FrameUnit_MAX = ResolvedWindowFrameEnums_FrameUnit_RANGE;
constexpr int ResolvedWindowFrameEnums_FrameUnit_FrameUnit_ARRAYSIZE = ResolvedWindowFrameEnums_FrameUnit_FrameUnit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedWindowFrameEnums_FrameUnit_descriptor();
template<typename T>
inline const std::string& ResolvedWindowFrameEnums_FrameUnit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedWindowFrameEnums_FrameUnit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedWindowFrameEnums_FrameUnit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedWindowFrameEnums_FrameUnit_descriptor(), enum_t_value);
}
inline bool ResolvedWindowFrameEnums_FrameUnit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedWindowFrameEnums_FrameUnit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedWindowFrameEnums_FrameUnit>(
    ResolvedWindowFrameEnums_FrameUnit_descriptor(), name, value);
}
enum ResolvedWindowFrameExprEnums_BoundaryType : int {
  ResolvedWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING = 0,
  ResolvedWindowFrameExprEnums_BoundaryType_OFFSET_PRECEDING = 1,
  ResolvedWindowFrameExprEnums_BoundaryType_CURRENT_ROW = 2,
  ResolvedWindowFrameExprEnums_BoundaryType_OFFSET_FOLLOWING = 3,
  ResolvedWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING = 4
};
bool ResolvedWindowFrameExprEnums_BoundaryType_IsValid(int value);
constexpr ResolvedWindowFrameExprEnums_BoundaryType ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_MIN = ResolvedWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING;
constexpr ResolvedWindowFrameExprEnums_BoundaryType ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_MAX = ResolvedWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING;
constexpr int ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_ARRAYSIZE = ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedWindowFrameExprEnums_BoundaryType_descriptor();
template<typename T>
inline const std::string& ResolvedWindowFrameExprEnums_BoundaryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedWindowFrameExprEnums_BoundaryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedWindowFrameExprEnums_BoundaryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedWindowFrameExprEnums_BoundaryType_descriptor(), enum_t_value);
}
inline bool ResolvedWindowFrameExprEnums_BoundaryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedWindowFrameExprEnums_BoundaryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedWindowFrameExprEnums_BoundaryType>(
    ResolvedWindowFrameExprEnums_BoundaryType_descriptor(), name, value);
}
enum ResolvedInsertStmtEnums_InsertMode : int {
  ResolvedInsertStmtEnums_InsertMode_OR_ERROR = 0,
  ResolvedInsertStmtEnums_InsertMode_OR_IGNORE = 1,
  ResolvedInsertStmtEnums_InsertMode_OR_REPLACE = 2,
  ResolvedInsertStmtEnums_InsertMode_OR_UPDATE = 3
};
bool ResolvedInsertStmtEnums_InsertMode_IsValid(int value);
constexpr ResolvedInsertStmtEnums_InsertMode ResolvedInsertStmtEnums_InsertMode_InsertMode_MIN = ResolvedInsertStmtEnums_InsertMode_OR_ERROR;
constexpr ResolvedInsertStmtEnums_InsertMode ResolvedInsertStmtEnums_InsertMode_InsertMode_MAX = ResolvedInsertStmtEnums_InsertMode_OR_UPDATE;
constexpr int ResolvedInsertStmtEnums_InsertMode_InsertMode_ARRAYSIZE = ResolvedInsertStmtEnums_InsertMode_InsertMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedInsertStmtEnums_InsertMode_descriptor();
template<typename T>
inline const std::string& ResolvedInsertStmtEnums_InsertMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedInsertStmtEnums_InsertMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedInsertStmtEnums_InsertMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedInsertStmtEnums_InsertMode_descriptor(), enum_t_value);
}
inline bool ResolvedInsertStmtEnums_InsertMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedInsertStmtEnums_InsertMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedInsertStmtEnums_InsertMode>(
    ResolvedInsertStmtEnums_InsertMode_descriptor(), name, value);
}
enum ResolvedMergeWhenEnums_MatchType : int {
  ResolvedMergeWhenEnums_MatchType_MATCHED = 0,
  ResolvedMergeWhenEnums_MatchType_NOT_MATCHED_BY_SOURCE = 1,
  ResolvedMergeWhenEnums_MatchType_NOT_MATCHED_BY_TARGET = 2
};
bool ResolvedMergeWhenEnums_MatchType_IsValid(int value);
constexpr ResolvedMergeWhenEnums_MatchType ResolvedMergeWhenEnums_MatchType_MatchType_MIN = ResolvedMergeWhenEnums_MatchType_MATCHED;
constexpr ResolvedMergeWhenEnums_MatchType ResolvedMergeWhenEnums_MatchType_MatchType_MAX = ResolvedMergeWhenEnums_MatchType_NOT_MATCHED_BY_TARGET;
constexpr int ResolvedMergeWhenEnums_MatchType_MatchType_ARRAYSIZE = ResolvedMergeWhenEnums_MatchType_MatchType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedMergeWhenEnums_MatchType_descriptor();
template<typename T>
inline const std::string& ResolvedMergeWhenEnums_MatchType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedMergeWhenEnums_MatchType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedMergeWhenEnums_MatchType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedMergeWhenEnums_MatchType_descriptor(), enum_t_value);
}
inline bool ResolvedMergeWhenEnums_MatchType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedMergeWhenEnums_MatchType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedMergeWhenEnums_MatchType>(
    ResolvedMergeWhenEnums_MatchType_descriptor(), name, value);
}
enum ResolvedMergeWhenEnums_ActionType : int {
  ResolvedMergeWhenEnums_ActionType_INSERT = 0,
  ResolvedMergeWhenEnums_ActionType_UPDATE = 1,
  ResolvedMergeWhenEnums_ActionType_DELETE = 2
};
bool ResolvedMergeWhenEnums_ActionType_IsValid(int value);
constexpr ResolvedMergeWhenEnums_ActionType ResolvedMergeWhenEnums_ActionType_ActionType_MIN = ResolvedMergeWhenEnums_ActionType_INSERT;
constexpr ResolvedMergeWhenEnums_ActionType ResolvedMergeWhenEnums_ActionType_ActionType_MAX = ResolvedMergeWhenEnums_ActionType_DELETE;
constexpr int ResolvedMergeWhenEnums_ActionType_ActionType_ARRAYSIZE = ResolvedMergeWhenEnums_ActionType_ActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedMergeWhenEnums_ActionType_descriptor();
template<typename T>
inline const std::string& ResolvedMergeWhenEnums_ActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedMergeWhenEnums_ActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedMergeWhenEnums_ActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedMergeWhenEnums_ActionType_descriptor(), enum_t_value);
}
inline bool ResolvedMergeWhenEnums_ActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedMergeWhenEnums_ActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedMergeWhenEnums_ActionType>(
    ResolvedMergeWhenEnums_ActionType_descriptor(), name, value);
}
enum ResolvedArgumentDefEnums_ArgumentKind : int {
  ResolvedArgumentDefEnums_ArgumentKind_SCALAR = 0,
  ResolvedArgumentDefEnums_ArgumentKind_AGGREGATE = 1,
  ResolvedArgumentDefEnums_ArgumentKind_NOT_AGGREGATE = 2
};
bool ResolvedArgumentDefEnums_ArgumentKind_IsValid(int value);
constexpr ResolvedArgumentDefEnums_ArgumentKind ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_MIN = ResolvedArgumentDefEnums_ArgumentKind_SCALAR;
constexpr ResolvedArgumentDefEnums_ArgumentKind ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_MAX = ResolvedArgumentDefEnums_ArgumentKind_NOT_AGGREGATE;
constexpr int ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_ARRAYSIZE = ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedArgumentDefEnums_ArgumentKind_descriptor();
template<typename T>
inline const std::string& ResolvedArgumentDefEnums_ArgumentKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedArgumentDefEnums_ArgumentKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedArgumentDefEnums_ArgumentKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedArgumentDefEnums_ArgumentKind_descriptor(), enum_t_value);
}
inline bool ResolvedArgumentDefEnums_ArgumentKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedArgumentDefEnums_ArgumentKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedArgumentDefEnums_ArgumentKind>(
    ResolvedArgumentDefEnums_ArgumentKind_descriptor(), name, value);
}
enum ResolvedFunctionCallBaseEnums_ErrorMode : int {
  ResolvedFunctionCallBaseEnums_ErrorMode_DEFAULT_ERROR_MODE = 0,
  ResolvedFunctionCallBaseEnums_ErrorMode_SAFE_ERROR_MODE = 1
};
bool ResolvedFunctionCallBaseEnums_ErrorMode_IsValid(int value);
constexpr ResolvedFunctionCallBaseEnums_ErrorMode ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_MIN = ResolvedFunctionCallBaseEnums_ErrorMode_DEFAULT_ERROR_MODE;
constexpr ResolvedFunctionCallBaseEnums_ErrorMode ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_MAX = ResolvedFunctionCallBaseEnums_ErrorMode_SAFE_ERROR_MODE;
constexpr int ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_ARRAYSIZE = ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedFunctionCallBaseEnums_ErrorMode_descriptor();
template<typename T>
inline const std::string& ResolvedFunctionCallBaseEnums_ErrorMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedFunctionCallBaseEnums_ErrorMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedFunctionCallBaseEnums_ErrorMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedFunctionCallBaseEnums_ErrorMode_descriptor(), enum_t_value);
}
inline bool ResolvedFunctionCallBaseEnums_ErrorMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedFunctionCallBaseEnums_ErrorMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedFunctionCallBaseEnums_ErrorMode>(
    ResolvedFunctionCallBaseEnums_ErrorMode_descriptor(), name, value);
}
enum ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier : int {
  ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING = 0,
  ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_IGNORE_NULLS = 1,
  ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_RESPECT_NULLS = 2
};
bool ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_IsValid(int value);
constexpr ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_MIN = ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING;
constexpr ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_MAX = ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_RESPECT_NULLS;
constexpr int ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_ARRAYSIZE = ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_descriptor();
template<typename T>
inline const std::string& ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_descriptor(), enum_t_value);
}
inline bool ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier>(
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_descriptor(), name, value);
}
enum ResolvedAggregateHavingModifierEnums_HavingModifierKind : int {
  ResolvedAggregateHavingModifierEnums_HavingModifierKind_INVALID = 0,
  ResolvedAggregateHavingModifierEnums_HavingModifierKind_MAX = 1,
  ResolvedAggregateHavingModifierEnums_HavingModifierKind_MIN = 2
};
bool ResolvedAggregateHavingModifierEnums_HavingModifierKind_IsValid(int value);
constexpr ResolvedAggregateHavingModifierEnums_HavingModifierKind ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_MIN = ResolvedAggregateHavingModifierEnums_HavingModifierKind_INVALID;
constexpr ResolvedAggregateHavingModifierEnums_HavingModifierKind ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_MAX = ResolvedAggregateHavingModifierEnums_HavingModifierKind_MIN;
constexpr int ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_ARRAYSIZE = ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedAggregateHavingModifierEnums_HavingModifierKind_descriptor();
template<typename T>
inline const std::string& ResolvedAggregateHavingModifierEnums_HavingModifierKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedAggregateHavingModifierEnums_HavingModifierKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedAggregateHavingModifierEnums_HavingModifierKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_descriptor(), enum_t_value);
}
inline bool ResolvedAggregateHavingModifierEnums_HavingModifierKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedAggregateHavingModifierEnums_HavingModifierKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedAggregateHavingModifierEnums_HavingModifierKind>(
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_descriptor(), name, value);
}
enum ResolvedStatementEnums_ObjectAccess : int {
  ResolvedStatementEnums_ObjectAccess_NONE = 0,
  ResolvedStatementEnums_ObjectAccess_READ = 1,
  ResolvedStatementEnums_ObjectAccess_WRITE = 2,
  ResolvedStatementEnums_ObjectAccess_READ_WRITE = 3
};
bool ResolvedStatementEnums_ObjectAccess_IsValid(int value);
constexpr ResolvedStatementEnums_ObjectAccess ResolvedStatementEnums_ObjectAccess_ObjectAccess_MIN = ResolvedStatementEnums_ObjectAccess_NONE;
constexpr ResolvedStatementEnums_ObjectAccess ResolvedStatementEnums_ObjectAccess_ObjectAccess_MAX = ResolvedStatementEnums_ObjectAccess_READ_WRITE;
constexpr int ResolvedStatementEnums_ObjectAccess_ObjectAccess_ARRAYSIZE = ResolvedStatementEnums_ObjectAccess_ObjectAccess_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedStatementEnums_ObjectAccess_descriptor();
template<typename T>
inline const std::string& ResolvedStatementEnums_ObjectAccess_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedStatementEnums_ObjectAccess>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedStatementEnums_ObjectAccess_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedStatementEnums_ObjectAccess_descriptor(), enum_t_value);
}
inline bool ResolvedStatementEnums_ObjectAccess_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedStatementEnums_ObjectAccess* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedStatementEnums_ObjectAccess>(
    ResolvedStatementEnums_ObjectAccess_descriptor(), name, value);
}
enum ResolvedImportStmtEnums_ImportKind : int {
  ResolvedImportStmtEnums_ImportKind_MODULE = 0,
  ResolvedImportStmtEnums_ImportKind_PROTO = 1,
  ResolvedImportStmtEnums_ImportKind___ImportKind__switch_must_have_a_default__ = -1
};
bool ResolvedImportStmtEnums_ImportKind_IsValid(int value);
constexpr ResolvedImportStmtEnums_ImportKind ResolvedImportStmtEnums_ImportKind_ImportKind_MIN = ResolvedImportStmtEnums_ImportKind___ImportKind__switch_must_have_a_default__;
constexpr ResolvedImportStmtEnums_ImportKind ResolvedImportStmtEnums_ImportKind_ImportKind_MAX = ResolvedImportStmtEnums_ImportKind_PROTO;
constexpr int ResolvedImportStmtEnums_ImportKind_ImportKind_ARRAYSIZE = ResolvedImportStmtEnums_ImportKind_ImportKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedImportStmtEnums_ImportKind_descriptor();
template<typename T>
inline const std::string& ResolvedImportStmtEnums_ImportKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedImportStmtEnums_ImportKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedImportStmtEnums_ImportKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedImportStmtEnums_ImportKind_descriptor(), enum_t_value);
}
inline bool ResolvedImportStmtEnums_ImportKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedImportStmtEnums_ImportKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedImportStmtEnums_ImportKind>(
    ResolvedImportStmtEnums_ImportKind_descriptor(), name, value);
}
enum ResolvedForeignKeyEnums_MatchMode : int {
  ResolvedForeignKeyEnums_MatchMode_SIMPLE = 0,
  ResolvedForeignKeyEnums_MatchMode_FULL = 1,
  ResolvedForeignKeyEnums_MatchMode_NOT_DISTINCT = 2
};
bool ResolvedForeignKeyEnums_MatchMode_IsValid(int value);
constexpr ResolvedForeignKeyEnums_MatchMode ResolvedForeignKeyEnums_MatchMode_MatchMode_MIN = ResolvedForeignKeyEnums_MatchMode_SIMPLE;
constexpr ResolvedForeignKeyEnums_MatchMode ResolvedForeignKeyEnums_MatchMode_MatchMode_MAX = ResolvedForeignKeyEnums_MatchMode_NOT_DISTINCT;
constexpr int ResolvedForeignKeyEnums_MatchMode_MatchMode_ARRAYSIZE = ResolvedForeignKeyEnums_MatchMode_MatchMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedForeignKeyEnums_MatchMode_descriptor();
template<typename T>
inline const std::string& ResolvedForeignKeyEnums_MatchMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedForeignKeyEnums_MatchMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedForeignKeyEnums_MatchMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedForeignKeyEnums_MatchMode_descriptor(), enum_t_value);
}
inline bool ResolvedForeignKeyEnums_MatchMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedForeignKeyEnums_MatchMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedForeignKeyEnums_MatchMode>(
    ResolvedForeignKeyEnums_MatchMode_descriptor(), name, value);
}
enum ResolvedForeignKeyEnums_ActionOperation : int {
  ResolvedForeignKeyEnums_ActionOperation_NO_ACTION = 0,
  ResolvedForeignKeyEnums_ActionOperation_RESTRICT = 1,
  ResolvedForeignKeyEnums_ActionOperation_CASCADE = 2,
  ResolvedForeignKeyEnums_ActionOperation_SET_NULL = 3
};
bool ResolvedForeignKeyEnums_ActionOperation_IsValid(int value);
constexpr ResolvedForeignKeyEnums_ActionOperation ResolvedForeignKeyEnums_ActionOperation_ActionOperation_MIN = ResolvedForeignKeyEnums_ActionOperation_NO_ACTION;
constexpr ResolvedForeignKeyEnums_ActionOperation ResolvedForeignKeyEnums_ActionOperation_ActionOperation_MAX = ResolvedForeignKeyEnums_ActionOperation_SET_NULL;
constexpr int ResolvedForeignKeyEnums_ActionOperation_ActionOperation_ARRAYSIZE = ResolvedForeignKeyEnums_ActionOperation_ActionOperation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedForeignKeyEnums_ActionOperation_descriptor();
template<typename T>
inline const std::string& ResolvedForeignKeyEnums_ActionOperation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedForeignKeyEnums_ActionOperation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedForeignKeyEnums_ActionOperation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedForeignKeyEnums_ActionOperation_descriptor(), enum_t_value);
}
inline bool ResolvedForeignKeyEnums_ActionOperation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedForeignKeyEnums_ActionOperation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedForeignKeyEnums_ActionOperation>(
    ResolvedForeignKeyEnums_ActionOperation_descriptor(), name, value);
}
enum ResolvedAuxLoadDataStmtEnums_InsertionMode : int {
  ResolvedAuxLoadDataStmtEnums_InsertionMode_NONE = 0,
  ResolvedAuxLoadDataStmtEnums_InsertionMode_APPEND = 1,
  ResolvedAuxLoadDataStmtEnums_InsertionMode_OVERWRITE = 2
};
bool ResolvedAuxLoadDataStmtEnums_InsertionMode_IsValid(int value);
constexpr ResolvedAuxLoadDataStmtEnums_InsertionMode ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_MIN = ResolvedAuxLoadDataStmtEnums_InsertionMode_NONE;
constexpr ResolvedAuxLoadDataStmtEnums_InsertionMode ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_MAX = ResolvedAuxLoadDataStmtEnums_InsertionMode_OVERWRITE;
constexpr int ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_ARRAYSIZE = ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResolvedAuxLoadDataStmtEnums_InsertionMode_descriptor();
template<typename T>
inline const std::string& ResolvedAuxLoadDataStmtEnums_InsertionMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResolvedAuxLoadDataStmtEnums_InsertionMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResolvedAuxLoadDataStmtEnums_InsertionMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResolvedAuxLoadDataStmtEnums_InsertionMode_descriptor(), enum_t_value);
}
inline bool ResolvedAuxLoadDataStmtEnums_InsertionMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResolvedAuxLoadDataStmtEnums_InsertionMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResolvedAuxLoadDataStmtEnums_InsertionMode>(
    ResolvedAuxLoadDataStmtEnums_InsertionMode_descriptor(), name, value);
}
// ===================================================================

class ResolvedSubqueryExprEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedSubqueryExprEnums) */ {
 public:
  inline ResolvedSubqueryExprEnums() : ResolvedSubqueryExprEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedSubqueryExprEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedSubqueryExprEnums(const ResolvedSubqueryExprEnums& from);
  ResolvedSubqueryExprEnums(ResolvedSubqueryExprEnums&& from) noexcept
    : ResolvedSubqueryExprEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedSubqueryExprEnums& operator=(const ResolvedSubqueryExprEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedSubqueryExprEnums& operator=(ResolvedSubqueryExprEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedSubqueryExprEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedSubqueryExprEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedSubqueryExprEnums*>(
               &_ResolvedSubqueryExprEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ResolvedSubqueryExprEnums& a, ResolvedSubqueryExprEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedSubqueryExprEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedSubqueryExprEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedSubqueryExprEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedSubqueryExprEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedSubqueryExprEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedSubqueryExprEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedSubqueryExprEnums";
  }
  protected:
  explicit ResolvedSubqueryExprEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedSubqueryExprEnums_SubqueryType SubqueryType;
  static constexpr SubqueryType SCALAR =
    ResolvedSubqueryExprEnums_SubqueryType_SCALAR;
  static constexpr SubqueryType ARRAY =
    ResolvedSubqueryExprEnums_SubqueryType_ARRAY;
  static constexpr SubqueryType EXISTS =
    ResolvedSubqueryExprEnums_SubqueryType_EXISTS;
  static constexpr SubqueryType IN =
    ResolvedSubqueryExprEnums_SubqueryType_IN;
  static constexpr SubqueryType LIKE_ANY =
    ResolvedSubqueryExprEnums_SubqueryType_LIKE_ANY;
  static constexpr SubqueryType LIKE_ALL =
    ResolvedSubqueryExprEnums_SubqueryType_LIKE_ALL;
  static inline bool SubqueryType_IsValid(int value) {
    return ResolvedSubqueryExprEnums_SubqueryType_IsValid(value);
  }
  static constexpr SubqueryType SubqueryType_MIN =
    ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_MIN;
  static constexpr SubqueryType SubqueryType_MAX =
    ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_MAX;
  static constexpr int SubqueryType_ARRAYSIZE =
    ResolvedSubqueryExprEnums_SubqueryType_SubqueryType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SubqueryType_descriptor() {
    return ResolvedSubqueryExprEnums_SubqueryType_descriptor();
  }
  template<typename T>
  static inline const std::string& SubqueryType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SubqueryType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SubqueryType_Name.");
    return ResolvedSubqueryExprEnums_SubqueryType_Name(enum_t_value);
  }
  static inline bool SubqueryType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SubqueryType* value) {
    return ResolvedSubqueryExprEnums_SubqueryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedSubqueryExprEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedJoinScanEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedJoinScanEnums) */ {
 public:
  inline ResolvedJoinScanEnums() : ResolvedJoinScanEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedJoinScanEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedJoinScanEnums(const ResolvedJoinScanEnums& from);
  ResolvedJoinScanEnums(ResolvedJoinScanEnums&& from) noexcept
    : ResolvedJoinScanEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedJoinScanEnums& operator=(const ResolvedJoinScanEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedJoinScanEnums& operator=(ResolvedJoinScanEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedJoinScanEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedJoinScanEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedJoinScanEnums*>(
               &_ResolvedJoinScanEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResolvedJoinScanEnums& a, ResolvedJoinScanEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedJoinScanEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedJoinScanEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedJoinScanEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedJoinScanEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedJoinScanEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedJoinScanEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedJoinScanEnums";
  }
  protected:
  explicit ResolvedJoinScanEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedJoinScanEnums_JoinType JoinType;
  static constexpr JoinType INNER =
    ResolvedJoinScanEnums_JoinType_INNER;
  static constexpr JoinType LEFT =
    ResolvedJoinScanEnums_JoinType_LEFT;
  static constexpr JoinType RIGHT =
    ResolvedJoinScanEnums_JoinType_RIGHT;
  static constexpr JoinType FULL =
    ResolvedJoinScanEnums_JoinType_FULL;
  static inline bool JoinType_IsValid(int value) {
    return ResolvedJoinScanEnums_JoinType_IsValid(value);
  }
  static constexpr JoinType JoinType_MIN =
    ResolvedJoinScanEnums_JoinType_JoinType_MIN;
  static constexpr JoinType JoinType_MAX =
    ResolvedJoinScanEnums_JoinType_JoinType_MAX;
  static constexpr int JoinType_ARRAYSIZE =
    ResolvedJoinScanEnums_JoinType_JoinType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  JoinType_descriptor() {
    return ResolvedJoinScanEnums_JoinType_descriptor();
  }
  template<typename T>
  static inline const std::string& JoinType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, JoinType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function JoinType_Name.");
    return ResolvedJoinScanEnums_JoinType_Name(enum_t_value);
  }
  static inline bool JoinType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      JoinType* value) {
    return ResolvedJoinScanEnums_JoinType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedJoinScanEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedSetOperationScanEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedSetOperationScanEnums) */ {
 public:
  inline ResolvedSetOperationScanEnums() : ResolvedSetOperationScanEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedSetOperationScanEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedSetOperationScanEnums(const ResolvedSetOperationScanEnums& from);
  ResolvedSetOperationScanEnums(ResolvedSetOperationScanEnums&& from) noexcept
    : ResolvedSetOperationScanEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedSetOperationScanEnums& operator=(const ResolvedSetOperationScanEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedSetOperationScanEnums& operator=(ResolvedSetOperationScanEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedSetOperationScanEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedSetOperationScanEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedSetOperationScanEnums*>(
               &_ResolvedSetOperationScanEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ResolvedSetOperationScanEnums& a, ResolvedSetOperationScanEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedSetOperationScanEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedSetOperationScanEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedSetOperationScanEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedSetOperationScanEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedSetOperationScanEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedSetOperationScanEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedSetOperationScanEnums";
  }
  protected:
  explicit ResolvedSetOperationScanEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedSetOperationScanEnums_SetOperationType SetOperationType;
  static constexpr SetOperationType UNION_ALL =
    ResolvedSetOperationScanEnums_SetOperationType_UNION_ALL;
  static constexpr SetOperationType UNION_DISTINCT =
    ResolvedSetOperationScanEnums_SetOperationType_UNION_DISTINCT;
  static constexpr SetOperationType INTERSECT_ALL =
    ResolvedSetOperationScanEnums_SetOperationType_INTERSECT_ALL;
  static constexpr SetOperationType INTERSECT_DISTINCT =
    ResolvedSetOperationScanEnums_SetOperationType_INTERSECT_DISTINCT;
  static constexpr SetOperationType EXCEPT_ALL =
    ResolvedSetOperationScanEnums_SetOperationType_EXCEPT_ALL;
  static constexpr SetOperationType EXCEPT_DISTINCT =
    ResolvedSetOperationScanEnums_SetOperationType_EXCEPT_DISTINCT;
  static inline bool SetOperationType_IsValid(int value) {
    return ResolvedSetOperationScanEnums_SetOperationType_IsValid(value);
  }
  static constexpr SetOperationType SetOperationType_MIN =
    ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_MIN;
  static constexpr SetOperationType SetOperationType_MAX =
    ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_MAX;
  static constexpr int SetOperationType_ARRAYSIZE =
    ResolvedSetOperationScanEnums_SetOperationType_SetOperationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SetOperationType_descriptor() {
    return ResolvedSetOperationScanEnums_SetOperationType_descriptor();
  }
  template<typename T>
  static inline const std::string& SetOperationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SetOperationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SetOperationType_Name.");
    return ResolvedSetOperationScanEnums_SetOperationType_Name(enum_t_value);
  }
  static inline bool SetOperationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SetOperationType* value) {
    return ResolvedSetOperationScanEnums_SetOperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedSetOperationScanEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedRecursiveScanEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedRecursiveScanEnums) */ {
 public:
  inline ResolvedRecursiveScanEnums() : ResolvedRecursiveScanEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedRecursiveScanEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedRecursiveScanEnums(const ResolvedRecursiveScanEnums& from);
  ResolvedRecursiveScanEnums(ResolvedRecursiveScanEnums&& from) noexcept
    : ResolvedRecursiveScanEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedRecursiveScanEnums& operator=(const ResolvedRecursiveScanEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedRecursiveScanEnums& operator=(ResolvedRecursiveScanEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedRecursiveScanEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedRecursiveScanEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedRecursiveScanEnums*>(
               &_ResolvedRecursiveScanEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ResolvedRecursiveScanEnums& a, ResolvedRecursiveScanEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedRecursiveScanEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedRecursiveScanEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedRecursiveScanEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedRecursiveScanEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedRecursiveScanEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedRecursiveScanEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedRecursiveScanEnums";
  }
  protected:
  explicit ResolvedRecursiveScanEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedRecursiveScanEnums_RecursiveSetOperationType RecursiveSetOperationType;
  static constexpr RecursiveSetOperationType UNION_ALL =
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_UNION_ALL;
  static constexpr RecursiveSetOperationType UNION_DISTINCT =
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_UNION_DISTINCT;
  static inline bool RecursiveSetOperationType_IsValid(int value) {
    return ResolvedRecursiveScanEnums_RecursiveSetOperationType_IsValid(value);
  }
  static constexpr RecursiveSetOperationType RecursiveSetOperationType_MIN =
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_MIN;
  static constexpr RecursiveSetOperationType RecursiveSetOperationType_MAX =
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_MAX;
  static constexpr int RecursiveSetOperationType_ARRAYSIZE =
    ResolvedRecursiveScanEnums_RecursiveSetOperationType_RecursiveSetOperationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RecursiveSetOperationType_descriptor() {
    return ResolvedRecursiveScanEnums_RecursiveSetOperationType_descriptor();
  }
  template<typename T>
  static inline const std::string& RecursiveSetOperationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RecursiveSetOperationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RecursiveSetOperationType_Name.");
    return ResolvedRecursiveScanEnums_RecursiveSetOperationType_Name(enum_t_value);
  }
  static inline bool RecursiveSetOperationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RecursiveSetOperationType* value) {
    return ResolvedRecursiveScanEnums_RecursiveSetOperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedRecursiveScanEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedSampleScanEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedSampleScanEnums) */ {
 public:
  inline ResolvedSampleScanEnums() : ResolvedSampleScanEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedSampleScanEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedSampleScanEnums(const ResolvedSampleScanEnums& from);
  ResolvedSampleScanEnums(ResolvedSampleScanEnums&& from) noexcept
    : ResolvedSampleScanEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedSampleScanEnums& operator=(const ResolvedSampleScanEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedSampleScanEnums& operator=(ResolvedSampleScanEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedSampleScanEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedSampleScanEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedSampleScanEnums*>(
               &_ResolvedSampleScanEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ResolvedSampleScanEnums& a, ResolvedSampleScanEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedSampleScanEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedSampleScanEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedSampleScanEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedSampleScanEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedSampleScanEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedSampleScanEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedSampleScanEnums";
  }
  protected:
  explicit ResolvedSampleScanEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedSampleScanEnums_SampleUnit SampleUnit;
  static constexpr SampleUnit ROWS =
    ResolvedSampleScanEnums_SampleUnit_ROWS;
  static constexpr SampleUnit PERCENT =
    ResolvedSampleScanEnums_SampleUnit_PERCENT;
  static inline bool SampleUnit_IsValid(int value) {
    return ResolvedSampleScanEnums_SampleUnit_IsValid(value);
  }
  static constexpr SampleUnit SampleUnit_MIN =
    ResolvedSampleScanEnums_SampleUnit_SampleUnit_MIN;
  static constexpr SampleUnit SampleUnit_MAX =
    ResolvedSampleScanEnums_SampleUnit_SampleUnit_MAX;
  static constexpr int SampleUnit_ARRAYSIZE =
    ResolvedSampleScanEnums_SampleUnit_SampleUnit_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SampleUnit_descriptor() {
    return ResolvedSampleScanEnums_SampleUnit_descriptor();
  }
  template<typename T>
  static inline const std::string& SampleUnit_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SampleUnit>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SampleUnit_Name.");
    return ResolvedSampleScanEnums_SampleUnit_Name(enum_t_value);
  }
  static inline bool SampleUnit_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SampleUnit* value) {
    return ResolvedSampleScanEnums_SampleUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedSampleScanEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedOrderByItemEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedOrderByItemEnums) */ {
 public:
  inline ResolvedOrderByItemEnums() : ResolvedOrderByItemEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedOrderByItemEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedOrderByItemEnums(const ResolvedOrderByItemEnums& from);
  ResolvedOrderByItemEnums(ResolvedOrderByItemEnums&& from) noexcept
    : ResolvedOrderByItemEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedOrderByItemEnums& operator=(const ResolvedOrderByItemEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedOrderByItemEnums& operator=(ResolvedOrderByItemEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedOrderByItemEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedOrderByItemEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedOrderByItemEnums*>(
               &_ResolvedOrderByItemEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResolvedOrderByItemEnums& a, ResolvedOrderByItemEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedOrderByItemEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedOrderByItemEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedOrderByItemEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedOrderByItemEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedOrderByItemEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedOrderByItemEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedOrderByItemEnums";
  }
  protected:
  explicit ResolvedOrderByItemEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedOrderByItemEnums_NullOrderMode NullOrderMode;
  static constexpr NullOrderMode ORDER_UNSPECIFIED =
    ResolvedOrderByItemEnums_NullOrderMode_ORDER_UNSPECIFIED;
  static constexpr NullOrderMode NULLS_FIRST =
    ResolvedOrderByItemEnums_NullOrderMode_NULLS_FIRST;
  static constexpr NullOrderMode NULLS_LAST =
    ResolvedOrderByItemEnums_NullOrderMode_NULLS_LAST;
  static inline bool NullOrderMode_IsValid(int value) {
    return ResolvedOrderByItemEnums_NullOrderMode_IsValid(value);
  }
  static constexpr NullOrderMode NullOrderMode_MIN =
    ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_MIN;
  static constexpr NullOrderMode NullOrderMode_MAX =
    ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_MAX;
  static constexpr int NullOrderMode_ARRAYSIZE =
    ResolvedOrderByItemEnums_NullOrderMode_NullOrderMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NullOrderMode_descriptor() {
    return ResolvedOrderByItemEnums_NullOrderMode_descriptor();
  }
  template<typename T>
  static inline const std::string& NullOrderMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NullOrderMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NullOrderMode_Name.");
    return ResolvedOrderByItemEnums_NullOrderMode_Name(enum_t_value);
  }
  static inline bool NullOrderMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NullOrderMode* value) {
    return ResolvedOrderByItemEnums_NullOrderMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedOrderByItemEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedCreateStatementEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedCreateStatementEnums) */ {
 public:
  inline ResolvedCreateStatementEnums() : ResolvedCreateStatementEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedCreateStatementEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedCreateStatementEnums(const ResolvedCreateStatementEnums& from);
  ResolvedCreateStatementEnums(ResolvedCreateStatementEnums&& from) noexcept
    : ResolvedCreateStatementEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedCreateStatementEnums& operator=(const ResolvedCreateStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedCreateStatementEnums& operator=(ResolvedCreateStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedCreateStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedCreateStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedCreateStatementEnums*>(
               &_ResolvedCreateStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ResolvedCreateStatementEnums& a, ResolvedCreateStatementEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedCreateStatementEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedCreateStatementEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedCreateStatementEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedCreateStatementEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedCreateStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedCreateStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedCreateStatementEnums";
  }
  protected:
  explicit ResolvedCreateStatementEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedCreateStatementEnums_CreateScope CreateScope;
  static constexpr CreateScope CREATE_DEFAULT_SCOPE =
    ResolvedCreateStatementEnums_CreateScope_CREATE_DEFAULT_SCOPE;
  static constexpr CreateScope CREATE_PRIVATE =
    ResolvedCreateStatementEnums_CreateScope_CREATE_PRIVATE;
  static constexpr CreateScope CREATE_PUBLIC =
    ResolvedCreateStatementEnums_CreateScope_CREATE_PUBLIC;
  static constexpr CreateScope CREATE_TEMP =
    ResolvedCreateStatementEnums_CreateScope_CREATE_TEMP;
  static inline bool CreateScope_IsValid(int value) {
    return ResolvedCreateStatementEnums_CreateScope_IsValid(value);
  }
  static constexpr CreateScope CreateScope_MIN =
    ResolvedCreateStatementEnums_CreateScope_CreateScope_MIN;
  static constexpr CreateScope CreateScope_MAX =
    ResolvedCreateStatementEnums_CreateScope_CreateScope_MAX;
  static constexpr int CreateScope_ARRAYSIZE =
    ResolvedCreateStatementEnums_CreateScope_CreateScope_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CreateScope_descriptor() {
    return ResolvedCreateStatementEnums_CreateScope_descriptor();
  }
  template<typename T>
  static inline const std::string& CreateScope_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CreateScope>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CreateScope_Name.");
    return ResolvedCreateStatementEnums_CreateScope_Name(enum_t_value);
  }
  static inline bool CreateScope_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CreateScope* value) {
    return ResolvedCreateStatementEnums_CreateScope_Parse(name, value);
  }

  typedef ResolvedCreateStatementEnums_CreateMode CreateMode;
  static constexpr CreateMode CREATE_DEFAULT =
    ResolvedCreateStatementEnums_CreateMode_CREATE_DEFAULT;
  static constexpr CreateMode CREATE_OR_REPLACE =
    ResolvedCreateStatementEnums_CreateMode_CREATE_OR_REPLACE;
  static constexpr CreateMode CREATE_IF_NOT_EXISTS =
    ResolvedCreateStatementEnums_CreateMode_CREATE_IF_NOT_EXISTS;
  static inline bool CreateMode_IsValid(int value) {
    return ResolvedCreateStatementEnums_CreateMode_IsValid(value);
  }
  static constexpr CreateMode CreateMode_MIN =
    ResolvedCreateStatementEnums_CreateMode_CreateMode_MIN;
  static constexpr CreateMode CreateMode_MAX =
    ResolvedCreateStatementEnums_CreateMode_CreateMode_MAX;
  static constexpr int CreateMode_ARRAYSIZE =
    ResolvedCreateStatementEnums_CreateMode_CreateMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CreateMode_descriptor() {
    return ResolvedCreateStatementEnums_CreateMode_descriptor();
  }
  template<typename T>
  static inline const std::string& CreateMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CreateMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CreateMode_Name.");
    return ResolvedCreateStatementEnums_CreateMode_Name(enum_t_value);
  }
  static inline bool CreateMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CreateMode* value) {
    return ResolvedCreateStatementEnums_CreateMode_Parse(name, value);
  }

  typedef ResolvedCreateStatementEnums_SqlSecurity SqlSecurity;
  static constexpr SqlSecurity SQL_SECURITY_UNSPECIFIED =
    ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED;
  static constexpr SqlSecurity SQL_SECURITY_DEFINER =
    ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_DEFINER;
  static constexpr SqlSecurity SQL_SECURITY_INVOKER =
    ResolvedCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER;
  static inline bool SqlSecurity_IsValid(int value) {
    return ResolvedCreateStatementEnums_SqlSecurity_IsValid(value);
  }
  static constexpr SqlSecurity SqlSecurity_MIN =
    ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_MIN;
  static constexpr SqlSecurity SqlSecurity_MAX =
    ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_MAX;
  static constexpr int SqlSecurity_ARRAYSIZE =
    ResolvedCreateStatementEnums_SqlSecurity_SqlSecurity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SqlSecurity_descriptor() {
    return ResolvedCreateStatementEnums_SqlSecurity_descriptor();
  }
  template<typename T>
  static inline const std::string& SqlSecurity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SqlSecurity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SqlSecurity_Name.");
    return ResolvedCreateStatementEnums_SqlSecurity_Name(enum_t_value);
  }
  static inline bool SqlSecurity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SqlSecurity* value) {
    return ResolvedCreateStatementEnums_SqlSecurity_Parse(name, value);
  }

  typedef ResolvedCreateStatementEnums_DeterminismLevel DeterminismLevel;
  static constexpr DeterminismLevel DETERMINISM_UNSPECIFIED =
    ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED;
  static constexpr DeterminismLevel DETERMINISM_DETERMINISTIC =
    ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_DETERMINISTIC;
  static constexpr DeterminismLevel DETERMINISM_NOT_DETERMINISTIC =
    ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_NOT_DETERMINISTIC;
  static constexpr DeterminismLevel DETERMINISM_IMMUTABLE =
    ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_IMMUTABLE;
  static constexpr DeterminismLevel DETERMINISM_STABLE =
    ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_STABLE;
  static constexpr DeterminismLevel DETERMINISM_VOLATILE =
    ResolvedCreateStatementEnums_DeterminismLevel_DETERMINISM_VOLATILE;
  static inline bool DeterminismLevel_IsValid(int value) {
    return ResolvedCreateStatementEnums_DeterminismLevel_IsValid(value);
  }
  static constexpr DeterminismLevel DeterminismLevel_MIN =
    ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_MIN;
  static constexpr DeterminismLevel DeterminismLevel_MAX =
    ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_MAX;
  static constexpr int DeterminismLevel_ARRAYSIZE =
    ResolvedCreateStatementEnums_DeterminismLevel_DeterminismLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DeterminismLevel_descriptor() {
    return ResolvedCreateStatementEnums_DeterminismLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& DeterminismLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DeterminismLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DeterminismLevel_Name.");
    return ResolvedCreateStatementEnums_DeterminismLevel_Name(enum_t_value);
  }
  static inline bool DeterminismLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DeterminismLevel* value) {
    return ResolvedCreateStatementEnums_DeterminismLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedCreateStatementEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedGeneratedColumnInfoEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedGeneratedColumnInfoEnums) */ {
 public:
  inline ResolvedGeneratedColumnInfoEnums() : ResolvedGeneratedColumnInfoEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedGeneratedColumnInfoEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedGeneratedColumnInfoEnums(const ResolvedGeneratedColumnInfoEnums& from);
  ResolvedGeneratedColumnInfoEnums(ResolvedGeneratedColumnInfoEnums&& from) noexcept
    : ResolvedGeneratedColumnInfoEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedGeneratedColumnInfoEnums& operator=(const ResolvedGeneratedColumnInfoEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedGeneratedColumnInfoEnums& operator=(ResolvedGeneratedColumnInfoEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedGeneratedColumnInfoEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedGeneratedColumnInfoEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedGeneratedColumnInfoEnums*>(
               &_ResolvedGeneratedColumnInfoEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ResolvedGeneratedColumnInfoEnums& a, ResolvedGeneratedColumnInfoEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedGeneratedColumnInfoEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedGeneratedColumnInfoEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedGeneratedColumnInfoEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedGeneratedColumnInfoEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedGeneratedColumnInfoEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedGeneratedColumnInfoEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedGeneratedColumnInfoEnums";
  }
  protected:
  explicit ResolvedGeneratedColumnInfoEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedGeneratedColumnInfoEnums_StoredMode StoredMode;
  static constexpr StoredMode NON_STORED =
    ResolvedGeneratedColumnInfoEnums_StoredMode_NON_STORED;
  static constexpr StoredMode STORED =
    ResolvedGeneratedColumnInfoEnums_StoredMode_STORED;
  static constexpr StoredMode STORED_VOLATILE =
    ResolvedGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE;
  static inline bool StoredMode_IsValid(int value) {
    return ResolvedGeneratedColumnInfoEnums_StoredMode_IsValid(value);
  }
  static constexpr StoredMode StoredMode_MIN =
    ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_MIN;
  static constexpr StoredMode StoredMode_MAX =
    ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX;
  static constexpr int StoredMode_ARRAYSIZE =
    ResolvedGeneratedColumnInfoEnums_StoredMode_StoredMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StoredMode_descriptor() {
    return ResolvedGeneratedColumnInfoEnums_StoredMode_descriptor();
  }
  template<typename T>
  static inline const std::string& StoredMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StoredMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StoredMode_Name.");
    return ResolvedGeneratedColumnInfoEnums_StoredMode_Name(enum_t_value);
  }
  static inline bool StoredMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StoredMode* value) {
    return ResolvedGeneratedColumnInfoEnums_StoredMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedGeneratedColumnInfoEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedDropStmtEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedDropStmtEnums) */ {
 public:
  inline ResolvedDropStmtEnums() : ResolvedDropStmtEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedDropStmtEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedDropStmtEnums(const ResolvedDropStmtEnums& from);
  ResolvedDropStmtEnums(ResolvedDropStmtEnums&& from) noexcept
    : ResolvedDropStmtEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedDropStmtEnums& operator=(const ResolvedDropStmtEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedDropStmtEnums& operator=(ResolvedDropStmtEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedDropStmtEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedDropStmtEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedDropStmtEnums*>(
               &_ResolvedDropStmtEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ResolvedDropStmtEnums& a, ResolvedDropStmtEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedDropStmtEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedDropStmtEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedDropStmtEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedDropStmtEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedDropStmtEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedDropStmtEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedDropStmtEnums";
  }
  protected:
  explicit ResolvedDropStmtEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedDropStmtEnums_DropMode DropMode;
  static constexpr DropMode DROP_MODE_UNSPECIFIED =
    ResolvedDropStmtEnums_DropMode_DROP_MODE_UNSPECIFIED;
  static constexpr DropMode RESTRICT =
    ResolvedDropStmtEnums_DropMode_RESTRICT;
  static constexpr DropMode CASCADE =
    ResolvedDropStmtEnums_DropMode_CASCADE;
  static inline bool DropMode_IsValid(int value) {
    return ResolvedDropStmtEnums_DropMode_IsValid(value);
  }
  static constexpr DropMode DropMode_MIN =
    ResolvedDropStmtEnums_DropMode_DropMode_MIN;
  static constexpr DropMode DropMode_MAX =
    ResolvedDropStmtEnums_DropMode_DropMode_MAX;
  static constexpr int DropMode_ARRAYSIZE =
    ResolvedDropStmtEnums_DropMode_DropMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DropMode_descriptor() {
    return ResolvedDropStmtEnums_DropMode_descriptor();
  }
  template<typename T>
  static inline const std::string& DropMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DropMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DropMode_Name.");
    return ResolvedDropStmtEnums_DropMode_Name(enum_t_value);
  }
  static inline bool DropMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DropMode* value) {
    return ResolvedDropStmtEnums_DropMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedDropStmtEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedBeginStmtEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedBeginStmtEnums) */ {
 public:
  inline ResolvedBeginStmtEnums() : ResolvedBeginStmtEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedBeginStmtEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedBeginStmtEnums(const ResolvedBeginStmtEnums& from);
  ResolvedBeginStmtEnums(ResolvedBeginStmtEnums&& from) noexcept
    : ResolvedBeginStmtEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedBeginStmtEnums& operator=(const ResolvedBeginStmtEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedBeginStmtEnums& operator=(ResolvedBeginStmtEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedBeginStmtEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedBeginStmtEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedBeginStmtEnums*>(
               &_ResolvedBeginStmtEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ResolvedBeginStmtEnums& a, ResolvedBeginStmtEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedBeginStmtEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedBeginStmtEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedBeginStmtEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedBeginStmtEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedBeginStmtEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedBeginStmtEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedBeginStmtEnums";
  }
  protected:
  explicit ResolvedBeginStmtEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedBeginStmtEnums_ReadWriteMode ReadWriteMode;
  static constexpr ReadWriteMode MODE_UNSPECIFIED =
    ResolvedBeginStmtEnums_ReadWriteMode_MODE_UNSPECIFIED;
  static constexpr ReadWriteMode MODE_READ_ONLY =
    ResolvedBeginStmtEnums_ReadWriteMode_MODE_READ_ONLY;
  static constexpr ReadWriteMode MODE_READ_WRITE =
    ResolvedBeginStmtEnums_ReadWriteMode_MODE_READ_WRITE;
  static inline bool ReadWriteMode_IsValid(int value) {
    return ResolvedBeginStmtEnums_ReadWriteMode_IsValid(value);
  }
  static constexpr ReadWriteMode ReadWriteMode_MIN =
    ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_MIN;
  static constexpr ReadWriteMode ReadWriteMode_MAX =
    ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_MAX;
  static constexpr int ReadWriteMode_ARRAYSIZE =
    ResolvedBeginStmtEnums_ReadWriteMode_ReadWriteMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ReadWriteMode_descriptor() {
    return ResolvedBeginStmtEnums_ReadWriteMode_descriptor();
  }
  template<typename T>
  static inline const std::string& ReadWriteMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ReadWriteMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ReadWriteMode_Name.");
    return ResolvedBeginStmtEnums_ReadWriteMode_Name(enum_t_value);
  }
  static inline bool ReadWriteMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ReadWriteMode* value) {
    return ResolvedBeginStmtEnums_ReadWriteMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedBeginStmtEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedWindowFrameEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedWindowFrameEnums) */ {
 public:
  inline ResolvedWindowFrameEnums() : ResolvedWindowFrameEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedWindowFrameEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedWindowFrameEnums(const ResolvedWindowFrameEnums& from);
  ResolvedWindowFrameEnums(ResolvedWindowFrameEnums&& from) noexcept
    : ResolvedWindowFrameEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedWindowFrameEnums& operator=(const ResolvedWindowFrameEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedWindowFrameEnums& operator=(ResolvedWindowFrameEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedWindowFrameEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedWindowFrameEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedWindowFrameEnums*>(
               &_ResolvedWindowFrameEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ResolvedWindowFrameEnums& a, ResolvedWindowFrameEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedWindowFrameEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedWindowFrameEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedWindowFrameEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedWindowFrameEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedWindowFrameEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedWindowFrameEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedWindowFrameEnums";
  }
  protected:
  explicit ResolvedWindowFrameEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedWindowFrameEnums_FrameUnit FrameUnit;
  static constexpr FrameUnit ROWS =
    ResolvedWindowFrameEnums_FrameUnit_ROWS;
  static constexpr FrameUnit RANGE =
    ResolvedWindowFrameEnums_FrameUnit_RANGE;
  static inline bool FrameUnit_IsValid(int value) {
    return ResolvedWindowFrameEnums_FrameUnit_IsValid(value);
  }
  static constexpr FrameUnit FrameUnit_MIN =
    ResolvedWindowFrameEnums_FrameUnit_FrameUnit_MIN;
  static constexpr FrameUnit FrameUnit_MAX =
    ResolvedWindowFrameEnums_FrameUnit_FrameUnit_MAX;
  static constexpr int FrameUnit_ARRAYSIZE =
    ResolvedWindowFrameEnums_FrameUnit_FrameUnit_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FrameUnit_descriptor() {
    return ResolvedWindowFrameEnums_FrameUnit_descriptor();
  }
  template<typename T>
  static inline const std::string& FrameUnit_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FrameUnit>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FrameUnit_Name.");
    return ResolvedWindowFrameEnums_FrameUnit_Name(enum_t_value);
  }
  static inline bool FrameUnit_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FrameUnit* value) {
    return ResolvedWindowFrameEnums_FrameUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedWindowFrameEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedWindowFrameExprEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedWindowFrameExprEnums) */ {
 public:
  inline ResolvedWindowFrameExprEnums() : ResolvedWindowFrameExprEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedWindowFrameExprEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedWindowFrameExprEnums(const ResolvedWindowFrameExprEnums& from);
  ResolvedWindowFrameExprEnums(ResolvedWindowFrameExprEnums&& from) noexcept
    : ResolvedWindowFrameExprEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedWindowFrameExprEnums& operator=(const ResolvedWindowFrameExprEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedWindowFrameExprEnums& operator=(ResolvedWindowFrameExprEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedWindowFrameExprEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedWindowFrameExprEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedWindowFrameExprEnums*>(
               &_ResolvedWindowFrameExprEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ResolvedWindowFrameExprEnums& a, ResolvedWindowFrameExprEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedWindowFrameExprEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedWindowFrameExprEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedWindowFrameExprEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedWindowFrameExprEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedWindowFrameExprEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedWindowFrameExprEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedWindowFrameExprEnums";
  }
  protected:
  explicit ResolvedWindowFrameExprEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedWindowFrameExprEnums_BoundaryType BoundaryType;
  static constexpr BoundaryType UNBOUNDED_PRECEDING =
    ResolvedWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING;
  static constexpr BoundaryType OFFSET_PRECEDING =
    ResolvedWindowFrameExprEnums_BoundaryType_OFFSET_PRECEDING;
  static constexpr BoundaryType CURRENT_ROW =
    ResolvedWindowFrameExprEnums_BoundaryType_CURRENT_ROW;
  static constexpr BoundaryType OFFSET_FOLLOWING =
    ResolvedWindowFrameExprEnums_BoundaryType_OFFSET_FOLLOWING;
  static constexpr BoundaryType UNBOUNDED_FOLLOWING =
    ResolvedWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING;
  static inline bool BoundaryType_IsValid(int value) {
    return ResolvedWindowFrameExprEnums_BoundaryType_IsValid(value);
  }
  static constexpr BoundaryType BoundaryType_MIN =
    ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_MIN;
  static constexpr BoundaryType BoundaryType_MAX =
    ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_MAX;
  static constexpr int BoundaryType_ARRAYSIZE =
    ResolvedWindowFrameExprEnums_BoundaryType_BoundaryType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BoundaryType_descriptor() {
    return ResolvedWindowFrameExprEnums_BoundaryType_descriptor();
  }
  template<typename T>
  static inline const std::string& BoundaryType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BoundaryType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BoundaryType_Name.");
    return ResolvedWindowFrameExprEnums_BoundaryType_Name(enum_t_value);
  }
  static inline bool BoundaryType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BoundaryType* value) {
    return ResolvedWindowFrameExprEnums_BoundaryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedWindowFrameExprEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedInsertStmtEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedInsertStmtEnums) */ {
 public:
  inline ResolvedInsertStmtEnums() : ResolvedInsertStmtEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedInsertStmtEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedInsertStmtEnums(const ResolvedInsertStmtEnums& from);
  ResolvedInsertStmtEnums(ResolvedInsertStmtEnums&& from) noexcept
    : ResolvedInsertStmtEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedInsertStmtEnums& operator=(const ResolvedInsertStmtEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedInsertStmtEnums& operator=(ResolvedInsertStmtEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedInsertStmtEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedInsertStmtEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedInsertStmtEnums*>(
               &_ResolvedInsertStmtEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ResolvedInsertStmtEnums& a, ResolvedInsertStmtEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedInsertStmtEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedInsertStmtEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedInsertStmtEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedInsertStmtEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedInsertStmtEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedInsertStmtEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedInsertStmtEnums";
  }
  protected:
  explicit ResolvedInsertStmtEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedInsertStmtEnums_InsertMode InsertMode;
  static constexpr InsertMode OR_ERROR =
    ResolvedInsertStmtEnums_InsertMode_OR_ERROR;
  static constexpr InsertMode OR_IGNORE =
    ResolvedInsertStmtEnums_InsertMode_OR_IGNORE;
  static constexpr InsertMode OR_REPLACE =
    ResolvedInsertStmtEnums_InsertMode_OR_REPLACE;
  static constexpr InsertMode OR_UPDATE =
    ResolvedInsertStmtEnums_InsertMode_OR_UPDATE;
  static inline bool InsertMode_IsValid(int value) {
    return ResolvedInsertStmtEnums_InsertMode_IsValid(value);
  }
  static constexpr InsertMode InsertMode_MIN =
    ResolvedInsertStmtEnums_InsertMode_InsertMode_MIN;
  static constexpr InsertMode InsertMode_MAX =
    ResolvedInsertStmtEnums_InsertMode_InsertMode_MAX;
  static constexpr int InsertMode_ARRAYSIZE =
    ResolvedInsertStmtEnums_InsertMode_InsertMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InsertMode_descriptor() {
    return ResolvedInsertStmtEnums_InsertMode_descriptor();
  }
  template<typename T>
  static inline const std::string& InsertMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InsertMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InsertMode_Name.");
    return ResolvedInsertStmtEnums_InsertMode_Name(enum_t_value);
  }
  static inline bool InsertMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InsertMode* value) {
    return ResolvedInsertStmtEnums_InsertMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedInsertStmtEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedMergeWhenEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedMergeWhenEnums) */ {
 public:
  inline ResolvedMergeWhenEnums() : ResolvedMergeWhenEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedMergeWhenEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedMergeWhenEnums(const ResolvedMergeWhenEnums& from);
  ResolvedMergeWhenEnums(ResolvedMergeWhenEnums&& from) noexcept
    : ResolvedMergeWhenEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedMergeWhenEnums& operator=(const ResolvedMergeWhenEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedMergeWhenEnums& operator=(ResolvedMergeWhenEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedMergeWhenEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedMergeWhenEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedMergeWhenEnums*>(
               &_ResolvedMergeWhenEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ResolvedMergeWhenEnums& a, ResolvedMergeWhenEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedMergeWhenEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedMergeWhenEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedMergeWhenEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedMergeWhenEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedMergeWhenEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedMergeWhenEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedMergeWhenEnums";
  }
  protected:
  explicit ResolvedMergeWhenEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedMergeWhenEnums_MatchType MatchType;
  static constexpr MatchType MATCHED =
    ResolvedMergeWhenEnums_MatchType_MATCHED;
  static constexpr MatchType NOT_MATCHED_BY_SOURCE =
    ResolvedMergeWhenEnums_MatchType_NOT_MATCHED_BY_SOURCE;
  static constexpr MatchType NOT_MATCHED_BY_TARGET =
    ResolvedMergeWhenEnums_MatchType_NOT_MATCHED_BY_TARGET;
  static inline bool MatchType_IsValid(int value) {
    return ResolvedMergeWhenEnums_MatchType_IsValid(value);
  }
  static constexpr MatchType MatchType_MIN =
    ResolvedMergeWhenEnums_MatchType_MatchType_MIN;
  static constexpr MatchType MatchType_MAX =
    ResolvedMergeWhenEnums_MatchType_MatchType_MAX;
  static constexpr int MatchType_ARRAYSIZE =
    ResolvedMergeWhenEnums_MatchType_MatchType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MatchType_descriptor() {
    return ResolvedMergeWhenEnums_MatchType_descriptor();
  }
  template<typename T>
  static inline const std::string& MatchType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MatchType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MatchType_Name.");
    return ResolvedMergeWhenEnums_MatchType_Name(enum_t_value);
  }
  static inline bool MatchType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MatchType* value) {
    return ResolvedMergeWhenEnums_MatchType_Parse(name, value);
  }

  typedef ResolvedMergeWhenEnums_ActionType ActionType;
  static constexpr ActionType INSERT =
    ResolvedMergeWhenEnums_ActionType_INSERT;
  static constexpr ActionType UPDATE =
    ResolvedMergeWhenEnums_ActionType_UPDATE;
  static constexpr ActionType DELETE =
    ResolvedMergeWhenEnums_ActionType_DELETE;
  static inline bool ActionType_IsValid(int value) {
    return ResolvedMergeWhenEnums_ActionType_IsValid(value);
  }
  static constexpr ActionType ActionType_MIN =
    ResolvedMergeWhenEnums_ActionType_ActionType_MIN;
  static constexpr ActionType ActionType_MAX =
    ResolvedMergeWhenEnums_ActionType_ActionType_MAX;
  static constexpr int ActionType_ARRAYSIZE =
    ResolvedMergeWhenEnums_ActionType_ActionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ActionType_descriptor() {
    return ResolvedMergeWhenEnums_ActionType_descriptor();
  }
  template<typename T>
  static inline const std::string& ActionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ActionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ActionType_Name.");
    return ResolvedMergeWhenEnums_ActionType_Name(enum_t_value);
  }
  static inline bool ActionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ActionType* value) {
    return ResolvedMergeWhenEnums_ActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedMergeWhenEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedArgumentDefEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedArgumentDefEnums) */ {
 public:
  inline ResolvedArgumentDefEnums() : ResolvedArgumentDefEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedArgumentDefEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedArgumentDefEnums(const ResolvedArgumentDefEnums& from);
  ResolvedArgumentDefEnums(ResolvedArgumentDefEnums&& from) noexcept
    : ResolvedArgumentDefEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedArgumentDefEnums& operator=(const ResolvedArgumentDefEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedArgumentDefEnums& operator=(ResolvedArgumentDefEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedArgumentDefEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedArgumentDefEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedArgumentDefEnums*>(
               &_ResolvedArgumentDefEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ResolvedArgumentDefEnums& a, ResolvedArgumentDefEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedArgumentDefEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedArgumentDefEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedArgumentDefEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedArgumentDefEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedArgumentDefEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedArgumentDefEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedArgumentDefEnums";
  }
  protected:
  explicit ResolvedArgumentDefEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedArgumentDefEnums_ArgumentKind ArgumentKind;
  static constexpr ArgumentKind SCALAR =
    ResolvedArgumentDefEnums_ArgumentKind_SCALAR;
  static constexpr ArgumentKind AGGREGATE =
    ResolvedArgumentDefEnums_ArgumentKind_AGGREGATE;
  static constexpr ArgumentKind NOT_AGGREGATE =
    ResolvedArgumentDefEnums_ArgumentKind_NOT_AGGREGATE;
  static inline bool ArgumentKind_IsValid(int value) {
    return ResolvedArgumentDefEnums_ArgumentKind_IsValid(value);
  }
  static constexpr ArgumentKind ArgumentKind_MIN =
    ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_MIN;
  static constexpr ArgumentKind ArgumentKind_MAX =
    ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_MAX;
  static constexpr int ArgumentKind_ARRAYSIZE =
    ResolvedArgumentDefEnums_ArgumentKind_ArgumentKind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ArgumentKind_descriptor() {
    return ResolvedArgumentDefEnums_ArgumentKind_descriptor();
  }
  template<typename T>
  static inline const std::string& ArgumentKind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ArgumentKind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ArgumentKind_Name.");
    return ResolvedArgumentDefEnums_ArgumentKind_Name(enum_t_value);
  }
  static inline bool ArgumentKind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ArgumentKind* value) {
    return ResolvedArgumentDefEnums_ArgumentKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedArgumentDefEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedFunctionCallBaseEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedFunctionCallBaseEnums) */ {
 public:
  inline ResolvedFunctionCallBaseEnums() : ResolvedFunctionCallBaseEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedFunctionCallBaseEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedFunctionCallBaseEnums(const ResolvedFunctionCallBaseEnums& from);
  ResolvedFunctionCallBaseEnums(ResolvedFunctionCallBaseEnums&& from) noexcept
    : ResolvedFunctionCallBaseEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedFunctionCallBaseEnums& operator=(const ResolvedFunctionCallBaseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedFunctionCallBaseEnums& operator=(ResolvedFunctionCallBaseEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedFunctionCallBaseEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedFunctionCallBaseEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedFunctionCallBaseEnums*>(
               &_ResolvedFunctionCallBaseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ResolvedFunctionCallBaseEnums& a, ResolvedFunctionCallBaseEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedFunctionCallBaseEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedFunctionCallBaseEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedFunctionCallBaseEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedFunctionCallBaseEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedFunctionCallBaseEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedFunctionCallBaseEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedFunctionCallBaseEnums";
  }
  protected:
  explicit ResolvedFunctionCallBaseEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedFunctionCallBaseEnums_ErrorMode ErrorMode;
  static constexpr ErrorMode DEFAULT_ERROR_MODE =
    ResolvedFunctionCallBaseEnums_ErrorMode_DEFAULT_ERROR_MODE;
  static constexpr ErrorMode SAFE_ERROR_MODE =
    ResolvedFunctionCallBaseEnums_ErrorMode_SAFE_ERROR_MODE;
  static inline bool ErrorMode_IsValid(int value) {
    return ResolvedFunctionCallBaseEnums_ErrorMode_IsValid(value);
  }
  static constexpr ErrorMode ErrorMode_MIN =
    ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_MIN;
  static constexpr ErrorMode ErrorMode_MAX =
    ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_MAX;
  static constexpr int ErrorMode_ARRAYSIZE =
    ResolvedFunctionCallBaseEnums_ErrorMode_ErrorMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ErrorMode_descriptor() {
    return ResolvedFunctionCallBaseEnums_ErrorMode_descriptor();
  }
  template<typename T>
  static inline const std::string& ErrorMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorMode_Name.");
    return ResolvedFunctionCallBaseEnums_ErrorMode_Name(enum_t_value);
  }
  static inline bool ErrorMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorMode* value) {
    return ResolvedFunctionCallBaseEnums_ErrorMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedFunctionCallBaseEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedNonScalarFunctionCallBaseEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedNonScalarFunctionCallBaseEnums) */ {
 public:
  inline ResolvedNonScalarFunctionCallBaseEnums() : ResolvedNonScalarFunctionCallBaseEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedNonScalarFunctionCallBaseEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedNonScalarFunctionCallBaseEnums(const ResolvedNonScalarFunctionCallBaseEnums& from);
  ResolvedNonScalarFunctionCallBaseEnums(ResolvedNonScalarFunctionCallBaseEnums&& from) noexcept
    : ResolvedNonScalarFunctionCallBaseEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedNonScalarFunctionCallBaseEnums& operator=(const ResolvedNonScalarFunctionCallBaseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedNonScalarFunctionCallBaseEnums& operator=(ResolvedNonScalarFunctionCallBaseEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedNonScalarFunctionCallBaseEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedNonScalarFunctionCallBaseEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedNonScalarFunctionCallBaseEnums*>(
               &_ResolvedNonScalarFunctionCallBaseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ResolvedNonScalarFunctionCallBaseEnums& a, ResolvedNonScalarFunctionCallBaseEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedNonScalarFunctionCallBaseEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedNonScalarFunctionCallBaseEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedNonScalarFunctionCallBaseEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedNonScalarFunctionCallBaseEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedNonScalarFunctionCallBaseEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedNonScalarFunctionCallBaseEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedNonScalarFunctionCallBaseEnums";
  }
  protected:
  explicit ResolvedNonScalarFunctionCallBaseEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier NullHandlingModifier;
  static constexpr NullHandlingModifier DEFAULT_NULL_HANDLING =
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING;
  static constexpr NullHandlingModifier IGNORE_NULLS =
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_IGNORE_NULLS;
  static constexpr NullHandlingModifier RESPECT_NULLS =
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_RESPECT_NULLS;
  static inline bool NullHandlingModifier_IsValid(int value) {
    return ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_IsValid(value);
  }
  static constexpr NullHandlingModifier NullHandlingModifier_MIN =
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_MIN;
  static constexpr NullHandlingModifier NullHandlingModifier_MAX =
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_MAX;
  static constexpr int NullHandlingModifier_ARRAYSIZE =
    ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_NullHandlingModifier_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NullHandlingModifier_descriptor() {
    return ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_descriptor();
  }
  template<typename T>
  static inline const std::string& NullHandlingModifier_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NullHandlingModifier>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NullHandlingModifier_Name.");
    return ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_Name(enum_t_value);
  }
  static inline bool NullHandlingModifier_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NullHandlingModifier* value) {
    return ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedNonScalarFunctionCallBaseEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedAggregateHavingModifierEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedAggregateHavingModifierEnums) */ {
 public:
  inline ResolvedAggregateHavingModifierEnums() : ResolvedAggregateHavingModifierEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedAggregateHavingModifierEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedAggregateHavingModifierEnums(const ResolvedAggregateHavingModifierEnums& from);
  ResolvedAggregateHavingModifierEnums(ResolvedAggregateHavingModifierEnums&& from) noexcept
    : ResolvedAggregateHavingModifierEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedAggregateHavingModifierEnums& operator=(const ResolvedAggregateHavingModifierEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedAggregateHavingModifierEnums& operator=(ResolvedAggregateHavingModifierEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedAggregateHavingModifierEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedAggregateHavingModifierEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedAggregateHavingModifierEnums*>(
               &_ResolvedAggregateHavingModifierEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ResolvedAggregateHavingModifierEnums& a, ResolvedAggregateHavingModifierEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedAggregateHavingModifierEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedAggregateHavingModifierEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedAggregateHavingModifierEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedAggregateHavingModifierEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedAggregateHavingModifierEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedAggregateHavingModifierEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedAggregateHavingModifierEnums";
  }
  protected:
  explicit ResolvedAggregateHavingModifierEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedAggregateHavingModifierEnums_HavingModifierKind HavingModifierKind;
  static constexpr HavingModifierKind INVALID =
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_INVALID;
  static constexpr HavingModifierKind MAX =
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_MAX;
  static constexpr HavingModifierKind MIN =
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_MIN;
  static inline bool HavingModifierKind_IsValid(int value) {
    return ResolvedAggregateHavingModifierEnums_HavingModifierKind_IsValid(value);
  }
  static constexpr HavingModifierKind HavingModifierKind_MIN =
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_MIN;
  static constexpr HavingModifierKind HavingModifierKind_MAX =
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_MAX;
  static constexpr int HavingModifierKind_ARRAYSIZE =
    ResolvedAggregateHavingModifierEnums_HavingModifierKind_HavingModifierKind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HavingModifierKind_descriptor() {
    return ResolvedAggregateHavingModifierEnums_HavingModifierKind_descriptor();
  }
  template<typename T>
  static inline const std::string& HavingModifierKind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HavingModifierKind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HavingModifierKind_Name.");
    return ResolvedAggregateHavingModifierEnums_HavingModifierKind_Name(enum_t_value);
  }
  static inline bool HavingModifierKind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HavingModifierKind* value) {
    return ResolvedAggregateHavingModifierEnums_HavingModifierKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedAggregateHavingModifierEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedStatementEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedStatementEnums) */ {
 public:
  inline ResolvedStatementEnums() : ResolvedStatementEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedStatementEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedStatementEnums(const ResolvedStatementEnums& from);
  ResolvedStatementEnums(ResolvedStatementEnums&& from) noexcept
    : ResolvedStatementEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedStatementEnums& operator=(const ResolvedStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedStatementEnums& operator=(ResolvedStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedStatementEnums*>(
               &_ResolvedStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ResolvedStatementEnums& a, ResolvedStatementEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedStatementEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedStatementEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedStatementEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedStatementEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedStatementEnums";
  }
  protected:
  explicit ResolvedStatementEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedStatementEnums_ObjectAccess ObjectAccess;
  static constexpr ObjectAccess NONE =
    ResolvedStatementEnums_ObjectAccess_NONE;
  static constexpr ObjectAccess READ =
    ResolvedStatementEnums_ObjectAccess_READ;
  static constexpr ObjectAccess WRITE =
    ResolvedStatementEnums_ObjectAccess_WRITE;
  static constexpr ObjectAccess READ_WRITE =
    ResolvedStatementEnums_ObjectAccess_READ_WRITE;
  static inline bool ObjectAccess_IsValid(int value) {
    return ResolvedStatementEnums_ObjectAccess_IsValid(value);
  }
  static constexpr ObjectAccess ObjectAccess_MIN =
    ResolvedStatementEnums_ObjectAccess_ObjectAccess_MIN;
  static constexpr ObjectAccess ObjectAccess_MAX =
    ResolvedStatementEnums_ObjectAccess_ObjectAccess_MAX;
  static constexpr int ObjectAccess_ARRAYSIZE =
    ResolvedStatementEnums_ObjectAccess_ObjectAccess_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ObjectAccess_descriptor() {
    return ResolvedStatementEnums_ObjectAccess_descriptor();
  }
  template<typename T>
  static inline const std::string& ObjectAccess_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ObjectAccess>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ObjectAccess_Name.");
    return ResolvedStatementEnums_ObjectAccess_Name(enum_t_value);
  }
  static inline bool ObjectAccess_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ObjectAccess* value) {
    return ResolvedStatementEnums_ObjectAccess_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedStatementEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedImportStmtEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedImportStmtEnums) */ {
 public:
  inline ResolvedImportStmtEnums() : ResolvedImportStmtEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedImportStmtEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedImportStmtEnums(const ResolvedImportStmtEnums& from);
  ResolvedImportStmtEnums(ResolvedImportStmtEnums&& from) noexcept
    : ResolvedImportStmtEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedImportStmtEnums& operator=(const ResolvedImportStmtEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedImportStmtEnums& operator=(ResolvedImportStmtEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedImportStmtEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedImportStmtEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedImportStmtEnums*>(
               &_ResolvedImportStmtEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ResolvedImportStmtEnums& a, ResolvedImportStmtEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedImportStmtEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedImportStmtEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedImportStmtEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedImportStmtEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedImportStmtEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedImportStmtEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedImportStmtEnums";
  }
  protected:
  explicit ResolvedImportStmtEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedImportStmtEnums_ImportKind ImportKind;
  static constexpr ImportKind MODULE =
    ResolvedImportStmtEnums_ImportKind_MODULE;
  static constexpr ImportKind PROTO =
    ResolvedImportStmtEnums_ImportKind_PROTO;
  static constexpr ImportKind __ImportKind__switch_must_have_a_default__ =
    ResolvedImportStmtEnums_ImportKind___ImportKind__switch_must_have_a_default__;
  static inline bool ImportKind_IsValid(int value) {
    return ResolvedImportStmtEnums_ImportKind_IsValid(value);
  }
  static constexpr ImportKind ImportKind_MIN =
    ResolvedImportStmtEnums_ImportKind_ImportKind_MIN;
  static constexpr ImportKind ImportKind_MAX =
    ResolvedImportStmtEnums_ImportKind_ImportKind_MAX;
  static constexpr int ImportKind_ARRAYSIZE =
    ResolvedImportStmtEnums_ImportKind_ImportKind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ImportKind_descriptor() {
    return ResolvedImportStmtEnums_ImportKind_descriptor();
  }
  template<typename T>
  static inline const std::string& ImportKind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ImportKind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ImportKind_Name.");
    return ResolvedImportStmtEnums_ImportKind_Name(enum_t_value);
  }
  static inline bool ImportKind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ImportKind* value) {
    return ResolvedImportStmtEnums_ImportKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedImportStmtEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedForeignKeyEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedForeignKeyEnums) */ {
 public:
  inline ResolvedForeignKeyEnums() : ResolvedForeignKeyEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedForeignKeyEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedForeignKeyEnums(const ResolvedForeignKeyEnums& from);
  ResolvedForeignKeyEnums(ResolvedForeignKeyEnums&& from) noexcept
    : ResolvedForeignKeyEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedForeignKeyEnums& operator=(const ResolvedForeignKeyEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedForeignKeyEnums& operator=(ResolvedForeignKeyEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedForeignKeyEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedForeignKeyEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedForeignKeyEnums*>(
               &_ResolvedForeignKeyEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ResolvedForeignKeyEnums& a, ResolvedForeignKeyEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedForeignKeyEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedForeignKeyEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedForeignKeyEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedForeignKeyEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedForeignKeyEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedForeignKeyEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedForeignKeyEnums";
  }
  protected:
  explicit ResolvedForeignKeyEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedForeignKeyEnums_MatchMode MatchMode;
  static constexpr MatchMode SIMPLE =
    ResolvedForeignKeyEnums_MatchMode_SIMPLE;
  static constexpr MatchMode FULL =
    ResolvedForeignKeyEnums_MatchMode_FULL;
  static constexpr MatchMode NOT_DISTINCT =
    ResolvedForeignKeyEnums_MatchMode_NOT_DISTINCT;
  static inline bool MatchMode_IsValid(int value) {
    return ResolvedForeignKeyEnums_MatchMode_IsValid(value);
  }
  static constexpr MatchMode MatchMode_MIN =
    ResolvedForeignKeyEnums_MatchMode_MatchMode_MIN;
  static constexpr MatchMode MatchMode_MAX =
    ResolvedForeignKeyEnums_MatchMode_MatchMode_MAX;
  static constexpr int MatchMode_ARRAYSIZE =
    ResolvedForeignKeyEnums_MatchMode_MatchMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MatchMode_descriptor() {
    return ResolvedForeignKeyEnums_MatchMode_descriptor();
  }
  template<typename T>
  static inline const std::string& MatchMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MatchMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MatchMode_Name.");
    return ResolvedForeignKeyEnums_MatchMode_Name(enum_t_value);
  }
  static inline bool MatchMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MatchMode* value) {
    return ResolvedForeignKeyEnums_MatchMode_Parse(name, value);
  }

  typedef ResolvedForeignKeyEnums_ActionOperation ActionOperation;
  static constexpr ActionOperation NO_ACTION =
    ResolvedForeignKeyEnums_ActionOperation_NO_ACTION;
  static constexpr ActionOperation RESTRICT =
    ResolvedForeignKeyEnums_ActionOperation_RESTRICT;
  static constexpr ActionOperation CASCADE =
    ResolvedForeignKeyEnums_ActionOperation_CASCADE;
  static constexpr ActionOperation SET_NULL =
    ResolvedForeignKeyEnums_ActionOperation_SET_NULL;
  static inline bool ActionOperation_IsValid(int value) {
    return ResolvedForeignKeyEnums_ActionOperation_IsValid(value);
  }
  static constexpr ActionOperation ActionOperation_MIN =
    ResolvedForeignKeyEnums_ActionOperation_ActionOperation_MIN;
  static constexpr ActionOperation ActionOperation_MAX =
    ResolvedForeignKeyEnums_ActionOperation_ActionOperation_MAX;
  static constexpr int ActionOperation_ARRAYSIZE =
    ResolvedForeignKeyEnums_ActionOperation_ActionOperation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ActionOperation_descriptor() {
    return ResolvedForeignKeyEnums_ActionOperation_descriptor();
  }
  template<typename T>
  static inline const std::string& ActionOperation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ActionOperation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ActionOperation_Name.");
    return ResolvedForeignKeyEnums_ActionOperation_Name(enum_t_value);
  }
  static inline bool ActionOperation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ActionOperation* value) {
    return ResolvedForeignKeyEnums_ActionOperation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedForeignKeyEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ResolvedAuxLoadDataStmtEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ResolvedAuxLoadDataStmtEnums) */ {
 public:
  inline ResolvedAuxLoadDataStmtEnums() : ResolvedAuxLoadDataStmtEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResolvedAuxLoadDataStmtEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedAuxLoadDataStmtEnums(const ResolvedAuxLoadDataStmtEnums& from);
  ResolvedAuxLoadDataStmtEnums(ResolvedAuxLoadDataStmtEnums&& from) noexcept
    : ResolvedAuxLoadDataStmtEnums() {
    *this = ::std::move(from);
  }

  inline ResolvedAuxLoadDataStmtEnums& operator=(const ResolvedAuxLoadDataStmtEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedAuxLoadDataStmtEnums& operator=(ResolvedAuxLoadDataStmtEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedAuxLoadDataStmtEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedAuxLoadDataStmtEnums* internal_default_instance() {
    return reinterpret_cast<const ResolvedAuxLoadDataStmtEnums*>(
               &_ResolvedAuxLoadDataStmtEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ResolvedAuxLoadDataStmtEnums& a, ResolvedAuxLoadDataStmtEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedAuxLoadDataStmtEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedAuxLoadDataStmtEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedAuxLoadDataStmtEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedAuxLoadDataStmtEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResolvedAuxLoadDataStmtEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResolvedAuxLoadDataStmtEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedAuxLoadDataStmtEnums";
  }
  protected:
  explicit ResolvedAuxLoadDataStmtEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResolvedAuxLoadDataStmtEnums_InsertionMode InsertionMode;
  static constexpr InsertionMode NONE =
    ResolvedAuxLoadDataStmtEnums_InsertionMode_NONE;
  static constexpr InsertionMode APPEND =
    ResolvedAuxLoadDataStmtEnums_InsertionMode_APPEND;
  static constexpr InsertionMode OVERWRITE =
    ResolvedAuxLoadDataStmtEnums_InsertionMode_OVERWRITE;
  static inline bool InsertionMode_IsValid(int value) {
    return ResolvedAuxLoadDataStmtEnums_InsertionMode_IsValid(value);
  }
  static constexpr InsertionMode InsertionMode_MIN =
    ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_MIN;
  static constexpr InsertionMode InsertionMode_MAX =
    ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_MAX;
  static constexpr int InsertionMode_ARRAYSIZE =
    ResolvedAuxLoadDataStmtEnums_InsertionMode_InsertionMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InsertionMode_descriptor() {
    return ResolvedAuxLoadDataStmtEnums_InsertionMode_descriptor();
  }
  template<typename T>
  static inline const std::string& InsertionMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InsertionMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InsertionMode_Name.");
    return ResolvedAuxLoadDataStmtEnums_InsertionMode_Name(enum_t_value);
  }
  static inline bool InsertionMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InsertionMode* value) {
    return ResolvedAuxLoadDataStmtEnums_InsertionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedAuxLoadDataStmtEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ResolvedSubqueryExprEnums

// -------------------------------------------------------------------

// ResolvedJoinScanEnums

// -------------------------------------------------------------------

// ResolvedSetOperationScanEnums

// -------------------------------------------------------------------

// ResolvedRecursiveScanEnums

// -------------------------------------------------------------------

// ResolvedSampleScanEnums

// -------------------------------------------------------------------

// ResolvedOrderByItemEnums

// -------------------------------------------------------------------

// ResolvedCreateStatementEnums

// -------------------------------------------------------------------

// ResolvedGeneratedColumnInfoEnums

// -------------------------------------------------------------------

// ResolvedDropStmtEnums

// -------------------------------------------------------------------

// ResolvedBeginStmtEnums

// -------------------------------------------------------------------

// ResolvedWindowFrameEnums

// -------------------------------------------------------------------

// ResolvedWindowFrameExprEnums

// -------------------------------------------------------------------

// ResolvedInsertStmtEnums

// -------------------------------------------------------------------

// ResolvedMergeWhenEnums

// -------------------------------------------------------------------

// ResolvedArgumentDefEnums

// -------------------------------------------------------------------

// ResolvedFunctionCallBaseEnums

// -------------------------------------------------------------------

// ResolvedNonScalarFunctionCallBaseEnums

// -------------------------------------------------------------------

// ResolvedAggregateHavingModifierEnums

// -------------------------------------------------------------------

// ResolvedStatementEnums

// -------------------------------------------------------------------

// ResolvedImportStmtEnums

// -------------------------------------------------------------------

// ResolvedForeignKeyEnums

// -------------------------------------------------------------------

// ResolvedAuxLoadDataStmtEnums

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zetasql

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zetasql::ResolvedSubqueryExprEnums_SubqueryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedSubqueryExprEnums_SubqueryType>() {
  return ::zetasql::ResolvedSubqueryExprEnums_SubqueryType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedJoinScanEnums_JoinType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedJoinScanEnums_JoinType>() {
  return ::zetasql::ResolvedJoinScanEnums_JoinType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedSetOperationScanEnums_SetOperationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedSetOperationScanEnums_SetOperationType>() {
  return ::zetasql::ResolvedSetOperationScanEnums_SetOperationType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedRecursiveScanEnums_RecursiveSetOperationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedRecursiveScanEnums_RecursiveSetOperationType>() {
  return ::zetasql::ResolvedRecursiveScanEnums_RecursiveSetOperationType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedSampleScanEnums_SampleUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedSampleScanEnums_SampleUnit>() {
  return ::zetasql::ResolvedSampleScanEnums_SampleUnit_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedOrderByItemEnums_NullOrderMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedOrderByItemEnums_NullOrderMode>() {
  return ::zetasql::ResolvedOrderByItemEnums_NullOrderMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedCreateStatementEnums_CreateScope> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedCreateStatementEnums_CreateScope>() {
  return ::zetasql::ResolvedCreateStatementEnums_CreateScope_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedCreateStatementEnums_CreateMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedCreateStatementEnums_CreateMode>() {
  return ::zetasql::ResolvedCreateStatementEnums_CreateMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedCreateStatementEnums_SqlSecurity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedCreateStatementEnums_SqlSecurity>() {
  return ::zetasql::ResolvedCreateStatementEnums_SqlSecurity_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedCreateStatementEnums_DeterminismLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedCreateStatementEnums_DeterminismLevel>() {
  return ::zetasql::ResolvedCreateStatementEnums_DeterminismLevel_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedGeneratedColumnInfoEnums_StoredMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedGeneratedColumnInfoEnums_StoredMode>() {
  return ::zetasql::ResolvedGeneratedColumnInfoEnums_StoredMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedDropStmtEnums_DropMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedDropStmtEnums_DropMode>() {
  return ::zetasql::ResolvedDropStmtEnums_DropMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedBeginStmtEnums_ReadWriteMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedBeginStmtEnums_ReadWriteMode>() {
  return ::zetasql::ResolvedBeginStmtEnums_ReadWriteMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedWindowFrameEnums_FrameUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedWindowFrameEnums_FrameUnit>() {
  return ::zetasql::ResolvedWindowFrameEnums_FrameUnit_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedWindowFrameExprEnums_BoundaryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedWindowFrameExprEnums_BoundaryType>() {
  return ::zetasql::ResolvedWindowFrameExprEnums_BoundaryType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedInsertStmtEnums_InsertMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedInsertStmtEnums_InsertMode>() {
  return ::zetasql::ResolvedInsertStmtEnums_InsertMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedMergeWhenEnums_MatchType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedMergeWhenEnums_MatchType>() {
  return ::zetasql::ResolvedMergeWhenEnums_MatchType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedMergeWhenEnums_ActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedMergeWhenEnums_ActionType>() {
  return ::zetasql::ResolvedMergeWhenEnums_ActionType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedArgumentDefEnums_ArgumentKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedArgumentDefEnums_ArgumentKind>() {
  return ::zetasql::ResolvedArgumentDefEnums_ArgumentKind_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedFunctionCallBaseEnums_ErrorMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedFunctionCallBaseEnums_ErrorMode>() {
  return ::zetasql::ResolvedFunctionCallBaseEnums_ErrorMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier>() {
  return ::zetasql::ResolvedNonScalarFunctionCallBaseEnums_NullHandlingModifier_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedAggregateHavingModifierEnums_HavingModifierKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedAggregateHavingModifierEnums_HavingModifierKind>() {
  return ::zetasql::ResolvedAggregateHavingModifierEnums_HavingModifierKind_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedStatementEnums_ObjectAccess> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedStatementEnums_ObjectAccess>() {
  return ::zetasql::ResolvedStatementEnums_ObjectAccess_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedImportStmtEnums_ImportKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedImportStmtEnums_ImportKind>() {
  return ::zetasql::ResolvedImportStmtEnums_ImportKind_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedForeignKeyEnums_MatchMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedForeignKeyEnums_MatchMode>() {
  return ::zetasql::ResolvedForeignKeyEnums_MatchMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedForeignKeyEnums_ActionOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedForeignKeyEnums_ActionOperation>() {
  return ::zetasql::ResolvedForeignKeyEnums_ActionOperation_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ResolvedAuxLoadDataStmtEnums_InsertionMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ResolvedAuxLoadDataStmtEnums_InsertionMode>() {
  return ::zetasql::ResolvedAuxLoadDataStmtEnums_InsertionMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_zetasql_2fresolved_5fast_2fresolved_5fast_5fenums_2eproto
