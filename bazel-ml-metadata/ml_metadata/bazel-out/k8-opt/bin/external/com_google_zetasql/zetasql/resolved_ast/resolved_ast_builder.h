//
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// resolved_ast_builder.h GENERATED FROM resolved_ast_builder.h.template
#ifndef ZETASQL_RESOLVED_AST_RESOLVED_AST_BUILDER_H_
#define ZETASQL_RESOLVED_AST_RESOLVED_AST_BUILDER_H_

#include <atomic>
#include <memory>
#include <vector>

#include "zetasql/base/logging.h"
#include "zetasql/common/status_payload_utils.h"
#include "zetasql/resolved_ast/resolved_ast.h"
#include "absl/status/statusor.h"

namespace zetasql {

// Forward declaration of builder classes to declare them as `friend` in node
// classes
class ResolvedLiteralBuilder;
class ResolvedParameterBuilder;
class ResolvedExpressionColumnBuilder;
class ResolvedColumnRefBuilder;
class ResolvedConstantBuilder;
class ResolvedSystemVariableBuilder;
class ResolvedInlineLambdaBuilder;
class ResolvedFilterFieldArgBuilder;
class ResolvedFilterFieldBuilder;
class ResolvedFunctionCallBuilder;
class ResolvedAggregateFunctionCallBuilder;
class ResolvedAnalyticFunctionCallBuilder;
class ResolvedExtendedCastElementBuilder;
class ResolvedExtendedCastBuilder;
class ResolvedCastBuilder;
class ResolvedMakeStructBuilder;
class ResolvedMakeProtoBuilder;
class ResolvedMakeProtoFieldBuilder;
class ResolvedGetStructFieldBuilder;
class ResolvedGetProtoFieldBuilder;
class ResolvedGetJsonFieldBuilder;
class ResolvedFlattenBuilder;
class ResolvedFlattenedArgBuilder;
class ResolvedReplaceFieldItemBuilder;
class ResolvedReplaceFieldBuilder;
class ResolvedSubqueryExprBuilder;
class ResolvedWithExprBuilder;
class ResolvedModelBuilder;
class ResolvedConnectionBuilder;
class ResolvedDescriptorBuilder;
class ResolvedSingleRowScanBuilder;
class ResolvedTableScanBuilder;
class ResolvedJoinScanBuilder;
class ResolvedArrayScanBuilder;
class ResolvedColumnHolderBuilder;
class ResolvedFilterScanBuilder;
class ResolvedGroupingSetBuilder;
class ResolvedAggregateScanBuilder;
class ResolvedAnonymizedAggregateScanBuilder;
class ResolvedSetOperationItemBuilder;
class ResolvedSetOperationScanBuilder;
class ResolvedOrderByScanBuilder;
class ResolvedLimitOffsetScanBuilder;
class ResolvedWithRefScanBuilder;
class ResolvedAnalyticScanBuilder;
class ResolvedSampleScanBuilder;
class ResolvedComputedColumnBuilder;
class ResolvedOrderByItemBuilder;
class ResolvedColumnAnnotationsBuilder;
class ResolvedGeneratedColumnInfoBuilder;
class ResolvedColumnDefaultValueBuilder;
class ResolvedColumnDefinitionBuilder;
class ResolvedPrimaryKeyBuilder;
class ResolvedForeignKeyBuilder;
class ResolvedCheckConstraintBuilder;
class ResolvedOutputColumnBuilder;
class ResolvedProjectScanBuilder;
class ResolvedTVFScanBuilder;
class ResolvedGroupRowsScanBuilder;
class ResolvedFunctionArgumentBuilder;
class ResolvedExplainStmtBuilder;
class ResolvedQueryStmtBuilder;
class ResolvedCreateDatabaseStmtBuilder;
class ResolvedIndexItemBuilder;
class ResolvedUnnestItemBuilder;
class ResolvedCreateIndexStmtBuilder;
class ResolvedCreateSchemaStmtBuilder;
class ResolvedCreateTableStmtBuilder;
class ResolvedCreateTableAsSelectStmtBuilder;
class ResolvedCreateModelStmtBuilder;
class ResolvedCreateViewStmtBuilder;
class ResolvedWithPartitionColumnsBuilder;
class ResolvedCreateSnapshotTableStmtBuilder;
class ResolvedCreateExternalTableStmtBuilder;
class ResolvedExportModelStmtBuilder;
class ResolvedExportDataStmtBuilder;
class ResolvedDefineTableStmtBuilder;
class ResolvedDescribeStmtBuilder;
class ResolvedShowStmtBuilder;
class ResolvedBeginStmtBuilder;
class ResolvedSetTransactionStmtBuilder;
class ResolvedCommitStmtBuilder;
class ResolvedRollbackStmtBuilder;
class ResolvedStartBatchStmtBuilder;
class ResolvedRunBatchStmtBuilder;
class ResolvedAbortBatchStmtBuilder;
class ResolvedDropStmtBuilder;
class ResolvedDropMaterializedViewStmtBuilder;
class ResolvedDropSnapshotTableStmtBuilder;
class ResolvedRecursiveRefScanBuilder;
class ResolvedRecursiveScanBuilder;
class ResolvedWithScanBuilder;
class ResolvedWithEntryBuilder;
class ResolvedOptionBuilder;
class ResolvedWindowPartitioningBuilder;
class ResolvedWindowOrderingBuilder;
class ResolvedWindowFrameBuilder;
class ResolvedAnalyticFunctionGroupBuilder;
class ResolvedWindowFrameExprBuilder;
class ResolvedDMLValueBuilder;
class ResolvedDMLDefaultBuilder;
class ResolvedAssertStmtBuilder;
class ResolvedAssertRowsModifiedBuilder;
class ResolvedInsertRowBuilder;
class ResolvedInsertStmtBuilder;
class ResolvedDeleteStmtBuilder;
class ResolvedUpdateItemBuilder;
class ResolvedUpdateArrayItemBuilder;
class ResolvedUpdateStmtBuilder;
class ResolvedMergeWhenBuilder;
class ResolvedMergeStmtBuilder;
class ResolvedTruncateStmtBuilder;
class ResolvedObjectUnitBuilder;
class ResolvedPrivilegeBuilder;
class ResolvedGrantStmtBuilder;
class ResolvedRevokeStmtBuilder;
class ResolvedAlterDatabaseStmtBuilder;
class ResolvedAlterMaterializedViewStmtBuilder;
class ResolvedAlterSchemaStmtBuilder;
class ResolvedAlterModelStmtBuilder;
class ResolvedAlterTableStmtBuilder;
class ResolvedAlterViewStmtBuilder;
class ResolvedSetOptionsActionBuilder;
class ResolvedAlterSubEntityActionBuilder;
class ResolvedAddSubEntityActionBuilder;
class ResolvedDropSubEntityActionBuilder;
class ResolvedAddColumnActionBuilder;
class ResolvedAddConstraintActionBuilder;
class ResolvedDropConstraintActionBuilder;
class ResolvedDropPrimaryKeyActionBuilder;
class ResolvedAlterColumnOptionsActionBuilder;
class ResolvedAlterColumnDropNotNullActionBuilder;
class ResolvedAlterColumnSetDataTypeActionBuilder;
class ResolvedAlterColumnSetDefaultActionBuilder;
class ResolvedAlterColumnDropDefaultActionBuilder;
class ResolvedDropColumnActionBuilder;
class ResolvedRenameColumnActionBuilder;
class ResolvedSetAsActionBuilder;
class ResolvedSetCollateClauseBuilder;
class ResolvedAlterTableSetOptionsStmtBuilder;
class ResolvedRenameStmtBuilder;
class ResolvedCreatePrivilegeRestrictionStmtBuilder;
class ResolvedCreateRowAccessPolicyStmtBuilder;
class ResolvedDropPrivilegeRestrictionStmtBuilder;
class ResolvedDropRowAccessPolicyStmtBuilder;
class ResolvedDropSearchIndexStmtBuilder;
class ResolvedGrantToActionBuilder;
class ResolvedRestrictToActionBuilder;
class ResolvedAddToRestricteeListActionBuilder;
class ResolvedRemoveFromRestricteeListActionBuilder;
class ResolvedFilterUsingActionBuilder;
class ResolvedRevokeFromActionBuilder;
class ResolvedRenameToActionBuilder;
class ResolvedAlterPrivilegeRestrictionStmtBuilder;
class ResolvedAlterRowAccessPolicyStmtBuilder;
class ResolvedAlterAllRowAccessPoliciesStmtBuilder;
class ResolvedCreateConstantStmtBuilder;
class ResolvedCreateFunctionStmtBuilder;
class ResolvedArgumentDefBuilder;
class ResolvedArgumentRefBuilder;
class ResolvedCreateTableFunctionStmtBuilder;
class ResolvedRelationArgumentScanBuilder;
class ResolvedArgumentListBuilder;
class ResolvedFunctionSignatureHolderBuilder;
class ResolvedDropFunctionStmtBuilder;
class ResolvedDropTableFunctionStmtBuilder;
class ResolvedCallStmtBuilder;
class ResolvedImportStmtBuilder;
class ResolvedModuleStmtBuilder;
class ResolvedAggregateHavingModifierBuilder;
class ResolvedCreateMaterializedViewStmtBuilder;
class ResolvedCreateProcedureStmtBuilder;
class ResolvedExecuteImmediateArgumentBuilder;
class ResolvedExecuteImmediateStmtBuilder;
class ResolvedAssignmentStmtBuilder;
class ResolvedCreateEntityStmtBuilder;
class ResolvedAlterEntityStmtBuilder;
class ResolvedPivotColumnBuilder;
class ResolvedPivotScanBuilder;
class ResolvedReturningClauseBuilder;
class ResolvedUnpivotArgBuilder;
class ResolvedUnpivotScanBuilder;
class ResolvedCloneDataStmtBuilder;
class ResolvedTableAndColumnInfoBuilder;
class ResolvedAnalyzeStmtBuilder;
class ResolvedAuxLoadDataStmtBuilder;

class ResolvedLiteralBuilder final {
 public:
  ResolvedLiteralBuilder() : ResolvedLiteralBuilder(absl::WrapUnique(new ResolvedLiteral)) {}

  ResolvedLiteralBuilder(const ResolvedLiteralBuilder&) = delete;
  ResolvedLiteralBuilder& operator=(const ResolvedLiteralBuilder&) = delete;
  ResolvedLiteralBuilder(ResolvedLiteralBuilder&& other)
      : ResolvedLiteralBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedLiteralBuilder& operator=(ResolvedLiteralBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedLiteral>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedLiteral::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedLiteral::value was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const Value& value() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->value();
  }

  ResolvedLiteralBuilder&& set_value(const Value& v) && {
    node_->set_value(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedLiteralBuilder& set_value(const Value& v) & {
    node_->set_value(v);
    field_is_set_.set(2, true);

    return *this;
  }

  // If true, then the literal is explicitly typed and cannot be used
  // for literal coercions.
  //
  // This exists mainly for resolver bookkeeping and should be ignored
  // by engines.
  bool has_explicit_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->has_explicit_type();
  }

  ResolvedLiteralBuilder&& set_has_explicit_type(bool v) && {
    node_->set_has_explicit_type(v);

    return std::move(*this);
  }

  ResolvedLiteralBuilder& set_has_explicit_type(bool v) & {
    node_->set_has_explicit_type(v);

    return *this;
  }

  // Distinct ID of the literal, if it is a floating point value,
  // within the resolved AST. When coercing from floating point
  // to NUMERIC, the resolver uses the float_literal_id to find the
  // original image of the literal to avoid precision loss. An ID of 0
  // represents a literal without a cached image.
  int float_literal_id() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->float_literal_id();
  }

  ResolvedLiteralBuilder&& set_float_literal_id(int v) && {
    node_->set_float_literal_id(v);

    return std::move(*this);
  }

  ResolvedLiteralBuilder& set_float_literal_id(int v) & {
    node_->set_float_literal_id(v);

    return *this;
  }

  // Indicates whether ReplaceLiteralsByParameters() should leave
  // this literal value in place, rather than replace it with a query
  // parameter.
  bool preserve_in_literal_remover() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->preserve_in_literal_remover();
  }

  ResolvedLiteralBuilder&& set_preserve_in_literal_remover(bool v) && {
    node_->set_preserve_in_literal_remover(v);

    return std::move(*this);
  }

  ResolvedLiteralBuilder& set_preserve_in_literal_remover(bool v) & {
    node_->set_preserve_in_literal_remover(v);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedLiteralBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedLiteralBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedLiteralBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedLiteralBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedLiteral> node_;

  absl::Status deferred_build_status_;
  std::bitset<6> field_is_set_ = {0};
  friend ResolvedLiteralBuilder ToBuilder(
      std::unique_ptr<const ResolvedLiteral> node);

  ResolvedLiteralBuilder(std::unique_ptr<ResolvedLiteral> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedLiteralBuilder ToBuilder(
    std::unique_ptr<const ResolvedLiteral> node) {
  ResolvedLiteralBuilder builder(absl::WrapUnique<ResolvedLiteral>(
      const_cast<ResolvedLiteral*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedParameterBuilder final {
 public:
  ResolvedParameterBuilder() : ResolvedParameterBuilder(absl::WrapUnique(new ResolvedParameter)) {}

  ResolvedParameterBuilder(const ResolvedParameterBuilder&) = delete;
  ResolvedParameterBuilder& operator=(const ResolvedParameterBuilder&) = delete;
  ResolvedParameterBuilder(ResolvedParameterBuilder&& other)
      : ResolvedParameterBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedParameterBuilder& operator=(ResolvedParameterBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedParameter>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedParameter::type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // If non-empty, the name of the parameter.
  //
  // A ResolvedParameter will have either a name or a position but not
  // both.
  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedParameterBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);

    return std::move(*this);
  }

  ResolvedParameterBuilder& set_name(const std::string& v) & {
    node_->set_name(v);

    return *this;
  }

  // If non-zero, the 1-based position of the positional parameter.
  //
  // A ResolvedParameter will have either a name or a position but not
  // both.
  int position() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->position();
  }

  ResolvedParameterBuilder&& set_position(int v) && {
    node_->set_position(v);

    return std::move(*this);
  }

  ResolvedParameterBuilder& set_position(int v) & {
    node_->set_position(v);

    return *this;
  }

  // If true, then the parameter has no specified type.
  //
  // This exists mainly for resolver bookkeeping and should be ignored
  // by engines.
  bool is_untyped() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_untyped();
  }

  ResolvedParameterBuilder&& set_is_untyped(bool v) && {
    node_->set_is_untyped(v);

    return std::move(*this);
  }

  ResolvedParameterBuilder& set_is_untyped(bool v) & {
    node_->set_is_untyped(v);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedParameterBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedParameterBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedParameterBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedParameterBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedParameter> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedParameterBuilder ToBuilder(
      std::unique_ptr<const ResolvedParameter> node);

  ResolvedParameterBuilder(std::unique_ptr<ResolvedParameter> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedParameterBuilder ToBuilder(
    std::unique_ptr<const ResolvedParameter> node) {
  ResolvedParameterBuilder builder(absl::WrapUnique<ResolvedParameter>(
      const_cast<ResolvedParameter*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedExpressionColumnBuilder final {
 public:
  ResolvedExpressionColumnBuilder() : ResolvedExpressionColumnBuilder(absl::WrapUnique(new ResolvedExpressionColumn)) {}

  ResolvedExpressionColumnBuilder(const ResolvedExpressionColumnBuilder&) = delete;
  ResolvedExpressionColumnBuilder& operator=(const ResolvedExpressionColumnBuilder&) = delete;
  ResolvedExpressionColumnBuilder(ResolvedExpressionColumnBuilder&& other)
      : ResolvedExpressionColumnBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedExpressionColumnBuilder& operator=(ResolvedExpressionColumnBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedExpressionColumn>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedExpressionColumn::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedExpressionColumn::name was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedExpressionColumnBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedExpressionColumnBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(2, true);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedExpressionColumnBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedExpressionColumnBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedExpressionColumnBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedExpressionColumnBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedExpressionColumn> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedExpressionColumnBuilder ToBuilder(
      std::unique_ptr<const ResolvedExpressionColumn> node);

  ResolvedExpressionColumnBuilder(std::unique_ptr<ResolvedExpressionColumn> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedExpressionColumnBuilder ToBuilder(
    std::unique_ptr<const ResolvedExpressionColumn> node) {
  ResolvedExpressionColumnBuilder builder(absl::WrapUnique<ResolvedExpressionColumn>(
      const_cast<ResolvedExpressionColumn*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedColumnRefBuilder final {
 public:
  ResolvedColumnRefBuilder() : ResolvedColumnRefBuilder(absl::WrapUnique(new ResolvedColumnRef)) {}

  ResolvedColumnRefBuilder(const ResolvedColumnRefBuilder&) = delete;
  ResolvedColumnRefBuilder& operator=(const ResolvedColumnRefBuilder&) = delete;
  ResolvedColumnRefBuilder(ResolvedColumnRefBuilder&& other)
      : ResolvedColumnRefBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedColumnRefBuilder& operator=(ResolvedColumnRefBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedColumnRef>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedColumnRef::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedColumnRef::column was not set on the builder");
    }
    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedColumnRef::is_correlated was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedColumn& column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column();
  }

  ResolvedColumnRefBuilder&& set_column(const ResolvedColumn& v) && {
    node_->set_column(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedColumnRefBuilder& set_column(const ResolvedColumn& v) & {
    node_->set_column(v);
    field_is_set_.set(2, true);

    return *this;
  }

  bool is_correlated() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_correlated();
  }

  ResolvedColumnRefBuilder&& set_is_correlated(bool v) && {
    node_->set_is_correlated(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedColumnRefBuilder& set_is_correlated(bool v) & {
    node_->set_is_correlated(v);
    field_is_set_.set(3, true);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedColumnRefBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedColumnRefBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedColumnRefBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedColumnRefBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedColumnRef> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedColumnRefBuilder ToBuilder(
      std::unique_ptr<const ResolvedColumnRef> node);

  ResolvedColumnRefBuilder(std::unique_ptr<ResolvedColumnRef> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedColumnRefBuilder ToBuilder(
    std::unique_ptr<const ResolvedColumnRef> node) {
  ResolvedColumnRefBuilder builder(absl::WrapUnique<ResolvedColumnRef>(
      const_cast<ResolvedColumnRef*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedConstantBuilder final {
 public:
  ResolvedConstantBuilder() : ResolvedConstantBuilder(absl::WrapUnique(new ResolvedConstant)) {}

  ResolvedConstantBuilder(const ResolvedConstantBuilder&) = delete;
  ResolvedConstantBuilder& operator=(const ResolvedConstantBuilder&) = delete;
  ResolvedConstantBuilder(ResolvedConstantBuilder&& other)
      : ResolvedConstantBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedConstantBuilder& operator=(ResolvedConstantBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedConstant>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedConstant::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedConstant::constant was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // The matching Constant from the Catalog.
  const Constant* constant() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->constant();
  }

  ResolvedConstantBuilder&& set_constant(const Constant* v) && {
    node_->set_constant(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedConstantBuilder& set_constant(const Constant* v) & {
    node_->set_constant(v);
    field_is_set_.set(2, true);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedConstantBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedConstantBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedConstantBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedConstantBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedConstant> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedConstantBuilder ToBuilder(
      std::unique_ptr<const ResolvedConstant> node);

  ResolvedConstantBuilder(std::unique_ptr<ResolvedConstant> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedConstantBuilder ToBuilder(
    std::unique_ptr<const ResolvedConstant> node) {
  ResolvedConstantBuilder builder(absl::WrapUnique<ResolvedConstant>(
      const_cast<ResolvedConstant*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedSystemVariableBuilder final {
 public:
  ResolvedSystemVariableBuilder() : ResolvedSystemVariableBuilder(absl::WrapUnique(new ResolvedSystemVariable)) {}

  ResolvedSystemVariableBuilder(const ResolvedSystemVariableBuilder&) = delete;
  ResolvedSystemVariableBuilder& operator=(const ResolvedSystemVariableBuilder&) = delete;
  ResolvedSystemVariableBuilder(ResolvedSystemVariableBuilder&& other)
      : ResolvedSystemVariableBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedSystemVariableBuilder& operator=(ResolvedSystemVariableBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedSystemVariable>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedSystemVariable::type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // Path to system variable.
  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedSystemVariableBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedSystemVariableBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedSystemVariableBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedSystemVariableBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedSystemVariableBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedSystemVariableBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedSystemVariableBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedSystemVariableBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedSystemVariable> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedSystemVariableBuilder ToBuilder(
      std::unique_ptr<const ResolvedSystemVariable> node);

  ResolvedSystemVariableBuilder(std::unique_ptr<ResolvedSystemVariable> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedSystemVariableBuilder ToBuilder(
    std::unique_ptr<const ResolvedSystemVariable> node) {
  ResolvedSystemVariableBuilder builder(absl::WrapUnique<ResolvedSystemVariable>(
      const_cast<ResolvedSystemVariable*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedInlineLambdaBuilder final {
 public:
  ResolvedInlineLambdaBuilder() : ResolvedInlineLambdaBuilder(absl::WrapUnique(new ResolvedInlineLambda)) {}

  ResolvedInlineLambdaBuilder(const ResolvedInlineLambdaBuilder&) = delete;
  ResolvedInlineLambdaBuilder& operator=(const ResolvedInlineLambdaBuilder&) = delete;
  ResolvedInlineLambdaBuilder(ResolvedInlineLambdaBuilder&& other)
      : ResolvedInlineLambdaBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedInlineLambdaBuilder& operator=(ResolvedInlineLambdaBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedInlineLambda>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedInlineLambda::body was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<ResolvedColumn>& argument_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list();
  }

  int argument_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list_size();
  }

  const ResolvedColumn& argument_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list(i);
  }

  ResolvedInlineLambdaBuilder&& add_argument_list(ResolvedColumn v) && {
    node_->add_argument_list(v);

    return std::move(*this);
  }

  ResolvedInlineLambdaBuilder& add_argument_list(ResolvedColumn v) & {
    node_->add_argument_list(v);

    return *this;
  }

  ResolvedInlineLambdaBuilder&& set_argument_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_argument_list(v);

    return std::move(*this);
  }

  ResolvedInlineLambdaBuilder& set_argument_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_argument_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedColumnRef>>& parameter_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->parameter_list();
  }

  int parameter_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->parameter_list_size();
  }

  const ResolvedColumnRef* parameter_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->parameter_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedInlineLambdaBuilder&& add_parameter_list(T v) && {
    node_->add_parameter_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedInlineLambdaBuilder& add_parameter_list(T v) & {
    node_->add_parameter_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedInlineLambdaBuilder&& add_parameter_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedInlineLambdaBuilder& add_parameter_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnRef>> release_parameter_list() {
    return node_->release_parameter_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedInlineLambdaBuilder&& set_parameter_list(T v) && {
    node_->set_parameter_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedInlineLambdaBuilder& set_parameter_list(T v) & {
    node_->set_parameter_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedInlineLambdaBuilder&& set_parameter_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedInlineLambdaBuilder& set_parameter_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedExpr* body() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->body();
  }

  std::unique_ptr<const ResolvedExpr> release_body() {
    return node_->release_body();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedInlineLambdaBuilder&& set_body(T v) && {
    node_->set_body(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedInlineLambdaBuilder& set_body(T v) & {
    node_->set_body(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedInlineLambdaBuilder&& set_body(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_body(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedInlineLambdaBuilder& set_body(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_body(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedInlineLambda> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedInlineLambdaBuilder ToBuilder(
      std::unique_ptr<const ResolvedInlineLambda> node);

  ResolvedInlineLambdaBuilder(std::unique_ptr<ResolvedInlineLambda> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedInlineLambdaBuilder ToBuilder(
    std::unique_ptr<const ResolvedInlineLambda> node) {
  ResolvedInlineLambdaBuilder builder(absl::WrapUnique<ResolvedInlineLambda>(
      const_cast<ResolvedInlineLambda*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedFilterFieldArgBuilder final {
 public:
  ResolvedFilterFieldArgBuilder() : ResolvedFilterFieldArgBuilder(absl::WrapUnique(new ResolvedFilterFieldArg)) {}

  ResolvedFilterFieldArgBuilder(const ResolvedFilterFieldArgBuilder&) = delete;
  ResolvedFilterFieldArgBuilder& operator=(const ResolvedFilterFieldArgBuilder&) = delete;
  ResolvedFilterFieldArgBuilder(ResolvedFilterFieldArgBuilder&& other)
      : ResolvedFilterFieldArgBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedFilterFieldArgBuilder& operator=(ResolvedFilterFieldArgBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedFilterFieldArg>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFilterFieldArg::include was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // True if we want to include this proto path in the resulting proto
  // (though we may still remove paths below it).
  // If False, we will remove this path (but may still include paths
  // below it).
  bool include() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->include();
  }

  ResolvedFilterFieldArgBuilder&& set_include(bool v) && {
    node_->set_include(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedFilterFieldArgBuilder& set_include(bool v) & {
    node_->set_include(v);
    field_is_set_.set(0, true);

    return *this;
  }

  // A vector of FieldDescriptors that denotes the path to a proto
  // field that will be include or exclude.
  const std::vector<const google::protobuf::FieldDescriptor*>& field_descriptor_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->field_descriptor_path();
  }

  int field_descriptor_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->field_descriptor_path_size();
  }

  const google::protobuf::FieldDescriptor* field_descriptor_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->field_descriptor_path(i);
  }

  ResolvedFilterFieldArgBuilder&& add_field_descriptor_path(const google::protobuf::FieldDescriptor* v) && {
    node_->add_field_descriptor_path(v);

    return std::move(*this);
  }

  ResolvedFilterFieldArgBuilder& add_field_descriptor_path(const google::protobuf::FieldDescriptor* v) & {
    node_->add_field_descriptor_path(v);

    return *this;
  }

  ResolvedFilterFieldArgBuilder&& set_field_descriptor_path(const std::vector<const google::protobuf::FieldDescriptor*>& v) && {
    node_->set_field_descriptor_path(v);

    return std::move(*this);
  }

  ResolvedFilterFieldArgBuilder& set_field_descriptor_path(const std::vector<const google::protobuf::FieldDescriptor*>& v) & {
    node_->set_field_descriptor_path(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedFilterFieldArg> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedFilterFieldArgBuilder ToBuilder(
      std::unique_ptr<const ResolvedFilterFieldArg> node);

  ResolvedFilterFieldArgBuilder(std::unique_ptr<ResolvedFilterFieldArg> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedFilterFieldArgBuilder ToBuilder(
    std::unique_ptr<const ResolvedFilterFieldArg> node) {
  ResolvedFilterFieldArgBuilder builder(absl::WrapUnique<ResolvedFilterFieldArg>(
      const_cast<ResolvedFilterFieldArg*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedFilterFieldBuilder final {
 public:
  ResolvedFilterFieldBuilder() : ResolvedFilterFieldBuilder(absl::WrapUnique(new ResolvedFilterField)) {}

  ResolvedFilterFieldBuilder(const ResolvedFilterFieldBuilder&) = delete;
  ResolvedFilterFieldBuilder& operator=(const ResolvedFilterFieldBuilder&) = delete;
  ResolvedFilterFieldBuilder(ResolvedFilterFieldBuilder&& other)
      : ResolvedFilterFieldBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedFilterFieldBuilder& operator=(ResolvedFilterFieldBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedFilterField>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFilterField::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFilterField::expr was not set on the builder");
    }
    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFilterField::reset_cleared_required_fields was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // The proto to modify.
  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFilterFieldBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFilterFieldBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFilterFieldBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFilterFieldBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

  // The list of field paths to include or exclude. The path starts
  // from the proto type of <expr>.
  const std::vector<std::unique_ptr<const ResolvedFilterFieldArg>>& filter_field_arg_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->filter_field_arg_list();
  }

  int filter_field_arg_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->filter_field_arg_list_size();
  }

  const ResolvedFilterFieldArg* filter_field_arg_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->filter_field_arg_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedFilterFieldArg>>::value>>
  ResolvedFilterFieldBuilder&& add_filter_field_arg_list(T v) && {
    node_->add_filter_field_arg_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedFilterFieldArg>>::value>>
  ResolvedFilterFieldBuilder& add_filter_field_arg_list(T v) & {
    node_->add_filter_field_arg_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedFilterFieldArg>>::value>>
  ResolvedFilterFieldBuilder&& add_filter_field_arg_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_filter_field_arg_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedFilterFieldArg>>::value>>
  ResolvedFilterFieldBuilder& add_filter_field_arg_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_filter_field_arg_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedFilterFieldArg>> release_filter_field_arg_list() {
    return node_->release_filter_field_arg_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedFilterFieldArg>>>::value>>
  ResolvedFilterFieldBuilder&& set_filter_field_arg_list(T v) && {
    node_->set_filter_field_arg_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedFilterFieldArg>>>::value>>
  ResolvedFilterFieldBuilder& set_filter_field_arg_list(T v) & {
    node_->set_filter_field_arg_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedFilterFieldArg>>>::value>>
  ResolvedFilterFieldBuilder&& set_filter_field_arg_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_filter_field_arg_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedFilterFieldArg>>>::value>>
  ResolvedFilterFieldBuilder& set_filter_field_arg_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_filter_field_arg_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // If true, will reset cleared required fields into a
  // default value.
  bool reset_cleared_required_fields() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->reset_cleared_required_fields();
  }

  ResolvedFilterFieldBuilder&& set_reset_cleared_required_fields(bool v) && {
    node_->set_reset_cleared_required_fields(v);
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  ResolvedFilterFieldBuilder& set_reset_cleared_required_fields(bool v) & {
    node_->set_reset_cleared_required_fields(v);
    field_is_set_.set(4, true);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedFilterFieldBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedFilterFieldBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedFilterFieldBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedFilterFieldBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedFilterField> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedFilterFieldBuilder ToBuilder(
      std::unique_ptr<const ResolvedFilterField> node);

  ResolvedFilterFieldBuilder(std::unique_ptr<ResolvedFilterField> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedFilterFieldBuilder ToBuilder(
    std::unique_ptr<const ResolvedFilterField> node) {
  ResolvedFilterFieldBuilder builder(absl::WrapUnique<ResolvedFilterField>(
      const_cast<ResolvedFilterField*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedFunctionCallBuilder final {
 public:
  ResolvedFunctionCallBuilder() : ResolvedFunctionCallBuilder(absl::WrapUnique(new ResolvedFunctionCall)) {}

  ResolvedFunctionCallBuilder(const ResolvedFunctionCallBuilder&) = delete;
  ResolvedFunctionCallBuilder& operator=(const ResolvedFunctionCallBuilder&) = delete;
  ResolvedFunctionCallBuilder(ResolvedFunctionCallBuilder&& other)
      : ResolvedFunctionCallBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedFunctionCallBuilder& operator=(ResolvedFunctionCallBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedFunctionCall>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFunctionCall::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFunctionCall::function was not set on the builder");
    }
    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFunctionCall::signature was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // This contains optional custom information about a particular
  // function call.
  //
  // If some Function subclass requires computing additional
  // information at resolving time, that extra information can be
  // stored as a subclass of ResolvedFunctionCallInfo here.
  // For example, TemplatedSQLFunction stores the resolved template
  // body here as a TemplatedSQLFunctionCall.
  //
  // This field is ignorable because for most types of function calls,
  // there is no extra information to consider besides the arguments
  // and other fields from ResolvedFunctionCallBase.
  const std::shared_ptr<ResolvedFunctionCallInfo>& function_call_info() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->function_call_info();
  }

  ResolvedFunctionCallBuilder&& set_function_call_info(const std::shared_ptr<ResolvedFunctionCallInfo>& v) && {
    node_->set_function_call_info(v);

    return std::move(*this);
  }

  ResolvedFunctionCallBuilder& set_function_call_info(const std::shared_ptr<ResolvedFunctionCallInfo>& v) & {
    node_->set_function_call_info(v);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedFunctionCallBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedFunctionCallBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedFunctionCallBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedFunctionCallBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

  // The matching Function from the Catalog.
  const Function* function() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->function();
  }

  ResolvedFunctionCallBuilder&& set_function(const Function* v) && {
    node_->set_function(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedFunctionCallBuilder& set_function(const Function* v) & {
    node_->set_function(v);
    field_is_set_.set(2, true);

    return *this;
  }

  // The concrete FunctionSignature reflecting the matching Function
  // signature and the function's resolved input <argument_list>.
  // The function has the mode AGGREGATE iff it is an aggregate
  // function, in which case this node must be either
  // ResolvedAggregateFunctionCall or ResolvedAnalyticFunctionCall.
  const FunctionSignature& signature() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->signature();
  }

  ResolvedFunctionCallBuilder&& set_signature(const FunctionSignature& v) && {
    node_->set_signature(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedFunctionCallBuilder& set_signature(const FunctionSignature& v) & {
    node_->set_signature(v);
    field_is_set_.set(3, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& argument_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list();
  }

  int argument_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list_size();
  }

  const ResolvedExpr* argument_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFunctionCallBuilder&& add_argument_list(T v) && {
    node_->add_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFunctionCallBuilder& add_argument_list(T v) & {
    node_->add_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFunctionCallBuilder&& add_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFunctionCallBuilder& add_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_argument_list() {
    return node_->release_argument_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedFunctionCallBuilder&& set_argument_list(T v) && {
    node_->set_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedFunctionCallBuilder& set_argument_list(T v) & {
    node_->set_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedFunctionCallBuilder&& set_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedFunctionCallBuilder& set_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedFunctionArgument>>& generic_argument_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->generic_argument_list();
  }

  int generic_argument_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->generic_argument_list_size();
  }

  const ResolvedFunctionArgument* generic_argument_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->generic_argument_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedFunctionCallBuilder&& add_generic_argument_list(T v) && {
    node_->add_generic_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedFunctionCallBuilder& add_generic_argument_list(T v) & {
    node_->add_generic_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedFunctionCallBuilder&& add_generic_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_generic_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedFunctionCallBuilder& add_generic_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_generic_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedFunctionArgument>> release_generic_argument_list() {
    return node_->release_generic_argument_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedFunctionCallBuilder&& set_generic_argument_list(T v) && {
    node_->set_generic_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedFunctionCallBuilder& set_generic_argument_list(T v) & {
    node_->set_generic_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedFunctionCallBuilder&& set_generic_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_generic_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedFunctionCallBuilder& set_generic_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_generic_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // If error_mode=SAFE_ERROR_MODE, and if this function call returns a
  // semantic error (based on input data, not transient server
  // problems), return NULL instead of an error. This is used for
  // functions called using SAFE, as in SAFE.FUNCTION(...).
  ResolvedFunctionCallBase::ErrorMode error_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->error_mode();
  }

  ResolvedFunctionCallBuilder&& set_error_mode(ResolvedFunctionCallBase::ErrorMode v) && {
    node_->set_error_mode(v);

    return std::move(*this);
  }

  ResolvedFunctionCallBuilder& set_error_mode(ResolvedFunctionCallBase::ErrorMode v) & {
    node_->set_error_mode(v);

    return *this;
  }

  // Function call hints.
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedFunctionCallBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedFunctionCallBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedFunctionCallBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedFunctionCallBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedFunctionCallBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedFunctionCallBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedFunctionCallBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedFunctionCallBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedCollation>& collation_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list();
  }

  int collation_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list_size();
  }

  const ResolvedCollation& collation_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list(i);
  }

  ResolvedFunctionCallBuilder&& add_collation_list(ResolvedCollation v) && {
    node_->add_collation_list(v);

    return std::move(*this);
  }

  ResolvedFunctionCallBuilder& add_collation_list(ResolvedCollation v) & {
    node_->add_collation_list(v);

    return *this;
  }

  ResolvedFunctionCallBuilder&& set_collation_list(const std::vector<ResolvedCollation>& v) && {
    node_->set_collation_list(v);

    return std::move(*this);
  }

  ResolvedFunctionCallBuilder& set_collation_list(const std::vector<ResolvedCollation>& v) & {
    node_->set_collation_list(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedFunctionCall> node_;

  absl::Status deferred_build_status_;
  std::bitset<10> field_is_set_ = {0};
  friend ResolvedFunctionCallBuilder ToBuilder(
      std::unique_ptr<const ResolvedFunctionCall> node);

  ResolvedFunctionCallBuilder(std::unique_ptr<ResolvedFunctionCall> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedFunctionCallBuilder ToBuilder(
    std::unique_ptr<const ResolvedFunctionCall> node) {
  ResolvedFunctionCallBuilder builder(absl::WrapUnique<ResolvedFunctionCall>(
      const_cast<ResolvedFunctionCall*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedAggregateFunctionCallBuilder final {
 public:
  ResolvedAggregateFunctionCallBuilder() : ResolvedAggregateFunctionCallBuilder(absl::WrapUnique(new ResolvedAggregateFunctionCall)) {}

  ResolvedAggregateFunctionCallBuilder(const ResolvedAggregateFunctionCallBuilder&) = delete;
  ResolvedAggregateFunctionCallBuilder& operator=(const ResolvedAggregateFunctionCallBuilder&) = delete;
  ResolvedAggregateFunctionCallBuilder(ResolvedAggregateFunctionCallBuilder&& other)
      : ResolvedAggregateFunctionCallBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAggregateFunctionCallBuilder& operator=(ResolvedAggregateFunctionCallBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAggregateFunctionCall>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAggregateFunctionCall::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAggregateFunctionCall::function was not set on the builder");
    }
    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAggregateFunctionCall::signature was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // Apply HAVING MAX/MIN filtering to the stream of input values.
  const ResolvedAggregateHavingModifier* having_modifier() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->having_modifier();
  }

  std::unique_ptr<const ResolvedAggregateHavingModifier> release_having_modifier() {
    return node_->release_having_modifier();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAggregateHavingModifier>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_having_modifier(T v) && {
    node_->set_having_modifier(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAggregateHavingModifier>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_having_modifier(T v) & {
    node_->set_having_modifier(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAggregateHavingModifier>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_having_modifier(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_having_modifier(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAggregateHavingModifier>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_having_modifier(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_having_modifier(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Apply ordering to the stream of input values before calling
  // function.
  const std::vector<std::unique_ptr<const ResolvedOrderByItem>>& order_by_item_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->order_by_item_list();
  }

  int order_by_item_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->order_by_item_list_size();
  }

  const ResolvedOrderByItem* order_by_item_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->order_by_item_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOrderByItem>>::value>>
  ResolvedAggregateFunctionCallBuilder&& add_order_by_item_list(T v) && {
    node_->add_order_by_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOrderByItem>>::value>>
  ResolvedAggregateFunctionCallBuilder& add_order_by_item_list(T v) & {
    node_->add_order_by_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOrderByItem>>::value>>
  ResolvedAggregateFunctionCallBuilder&& add_order_by_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_order_by_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOrderByItem>>::value>>
  ResolvedAggregateFunctionCallBuilder& add_order_by_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_order_by_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOrderByItem>> release_order_by_item_list() {
    return node_->release_order_by_item_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOrderByItem>>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_order_by_item_list(T v) && {
    node_->set_order_by_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOrderByItem>>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_order_by_item_list(T v) & {
    node_->set_order_by_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOrderByItem>>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_order_by_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_order_by_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOrderByItem>>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_order_by_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_order_by_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedExpr* limit() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->limit();
  }

  std::unique_ptr<const ResolvedExpr> release_limit() {
    return node_->release_limit();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_limit(T v) && {
    node_->set_limit(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_limit(T v) & {
    node_->set_limit(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_limit(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_limit(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_limit(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_limit(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // This contains optional custom information about a particular
  // function call. Functions may introduce subclasses of this class to
  // add custom information as needed on a per-function basis.
  //
  // This field is ignorable because for most types of function calls,
  // there is no extra information to consider besides the arguments
  // and other fields from ResolvedFunctionCallBase. However, for
  // example, the TemplateSQLFunction in
  // zetasql/public/templated_sql_function.h defines the
  // TemplatedSQLFunctionCall subclass which includes the
  // fully-resolved function body in context of the actual concrete
  // types of the arguments provided to the function call.
  const std::shared_ptr<ResolvedFunctionCallInfo>& function_call_info() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->function_call_info();
  }

  ResolvedAggregateFunctionCallBuilder&& set_function_call_info(const std::shared_ptr<ResolvedFunctionCallInfo>& v) && {
    node_->set_function_call_info(v);

    return std::move(*this);
  }

  ResolvedAggregateFunctionCallBuilder& set_function_call_info(const std::shared_ptr<ResolvedFunctionCallInfo>& v) & {
    node_->set_function_call_info(v);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedAggregateFunctionCallBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedAggregateFunctionCallBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedAggregateFunctionCallBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedAggregateFunctionCallBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

  // The matching Function from the Catalog.
  const Function* function() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->function();
  }

  ResolvedAggregateFunctionCallBuilder&& set_function(const Function* v) && {
    node_->set_function(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedAggregateFunctionCallBuilder& set_function(const Function* v) & {
    node_->set_function(v);
    field_is_set_.set(2, true);

    return *this;
  }

  // The concrete FunctionSignature reflecting the matching Function
  // signature and the function's resolved input <argument_list>.
  // The function has the mode AGGREGATE iff it is an aggregate
  // function, in which case this node must be either
  // ResolvedAggregateFunctionCall or ResolvedAnalyticFunctionCall.
  const FunctionSignature& signature() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->signature();
  }

  ResolvedAggregateFunctionCallBuilder&& set_signature(const FunctionSignature& v) && {
    node_->set_signature(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedAggregateFunctionCallBuilder& set_signature(const FunctionSignature& v) & {
    node_->set_signature(v);
    field_is_set_.set(3, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& argument_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list();
  }

  int argument_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list_size();
  }

  const ResolvedExpr* argument_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAggregateFunctionCallBuilder&& add_argument_list(T v) && {
    node_->add_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAggregateFunctionCallBuilder& add_argument_list(T v) & {
    node_->add_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAggregateFunctionCallBuilder&& add_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAggregateFunctionCallBuilder& add_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_argument_list() {
    return node_->release_argument_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_argument_list(T v) && {
    node_->set_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_argument_list(T v) & {
    node_->set_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedFunctionArgument>>& generic_argument_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->generic_argument_list();
  }

  int generic_argument_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->generic_argument_list_size();
  }

  const ResolvedFunctionArgument* generic_argument_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->generic_argument_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedAggregateFunctionCallBuilder&& add_generic_argument_list(T v) && {
    node_->add_generic_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedAggregateFunctionCallBuilder& add_generic_argument_list(T v) & {
    node_->add_generic_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedAggregateFunctionCallBuilder&& add_generic_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_generic_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedAggregateFunctionCallBuilder& add_generic_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_generic_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedFunctionArgument>> release_generic_argument_list() {
    return node_->release_generic_argument_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_generic_argument_list(T v) && {
    node_->set_generic_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_generic_argument_list(T v) & {
    node_->set_generic_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_generic_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_generic_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_generic_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_generic_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // If error_mode=SAFE_ERROR_MODE, and if this function call returns a
  // semantic error (based on input data, not transient server
  // problems), return NULL instead of an error. This is used for
  // functions called using SAFE, as in SAFE.FUNCTION(...).
  ResolvedFunctionCallBase::ErrorMode error_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->error_mode();
  }

  ResolvedAggregateFunctionCallBuilder&& set_error_mode(ResolvedFunctionCallBase::ErrorMode v) && {
    node_->set_error_mode(v);

    return std::move(*this);
  }

  ResolvedAggregateFunctionCallBuilder& set_error_mode(ResolvedFunctionCallBase::ErrorMode v) & {
    node_->set_error_mode(v);

    return *this;
  }

  // Function call hints.
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAggregateFunctionCallBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAggregateFunctionCallBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAggregateFunctionCallBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAggregateFunctionCallBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedCollation>& collation_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list();
  }

  int collation_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list_size();
  }

  const ResolvedCollation& collation_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list(i);
  }

  ResolvedAggregateFunctionCallBuilder&& add_collation_list(ResolvedCollation v) && {
    node_->add_collation_list(v);

    return std::move(*this);
  }

  ResolvedAggregateFunctionCallBuilder& add_collation_list(ResolvedCollation v) & {
    node_->add_collation_list(v);

    return *this;
  }

  ResolvedAggregateFunctionCallBuilder&& set_collation_list(const std::vector<ResolvedCollation>& v) && {
    node_->set_collation_list(v);

    return std::move(*this);
  }

  ResolvedAggregateFunctionCallBuilder& set_collation_list(const std::vector<ResolvedCollation>& v) & {
    node_->set_collation_list(v);

    return *this;
  }

  // Apply DISTINCT to the stream of input values before calling
  // function.
  bool distinct() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->distinct();
  }

  ResolvedAggregateFunctionCallBuilder&& set_distinct(bool v) && {
    node_->set_distinct(v);

    return std::move(*this);
  }

  ResolvedAggregateFunctionCallBuilder& set_distinct(bool v) & {
    node_->set_distinct(v);

    return *this;
  }

  // Apply IGNORE/RESPECT NULLS filtering to the stream of input
  // values.
  ResolvedNonScalarFunctionCallBase::NullHandlingModifier null_handling_modifier() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->null_handling_modifier();
  }

  ResolvedAggregateFunctionCallBuilder&& set_null_handling_modifier(ResolvedNonScalarFunctionCallBase::NullHandlingModifier v) && {
    node_->set_null_handling_modifier(v);

    return std::move(*this);
  }

  ResolvedAggregateFunctionCallBuilder& set_null_handling_modifier(ResolvedNonScalarFunctionCallBase::NullHandlingModifier v) & {
    node_->set_null_handling_modifier(v);

    return *this;
  }

  // Holds a table subquery defined in WITH GROUP_ROWS(...) that is
  // evaluated over the input rows of a ResolvedAggregateScan
  // corresponding to the current group. The function itself is
  // evaluated over the rows returned from the subquery.
  //
  // The subquery should refer to a special TVF GROUP_ROWS(), which
  // resolves as ResolvedGroupRowsScan. The subquery will be run for
  // each group produced by ResolvedAggregateScan.
  //
  // GROUP_ROWS() produces a row for each source row in the
  // ResolvedAggregateScan's input that matches current group.
  //
  // The subquery cannot reference any ResolvedColumns from the outer
  // query except what comes in via <with_group_rows_parameter_list>,
  // and GROUP_ROWS().
  //
  // The subquery can return more than one column, and these columns
  // can be referenced by the function.
  //
  // The subquery can be correlated. In this case the
  // <with_group_rows_parameter_list> gives the set of ResolvedColumns
  // from outside the subquery that are used inside. The subuery cannot
  // refer to correlated columns that are used as aggregation input in
  // the immediate outer query. The same rules apply to
  // <with_group_rows_parameter_list> as in ResolvedSubqueryExpr.
  const ResolvedScan* with_group_rows_subquery() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_group_rows_subquery();
  }

  std::unique_ptr<const ResolvedScan> release_with_group_rows_subquery() {
    return node_->release_with_group_rows_subquery();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_with_group_rows_subquery(T v) && {
    node_->set_with_group_rows_subquery(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_with_group_rows_subquery(T v) & {
    node_->set_with_group_rows_subquery(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_with_group_rows_subquery(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_group_rows_subquery(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_with_group_rows_subquery(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_group_rows_subquery(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Correlated parameters to <with_group_rows_subquery>
  const std::vector<std::unique_ptr<const ResolvedColumnRef>>& with_group_rows_parameter_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_group_rows_parameter_list();
  }

  int with_group_rows_parameter_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_group_rows_parameter_list_size();
  }

  const ResolvedColumnRef* with_group_rows_parameter_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_group_rows_parameter_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAggregateFunctionCallBuilder&& add_with_group_rows_parameter_list(T v) && {
    node_->add_with_group_rows_parameter_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAggregateFunctionCallBuilder& add_with_group_rows_parameter_list(T v) & {
    node_->add_with_group_rows_parameter_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAggregateFunctionCallBuilder&& add_with_group_rows_parameter_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_with_group_rows_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAggregateFunctionCallBuilder& add_with_group_rows_parameter_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_with_group_rows_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnRef>> release_with_group_rows_parameter_list() {
    return node_->release_with_group_rows_parameter_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_with_group_rows_parameter_list(T v) && {
    node_->set_with_group_rows_parameter_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_with_group_rows_parameter_list(T v) & {
    node_->set_with_group_rows_parameter_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedAggregateFunctionCallBuilder&& set_with_group_rows_parameter_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_group_rows_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedAggregateFunctionCallBuilder& set_with_group_rows_parameter_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_group_rows_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAggregateFunctionCall> node_;

  absl::Status deferred_build_status_;
  std::bitset<17> field_is_set_ = {0};
  friend ResolvedAggregateFunctionCallBuilder ToBuilder(
      std::unique_ptr<const ResolvedAggregateFunctionCall> node);

  ResolvedAggregateFunctionCallBuilder(std::unique_ptr<ResolvedAggregateFunctionCall> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAggregateFunctionCallBuilder ToBuilder(
    std::unique_ptr<const ResolvedAggregateFunctionCall> node) {
  ResolvedAggregateFunctionCallBuilder builder(absl::WrapUnique<ResolvedAggregateFunctionCall>(
      const_cast<ResolvedAggregateFunctionCall*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedAnalyticFunctionCallBuilder final {
 public:
  ResolvedAnalyticFunctionCallBuilder() : ResolvedAnalyticFunctionCallBuilder(absl::WrapUnique(new ResolvedAnalyticFunctionCall)) {}

  ResolvedAnalyticFunctionCallBuilder(const ResolvedAnalyticFunctionCallBuilder&) = delete;
  ResolvedAnalyticFunctionCallBuilder& operator=(const ResolvedAnalyticFunctionCallBuilder&) = delete;
  ResolvedAnalyticFunctionCallBuilder(ResolvedAnalyticFunctionCallBuilder&& other)
      : ResolvedAnalyticFunctionCallBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAnalyticFunctionCallBuilder& operator=(ResolvedAnalyticFunctionCallBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAnalyticFunctionCall>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAnalyticFunctionCall::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAnalyticFunctionCall::function was not set on the builder");
    }
    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAnalyticFunctionCall::signature was not set on the builder");
    }
    if (!field_is_set_.test(13)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAnalyticFunctionCall::window_frame was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedWindowFrame* window_frame() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->window_frame();
  }

  std::unique_ptr<const ResolvedWindowFrame> release_window_frame() {
    return node_->release_window_frame();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWindowFrame>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& set_window_frame(T v) && {
    node_->set_window_frame(std::move(v));
    field_is_set_.set(13, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWindowFrame>>::value>>
  ResolvedAnalyticFunctionCallBuilder& set_window_frame(T v) & {
    node_->set_window_frame(std::move(v));
    field_is_set_.set(13, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWindowFrame>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& set_window_frame(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_window_frame(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(13, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWindowFrame>>::value>>
  ResolvedAnalyticFunctionCallBuilder& set_window_frame(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_window_frame(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(13, true);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedAnalyticFunctionCallBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedAnalyticFunctionCallBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedAnalyticFunctionCallBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedAnalyticFunctionCallBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

  // The matching Function from the Catalog.
  const Function* function() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->function();
  }

  ResolvedAnalyticFunctionCallBuilder&& set_function(const Function* v) && {
    node_->set_function(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedAnalyticFunctionCallBuilder& set_function(const Function* v) & {
    node_->set_function(v);
    field_is_set_.set(2, true);

    return *this;
  }

  // The concrete FunctionSignature reflecting the matching Function
  // signature and the function's resolved input <argument_list>.
  // The function has the mode AGGREGATE iff it is an aggregate
  // function, in which case this node must be either
  // ResolvedAggregateFunctionCall or ResolvedAnalyticFunctionCall.
  const FunctionSignature& signature() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->signature();
  }

  ResolvedAnalyticFunctionCallBuilder&& set_signature(const FunctionSignature& v) && {
    node_->set_signature(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedAnalyticFunctionCallBuilder& set_signature(const FunctionSignature& v) & {
    node_->set_signature(v);
    field_is_set_.set(3, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& argument_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list();
  }

  int argument_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list_size();
  }

  const ResolvedExpr* argument_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& add_argument_list(T v) && {
    node_->add_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAnalyticFunctionCallBuilder& add_argument_list(T v) & {
    node_->add_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& add_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAnalyticFunctionCallBuilder& add_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_argument_list() {
    return node_->release_argument_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& set_argument_list(T v) && {
    node_->set_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAnalyticFunctionCallBuilder& set_argument_list(T v) & {
    node_->set_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& set_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAnalyticFunctionCallBuilder& set_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedFunctionArgument>>& generic_argument_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->generic_argument_list();
  }

  int generic_argument_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->generic_argument_list_size();
  }

  const ResolvedFunctionArgument* generic_argument_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->generic_argument_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& add_generic_argument_list(T v) && {
    node_->add_generic_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedAnalyticFunctionCallBuilder& add_generic_argument_list(T v) & {
    node_->add_generic_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& add_generic_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_generic_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedAnalyticFunctionCallBuilder& add_generic_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_generic_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedFunctionArgument>> release_generic_argument_list() {
    return node_->release_generic_argument_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& set_generic_argument_list(T v) && {
    node_->set_generic_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedAnalyticFunctionCallBuilder& set_generic_argument_list(T v) & {
    node_->set_generic_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& set_generic_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_generic_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedAnalyticFunctionCallBuilder& set_generic_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_generic_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // If error_mode=SAFE_ERROR_MODE, and if this function call returns a
  // semantic error (based on input data, not transient server
  // problems), return NULL instead of an error. This is used for
  // functions called using SAFE, as in SAFE.FUNCTION(...).
  ResolvedFunctionCallBase::ErrorMode error_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->error_mode();
  }

  ResolvedAnalyticFunctionCallBuilder&& set_error_mode(ResolvedFunctionCallBase::ErrorMode v) && {
    node_->set_error_mode(v);

    return std::move(*this);
  }

  ResolvedAnalyticFunctionCallBuilder& set_error_mode(ResolvedFunctionCallBase::ErrorMode v) & {
    node_->set_error_mode(v);

    return *this;
  }

  // Function call hints.
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyticFunctionCallBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyticFunctionCallBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyticFunctionCallBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyticFunctionCallBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedCollation>& collation_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list();
  }

  int collation_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list_size();
  }

  const ResolvedCollation& collation_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list(i);
  }

  ResolvedAnalyticFunctionCallBuilder&& add_collation_list(ResolvedCollation v) && {
    node_->add_collation_list(v);

    return std::move(*this);
  }

  ResolvedAnalyticFunctionCallBuilder& add_collation_list(ResolvedCollation v) & {
    node_->add_collation_list(v);

    return *this;
  }

  ResolvedAnalyticFunctionCallBuilder&& set_collation_list(const std::vector<ResolvedCollation>& v) && {
    node_->set_collation_list(v);

    return std::move(*this);
  }

  ResolvedAnalyticFunctionCallBuilder& set_collation_list(const std::vector<ResolvedCollation>& v) & {
    node_->set_collation_list(v);

    return *this;
  }

  // Apply DISTINCT to the stream of input values before calling
  // function.
  bool distinct() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->distinct();
  }

  ResolvedAnalyticFunctionCallBuilder&& set_distinct(bool v) && {
    node_->set_distinct(v);

    return std::move(*this);
  }

  ResolvedAnalyticFunctionCallBuilder& set_distinct(bool v) & {
    node_->set_distinct(v);

    return *this;
  }

  // Apply IGNORE/RESPECT NULLS filtering to the stream of input
  // values.
  ResolvedNonScalarFunctionCallBase::NullHandlingModifier null_handling_modifier() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->null_handling_modifier();
  }

  ResolvedAnalyticFunctionCallBuilder&& set_null_handling_modifier(ResolvedNonScalarFunctionCallBase::NullHandlingModifier v) && {
    node_->set_null_handling_modifier(v);

    return std::move(*this);
  }

  ResolvedAnalyticFunctionCallBuilder& set_null_handling_modifier(ResolvedNonScalarFunctionCallBase::NullHandlingModifier v) & {
    node_->set_null_handling_modifier(v);

    return *this;
  }

  // Holds a table subquery defined in WITH GROUP_ROWS(...) that is
  // evaluated over the input rows of a ResolvedAggregateScan
  // corresponding to the current group. The function itself is
  // evaluated over the rows returned from the subquery.
  //
  // The subquery should refer to a special TVF GROUP_ROWS(), which
  // resolves as ResolvedGroupRowsScan. The subquery will be run for
  // each group produced by ResolvedAggregateScan.
  //
  // GROUP_ROWS() produces a row for each source row in the
  // ResolvedAggregateScan's input that matches current group.
  //
  // The subquery cannot reference any ResolvedColumns from the outer
  // query except what comes in via <with_group_rows_parameter_list>,
  // and GROUP_ROWS().
  //
  // The subquery can return more than one column, and these columns
  // can be referenced by the function.
  //
  // The subquery can be correlated. In this case the
  // <with_group_rows_parameter_list> gives the set of ResolvedColumns
  // from outside the subquery that are used inside. The subuery cannot
  // refer to correlated columns that are used as aggregation input in
  // the immediate outer query. The same rules apply to
  // <with_group_rows_parameter_list> as in ResolvedSubqueryExpr.
  const ResolvedScan* with_group_rows_subquery() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_group_rows_subquery();
  }

  std::unique_ptr<const ResolvedScan> release_with_group_rows_subquery() {
    return node_->release_with_group_rows_subquery();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& set_with_group_rows_subquery(T v) && {
    node_->set_with_group_rows_subquery(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAnalyticFunctionCallBuilder& set_with_group_rows_subquery(T v) & {
    node_->set_with_group_rows_subquery(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& set_with_group_rows_subquery(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_group_rows_subquery(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAnalyticFunctionCallBuilder& set_with_group_rows_subquery(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_group_rows_subquery(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Correlated parameters to <with_group_rows_subquery>
  const std::vector<std::unique_ptr<const ResolvedColumnRef>>& with_group_rows_parameter_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_group_rows_parameter_list();
  }

  int with_group_rows_parameter_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_group_rows_parameter_list_size();
  }

  const ResolvedColumnRef* with_group_rows_parameter_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_group_rows_parameter_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& add_with_group_rows_parameter_list(T v) && {
    node_->add_with_group_rows_parameter_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAnalyticFunctionCallBuilder& add_with_group_rows_parameter_list(T v) & {
    node_->add_with_group_rows_parameter_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& add_with_group_rows_parameter_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_with_group_rows_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAnalyticFunctionCallBuilder& add_with_group_rows_parameter_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_with_group_rows_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnRef>> release_with_group_rows_parameter_list() {
    return node_->release_with_group_rows_parameter_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& set_with_group_rows_parameter_list(T v) && {
    node_->set_with_group_rows_parameter_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedAnalyticFunctionCallBuilder& set_with_group_rows_parameter_list(T v) & {
    node_->set_with_group_rows_parameter_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedAnalyticFunctionCallBuilder&& set_with_group_rows_parameter_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_group_rows_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedAnalyticFunctionCallBuilder& set_with_group_rows_parameter_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_group_rows_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAnalyticFunctionCall> node_;

  absl::Status deferred_build_status_;
  std::bitset<14> field_is_set_ = {0};
  friend ResolvedAnalyticFunctionCallBuilder ToBuilder(
      std::unique_ptr<const ResolvedAnalyticFunctionCall> node);

  ResolvedAnalyticFunctionCallBuilder(std::unique_ptr<ResolvedAnalyticFunctionCall> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAnalyticFunctionCallBuilder ToBuilder(
    std::unique_ptr<const ResolvedAnalyticFunctionCall> node) {
  ResolvedAnalyticFunctionCallBuilder builder(absl::WrapUnique<ResolvedAnalyticFunctionCall>(
      const_cast<ResolvedAnalyticFunctionCall*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  builder.field_is_set_.set(3, true);
  builder.field_is_set_.set(13, true);
  return builder;
}

class ResolvedExtendedCastElementBuilder final {
 public:
  ResolvedExtendedCastElementBuilder() : ResolvedExtendedCastElementBuilder(absl::WrapUnique(new ResolvedExtendedCastElement)) {}

  ResolvedExtendedCastElementBuilder(const ResolvedExtendedCastElementBuilder&) = delete;
  ResolvedExtendedCastElementBuilder& operator=(const ResolvedExtendedCastElementBuilder&) = delete;
  ResolvedExtendedCastElementBuilder(ResolvedExtendedCastElementBuilder&& other)
      : ResolvedExtendedCastElementBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedExtendedCastElementBuilder& operator=(ResolvedExtendedCastElementBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedExtendedCastElement>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedExtendedCastElement::from_type was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedExtendedCastElement::to_type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedExtendedCastElement::function was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const Type* from_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->from_type();
  }

  ResolvedExtendedCastElementBuilder&& set_from_type(const Type* v) && {
    node_->set_from_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedExtendedCastElementBuilder& set_from_type(const Type* v) & {
    node_->set_from_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const Type* to_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->to_type();
  }

  ResolvedExtendedCastElementBuilder&& set_to_type(const Type* v) && {
    node_->set_to_type(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedExtendedCastElementBuilder& set_to_type(const Type* v) & {
    node_->set_to_type(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const Function* function() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->function();
  }

  ResolvedExtendedCastElementBuilder&& set_function(const Function* v) && {
    node_->set_function(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedExtendedCastElementBuilder& set_function(const Function* v) & {
    node_->set_function(v);
    field_is_set_.set(2, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedExtendedCastElement> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedExtendedCastElementBuilder ToBuilder(
      std::unique_ptr<const ResolvedExtendedCastElement> node);

  ResolvedExtendedCastElementBuilder(std::unique_ptr<ResolvedExtendedCastElement> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedExtendedCastElementBuilder ToBuilder(
    std::unique_ptr<const ResolvedExtendedCastElement> node) {
  ResolvedExtendedCastElementBuilder builder(absl::WrapUnique<ResolvedExtendedCastElement>(
      const_cast<ResolvedExtendedCastElement*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedExtendedCastBuilder final {
 public:
  ResolvedExtendedCastBuilder() : ResolvedExtendedCastBuilder(absl::WrapUnique(new ResolvedExtendedCast)) {}

  ResolvedExtendedCastBuilder(const ResolvedExtendedCastBuilder&) = delete;
  ResolvedExtendedCastBuilder& operator=(const ResolvedExtendedCastBuilder&) = delete;
  ResolvedExtendedCastBuilder(ResolvedExtendedCastBuilder&& other)
      : ResolvedExtendedCastBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedExtendedCastBuilder& operator=(ResolvedExtendedCastBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedExtendedCast>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // Stores the list of leaf extended casts required as elements of
  // this cast.  Each element is a cast where at least one of the input
  // or output is an extended type. For structs or arrays, the elements
  // will be casts for the field or element types. For structs, there
  // can be multiple cast elements (one for each distinct pair of field
  // types). For non-struct types, there will be just a single element.
  const std::vector<std::unique_ptr<const ResolvedExtendedCastElement>>& element_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->element_list();
  }

  int element_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->element_list_size();
  }

  const ResolvedExtendedCastElement* element_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->element_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExtendedCastElement>>::value>>
  ResolvedExtendedCastBuilder&& add_element_list(T v) && {
    node_->add_element_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExtendedCastElement>>::value>>
  ResolvedExtendedCastBuilder& add_element_list(T v) & {
    node_->add_element_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExtendedCastElement>>::value>>
  ResolvedExtendedCastBuilder&& add_element_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_element_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExtendedCastElement>>::value>>
  ResolvedExtendedCastBuilder& add_element_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_element_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExtendedCastElement>> release_element_list() {
    return node_->release_element_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExtendedCastElement>>>::value>>
  ResolvedExtendedCastBuilder&& set_element_list(T v) && {
    node_->set_element_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExtendedCastElement>>>::value>>
  ResolvedExtendedCastBuilder& set_element_list(T v) & {
    node_->set_element_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExtendedCastElement>>>::value>>
  ResolvedExtendedCastBuilder&& set_element_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_element_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExtendedCastElement>>>::value>>
  ResolvedExtendedCastBuilder& set_element_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_element_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedExtendedCast> node_;

  absl::Status deferred_build_status_;
  friend ResolvedExtendedCastBuilder ToBuilder(
      std::unique_ptr<const ResolvedExtendedCast> node);

  ResolvedExtendedCastBuilder(std::unique_ptr<ResolvedExtendedCast> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedExtendedCastBuilder ToBuilder(
    std::unique_ptr<const ResolvedExtendedCast> node) {
  ResolvedExtendedCastBuilder builder(absl::WrapUnique<ResolvedExtendedCast>(
      const_cast<ResolvedExtendedCast*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedCastBuilder final {
 public:
  ResolvedCastBuilder() : ResolvedCastBuilder(absl::WrapUnique(new ResolvedCast)) {}

  ResolvedCastBuilder(const ResolvedCastBuilder&) = delete;
  ResolvedCastBuilder& operator=(const ResolvedCastBuilder&) = delete;
  ResolvedCastBuilder(ResolvedCastBuilder&& other)
      : ResolvedCastBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCastBuilder& operator=(ResolvedCastBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCast>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCast::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCast::expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCastBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCastBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCastBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCastBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

  // Whether to return NULL if the cast fails. This is set to true for
  // SAFE_CAST.
  bool return_null_on_error() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->return_null_on_error();
  }

  ResolvedCastBuilder&& set_return_null_on_error(bool v) && {
    node_->set_return_null_on_error(v);

    return std::move(*this);
  }

  ResolvedCastBuilder& set_return_null_on_error(bool v) & {
    node_->set_return_null_on_error(v);

    return *this;
  }

  // If at least one of types involved in this cast is or contains an
  // extended (TYPE_EXTENDED) type, this field contains information
  // necessary to execute this cast.
  const ResolvedExtendedCast* extended_cast() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->extended_cast();
  }

  std::unique_ptr<const ResolvedExtendedCast> release_extended_cast() {
    return node_->release_extended_cast();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExtendedCast>>::value>>
  ResolvedCastBuilder&& set_extended_cast(T v) && {
    node_->set_extended_cast(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExtendedCast>>::value>>
  ResolvedCastBuilder& set_extended_cast(T v) & {
    node_->set_extended_cast(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExtendedCast>>::value>>
  ResolvedCastBuilder&& set_extended_cast(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_extended_cast(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExtendedCast>>::value>>
  ResolvedCastBuilder& set_extended_cast(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_extended_cast(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // The format string specified by the optional FORMAT clause. It is
  // nullptr when the clause does not exist.
  const ResolvedExpr* format() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->format();
  }

  std::unique_ptr<const ResolvedExpr> release_format() {
    return node_->release_format();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCastBuilder&& set_format(T v) && {
    node_->set_format(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCastBuilder& set_format(T v) & {
    node_->set_format(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCastBuilder&& set_format(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_format(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCastBuilder& set_format(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_format(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // The time zone expression by the optional AT TIME ZONE clause. It
  // is nullptr when the clause does not exist.
  const ResolvedExpr* time_zone() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->time_zone();
  }

  std::unique_ptr<const ResolvedExpr> release_time_zone() {
    return node_->release_time_zone();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCastBuilder&& set_time_zone(T v) && {
    node_->set_time_zone(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCastBuilder& set_time_zone(T v) & {
    node_->set_time_zone(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCastBuilder&& set_time_zone(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_time_zone(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCastBuilder& set_time_zone(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_time_zone(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Contains the TypeParametersProto, which stores the type parameters
  // if specified in a cast. If there are no type parameters, this
  // proto will be empty.
  //
  // If type parameters are specified, the result of the cast should
  // conform to the type parameters. Engines are expected to enforce
  // type parameter constraints by erroring out or truncating the cast
  // result, depending on the output type.
  //
  // For example:
  //   CAST("ABC" as STRING(2)) should error out
  //   CAST(1234 as NUMERIC(2)) should error out
  //   CAST(1.234 as NUMERIC(2,1)) should return a NumericValue of 1.2
  //
  // See (broken link) for more details.
  const TypeParameters& type_parameters() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_parameters();
  }

  ResolvedCastBuilder&& set_type_parameters(const TypeParameters& v) && {
    node_->set_type_parameters(v);

    return std::move(*this);
  }

  ResolvedCastBuilder& set_type_parameters(const TypeParameters& v) & {
    node_->set_type_parameters(v);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedCastBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedCastBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedCastBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedCastBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCast> node_;

  absl::Status deferred_build_status_;
  std::bitset<8> field_is_set_ = {0};
  friend ResolvedCastBuilder ToBuilder(
      std::unique_ptr<const ResolvedCast> node);

  ResolvedCastBuilder(std::unique_ptr<ResolvedCast> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCastBuilder ToBuilder(
    std::unique_ptr<const ResolvedCast> node) {
  ResolvedCastBuilder builder(absl::WrapUnique<ResolvedCast>(
      const_cast<ResolvedCast*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedMakeStructBuilder final {
 public:
  ResolvedMakeStructBuilder() : ResolvedMakeStructBuilder(absl::WrapUnique(new ResolvedMakeStruct)) {}

  ResolvedMakeStructBuilder(const ResolvedMakeStructBuilder&) = delete;
  ResolvedMakeStructBuilder& operator=(const ResolvedMakeStructBuilder&) = delete;
  ResolvedMakeStructBuilder(ResolvedMakeStructBuilder&& other)
      : ResolvedMakeStructBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedMakeStructBuilder& operator=(ResolvedMakeStructBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedMakeStruct>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedMakeStruct::type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedExpr>>& field_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->field_list();
  }

  int field_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->field_list_size();
  }

  const ResolvedExpr* field_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->field_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMakeStructBuilder&& add_field_list(T v) && {
    node_->add_field_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMakeStructBuilder& add_field_list(T v) & {
    node_->add_field_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMakeStructBuilder&& add_field_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_field_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMakeStructBuilder& add_field_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_field_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_field_list() {
    return node_->release_field_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedMakeStructBuilder&& set_field_list(T v) && {
    node_->set_field_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedMakeStructBuilder& set_field_list(T v) & {
    node_->set_field_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedMakeStructBuilder&& set_field_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_field_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedMakeStructBuilder& set_field_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_field_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedMakeStructBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedMakeStructBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedMakeStructBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedMakeStructBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedMakeStruct> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedMakeStructBuilder ToBuilder(
      std::unique_ptr<const ResolvedMakeStruct> node);

  ResolvedMakeStructBuilder(std::unique_ptr<ResolvedMakeStruct> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedMakeStructBuilder ToBuilder(
    std::unique_ptr<const ResolvedMakeStruct> node) {
  ResolvedMakeStructBuilder builder(absl::WrapUnique<ResolvedMakeStruct>(
      const_cast<ResolvedMakeStruct*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedMakeProtoBuilder final {
 public:
  ResolvedMakeProtoBuilder() : ResolvedMakeProtoBuilder(absl::WrapUnique(new ResolvedMakeProto)) {}

  ResolvedMakeProtoBuilder(const ResolvedMakeProtoBuilder&) = delete;
  ResolvedMakeProtoBuilder& operator=(const ResolvedMakeProtoBuilder&) = delete;
  ResolvedMakeProtoBuilder(ResolvedMakeProtoBuilder&& other)
      : ResolvedMakeProtoBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedMakeProtoBuilder& operator=(ResolvedMakeProtoBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedMakeProto>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedMakeProto::type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedMakeProtoField>>& field_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->field_list();
  }

  int field_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->field_list_size();
  }

  const ResolvedMakeProtoField* field_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->field_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedMakeProtoField>>::value>>
  ResolvedMakeProtoBuilder&& add_field_list(T v) && {
    node_->add_field_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedMakeProtoField>>::value>>
  ResolvedMakeProtoBuilder& add_field_list(T v) & {
    node_->add_field_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedMakeProtoField>>::value>>
  ResolvedMakeProtoBuilder&& add_field_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_field_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedMakeProtoField>>::value>>
  ResolvedMakeProtoBuilder& add_field_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_field_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedMakeProtoField>> release_field_list() {
    return node_->release_field_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedMakeProtoField>>>::value>>
  ResolvedMakeProtoBuilder&& set_field_list(T v) && {
    node_->set_field_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedMakeProtoField>>>::value>>
  ResolvedMakeProtoBuilder& set_field_list(T v) & {
    node_->set_field_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedMakeProtoField>>>::value>>
  ResolvedMakeProtoBuilder&& set_field_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_field_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedMakeProtoField>>>::value>>
  ResolvedMakeProtoBuilder& set_field_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_field_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedMakeProtoBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedMakeProtoBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedMakeProtoBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedMakeProtoBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedMakeProto> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedMakeProtoBuilder ToBuilder(
      std::unique_ptr<const ResolvedMakeProto> node);

  ResolvedMakeProtoBuilder(std::unique_ptr<ResolvedMakeProto> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedMakeProtoBuilder ToBuilder(
    std::unique_ptr<const ResolvedMakeProto> node) {
  ResolvedMakeProtoBuilder builder(absl::WrapUnique<ResolvedMakeProto>(
      const_cast<ResolvedMakeProto*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedMakeProtoFieldBuilder final {
 public:
  ResolvedMakeProtoFieldBuilder() : ResolvedMakeProtoFieldBuilder(absl::WrapUnique(new ResolvedMakeProtoField)) {}

  ResolvedMakeProtoFieldBuilder(const ResolvedMakeProtoFieldBuilder&) = delete;
  ResolvedMakeProtoFieldBuilder& operator=(const ResolvedMakeProtoFieldBuilder&) = delete;
  ResolvedMakeProtoFieldBuilder(ResolvedMakeProtoFieldBuilder&& other)
      : ResolvedMakeProtoFieldBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedMakeProtoFieldBuilder& operator=(ResolvedMakeProtoFieldBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedMakeProtoField>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedMakeProtoField::field_descriptor was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedMakeProtoField::expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const google::protobuf::FieldDescriptor* field_descriptor() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->field_descriptor();
  }

  ResolvedMakeProtoFieldBuilder&& set_field_descriptor(const google::protobuf::FieldDescriptor* v) && {
    node_->set_field_descriptor(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedMakeProtoFieldBuilder& set_field_descriptor(const google::protobuf::FieldDescriptor* v) & {
    node_->set_field_descriptor(v);
    field_is_set_.set(0, true);

    return *this;
  }

  // Provides the Format annotation that should be used when building
  // this field.  The annotation specifies both the ZetaSQL type and
  // the encoding format for this field.
  FieldFormat::Format format() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->format();
  }

  ResolvedMakeProtoFieldBuilder&& set_format(FieldFormat::Format v) && {
    node_->set_format(v);

    return std::move(*this);
  }

  ResolvedMakeProtoFieldBuilder& set_format(FieldFormat::Format v) & {
    node_->set_format(v);

    return *this;
  }

  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMakeProtoFieldBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMakeProtoFieldBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMakeProtoFieldBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMakeProtoFieldBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedMakeProtoField> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedMakeProtoFieldBuilder ToBuilder(
      std::unique_ptr<const ResolvedMakeProtoField> node);

  ResolvedMakeProtoFieldBuilder(std::unique_ptr<ResolvedMakeProtoField> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedMakeProtoFieldBuilder ToBuilder(
    std::unique_ptr<const ResolvedMakeProtoField> node) {
  ResolvedMakeProtoFieldBuilder builder(absl::WrapUnique<ResolvedMakeProtoField>(
      const_cast<ResolvedMakeProtoField*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedGetStructFieldBuilder final {
 public:
  ResolvedGetStructFieldBuilder() : ResolvedGetStructFieldBuilder(absl::WrapUnique(new ResolvedGetStructField)) {}

  ResolvedGetStructFieldBuilder(const ResolvedGetStructFieldBuilder&) = delete;
  ResolvedGetStructFieldBuilder& operator=(const ResolvedGetStructFieldBuilder&) = delete;
  ResolvedGetStructFieldBuilder(ResolvedGetStructFieldBuilder&& other)
      : ResolvedGetStructFieldBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedGetStructFieldBuilder& operator=(ResolvedGetStructFieldBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedGetStructField>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGetStructField::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGetStructField::expr was not set on the builder");
    }
    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGetStructField::field_idx was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGetStructFieldBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGetStructFieldBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGetStructFieldBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGetStructFieldBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

  int field_idx() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->field_idx();
  }

  ResolvedGetStructFieldBuilder&& set_field_idx(int v) && {
    node_->set_field_idx(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedGetStructFieldBuilder& set_field_idx(int v) & {
    node_->set_field_idx(v);
    field_is_set_.set(3, true);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedGetStructFieldBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedGetStructFieldBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedGetStructFieldBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedGetStructFieldBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedGetStructField> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedGetStructFieldBuilder ToBuilder(
      std::unique_ptr<const ResolvedGetStructField> node);

  ResolvedGetStructFieldBuilder(std::unique_ptr<ResolvedGetStructField> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedGetStructFieldBuilder ToBuilder(
    std::unique_ptr<const ResolvedGetStructField> node) {
  ResolvedGetStructFieldBuilder builder(absl::WrapUnique<ResolvedGetStructField>(
      const_cast<ResolvedGetStructField*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedGetProtoFieldBuilder final {
 public:
  ResolvedGetProtoFieldBuilder() : ResolvedGetProtoFieldBuilder(absl::WrapUnique(new ResolvedGetProtoField)) {}

  ResolvedGetProtoFieldBuilder(const ResolvedGetProtoFieldBuilder&) = delete;
  ResolvedGetProtoFieldBuilder& operator=(const ResolvedGetProtoFieldBuilder&) = delete;
  ResolvedGetProtoFieldBuilder(ResolvedGetProtoFieldBuilder&& other)
      : ResolvedGetProtoFieldBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedGetProtoFieldBuilder& operator=(ResolvedGetProtoFieldBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedGetProtoField>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGetProtoField::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGetProtoField::expr was not set on the builder");
    }
    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGetProtoField::field_descriptor was not set on the builder");
    }
    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGetProtoField::default_value was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGetProtoFieldBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGetProtoFieldBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGetProtoFieldBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGetProtoFieldBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

  // The proto2 FieldDescriptor to extract.  This provides the tag
  // number and wire type.  Additional decoding may be necessary if any
  // of the other modifiers below are set.  Consumers should use those
  // ZetaSQL-computed modifiers rather than examining field
  // annotations directly.
  //
  // The field is an extension field iff
  // field_descriptor->is_extension() is true.  NOTE: The extended
  // descriptor's full_name must match the <expr>'s type's full_name,
  // but may not be the same Descriptor. Extension FieldDescriptors may
  // come from a different DescriptorPool.
  //
  // The field is required if field_descriptor->is_required().  If the
  // field is required and not present, an error should result.
  const google::protobuf::FieldDescriptor* field_descriptor() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->field_descriptor();
  }

  ResolvedGetProtoFieldBuilder&& set_field_descriptor(const google::protobuf::FieldDescriptor* v) && {
    node_->set_field_descriptor(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedGetProtoFieldBuilder& set_field_descriptor(const google::protobuf::FieldDescriptor* v) & {
    node_->set_field_descriptor(v);
    field_is_set_.set(3, true);

    return *this;
  }

  // Default value to use when the proto field is not set. The default
  // may be NULL (e.g. for proto2 fields with a use_defaults=false
  // annotation).
  //
  // This will not be filled in (the Value will be uninitialized) if
  // get_has_bit is true, or the field is required.
  //
  // If field_descriptor->is_required() and the field is not present,
  // the engine should return an error.
  //
  // If the <expr> itself returns NULL, then extracting a field should
  // also return NULL, unless <return_default_value_when_unset> is
  // true. In that case, the default value is returned.
  //
  // TODO Make un-ignorable after clients migrate to start
  // using it.
  const Value& default_value() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->default_value();
  }

  ResolvedGetProtoFieldBuilder&& set_default_value(const Value& v) && {
    node_->set_default_value(v);
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  ResolvedGetProtoFieldBuilder& set_default_value(const Value& v) & {
    node_->set_default_value(v);
    field_is_set_.set(4, true);

    return *this;
  }

  // Indicates whether to return a bool indicating if a value was
  // present, rather than return the value (or NULL). Never set for
  // repeated fields. This field cannot be set if
  // <return_default_value_when_unset> is true, and vice versa.
  // Expression type will be BOOL.
  bool get_has_bit() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->get_has_bit();
  }

  ResolvedGetProtoFieldBuilder&& set_get_has_bit(bool v) && {
    node_->set_get_has_bit(v);

    return std::move(*this);
  }

  ResolvedGetProtoFieldBuilder& set_get_has_bit(bool v) & {
    node_->set_get_has_bit(v);

    return *this;
  }

  // Provides the Format annotation that should be used when reading
  // this field.  The annotation specifies both the ZetaSQL type and
  // the encoding format for this field. This cannot be set when
  // get_has_bit is true.
  FieldFormat::Format format() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->format();
  }

  ResolvedGetProtoFieldBuilder&& set_format(FieldFormat::Format v) && {
    node_->set_format(v);

    return std::move(*this);
  }

  ResolvedGetProtoFieldBuilder& set_format(FieldFormat::Format v) & {
    node_->set_format(v);

    return *this;
  }

  // Indicates that the default value should be returned if <expr>
  // (the parent message) is NULL.  Note that this does *not* affect
  // the return value when the extracted field itself is unset, in
  // which case the return value depends on the extracted field's
  // annotations (e.g., use_field_defaults).
  //
  // This can only be set for non-message fields. If the field is a
  // proto2 field, then it must be annotated with
  // zetasql.use_defaults=true. This cannot be set when <get_has_bit>
  // is true or the field is required.
  bool return_default_value_when_unset() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->return_default_value_when_unset();
  }

  ResolvedGetProtoFieldBuilder&& set_return_default_value_when_unset(bool v) && {
    node_->set_return_default_value_when_unset(v);

    return std::move(*this);
  }

  ResolvedGetProtoFieldBuilder& set_return_default_value_when_unset(bool v) & {
    node_->set_return_default_value_when_unset(v);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedGetProtoFieldBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedGetProtoFieldBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedGetProtoFieldBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedGetProtoFieldBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedGetProtoField> node_;

  absl::Status deferred_build_status_;
  std::bitset<8> field_is_set_ = {0};
  friend ResolvedGetProtoFieldBuilder ToBuilder(
      std::unique_ptr<const ResolvedGetProtoField> node);

  ResolvedGetProtoFieldBuilder(std::unique_ptr<ResolvedGetProtoField> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedGetProtoFieldBuilder ToBuilder(
    std::unique_ptr<const ResolvedGetProtoField> node) {
  ResolvedGetProtoFieldBuilder builder(absl::WrapUnique<ResolvedGetProtoField>(
      const_cast<ResolvedGetProtoField*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  builder.field_is_set_.set(3, true);
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedGetJsonFieldBuilder final {
 public:
  ResolvedGetJsonFieldBuilder() : ResolvedGetJsonFieldBuilder(absl::WrapUnique(new ResolvedGetJsonField)) {}

  ResolvedGetJsonFieldBuilder(const ResolvedGetJsonFieldBuilder&) = delete;
  ResolvedGetJsonFieldBuilder& operator=(const ResolvedGetJsonFieldBuilder&) = delete;
  ResolvedGetJsonFieldBuilder(ResolvedGetJsonFieldBuilder&& other)
      : ResolvedGetJsonFieldBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedGetJsonFieldBuilder& operator=(ResolvedGetJsonFieldBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedGetJsonField>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGetJsonField::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGetJsonField::expr was not set on the builder");
    }
    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGetJsonField::field_name was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGetJsonFieldBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGetJsonFieldBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGetJsonFieldBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGetJsonFieldBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

  const std::string& field_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->field_name();
  }

  ResolvedGetJsonFieldBuilder&& set_field_name(const std::string& v) && {
    node_->set_field_name(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedGetJsonFieldBuilder& set_field_name(const std::string& v) & {
    node_->set_field_name(v);
    field_is_set_.set(3, true);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedGetJsonFieldBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedGetJsonFieldBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedGetJsonFieldBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedGetJsonFieldBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedGetJsonField> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedGetJsonFieldBuilder ToBuilder(
      std::unique_ptr<const ResolvedGetJsonField> node);

  ResolvedGetJsonFieldBuilder(std::unique_ptr<ResolvedGetJsonField> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedGetJsonFieldBuilder ToBuilder(
    std::unique_ptr<const ResolvedGetJsonField> node) {
  ResolvedGetJsonFieldBuilder builder(absl::WrapUnique<ResolvedGetJsonField>(
      const_cast<ResolvedGetJsonField*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedFlattenBuilder final {
 public:
  ResolvedFlattenBuilder() : ResolvedFlattenBuilder(absl::WrapUnique(new ResolvedFlatten)) {}

  ResolvedFlattenBuilder(const ResolvedFlattenBuilder&) = delete;
  ResolvedFlattenBuilder& operator=(const ResolvedFlattenBuilder&) = delete;
  ResolvedFlattenBuilder(ResolvedFlattenBuilder&& other)
      : ResolvedFlattenBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedFlattenBuilder& operator=(ResolvedFlattenBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedFlatten>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFlatten::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFlatten::expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFlattenBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFlattenBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFlattenBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFlattenBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

  // List of 'get' fields to evaluate in order (0 or more struct get
  // fields followed by 0 or more proto or json get fields) starting
  // from expr. Each get is evaluated N times where N is the number of
  // array elements from the previous get (or expr for the first
  // expression) generated.
  //
  // The 'get' fields may either be a ResolvedGet*Field or an array
  // offset function around a ResolvedGet*Field.
  const std::vector<std::unique_ptr<const ResolvedExpr>>& get_field_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->get_field_list();
  }

  int get_field_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->get_field_list_size();
  }

  const ResolvedExpr* get_field_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->get_field_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFlattenBuilder&& add_get_field_list(T v) && {
    node_->add_get_field_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFlattenBuilder& add_get_field_list(T v) & {
    node_->add_get_field_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFlattenBuilder&& add_get_field_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_get_field_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFlattenBuilder& add_get_field_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_get_field_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_get_field_list() {
    return node_->release_get_field_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedFlattenBuilder&& set_get_field_list(T v) && {
    node_->set_get_field_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedFlattenBuilder& set_get_field_list(T v) & {
    node_->set_get_field_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedFlattenBuilder&& set_get_field_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_get_field_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedFlattenBuilder& set_get_field_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_get_field_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedFlattenBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedFlattenBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedFlattenBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedFlattenBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedFlatten> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedFlattenBuilder ToBuilder(
      std::unique_ptr<const ResolvedFlatten> node);

  ResolvedFlattenBuilder(std::unique_ptr<ResolvedFlatten> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedFlattenBuilder ToBuilder(
    std::unique_ptr<const ResolvedFlatten> node) {
  ResolvedFlattenBuilder builder(absl::WrapUnique<ResolvedFlatten>(
      const_cast<ResolvedFlatten*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedFlattenedArgBuilder final {
 public:
  ResolvedFlattenedArgBuilder() : ResolvedFlattenedArgBuilder(absl::WrapUnique(new ResolvedFlattenedArg)) {}

  ResolvedFlattenedArgBuilder(const ResolvedFlattenedArgBuilder&) = delete;
  ResolvedFlattenedArgBuilder& operator=(const ResolvedFlattenedArgBuilder&) = delete;
  ResolvedFlattenedArgBuilder(ResolvedFlattenedArgBuilder&& other)
      : ResolvedFlattenedArgBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedFlattenedArgBuilder& operator=(ResolvedFlattenedArgBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedFlattenedArg>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFlattenedArg::type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedFlattenedArgBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedFlattenedArgBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedFlattenedArgBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedFlattenedArgBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedFlattenedArg> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedFlattenedArgBuilder ToBuilder(
      std::unique_ptr<const ResolvedFlattenedArg> node);

  ResolvedFlattenedArgBuilder(std::unique_ptr<ResolvedFlattenedArg> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedFlattenedArgBuilder ToBuilder(
    std::unique_ptr<const ResolvedFlattenedArg> node) {
  ResolvedFlattenedArgBuilder builder(absl::WrapUnique<ResolvedFlattenedArg>(
      const_cast<ResolvedFlattenedArg*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedReplaceFieldItemBuilder final {
 public:
  ResolvedReplaceFieldItemBuilder() : ResolvedReplaceFieldItemBuilder(absl::WrapUnique(new ResolvedReplaceFieldItem)) {}

  ResolvedReplaceFieldItemBuilder(const ResolvedReplaceFieldItemBuilder&) = delete;
  ResolvedReplaceFieldItemBuilder& operator=(const ResolvedReplaceFieldItemBuilder&) = delete;
  ResolvedReplaceFieldItemBuilder(ResolvedReplaceFieldItemBuilder&& other)
      : ResolvedReplaceFieldItemBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedReplaceFieldItemBuilder& operator=(ResolvedReplaceFieldItemBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedReplaceFieldItem>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedReplaceFieldItem::expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // The value that the final field in <proto_field_path> will be set
  // to.
  //
  // If <expr> is NULL, the field will be unset. If <proto_field_path>
  // is a required field, the engine must return an error if it is set
  // to NULL.
  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedReplaceFieldItemBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedReplaceFieldItemBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedReplaceFieldItemBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedReplaceFieldItemBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

  // A vector of integers that denotes the path to a struct field that
  // will be modified. The integer values in this vector correspond to
  // field positions (0-based) in a STRUCT. If <proto_field_path>
  // is also non-empty, then the field corresponding to the last index
  // in this vector should be of proto type.
  const std::vector<int>& struct_index_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->struct_index_path();
  }

  int struct_index_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->struct_index_path_size();
  }

  int struct_index_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->struct_index_path(i);
  }

  ResolvedReplaceFieldItemBuilder&& add_struct_index_path(int v) && {
    node_->add_struct_index_path(v);

    return std::move(*this);
  }

  ResolvedReplaceFieldItemBuilder& add_struct_index_path(int v) & {
    node_->add_struct_index_path(v);

    return *this;
  }

  ResolvedReplaceFieldItemBuilder&& set_struct_index_path(const std::vector<int>& v) && {
    node_->set_struct_index_path(v);

    return std::move(*this);
  }

  ResolvedReplaceFieldItemBuilder& set_struct_index_path(const std::vector<int>& v) & {
    node_->set_struct_index_path(v);

    return *this;
  }

  // A vector of FieldDescriptors that denotes the path to a proto
  // field that will be modified. If <struct_index_path> is also
  // non-empty, then the first element in this vector should be a
  // subfield of the proto corresponding to the last element in
  // <struct_index_path>.
  const std::vector<const google::protobuf::FieldDescriptor*>& proto_field_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->proto_field_path();
  }

  int proto_field_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->proto_field_path_size();
  }

  const google::protobuf::FieldDescriptor* proto_field_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->proto_field_path(i);
  }

  ResolvedReplaceFieldItemBuilder&& add_proto_field_path(const google::protobuf::FieldDescriptor* v) && {
    node_->add_proto_field_path(v);

    return std::move(*this);
  }

  ResolvedReplaceFieldItemBuilder& add_proto_field_path(const google::protobuf::FieldDescriptor* v) & {
    node_->add_proto_field_path(v);

    return *this;
  }

  ResolvedReplaceFieldItemBuilder&& set_proto_field_path(const std::vector<const google::protobuf::FieldDescriptor*>& v) && {
    node_->set_proto_field_path(v);

    return std::move(*this);
  }

  ResolvedReplaceFieldItemBuilder& set_proto_field_path(const std::vector<const google::protobuf::FieldDescriptor*>& v) & {
    node_->set_proto_field_path(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedReplaceFieldItem> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedReplaceFieldItemBuilder ToBuilder(
      std::unique_ptr<const ResolvedReplaceFieldItem> node);

  ResolvedReplaceFieldItemBuilder(std::unique_ptr<ResolvedReplaceFieldItem> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedReplaceFieldItemBuilder ToBuilder(
    std::unique_ptr<const ResolvedReplaceFieldItem> node) {
  ResolvedReplaceFieldItemBuilder builder(absl::WrapUnique<ResolvedReplaceFieldItem>(
      const_cast<ResolvedReplaceFieldItem*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedReplaceFieldBuilder final {
 public:
  ResolvedReplaceFieldBuilder() : ResolvedReplaceFieldBuilder(absl::WrapUnique(new ResolvedReplaceField)) {}

  ResolvedReplaceFieldBuilder(const ResolvedReplaceFieldBuilder&) = delete;
  ResolvedReplaceFieldBuilder& operator=(const ResolvedReplaceFieldBuilder&) = delete;
  ResolvedReplaceFieldBuilder(ResolvedReplaceFieldBuilder&& other)
      : ResolvedReplaceFieldBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedReplaceFieldBuilder& operator=(ResolvedReplaceFieldBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedReplaceField>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedReplaceField::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedReplaceField::expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // The proto/struct to modify.
  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedReplaceFieldBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedReplaceFieldBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedReplaceFieldBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedReplaceFieldBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

  // The list of field paths to be modified along with their new
  // values.
  //
  // Engines must check at evaluation time that the modifications in
  // <replace_field_item_list> obey the following rules
  // regarding updating protos in ZetaSQL:
  // - Modifying a subfield of a NULL-valued proto-valued field is an
  //   error.
  // - Clearing a required field or subfield is an error.
  const std::vector<std::unique_ptr<const ResolvedReplaceFieldItem>>& replace_field_item_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->replace_field_item_list();
  }

  int replace_field_item_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->replace_field_item_list_size();
  }

  const ResolvedReplaceFieldItem* replace_field_item_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->replace_field_item_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedReplaceFieldItem>>::value>>
  ResolvedReplaceFieldBuilder&& add_replace_field_item_list(T v) && {
    node_->add_replace_field_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedReplaceFieldItem>>::value>>
  ResolvedReplaceFieldBuilder& add_replace_field_item_list(T v) & {
    node_->add_replace_field_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedReplaceFieldItem>>::value>>
  ResolvedReplaceFieldBuilder&& add_replace_field_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_replace_field_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedReplaceFieldItem>>::value>>
  ResolvedReplaceFieldBuilder& add_replace_field_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_replace_field_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedReplaceFieldItem>> release_replace_field_item_list() {
    return node_->release_replace_field_item_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedReplaceFieldItem>>>::value>>
  ResolvedReplaceFieldBuilder&& set_replace_field_item_list(T v) && {
    node_->set_replace_field_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedReplaceFieldItem>>>::value>>
  ResolvedReplaceFieldBuilder& set_replace_field_item_list(T v) & {
    node_->set_replace_field_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedReplaceFieldItem>>>::value>>
  ResolvedReplaceFieldBuilder&& set_replace_field_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_replace_field_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedReplaceFieldItem>>>::value>>
  ResolvedReplaceFieldBuilder& set_replace_field_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_replace_field_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedReplaceFieldBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedReplaceFieldBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedReplaceFieldBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedReplaceFieldBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedReplaceField> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedReplaceFieldBuilder ToBuilder(
      std::unique_ptr<const ResolvedReplaceField> node);

  ResolvedReplaceFieldBuilder(std::unique_ptr<ResolvedReplaceField> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedReplaceFieldBuilder ToBuilder(
    std::unique_ptr<const ResolvedReplaceField> node) {
  ResolvedReplaceFieldBuilder builder(absl::WrapUnique<ResolvedReplaceField>(
      const_cast<ResolvedReplaceField*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedSubqueryExprBuilder final {
 public:
    typedef ResolvedSubqueryExprEnums::SubqueryType SubqueryType;
  static const SubqueryType SCALAR = ResolvedSubqueryExprEnums::SCALAR;
  static const SubqueryType ARRAY = ResolvedSubqueryExprEnums::ARRAY;
  static const SubqueryType EXISTS = ResolvedSubqueryExprEnums::EXISTS;
  static const SubqueryType IN = ResolvedSubqueryExprEnums::IN;
  static const SubqueryType LIKE_ANY = ResolvedSubqueryExprEnums::LIKE_ANY;
  static const SubqueryType LIKE_ALL = ResolvedSubqueryExprEnums::LIKE_ALL;

  ResolvedSubqueryExprBuilder() : ResolvedSubqueryExprBuilder(absl::WrapUnique(new ResolvedSubqueryExpr)) {}

  ResolvedSubqueryExprBuilder(const ResolvedSubqueryExprBuilder&) = delete;
  ResolvedSubqueryExprBuilder& operator=(const ResolvedSubqueryExprBuilder&) = delete;
  ResolvedSubqueryExprBuilder(ResolvedSubqueryExprBuilder&& other)
      : ResolvedSubqueryExprBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedSubqueryExprBuilder& operator=(ResolvedSubqueryExprBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedSubqueryExpr>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedSubqueryExpr::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedSubqueryExpr::subquery_type was not set on the builder");
    }
    if (!field_is_set_.test(6)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedSubqueryExpr::subquery was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  ResolvedSubqueryExpr::SubqueryType subquery_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->subquery_type();
  }

  ResolvedSubqueryExprBuilder&& set_subquery_type(ResolvedSubqueryExpr::SubqueryType v) && {
    node_->set_subquery_type(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedSubqueryExprBuilder& set_subquery_type(ResolvedSubqueryExpr::SubqueryType v) & {
    node_->set_subquery_type(v);
    field_is_set_.set(2, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedColumnRef>>& parameter_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->parameter_list();
  }

  int parameter_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->parameter_list_size();
  }

  const ResolvedColumnRef* parameter_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->parameter_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedSubqueryExprBuilder&& add_parameter_list(T v) && {
    node_->add_parameter_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedSubqueryExprBuilder& add_parameter_list(T v) & {
    node_->add_parameter_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedSubqueryExprBuilder&& add_parameter_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedSubqueryExprBuilder& add_parameter_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnRef>> release_parameter_list() {
    return node_->release_parameter_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedSubqueryExprBuilder&& set_parameter_list(T v) && {
    node_->set_parameter_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedSubqueryExprBuilder& set_parameter_list(T v) & {
    node_->set_parameter_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedSubqueryExprBuilder&& set_parameter_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedSubqueryExprBuilder& set_parameter_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Field is only populated for subqueries of type IN or LIKE
  // ANY|SOME|ALL.
  const ResolvedExpr* in_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->in_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_in_expr() {
    return node_->release_in_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSubqueryExprBuilder&& set_in_expr(T v) && {
    node_->set_in_expr(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSubqueryExprBuilder& set_in_expr(T v) & {
    node_->set_in_expr(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSubqueryExprBuilder&& set_in_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_in_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSubqueryExprBuilder& set_in_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_in_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Field is only populated for subqueries of type IN to specify the
  // operation collation to use to compare <in_expr> with the rows from
  // <subquery>.
  const ResolvedCollation& in_collation() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->in_collation();
  }

  ResolvedSubqueryExprBuilder&& set_in_collation(const ResolvedCollation& v) && {
    node_->set_in_collation(v);

    return std::move(*this);
  }

  ResolvedSubqueryExprBuilder& set_in_collation(const ResolvedCollation& v) & {
    node_->set_in_collation(v);

    return *this;
  }

  const ResolvedScan* subquery() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->subquery();
  }

  std::unique_ptr<const ResolvedScan> release_subquery() {
    return node_->release_subquery();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedSubqueryExprBuilder&& set_subquery(T v) && {
    node_->set_subquery(std::move(v));
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedSubqueryExprBuilder& set_subquery(T v) & {
    node_->set_subquery(std::move(v));
    field_is_set_.set(6, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedSubqueryExprBuilder&& set_subquery(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_subquery(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedSubqueryExprBuilder& set_subquery(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_subquery(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(6, true);

    return *this;
  }

  // Note: Hints currently happen only for EXISTS, IN, or a LIKE
  // expression subquery but not for ARRAY or SCALAR subquery.
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSubqueryExprBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSubqueryExprBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSubqueryExprBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSubqueryExprBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSubqueryExprBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSubqueryExprBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSubqueryExprBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSubqueryExprBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedSubqueryExprBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedSubqueryExprBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedSubqueryExprBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedSubqueryExprBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedSubqueryExpr> node_;

  absl::Status deferred_build_status_;
  std::bitset<8> field_is_set_ = {0};
  friend ResolvedSubqueryExprBuilder ToBuilder(
      std::unique_ptr<const ResolvedSubqueryExpr> node);

  ResolvedSubqueryExprBuilder(std::unique_ptr<ResolvedSubqueryExpr> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedSubqueryExprBuilder ToBuilder(
    std::unique_ptr<const ResolvedSubqueryExpr> node) {
  ResolvedSubqueryExprBuilder builder(absl::WrapUnique<ResolvedSubqueryExpr>(
      const_cast<ResolvedSubqueryExpr*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  builder.field_is_set_.set(6, true);
  return builder;
}

class ResolvedWithExprBuilder final {
 public:
  ResolvedWithExprBuilder() : ResolvedWithExprBuilder(absl::WrapUnique(new ResolvedWithExpr)) {}

  ResolvedWithExprBuilder(const ResolvedWithExprBuilder&) = delete;
  ResolvedWithExprBuilder& operator=(const ResolvedWithExprBuilder&) = delete;
  ResolvedWithExprBuilder(ResolvedWithExprBuilder&& other)
      : ResolvedWithExprBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedWithExprBuilder& operator=(ResolvedWithExprBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedWithExpr>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedWithExpr::type was not set on the builder");
    }
    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedWithExpr::expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& assignment_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->assignment_list();
  }

  int assignment_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->assignment_list_size();
  }

  const ResolvedComputedColumn* assignment_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->assignment_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedWithExprBuilder&& add_assignment_list(T v) && {
    node_->add_assignment_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedWithExprBuilder& add_assignment_list(T v) & {
    node_->add_assignment_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedWithExprBuilder&& add_assignment_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_assignment_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedWithExprBuilder& add_assignment_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_assignment_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_assignment_list() {
    return node_->release_assignment_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedWithExprBuilder&& set_assignment_list(T v) && {
    node_->set_assignment_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedWithExprBuilder& set_assignment_list(T v) & {
    node_->set_assignment_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedWithExprBuilder&& set_assignment_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_assignment_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedWithExprBuilder& set_assignment_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_assignment_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedWithExprBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedWithExprBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));
    field_is_set_.set(3, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedWithExprBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedWithExprBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedWithExprBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedWithExprBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedWithExprBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedWithExprBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedWithExpr> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedWithExprBuilder ToBuilder(
      std::unique_ptr<const ResolvedWithExpr> node);

  ResolvedWithExprBuilder(std::unique_ptr<ResolvedWithExpr> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedWithExprBuilder ToBuilder(
    std::unique_ptr<const ResolvedWithExpr> node) {
  ResolvedWithExprBuilder builder(absl::WrapUnique<ResolvedWithExpr>(
      const_cast<ResolvedWithExpr*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedModelBuilder final {
 public:
  ResolvedModelBuilder() : ResolvedModelBuilder(absl::WrapUnique(new ResolvedModel)) {}

  ResolvedModelBuilder(const ResolvedModelBuilder&) = delete;
  ResolvedModelBuilder& operator=(const ResolvedModelBuilder&) = delete;
  ResolvedModelBuilder(ResolvedModelBuilder&& other)
      : ResolvedModelBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedModelBuilder& operator=(ResolvedModelBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedModel>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedModel::model was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const Model* model() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->model();
  }

  ResolvedModelBuilder&& set_model(const Model* v) && {
    node_->set_model(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedModelBuilder& set_model(const Model* v) & {
    node_->set_model(v);
    field_is_set_.set(0, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedModel> node_;

  absl::Status deferred_build_status_;
  std::bitset<1> field_is_set_ = {0};
  friend ResolvedModelBuilder ToBuilder(
      std::unique_ptr<const ResolvedModel> node);

  ResolvedModelBuilder(std::unique_ptr<ResolvedModel> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedModelBuilder ToBuilder(
    std::unique_ptr<const ResolvedModel> node) {
  ResolvedModelBuilder builder(absl::WrapUnique<ResolvedModel>(
      const_cast<ResolvedModel*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedConnectionBuilder final {
 public:
  ResolvedConnectionBuilder() : ResolvedConnectionBuilder(absl::WrapUnique(new ResolvedConnection)) {}

  ResolvedConnectionBuilder(const ResolvedConnectionBuilder&) = delete;
  ResolvedConnectionBuilder& operator=(const ResolvedConnectionBuilder&) = delete;
  ResolvedConnectionBuilder(ResolvedConnectionBuilder&& other)
      : ResolvedConnectionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedConnectionBuilder& operator=(ResolvedConnectionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedConnection>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedConnection::connection was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const Connection* connection() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->connection();
  }

  ResolvedConnectionBuilder&& set_connection(const Connection* v) && {
    node_->set_connection(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedConnectionBuilder& set_connection(const Connection* v) & {
    node_->set_connection(v);
    field_is_set_.set(0, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedConnection> node_;

  absl::Status deferred_build_status_;
  std::bitset<1> field_is_set_ = {0};
  friend ResolvedConnectionBuilder ToBuilder(
      std::unique_ptr<const ResolvedConnection> node);

  ResolvedConnectionBuilder(std::unique_ptr<ResolvedConnection> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedConnectionBuilder ToBuilder(
    std::unique_ptr<const ResolvedConnection> node) {
  ResolvedConnectionBuilder builder(absl::WrapUnique<ResolvedConnection>(
      const_cast<ResolvedConnection*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedDescriptorBuilder final {
 public:
  ResolvedDescriptorBuilder() : ResolvedDescriptorBuilder(absl::WrapUnique(new ResolvedDescriptor)) {}

  ResolvedDescriptorBuilder(const ResolvedDescriptorBuilder&) = delete;
  ResolvedDescriptorBuilder& operator=(const ResolvedDescriptorBuilder&) = delete;
  ResolvedDescriptorBuilder(ResolvedDescriptorBuilder&& other)
      : ResolvedDescriptorBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedDescriptorBuilder& operator=(ResolvedDescriptorBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDescriptor>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<ResolvedColumn>& descriptor_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->descriptor_column_list();
  }

  int descriptor_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->descriptor_column_list_size();
  }

  const ResolvedColumn& descriptor_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->descriptor_column_list(i);
  }

  ResolvedDescriptorBuilder&& add_descriptor_column_list(ResolvedColumn v) && {
    node_->add_descriptor_column_list(v);

    return std::move(*this);
  }

  ResolvedDescriptorBuilder& add_descriptor_column_list(ResolvedColumn v) & {
    node_->add_descriptor_column_list(v);

    return *this;
  }

  ResolvedDescriptorBuilder&& set_descriptor_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_descriptor_column_list(v);

    return std::move(*this);
  }

  ResolvedDescriptorBuilder& set_descriptor_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_descriptor_column_list(v);

    return *this;
  }

  const std::vector<std::string>& descriptor_column_name_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->descriptor_column_name_list();
  }

  int descriptor_column_name_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->descriptor_column_name_list_size();
  }

  const std::string& descriptor_column_name_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->descriptor_column_name_list(i);
  }

  ResolvedDescriptorBuilder&& add_descriptor_column_name_list(std::string v) && {
    node_->add_descriptor_column_name_list(v);

    return std::move(*this);
  }

  ResolvedDescriptorBuilder& add_descriptor_column_name_list(std::string v) & {
    node_->add_descriptor_column_name_list(v);

    return *this;
  }

  ResolvedDescriptorBuilder&& set_descriptor_column_name_list(const std::vector<std::string>& v) && {
    node_->set_descriptor_column_name_list(v);

    return std::move(*this);
  }

  ResolvedDescriptorBuilder& set_descriptor_column_name_list(const std::vector<std::string>& v) & {
    node_->set_descriptor_column_name_list(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDescriptor> node_;

  absl::Status deferred_build_status_;
  friend ResolvedDescriptorBuilder ToBuilder(
      std::unique_ptr<const ResolvedDescriptor> node);

  ResolvedDescriptorBuilder(std::unique_ptr<ResolvedDescriptor> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDescriptorBuilder ToBuilder(
    std::unique_ptr<const ResolvedDescriptor> node) {
  ResolvedDescriptorBuilder builder(absl::WrapUnique<ResolvedDescriptor>(
      const_cast<ResolvedDescriptor*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedSingleRowScanBuilder final {
 public:
  ResolvedSingleRowScanBuilder() : ResolvedSingleRowScanBuilder(absl::WrapUnique(new ResolvedSingleRowScan)) {}

  ResolvedSingleRowScanBuilder(const ResolvedSingleRowScanBuilder&) = delete;
  ResolvedSingleRowScanBuilder& operator=(const ResolvedSingleRowScanBuilder&) = delete;
  ResolvedSingleRowScanBuilder(ResolvedSingleRowScanBuilder&& other)
      : ResolvedSingleRowScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedSingleRowScanBuilder& operator=(ResolvedSingleRowScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedSingleRowScan>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedSingleRowScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedSingleRowScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedSingleRowScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedSingleRowScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSingleRowScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSingleRowScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSingleRowScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSingleRowScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSingleRowScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSingleRowScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSingleRowScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSingleRowScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedSingleRowScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedSingleRowScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedSingleRowScan> node_;

  absl::Status deferred_build_status_;
  friend ResolvedSingleRowScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedSingleRowScan> node);

  ResolvedSingleRowScanBuilder(std::unique_ptr<ResolvedSingleRowScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedSingleRowScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedSingleRowScan> node) {
  ResolvedSingleRowScanBuilder builder(absl::WrapUnique<ResolvedSingleRowScan>(
      const_cast<ResolvedSingleRowScan*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedTableScanBuilder final {
 public:
  ResolvedTableScanBuilder() : ResolvedTableScanBuilder(absl::WrapUnique(new ResolvedTableScan)) {}

  ResolvedTableScanBuilder(const ResolvedTableScanBuilder&) = delete;
  ResolvedTableScanBuilder& operator=(const ResolvedTableScanBuilder&) = delete;
  ResolvedTableScanBuilder(ResolvedTableScanBuilder&& other)
      : ResolvedTableScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedTableScanBuilder& operator=(ResolvedTableScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedTableScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedTableScan::table was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const Table* table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table();
  }

  ResolvedTableScanBuilder&& set_table(const Table* v) && {
    node_->set_table(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedTableScanBuilder& set_table(const Table* v) & {
    node_->set_table(v);
    field_is_set_.set(3, true);

    return *this;
  }

  const ResolvedExpr* for_system_time_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->for_system_time_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_for_system_time_expr() {
    return node_->release_for_system_time_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedTableScanBuilder&& set_for_system_time_expr(T v) && {
    node_->set_for_system_time_expr(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedTableScanBuilder& set_for_system_time_expr(T v) & {
    node_->set_for_system_time_expr(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedTableScanBuilder&& set_for_system_time_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_for_system_time_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedTableScanBuilder& set_for_system_time_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_for_system_time_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<int>& column_index_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_index_list();
  }

  int column_index_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_index_list_size();
  }

  int column_index_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_index_list(i);
  }

  ResolvedTableScanBuilder&& add_column_index_list(int v) && {
    node_->add_column_index_list(v);

    return std::move(*this);
  }

  ResolvedTableScanBuilder& add_column_index_list(int v) & {
    node_->add_column_index_list(v);

    return *this;
  }

  ResolvedTableScanBuilder&& set_column_index_list(const std::vector<int>& v) && {
    node_->set_column_index_list(v);

    return std::move(*this);
  }

  ResolvedTableScanBuilder& set_column_index_list(const std::vector<int>& v) & {
    node_->set_column_index_list(v);

    return *this;
  }

  const std::string& alias() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alias();
  }

  ResolvedTableScanBuilder&& set_alias(const std::string& v) && {
    node_->set_alias(v);

    return std::move(*this);
  }

  ResolvedTableScanBuilder& set_alias(const std::string& v) & {
    node_->set_alias(v);

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedTableScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedTableScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedTableScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedTableScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedTableScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedTableScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedTableScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedTableScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedTableScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedTableScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedTableScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedTableScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedTableScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedTableScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedTableScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<7> field_is_set_ = {0};
  friend ResolvedTableScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedTableScan> node);

  ResolvedTableScanBuilder(std::unique_ptr<ResolvedTableScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedTableScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedTableScan> node) {
  ResolvedTableScanBuilder builder(absl::WrapUnique<ResolvedTableScan>(
      const_cast<ResolvedTableScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedJoinScanBuilder final {
 public:
    typedef ResolvedJoinScanEnums::JoinType JoinType;
  static const JoinType INNER = ResolvedJoinScanEnums::INNER;
  static const JoinType LEFT = ResolvedJoinScanEnums::LEFT;
  static const JoinType RIGHT = ResolvedJoinScanEnums::RIGHT;
  static const JoinType FULL = ResolvedJoinScanEnums::FULL;

  ResolvedJoinScanBuilder() : ResolvedJoinScanBuilder(absl::WrapUnique(new ResolvedJoinScan)) {}

  ResolvedJoinScanBuilder(const ResolvedJoinScanBuilder&) = delete;
  ResolvedJoinScanBuilder& operator=(const ResolvedJoinScanBuilder&) = delete;
  ResolvedJoinScanBuilder(ResolvedJoinScanBuilder&& other)
      : ResolvedJoinScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedJoinScanBuilder& operator=(ResolvedJoinScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedJoinScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedJoinScan::left_scan was not set on the builder");
    }
    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedJoinScan::right_scan was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  ResolvedJoinScan::JoinType join_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->join_type();
  }

  ResolvedJoinScanBuilder&& set_join_type(ResolvedJoinScan::JoinType v) && {
    node_->set_join_type(v);

    return std::move(*this);
  }

  ResolvedJoinScanBuilder& set_join_type(ResolvedJoinScan::JoinType v) & {
    node_->set_join_type(v);

    return *this;
  }

  const ResolvedScan* left_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->left_scan();
  }

  std::unique_ptr<const ResolvedScan> release_left_scan() {
    return node_->release_left_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedJoinScanBuilder&& set_left_scan(T v) && {
    node_->set_left_scan(std::move(v));
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedJoinScanBuilder& set_left_scan(T v) & {
    node_->set_left_scan(std::move(v));
    field_is_set_.set(4, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedJoinScanBuilder&& set_left_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_left_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedJoinScanBuilder& set_left_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_left_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return *this;
  }

  const ResolvedScan* right_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->right_scan();
  }

  std::unique_ptr<const ResolvedScan> release_right_scan() {
    return node_->release_right_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedJoinScanBuilder&& set_right_scan(T v) && {
    node_->set_right_scan(std::move(v));
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedJoinScanBuilder& set_right_scan(T v) & {
    node_->set_right_scan(std::move(v));
    field_is_set_.set(5, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedJoinScanBuilder&& set_right_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_right_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedJoinScanBuilder& set_right_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_right_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return *this;
  }

  const ResolvedExpr* join_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->join_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_join_expr() {
    return node_->release_join_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedJoinScanBuilder&& set_join_expr(T v) && {
    node_->set_join_expr(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedJoinScanBuilder& set_join_expr(T v) & {
    node_->set_join_expr(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedJoinScanBuilder&& set_join_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_join_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedJoinScanBuilder& set_join_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_join_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedJoinScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedJoinScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedJoinScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedJoinScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedJoinScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedJoinScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedJoinScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedJoinScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedJoinScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedJoinScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedJoinScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedJoinScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedJoinScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedJoinScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedJoinScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<7> field_is_set_ = {0};
  friend ResolvedJoinScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedJoinScan> node);

  ResolvedJoinScanBuilder(std::unique_ptr<ResolvedJoinScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedJoinScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedJoinScan> node) {
  ResolvedJoinScanBuilder builder(absl::WrapUnique<ResolvedJoinScan>(
      const_cast<ResolvedJoinScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(4, true);
  builder.field_is_set_.set(5, true);
  return builder;
}

class ResolvedArrayScanBuilder final {
 public:
  ResolvedArrayScanBuilder() : ResolvedArrayScanBuilder(absl::WrapUnique(new ResolvedArrayScan)) {}

  ResolvedArrayScanBuilder(const ResolvedArrayScanBuilder&) = delete;
  ResolvedArrayScanBuilder& operator=(const ResolvedArrayScanBuilder&) = delete;
  ResolvedArrayScanBuilder(ResolvedArrayScanBuilder&& other)
      : ResolvedArrayScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedArrayScanBuilder& operator=(ResolvedArrayScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedArrayScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedArrayScan::array_expr was not set on the builder");
    }
    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedArrayScan::element_column was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedScan* input_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_scan();
  }

  std::unique_ptr<const ResolvedScan> release_input_scan() {
    return node_->release_input_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedArrayScanBuilder&& set_input_scan(T v) && {
    node_->set_input_scan(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedArrayScanBuilder& set_input_scan(T v) & {
    node_->set_input_scan(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedArrayScanBuilder&& set_input_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedArrayScanBuilder& set_input_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedExpr* array_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->array_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_array_expr() {
    return node_->release_array_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedArrayScanBuilder&& set_array_expr(T v) && {
    node_->set_array_expr(std::move(v));
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedArrayScanBuilder& set_array_expr(T v) & {
    node_->set_array_expr(std::move(v));
    field_is_set_.set(4, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedArrayScanBuilder&& set_array_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedArrayScanBuilder& set_array_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return *this;
  }

  const ResolvedColumn& element_column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->element_column();
  }

  ResolvedArrayScanBuilder&& set_element_column(const ResolvedColumn& v) && {
    node_->set_element_column(v);
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  ResolvedArrayScanBuilder& set_element_column(const ResolvedColumn& v) & {
    node_->set_element_column(v);
    field_is_set_.set(5, true);

    return *this;
  }

  const ResolvedColumnHolder* array_offset_column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->array_offset_column();
  }

  std::unique_ptr<const ResolvedColumnHolder> release_array_offset_column() {
    return node_->release_array_offset_column();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedArrayScanBuilder&& set_array_offset_column(T v) && {
    node_->set_array_offset_column(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedArrayScanBuilder& set_array_offset_column(T v) & {
    node_->set_array_offset_column(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedArrayScanBuilder&& set_array_offset_column(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_offset_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedArrayScanBuilder& set_array_offset_column(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_offset_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedExpr* join_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->join_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_join_expr() {
    return node_->release_join_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedArrayScanBuilder&& set_join_expr(T v) && {
    node_->set_join_expr(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedArrayScanBuilder& set_join_expr(T v) & {
    node_->set_join_expr(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedArrayScanBuilder&& set_join_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_join_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedArrayScanBuilder& set_join_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_join_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_outer() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_outer();
  }

  ResolvedArrayScanBuilder&& set_is_outer(bool v) && {
    node_->set_is_outer(v);

    return std::move(*this);
  }

  ResolvedArrayScanBuilder& set_is_outer(bool v) & {
    node_->set_is_outer(v);

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedArrayScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedArrayScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedArrayScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedArrayScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedArrayScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedArrayScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedArrayScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedArrayScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedArrayScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedArrayScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedArrayScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedArrayScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedArrayScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedArrayScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedArrayScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<9> field_is_set_ = {0};
  friend ResolvedArrayScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedArrayScan> node);

  ResolvedArrayScanBuilder(std::unique_ptr<ResolvedArrayScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedArrayScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedArrayScan> node) {
  ResolvedArrayScanBuilder builder(absl::WrapUnique<ResolvedArrayScan>(
      const_cast<ResolvedArrayScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(4, true);
  builder.field_is_set_.set(5, true);
  return builder;
}

class ResolvedColumnHolderBuilder final {
 public:
  ResolvedColumnHolderBuilder() : ResolvedColumnHolderBuilder(absl::WrapUnique(new ResolvedColumnHolder)) {}

  ResolvedColumnHolderBuilder(const ResolvedColumnHolderBuilder&) = delete;
  ResolvedColumnHolderBuilder& operator=(const ResolvedColumnHolderBuilder&) = delete;
  ResolvedColumnHolderBuilder(ResolvedColumnHolderBuilder&& other)
      : ResolvedColumnHolderBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedColumnHolderBuilder& operator=(ResolvedColumnHolderBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedColumnHolder>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedColumnHolder::column was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedColumn& column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column();
  }

  ResolvedColumnHolderBuilder&& set_column(const ResolvedColumn& v) && {
    node_->set_column(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedColumnHolderBuilder& set_column(const ResolvedColumn& v) & {
    node_->set_column(v);
    field_is_set_.set(0, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedColumnHolder> node_;

  absl::Status deferred_build_status_;
  std::bitset<1> field_is_set_ = {0};
  friend ResolvedColumnHolderBuilder ToBuilder(
      std::unique_ptr<const ResolvedColumnHolder> node);

  ResolvedColumnHolderBuilder(std::unique_ptr<ResolvedColumnHolder> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedColumnHolderBuilder ToBuilder(
    std::unique_ptr<const ResolvedColumnHolder> node) {
  ResolvedColumnHolderBuilder builder(absl::WrapUnique<ResolvedColumnHolder>(
      const_cast<ResolvedColumnHolder*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedFilterScanBuilder final {
 public:
  ResolvedFilterScanBuilder() : ResolvedFilterScanBuilder(absl::WrapUnique(new ResolvedFilterScan)) {}

  ResolvedFilterScanBuilder(const ResolvedFilterScanBuilder&) = delete;
  ResolvedFilterScanBuilder& operator=(const ResolvedFilterScanBuilder&) = delete;
  ResolvedFilterScanBuilder(ResolvedFilterScanBuilder&& other)
      : ResolvedFilterScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedFilterScanBuilder& operator=(ResolvedFilterScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedFilterScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFilterScan::input_scan was not set on the builder");
    }
    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFilterScan::filter_expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedScan* input_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_scan();
  }

  std::unique_ptr<const ResolvedScan> release_input_scan() {
    return node_->release_input_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedFilterScanBuilder&& set_input_scan(T v) && {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedFilterScanBuilder& set_input_scan(T v) & {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedFilterScanBuilder&& set_input_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedFilterScanBuilder& set_input_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return *this;
  }

  const ResolvedExpr* filter_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->filter_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_filter_expr() {
    return node_->release_filter_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFilterScanBuilder&& set_filter_expr(T v) && {
    node_->set_filter_expr(std::move(v));
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFilterScanBuilder& set_filter_expr(T v) & {
    node_->set_filter_expr(std::move(v));
    field_is_set_.set(4, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFilterScanBuilder&& set_filter_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_filter_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFilterScanBuilder& set_filter_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_filter_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedFilterScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedFilterScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedFilterScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedFilterScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedFilterScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedFilterScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedFilterScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedFilterScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedFilterScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedFilterScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedFilterScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedFilterScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedFilterScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedFilterScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedFilterScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedFilterScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedFilterScan> node);

  ResolvedFilterScanBuilder(std::unique_ptr<ResolvedFilterScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedFilterScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedFilterScan> node) {
  ResolvedFilterScanBuilder builder(absl::WrapUnique<ResolvedFilterScan>(
      const_cast<ResolvedFilterScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedGroupingSetBuilder final {
 public:
  ResolvedGroupingSetBuilder() : ResolvedGroupingSetBuilder(absl::WrapUnique(new ResolvedGroupingSet)) {}

  ResolvedGroupingSetBuilder(const ResolvedGroupingSetBuilder&) = delete;
  ResolvedGroupingSetBuilder& operator=(const ResolvedGroupingSetBuilder&) = delete;
  ResolvedGroupingSetBuilder(ResolvedGroupingSetBuilder&& other)
      : ResolvedGroupingSetBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedGroupingSetBuilder& operator=(ResolvedGroupingSetBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedGroupingSet>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedColumnRef>>& group_by_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->group_by_column_list();
  }

  int group_by_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->group_by_column_list_size();
  }

  const ResolvedColumnRef* group_by_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->group_by_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedGroupingSetBuilder&& add_group_by_column_list(T v) && {
    node_->add_group_by_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedGroupingSetBuilder& add_group_by_column_list(T v) & {
    node_->add_group_by_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedGroupingSetBuilder&& add_group_by_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_group_by_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedGroupingSetBuilder& add_group_by_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_group_by_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnRef>> release_group_by_column_list() {
    return node_->release_group_by_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedGroupingSetBuilder&& set_group_by_column_list(T v) && {
    node_->set_group_by_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedGroupingSetBuilder& set_group_by_column_list(T v) & {
    node_->set_group_by_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedGroupingSetBuilder&& set_group_by_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_group_by_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedGroupingSetBuilder& set_group_by_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_group_by_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedGroupingSet> node_;

  absl::Status deferred_build_status_;
  friend ResolvedGroupingSetBuilder ToBuilder(
      std::unique_ptr<const ResolvedGroupingSet> node);

  ResolvedGroupingSetBuilder(std::unique_ptr<ResolvedGroupingSet> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedGroupingSetBuilder ToBuilder(
    std::unique_ptr<const ResolvedGroupingSet> node) {
  ResolvedGroupingSetBuilder builder(absl::WrapUnique<ResolvedGroupingSet>(
      const_cast<ResolvedGroupingSet*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedAggregateScanBuilder final {
 public:
  ResolvedAggregateScanBuilder() : ResolvedAggregateScanBuilder(absl::WrapUnique(new ResolvedAggregateScan)) {}

  ResolvedAggregateScanBuilder(const ResolvedAggregateScanBuilder&) = delete;
  ResolvedAggregateScanBuilder& operator=(const ResolvedAggregateScanBuilder&) = delete;
  ResolvedAggregateScanBuilder(ResolvedAggregateScanBuilder&& other)
      : ResolvedAggregateScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAggregateScanBuilder& operator=(ResolvedAggregateScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAggregateScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAggregateScan::input_scan was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedGroupingSet>>& grouping_set_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grouping_set_list();
  }

  int grouping_set_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grouping_set_list_size();
  }

  const ResolvedGroupingSet* grouping_set_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grouping_set_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedGroupingSet>>::value>>
  ResolvedAggregateScanBuilder&& add_grouping_set_list(T v) && {
    node_->add_grouping_set_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedGroupingSet>>::value>>
  ResolvedAggregateScanBuilder& add_grouping_set_list(T v) & {
    node_->add_grouping_set_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedGroupingSet>>::value>>
  ResolvedAggregateScanBuilder&& add_grouping_set_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_grouping_set_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedGroupingSet>>::value>>
  ResolvedAggregateScanBuilder& add_grouping_set_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_grouping_set_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedGroupingSet>> release_grouping_set_list() {
    return node_->release_grouping_set_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedGroupingSet>>>::value>>
  ResolvedAggregateScanBuilder&& set_grouping_set_list(T v) && {
    node_->set_grouping_set_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedGroupingSet>>>::value>>
  ResolvedAggregateScanBuilder& set_grouping_set_list(T v) & {
    node_->set_grouping_set_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedGroupingSet>>>::value>>
  ResolvedAggregateScanBuilder&& set_grouping_set_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_grouping_set_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedGroupingSet>>>::value>>
  ResolvedAggregateScanBuilder& set_grouping_set_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_grouping_set_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedColumnRef>>& rollup_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->rollup_column_list();
  }

  int rollup_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->rollup_column_list_size();
  }

  const ResolvedColumnRef* rollup_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->rollup_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAggregateScanBuilder&& add_rollup_column_list(T v) && {
    node_->add_rollup_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAggregateScanBuilder& add_rollup_column_list(T v) & {
    node_->add_rollup_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAggregateScanBuilder&& add_rollup_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_rollup_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAggregateScanBuilder& add_rollup_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_rollup_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnRef>> release_rollup_column_list() {
    return node_->release_rollup_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedAggregateScanBuilder&& set_rollup_column_list(T v) && {
    node_->set_rollup_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedAggregateScanBuilder& set_rollup_column_list(T v) & {
    node_->set_rollup_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedAggregateScanBuilder&& set_rollup_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_rollup_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedAggregateScanBuilder& set_rollup_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_rollup_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedAggregateScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedAggregateScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedAggregateScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedAggregateScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAggregateScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAggregateScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAggregateScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAggregateScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAggregateScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAggregateScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAggregateScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAggregateScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedAggregateScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedAggregateScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

  const ResolvedScan* input_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_scan();
  }

  std::unique_ptr<const ResolvedScan> release_input_scan() {
    return node_->release_input_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAggregateScanBuilder&& set_input_scan(T v) && {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAggregateScanBuilder& set_input_scan(T v) & {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAggregateScanBuilder&& set_input_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAggregateScanBuilder& set_input_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& group_by_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->group_by_list();
  }

  int group_by_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->group_by_list_size();
  }

  const ResolvedComputedColumn* group_by_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->group_by_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAggregateScanBuilder&& add_group_by_list(T v) && {
    node_->add_group_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAggregateScanBuilder& add_group_by_list(T v) & {
    node_->add_group_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAggregateScanBuilder&& add_group_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_group_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAggregateScanBuilder& add_group_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_group_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_group_by_list() {
    return node_->release_group_by_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAggregateScanBuilder&& set_group_by_list(T v) && {
    node_->set_group_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAggregateScanBuilder& set_group_by_list(T v) & {
    node_->set_group_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAggregateScanBuilder&& set_group_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_group_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAggregateScanBuilder& set_group_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_group_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedCollation>& collation_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list();
  }

  int collation_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list_size();
  }

  const ResolvedCollation& collation_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list(i);
  }

  ResolvedAggregateScanBuilder&& add_collation_list(ResolvedCollation v) && {
    node_->add_collation_list(v);

    return std::move(*this);
  }

  ResolvedAggregateScanBuilder& add_collation_list(ResolvedCollation v) & {
    node_->add_collation_list(v);

    return *this;
  }

  ResolvedAggregateScanBuilder&& set_collation_list(const std::vector<ResolvedCollation>& v) && {
    node_->set_collation_list(v);

    return std::move(*this);
  }

  ResolvedAggregateScanBuilder& set_collation_list(const std::vector<ResolvedCollation>& v) & {
    node_->set_collation_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& aggregate_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->aggregate_list();
  }

  int aggregate_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->aggregate_list_size();
  }

  const ResolvedComputedColumn* aggregate_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->aggregate_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAggregateScanBuilder&& add_aggregate_list(T v) && {
    node_->add_aggregate_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAggregateScanBuilder& add_aggregate_list(T v) & {
    node_->add_aggregate_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAggregateScanBuilder&& add_aggregate_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_aggregate_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAggregateScanBuilder& add_aggregate_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_aggregate_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_aggregate_list() {
    return node_->release_aggregate_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAggregateScanBuilder&& set_aggregate_list(T v) && {
    node_->set_aggregate_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAggregateScanBuilder& set_aggregate_list(T v) & {
    node_->set_aggregate_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAggregateScanBuilder&& set_aggregate_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_aggregate_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAggregateScanBuilder& set_aggregate_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_aggregate_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAggregateScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<9> field_is_set_ = {0};
  friend ResolvedAggregateScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedAggregateScan> node);

  ResolvedAggregateScanBuilder(std::unique_ptr<ResolvedAggregateScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAggregateScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedAggregateScan> node) {
  ResolvedAggregateScanBuilder builder(absl::WrapUnique<ResolvedAggregateScan>(
      const_cast<ResolvedAggregateScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedAnonymizedAggregateScanBuilder final {
 public:
  ResolvedAnonymizedAggregateScanBuilder() : ResolvedAnonymizedAggregateScanBuilder(absl::WrapUnique(new ResolvedAnonymizedAggregateScan)) {}

  ResolvedAnonymizedAggregateScanBuilder(const ResolvedAnonymizedAggregateScanBuilder&) = delete;
  ResolvedAnonymizedAggregateScanBuilder& operator=(const ResolvedAnonymizedAggregateScanBuilder&) = delete;
  ResolvedAnonymizedAggregateScanBuilder(ResolvedAnonymizedAggregateScanBuilder&& other)
      : ResolvedAnonymizedAggregateScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAnonymizedAggregateScanBuilder& operator=(ResolvedAnonymizedAggregateScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAnonymizedAggregateScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAnonymizedAggregateScan::input_scan was not set on the builder");
    }
    if (!field_is_set_.test(7)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAnonymizedAggregateScan::k_threshold_expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedColumnRef* k_threshold_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->k_threshold_expr();
  }

  std::unique_ptr<const ResolvedColumnRef> release_k_threshold_expr() {
    return node_->release_k_threshold_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& set_k_threshold_expr(T v) && {
    node_->set_k_threshold_expr(std::move(v));
    field_is_set_.set(7, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& set_k_threshold_expr(T v) & {
    node_->set_k_threshold_expr(std::move(v));
    field_is_set_.set(7, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& set_k_threshold_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_k_threshold_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(7, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& set_k_threshold_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_k_threshold_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(7, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& anonymization_option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->anonymization_option_list();
  }

  int anonymization_option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->anonymization_option_list_size();
  }

  const ResolvedOption* anonymization_option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->anonymization_option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& add_anonymization_option_list(T v) && {
    node_->add_anonymization_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& add_anonymization_option_list(T v) & {
    node_->add_anonymization_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& add_anonymization_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_anonymization_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& add_anonymization_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_anonymization_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_anonymization_option_list() {
    return node_->release_anonymization_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& set_anonymization_option_list(T v) && {
    node_->set_anonymization_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& set_anonymization_option_list(T v) & {
    node_->set_anonymization_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& set_anonymization_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_anonymization_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& set_anonymization_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_anonymization_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedAnonymizedAggregateScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedAnonymizedAggregateScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedAnonymizedAggregateScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedAnonymizedAggregateScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedAnonymizedAggregateScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedAnonymizedAggregateScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

  const ResolvedScan* input_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_scan();
  }

  std::unique_ptr<const ResolvedScan> release_input_scan() {
    return node_->release_input_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& set_input_scan(T v) && {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& set_input_scan(T v) & {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& set_input_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& set_input_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& group_by_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->group_by_list();
  }

  int group_by_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->group_by_list_size();
  }

  const ResolvedComputedColumn* group_by_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->group_by_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& add_group_by_list(T v) && {
    node_->add_group_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& add_group_by_list(T v) & {
    node_->add_group_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& add_group_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_group_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& add_group_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_group_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_group_by_list() {
    return node_->release_group_by_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& set_group_by_list(T v) && {
    node_->set_group_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& set_group_by_list(T v) & {
    node_->set_group_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& set_group_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_group_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& set_group_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_group_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedCollation>& collation_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list();
  }

  int collation_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list_size();
  }

  const ResolvedCollation& collation_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_list(i);
  }

  ResolvedAnonymizedAggregateScanBuilder&& add_collation_list(ResolvedCollation v) && {
    node_->add_collation_list(v);

    return std::move(*this);
  }

  ResolvedAnonymizedAggregateScanBuilder& add_collation_list(ResolvedCollation v) & {
    node_->add_collation_list(v);

    return *this;
  }

  ResolvedAnonymizedAggregateScanBuilder&& set_collation_list(const std::vector<ResolvedCollation>& v) && {
    node_->set_collation_list(v);

    return std::move(*this);
  }

  ResolvedAnonymizedAggregateScanBuilder& set_collation_list(const std::vector<ResolvedCollation>& v) & {
    node_->set_collation_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& aggregate_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->aggregate_list();
  }

  int aggregate_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->aggregate_list_size();
  }

  const ResolvedComputedColumn* aggregate_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->aggregate_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& add_aggregate_list(T v) && {
    node_->add_aggregate_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& add_aggregate_list(T v) & {
    node_->add_aggregate_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& add_aggregate_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_aggregate_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& add_aggregate_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_aggregate_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_aggregate_list() {
    return node_->release_aggregate_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& set_aggregate_list(T v) && {
    node_->set_aggregate_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& set_aggregate_list(T v) & {
    node_->set_aggregate_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder&& set_aggregate_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_aggregate_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAnonymizedAggregateScanBuilder& set_aggregate_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_aggregate_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAnonymizedAggregateScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<9> field_is_set_ = {0};
  friend ResolvedAnonymizedAggregateScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedAnonymizedAggregateScan> node);

  ResolvedAnonymizedAggregateScanBuilder(std::unique_ptr<ResolvedAnonymizedAggregateScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAnonymizedAggregateScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedAnonymizedAggregateScan> node) {
  ResolvedAnonymizedAggregateScanBuilder builder(absl::WrapUnique<ResolvedAnonymizedAggregateScan>(
      const_cast<ResolvedAnonymizedAggregateScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  builder.field_is_set_.set(7, true);
  return builder;
}

class ResolvedSetOperationItemBuilder final {
 public:
  ResolvedSetOperationItemBuilder() : ResolvedSetOperationItemBuilder(absl::WrapUnique(new ResolvedSetOperationItem)) {}

  ResolvedSetOperationItemBuilder(const ResolvedSetOperationItemBuilder&) = delete;
  ResolvedSetOperationItemBuilder& operator=(const ResolvedSetOperationItemBuilder&) = delete;
  ResolvedSetOperationItemBuilder(ResolvedSetOperationItemBuilder&& other)
      : ResolvedSetOperationItemBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedSetOperationItemBuilder& operator=(ResolvedSetOperationItemBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedSetOperationItem>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedSetOperationItem::scan was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedScan* scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->scan();
  }

  std::unique_ptr<const ResolvedScan> release_scan() {
    return node_->release_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedSetOperationItemBuilder&& set_scan(T v) && {
    node_->set_scan(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedSetOperationItemBuilder& set_scan(T v) & {
    node_->set_scan(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedSetOperationItemBuilder&& set_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedSetOperationItemBuilder& set_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

  const std::vector<ResolvedColumn>& output_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list();
  }

  int output_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list_size();
  }

  const ResolvedColumn& output_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list(i);
  }

  ResolvedSetOperationItemBuilder&& add_output_column_list(ResolvedColumn v) && {
    node_->add_output_column_list(v);

    return std::move(*this);
  }

  ResolvedSetOperationItemBuilder& add_output_column_list(ResolvedColumn v) & {
    node_->add_output_column_list(v);

    return *this;
  }

  ResolvedSetOperationItemBuilder&& set_output_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_output_column_list(v);

    return std::move(*this);
  }

  ResolvedSetOperationItemBuilder& set_output_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_output_column_list(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedSetOperationItem> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedSetOperationItemBuilder ToBuilder(
      std::unique_ptr<const ResolvedSetOperationItem> node);

  ResolvedSetOperationItemBuilder(std::unique_ptr<ResolvedSetOperationItem> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedSetOperationItemBuilder ToBuilder(
    std::unique_ptr<const ResolvedSetOperationItem> node) {
  ResolvedSetOperationItemBuilder builder(absl::WrapUnique<ResolvedSetOperationItem>(
      const_cast<ResolvedSetOperationItem*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedSetOperationScanBuilder final {
 public:
    typedef ResolvedSetOperationScanEnums::SetOperationType SetOperationType;
  static const SetOperationType UNION_ALL = ResolvedSetOperationScanEnums::UNION_ALL;
  static const SetOperationType UNION_DISTINCT = ResolvedSetOperationScanEnums::UNION_DISTINCT;
  static const SetOperationType INTERSECT_ALL = ResolvedSetOperationScanEnums::INTERSECT_ALL;
  static const SetOperationType INTERSECT_DISTINCT = ResolvedSetOperationScanEnums::INTERSECT_DISTINCT;
  static const SetOperationType EXCEPT_ALL = ResolvedSetOperationScanEnums::EXCEPT_ALL;
  static const SetOperationType EXCEPT_DISTINCT = ResolvedSetOperationScanEnums::EXCEPT_DISTINCT;

  ResolvedSetOperationScanBuilder() : ResolvedSetOperationScanBuilder(absl::WrapUnique(new ResolvedSetOperationScan)) {}

  ResolvedSetOperationScanBuilder(const ResolvedSetOperationScanBuilder&) = delete;
  ResolvedSetOperationScanBuilder& operator=(const ResolvedSetOperationScanBuilder&) = delete;
  ResolvedSetOperationScanBuilder(ResolvedSetOperationScanBuilder&& other)
      : ResolvedSetOperationScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedSetOperationScanBuilder& operator=(ResolvedSetOperationScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedSetOperationScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedSetOperationScan::op_type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  ResolvedSetOperationScan::SetOperationType op_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->op_type();
  }

  ResolvedSetOperationScanBuilder&& set_op_type(ResolvedSetOperationScan::SetOperationType v) && {
    node_->set_op_type(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedSetOperationScanBuilder& set_op_type(ResolvedSetOperationScan::SetOperationType v) & {
    node_->set_op_type(v);
    field_is_set_.set(3, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedSetOperationItem>>& input_item_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_item_list();
  }

  int input_item_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_item_list_size();
  }

  const ResolvedSetOperationItem* input_item_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_item_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedSetOperationItem>>::value>>
  ResolvedSetOperationScanBuilder&& add_input_item_list(T v) && {
    node_->add_input_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedSetOperationItem>>::value>>
  ResolvedSetOperationScanBuilder& add_input_item_list(T v) & {
    node_->add_input_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedSetOperationItem>>::value>>
  ResolvedSetOperationScanBuilder&& add_input_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_input_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedSetOperationItem>>::value>>
  ResolvedSetOperationScanBuilder& add_input_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_input_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedSetOperationItem>> release_input_item_list() {
    return node_->release_input_item_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedSetOperationItem>>>::value>>
  ResolvedSetOperationScanBuilder&& set_input_item_list(T v) && {
    node_->set_input_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedSetOperationItem>>>::value>>
  ResolvedSetOperationScanBuilder& set_input_item_list(T v) & {
    node_->set_input_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedSetOperationItem>>>::value>>
  ResolvedSetOperationScanBuilder&& set_input_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedSetOperationItem>>>::value>>
  ResolvedSetOperationScanBuilder& set_input_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedSetOperationScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedSetOperationScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedSetOperationScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedSetOperationScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSetOperationScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSetOperationScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSetOperationScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSetOperationScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSetOperationScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSetOperationScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSetOperationScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSetOperationScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedSetOperationScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedSetOperationScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedSetOperationScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedSetOperationScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedSetOperationScan> node);

  ResolvedSetOperationScanBuilder(std::unique_ptr<ResolvedSetOperationScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedSetOperationScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedSetOperationScan> node) {
  ResolvedSetOperationScanBuilder builder(absl::WrapUnique<ResolvedSetOperationScan>(
      const_cast<ResolvedSetOperationScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedOrderByScanBuilder final {
 public:
  ResolvedOrderByScanBuilder() : ResolvedOrderByScanBuilder(absl::WrapUnique(new ResolvedOrderByScan)) {}

  ResolvedOrderByScanBuilder(const ResolvedOrderByScanBuilder&) = delete;
  ResolvedOrderByScanBuilder& operator=(const ResolvedOrderByScanBuilder&) = delete;
  ResolvedOrderByScanBuilder(ResolvedOrderByScanBuilder&& other)
      : ResolvedOrderByScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedOrderByScanBuilder& operator=(ResolvedOrderByScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedOrderByScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedOrderByScan::input_scan was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedScan* input_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_scan();
  }

  std::unique_ptr<const ResolvedScan> release_input_scan() {
    return node_->release_input_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedOrderByScanBuilder&& set_input_scan(T v) && {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedOrderByScanBuilder& set_input_scan(T v) & {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedOrderByScanBuilder&& set_input_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedOrderByScanBuilder& set_input_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOrderByItem>>& order_by_item_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->order_by_item_list();
  }

  int order_by_item_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->order_by_item_list_size();
  }

  const ResolvedOrderByItem* order_by_item_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->order_by_item_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOrderByItem>>::value>>
  ResolvedOrderByScanBuilder&& add_order_by_item_list(T v) && {
    node_->add_order_by_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOrderByItem>>::value>>
  ResolvedOrderByScanBuilder& add_order_by_item_list(T v) & {
    node_->add_order_by_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOrderByItem>>::value>>
  ResolvedOrderByScanBuilder&& add_order_by_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_order_by_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOrderByItem>>::value>>
  ResolvedOrderByScanBuilder& add_order_by_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_order_by_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOrderByItem>> release_order_by_item_list() {
    return node_->release_order_by_item_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOrderByItem>>>::value>>
  ResolvedOrderByScanBuilder&& set_order_by_item_list(T v) && {
    node_->set_order_by_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOrderByItem>>>::value>>
  ResolvedOrderByScanBuilder& set_order_by_item_list(T v) & {
    node_->set_order_by_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOrderByItem>>>::value>>
  ResolvedOrderByScanBuilder&& set_order_by_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_order_by_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOrderByItem>>>::value>>
  ResolvedOrderByScanBuilder& set_order_by_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_order_by_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedOrderByScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedOrderByScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedOrderByScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedOrderByScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedOrderByScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedOrderByScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedOrderByScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedOrderByScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedOrderByScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedOrderByScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedOrderByScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedOrderByScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedOrderByScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedOrderByScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedOrderByScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedOrderByScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedOrderByScan> node);

  ResolvedOrderByScanBuilder(std::unique_ptr<ResolvedOrderByScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedOrderByScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedOrderByScan> node) {
  ResolvedOrderByScanBuilder builder(absl::WrapUnique<ResolvedOrderByScan>(
      const_cast<ResolvedOrderByScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedLimitOffsetScanBuilder final {
 public:
  ResolvedLimitOffsetScanBuilder() : ResolvedLimitOffsetScanBuilder(absl::WrapUnique(new ResolvedLimitOffsetScan)) {}

  ResolvedLimitOffsetScanBuilder(const ResolvedLimitOffsetScanBuilder&) = delete;
  ResolvedLimitOffsetScanBuilder& operator=(const ResolvedLimitOffsetScanBuilder&) = delete;
  ResolvedLimitOffsetScanBuilder(ResolvedLimitOffsetScanBuilder&& other)
      : ResolvedLimitOffsetScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedLimitOffsetScanBuilder& operator=(ResolvedLimitOffsetScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedLimitOffsetScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedLimitOffsetScan::input_scan was not set on the builder");
    }
    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedLimitOffsetScan::limit was not set on the builder");
    }
    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedLimitOffsetScan::offset was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedScan* input_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_scan();
  }

  std::unique_ptr<const ResolvedScan> release_input_scan() {
    return node_->release_input_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedLimitOffsetScanBuilder&& set_input_scan(T v) && {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedLimitOffsetScanBuilder& set_input_scan(T v) & {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedLimitOffsetScanBuilder&& set_input_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedLimitOffsetScanBuilder& set_input_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return *this;
  }

  const ResolvedExpr* limit() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->limit();
  }

  std::unique_ptr<const ResolvedExpr> release_limit() {
    return node_->release_limit();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedLimitOffsetScanBuilder&& set_limit(T v) && {
    node_->set_limit(std::move(v));
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedLimitOffsetScanBuilder& set_limit(T v) & {
    node_->set_limit(std::move(v));
    field_is_set_.set(4, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedLimitOffsetScanBuilder&& set_limit(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_limit(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedLimitOffsetScanBuilder& set_limit(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_limit(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return *this;
  }

  const ResolvedExpr* offset() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->offset();
  }

  std::unique_ptr<const ResolvedExpr> release_offset() {
    return node_->release_offset();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedLimitOffsetScanBuilder&& set_offset(T v) && {
    node_->set_offset(std::move(v));
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedLimitOffsetScanBuilder& set_offset(T v) & {
    node_->set_offset(std::move(v));
    field_is_set_.set(5, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedLimitOffsetScanBuilder&& set_offset(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_offset(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedLimitOffsetScanBuilder& set_offset(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_offset(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedLimitOffsetScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedLimitOffsetScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedLimitOffsetScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedLimitOffsetScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedLimitOffsetScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedLimitOffsetScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedLimitOffsetScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedLimitOffsetScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedLimitOffsetScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedLimitOffsetScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedLimitOffsetScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedLimitOffsetScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedLimitOffsetScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedLimitOffsetScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedLimitOffsetScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<6> field_is_set_ = {0};
  friend ResolvedLimitOffsetScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedLimitOffsetScan> node);

  ResolvedLimitOffsetScanBuilder(std::unique_ptr<ResolvedLimitOffsetScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedLimitOffsetScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedLimitOffsetScan> node) {
  ResolvedLimitOffsetScanBuilder builder(absl::WrapUnique<ResolvedLimitOffsetScan>(
      const_cast<ResolvedLimitOffsetScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  builder.field_is_set_.set(4, true);
  builder.field_is_set_.set(5, true);
  return builder;
}

class ResolvedWithRefScanBuilder final {
 public:
  ResolvedWithRefScanBuilder() : ResolvedWithRefScanBuilder(absl::WrapUnique(new ResolvedWithRefScan)) {}

  ResolvedWithRefScanBuilder(const ResolvedWithRefScanBuilder&) = delete;
  ResolvedWithRefScanBuilder& operator=(const ResolvedWithRefScanBuilder&) = delete;
  ResolvedWithRefScanBuilder(ResolvedWithRefScanBuilder&& other)
      : ResolvedWithRefScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedWithRefScanBuilder& operator=(ResolvedWithRefScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedWithRefScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedWithRefScan::with_query_name was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& with_query_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_query_name();
  }

  ResolvedWithRefScanBuilder&& set_with_query_name(const std::string& v) && {
    node_->set_with_query_name(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedWithRefScanBuilder& set_with_query_name(const std::string& v) & {
    node_->set_with_query_name(v);
    field_is_set_.set(3, true);

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedWithRefScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedWithRefScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedWithRefScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedWithRefScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWithRefScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWithRefScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWithRefScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWithRefScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWithRefScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWithRefScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWithRefScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWithRefScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedWithRefScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedWithRefScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedWithRefScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedWithRefScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedWithRefScan> node);

  ResolvedWithRefScanBuilder(std::unique_ptr<ResolvedWithRefScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedWithRefScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedWithRefScan> node) {
  ResolvedWithRefScanBuilder builder(absl::WrapUnique<ResolvedWithRefScan>(
      const_cast<ResolvedWithRefScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedAnalyticScanBuilder final {
 public:
  ResolvedAnalyticScanBuilder() : ResolvedAnalyticScanBuilder(absl::WrapUnique(new ResolvedAnalyticScan)) {}

  ResolvedAnalyticScanBuilder(const ResolvedAnalyticScanBuilder&) = delete;
  ResolvedAnalyticScanBuilder& operator=(const ResolvedAnalyticScanBuilder&) = delete;
  ResolvedAnalyticScanBuilder(ResolvedAnalyticScanBuilder&& other)
      : ResolvedAnalyticScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAnalyticScanBuilder& operator=(ResolvedAnalyticScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAnalyticScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAnalyticScan::input_scan was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedScan* input_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_scan();
  }

  std::unique_ptr<const ResolvedScan> release_input_scan() {
    return node_->release_input_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAnalyticScanBuilder&& set_input_scan(T v) && {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAnalyticScanBuilder& set_input_scan(T v) & {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAnalyticScanBuilder&& set_input_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedAnalyticScanBuilder& set_input_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>>& function_group_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->function_group_list();
  }

  int function_group_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->function_group_list_size();
  }

  const ResolvedAnalyticFunctionGroup* function_group_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->function_group_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAnalyticFunctionGroup>>::value>>
  ResolvedAnalyticScanBuilder&& add_function_group_list(T v) && {
    node_->add_function_group_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAnalyticFunctionGroup>>::value>>
  ResolvedAnalyticScanBuilder& add_function_group_list(T v) & {
    node_->add_function_group_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAnalyticFunctionGroup>>::value>>
  ResolvedAnalyticScanBuilder&& add_function_group_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_function_group_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAnalyticFunctionGroup>>::value>>
  ResolvedAnalyticScanBuilder& add_function_group_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_function_group_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>> release_function_group_list() {
    return node_->release_function_group_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>>>::value>>
  ResolvedAnalyticScanBuilder&& set_function_group_list(T v) && {
    node_->set_function_group_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>>>::value>>
  ResolvedAnalyticScanBuilder& set_function_group_list(T v) & {
    node_->set_function_group_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>>>::value>>
  ResolvedAnalyticScanBuilder&& set_function_group_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_function_group_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>>>::value>>
  ResolvedAnalyticScanBuilder& set_function_group_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_function_group_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedAnalyticScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedAnalyticScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedAnalyticScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedAnalyticScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyticScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyticScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyticScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyticScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyticScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyticScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyticScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyticScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedAnalyticScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedAnalyticScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAnalyticScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedAnalyticScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedAnalyticScan> node);

  ResolvedAnalyticScanBuilder(std::unique_ptr<ResolvedAnalyticScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAnalyticScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedAnalyticScan> node) {
  ResolvedAnalyticScanBuilder builder(absl::WrapUnique<ResolvedAnalyticScan>(
      const_cast<ResolvedAnalyticScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedSampleScanBuilder final {
 public:
    typedef ResolvedSampleScanEnums::SampleUnit SampleUnit;
  static const SampleUnit ROWS = ResolvedSampleScanEnums::ROWS;
  static const SampleUnit PERCENT = ResolvedSampleScanEnums::PERCENT;

  ResolvedSampleScanBuilder() : ResolvedSampleScanBuilder(absl::WrapUnique(new ResolvedSampleScan)) {}

  ResolvedSampleScanBuilder(const ResolvedSampleScanBuilder&) = delete;
  ResolvedSampleScanBuilder& operator=(const ResolvedSampleScanBuilder&) = delete;
  ResolvedSampleScanBuilder(ResolvedSampleScanBuilder&& other)
      : ResolvedSampleScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedSampleScanBuilder& operator=(ResolvedSampleScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedSampleScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedSampleScan::input_scan was not set on the builder");
    }
    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedSampleScan::method was not set on the builder");
    }
    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedSampleScan::size was not set on the builder");
    }
    if (!field_is_set_.test(6)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedSampleScan::unit was not set on the builder");
    }
    if (!field_is_set_.test(7)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedSampleScan::repeatable_argument was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedScan* input_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_scan();
  }

  std::unique_ptr<const ResolvedScan> release_input_scan() {
    return node_->release_input_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedSampleScanBuilder&& set_input_scan(T v) && {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedSampleScanBuilder& set_input_scan(T v) & {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedSampleScanBuilder&& set_input_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedSampleScanBuilder& set_input_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return *this;
  }

  const std::string& method() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->method();
  }

  ResolvedSampleScanBuilder&& set_method(const std::string& v) && {
    node_->set_method(v);
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  ResolvedSampleScanBuilder& set_method(const std::string& v) & {
    node_->set_method(v);
    field_is_set_.set(4, true);

    return *this;
  }

  const ResolvedExpr* size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->size();
  }

  std::unique_ptr<const ResolvedExpr> release_size() {
    return node_->release_size();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSampleScanBuilder&& set_size(T v) && {
    node_->set_size(std::move(v));
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSampleScanBuilder& set_size(T v) & {
    node_->set_size(std::move(v));
    field_is_set_.set(5, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSampleScanBuilder&& set_size(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_size(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSampleScanBuilder& set_size(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_size(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return *this;
  }

  ResolvedSampleScan::SampleUnit unit() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->unit();
  }

  ResolvedSampleScanBuilder&& set_unit(ResolvedSampleScan::SampleUnit v) && {
    node_->set_unit(v);
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  ResolvedSampleScanBuilder& set_unit(ResolvedSampleScan::SampleUnit v) & {
    node_->set_unit(v);
    field_is_set_.set(6, true);

    return *this;
  }

  const ResolvedExpr* repeatable_argument() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->repeatable_argument();
  }

  std::unique_ptr<const ResolvedExpr> release_repeatable_argument() {
    return node_->release_repeatable_argument();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSampleScanBuilder&& set_repeatable_argument(T v) && {
    node_->set_repeatable_argument(std::move(v));
    field_is_set_.set(7, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSampleScanBuilder& set_repeatable_argument(T v) & {
    node_->set_repeatable_argument(std::move(v));
    field_is_set_.set(7, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSampleScanBuilder&& set_repeatable_argument(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_repeatable_argument(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(7, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSampleScanBuilder& set_repeatable_argument(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_repeatable_argument(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(7, true);

    return *this;
  }

  const ResolvedColumnHolder* weight_column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->weight_column();
  }

  std::unique_ptr<const ResolvedColumnHolder> release_weight_column() {
    return node_->release_weight_column();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedSampleScanBuilder&& set_weight_column(T v) && {
    node_->set_weight_column(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedSampleScanBuilder& set_weight_column(T v) & {
    node_->set_weight_column(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedSampleScanBuilder&& set_weight_column(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_weight_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedSampleScanBuilder& set_weight_column(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_weight_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& partition_by_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list();
  }

  int partition_by_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list_size();
  }

  const ResolvedExpr* partition_by_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSampleScanBuilder&& add_partition_by_list(T v) && {
    node_->add_partition_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSampleScanBuilder& add_partition_by_list(T v) & {
    node_->add_partition_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSampleScanBuilder&& add_partition_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSampleScanBuilder& add_partition_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_partition_by_list() {
    return node_->release_partition_by_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedSampleScanBuilder&& set_partition_by_list(T v) && {
    node_->set_partition_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedSampleScanBuilder& set_partition_by_list(T v) & {
    node_->set_partition_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedSampleScanBuilder&& set_partition_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedSampleScanBuilder& set_partition_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedSampleScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedSampleScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedSampleScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedSampleScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSampleScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSampleScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSampleScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSampleScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSampleScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSampleScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSampleScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSampleScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedSampleScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedSampleScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedSampleScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<10> field_is_set_ = {0};
  friend ResolvedSampleScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedSampleScan> node);

  ResolvedSampleScanBuilder(std::unique_ptr<ResolvedSampleScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedSampleScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedSampleScan> node) {
  ResolvedSampleScanBuilder builder(absl::WrapUnique<ResolvedSampleScan>(
      const_cast<ResolvedSampleScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  builder.field_is_set_.set(4, true);
  builder.field_is_set_.set(5, true);
  builder.field_is_set_.set(6, true);
  builder.field_is_set_.set(7, true);
  return builder;
}

class ResolvedComputedColumnBuilder final {
 public:
  ResolvedComputedColumnBuilder() : ResolvedComputedColumnBuilder(absl::WrapUnique(new ResolvedComputedColumn)) {}

  ResolvedComputedColumnBuilder(const ResolvedComputedColumnBuilder&) = delete;
  ResolvedComputedColumnBuilder& operator=(const ResolvedComputedColumnBuilder&) = delete;
  ResolvedComputedColumnBuilder(ResolvedComputedColumnBuilder&& other)
      : ResolvedComputedColumnBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedComputedColumnBuilder& operator=(ResolvedComputedColumnBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedComputedColumn>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedComputedColumn::column was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedComputedColumn::expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedColumn& column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column();
  }

  ResolvedComputedColumnBuilder&& set_column(const ResolvedColumn& v) && {
    node_->set_column(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedComputedColumnBuilder& set_column(const ResolvedColumn& v) & {
    node_->set_column(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedComputedColumnBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedComputedColumnBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedComputedColumnBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedComputedColumnBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedComputedColumn> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedComputedColumnBuilder ToBuilder(
      std::unique_ptr<const ResolvedComputedColumn> node);

  ResolvedComputedColumnBuilder(std::unique_ptr<ResolvedComputedColumn> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedComputedColumnBuilder ToBuilder(
    std::unique_ptr<const ResolvedComputedColumn> node) {
  ResolvedComputedColumnBuilder builder(absl::WrapUnique<ResolvedComputedColumn>(
      const_cast<ResolvedComputedColumn*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedOrderByItemBuilder final {
 public:
    typedef ResolvedOrderByItemEnums::NullOrderMode NullOrderMode;
  static const NullOrderMode ORDER_UNSPECIFIED = ResolvedOrderByItemEnums::ORDER_UNSPECIFIED;
  static const NullOrderMode NULLS_FIRST = ResolvedOrderByItemEnums::NULLS_FIRST;
  static const NullOrderMode NULLS_LAST = ResolvedOrderByItemEnums::NULLS_LAST;

  ResolvedOrderByItemBuilder() : ResolvedOrderByItemBuilder(absl::WrapUnique(new ResolvedOrderByItem)) {}

  ResolvedOrderByItemBuilder(const ResolvedOrderByItemBuilder&) = delete;
  ResolvedOrderByItemBuilder& operator=(const ResolvedOrderByItemBuilder&) = delete;
  ResolvedOrderByItemBuilder(ResolvedOrderByItemBuilder&& other)
      : ResolvedOrderByItemBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedOrderByItemBuilder& operator=(ResolvedOrderByItemBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedOrderByItem>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedOrderByItem::column_ref was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedColumnRef* column_ref() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_ref();
  }

  std::unique_ptr<const ResolvedColumnRef> release_column_ref() {
    return node_->release_column_ref();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedOrderByItemBuilder&& set_column_ref(T v) && {
    node_->set_column_ref(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedOrderByItemBuilder& set_column_ref(T v) & {
    node_->set_column_ref(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedOrderByItemBuilder&& set_column_ref(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_ref(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedOrderByItemBuilder& set_column_ref(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_ref(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedExpr* collation_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_name();
  }

  std::unique_ptr<const ResolvedExpr> release_collation_name() {
    return node_->release_collation_name();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedOrderByItemBuilder&& set_collation_name(T v) && {
    node_->set_collation_name(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedOrderByItemBuilder& set_collation_name(T v) & {
    node_->set_collation_name(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedOrderByItemBuilder&& set_collation_name(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedOrderByItemBuilder& set_collation_name(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_descending() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_descending();
  }

  ResolvedOrderByItemBuilder&& set_is_descending(bool v) && {
    node_->set_is_descending(v);

    return std::move(*this);
  }

  ResolvedOrderByItemBuilder& set_is_descending(bool v) & {
    node_->set_is_descending(v);

    return *this;
  }

  ResolvedOrderByItem::NullOrderMode null_order() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->null_order();
  }

  ResolvedOrderByItemBuilder&& set_null_order(ResolvedOrderByItem::NullOrderMode v) && {
    node_->set_null_order(v);

    return std::move(*this);
  }

  ResolvedOrderByItemBuilder& set_null_order(ResolvedOrderByItem::NullOrderMode v) & {
    node_->set_null_order(v);

    return *this;
  }

  const ResolvedCollation& collation() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation();
  }

  ResolvedOrderByItemBuilder&& set_collation(const ResolvedCollation& v) && {
    node_->set_collation(v);

    return std::move(*this);
  }

  ResolvedOrderByItemBuilder& set_collation(const ResolvedCollation& v) & {
    node_->set_collation(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedOrderByItem> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedOrderByItemBuilder ToBuilder(
      std::unique_ptr<const ResolvedOrderByItem> node);

  ResolvedOrderByItemBuilder(std::unique_ptr<ResolvedOrderByItem> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedOrderByItemBuilder ToBuilder(
    std::unique_ptr<const ResolvedOrderByItem> node) {
  ResolvedOrderByItemBuilder builder(absl::WrapUnique<ResolvedOrderByItem>(
      const_cast<ResolvedOrderByItem*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedColumnAnnotationsBuilder final {
 public:
    // Get the full TypeParameters object for these annotations given a
  // type, including parameters on nested fields.
  absl::StatusOr<TypeParameters> GetFullTypeParameters(
      const Type* type) const;

  ResolvedColumnAnnotationsBuilder() : ResolvedColumnAnnotationsBuilder(absl::WrapUnique(new ResolvedColumnAnnotations)) {}

  ResolvedColumnAnnotationsBuilder(const ResolvedColumnAnnotationsBuilder&) = delete;
  ResolvedColumnAnnotationsBuilder& operator=(const ResolvedColumnAnnotationsBuilder&) = delete;
  ResolvedColumnAnnotationsBuilder(ResolvedColumnAnnotationsBuilder&& other)
      : ResolvedColumnAnnotationsBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedColumnAnnotationsBuilder& operator=(ResolvedColumnAnnotationsBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedColumnAnnotations>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // <collation_name> can only be a string literal, and is only set
  // when FEATURE_V_1_3_COLLATION_SUPPORT is enabled. See
  // (broken link).
  const ResolvedExpr* collation_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_name();
  }

  std::unique_ptr<const ResolvedExpr> release_collation_name() {
    return node_->release_collation_name();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedColumnAnnotationsBuilder&& set_collation_name(T v) && {
    node_->set_collation_name(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedColumnAnnotationsBuilder& set_collation_name(T v) & {
    node_->set_collation_name(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedColumnAnnotationsBuilder&& set_collation_name(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedColumnAnnotationsBuilder& set_collation_name(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool not_null() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->not_null();
  }

  ResolvedColumnAnnotationsBuilder&& set_not_null(bool v) && {
    node_->set_not_null(v);

    return std::move(*this);
  }

  ResolvedColumnAnnotationsBuilder& set_not_null(bool v) & {
    node_->set_not_null(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedColumnAnnotationsBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedColumnAnnotationsBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedColumnAnnotationsBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedColumnAnnotationsBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedColumnAnnotationsBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedColumnAnnotationsBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedColumnAnnotationsBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedColumnAnnotationsBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedColumnAnnotations>>& child_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->child_list();
  }

  int child_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->child_list_size();
  }

  const ResolvedColumnAnnotations* child_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->child_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnAnnotations>>::value>>
  ResolvedColumnAnnotationsBuilder&& add_child_list(T v) && {
    node_->add_child_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnAnnotations>>::value>>
  ResolvedColumnAnnotationsBuilder& add_child_list(T v) & {
    node_->add_child_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnAnnotations>>::value>>
  ResolvedColumnAnnotationsBuilder&& add_child_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_child_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnAnnotations>>::value>>
  ResolvedColumnAnnotationsBuilder& add_child_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_child_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnAnnotations>> release_child_list() {
    return node_->release_child_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnAnnotations>>>::value>>
  ResolvedColumnAnnotationsBuilder&& set_child_list(T v) && {
    node_->set_child_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnAnnotations>>>::value>>
  ResolvedColumnAnnotationsBuilder& set_child_list(T v) & {
    node_->set_child_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnAnnotations>>>::value>>
  ResolvedColumnAnnotationsBuilder&& set_child_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_child_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnAnnotations>>>::value>>
  ResolvedColumnAnnotationsBuilder& set_child_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_child_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // child_list in <type_parameters> is not used in here.
  // Instead we use child_list of this node (ResolvedColumnAnnotations)
  // to store type parameters of subfields of STRUCT or ARRAY. Users
  // can access the full type parameters with child_list by calling
  // ResolvedColumnDefinition.getFullTypeParameters() function.
  const TypeParameters& type_parameters() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_parameters();
  }

  ResolvedColumnAnnotationsBuilder&& set_type_parameters(const TypeParameters& v) && {
    node_->set_type_parameters(v);

    return std::move(*this);
  }

  ResolvedColumnAnnotationsBuilder& set_type_parameters(const TypeParameters& v) & {
    node_->set_type_parameters(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedColumnAnnotations> node_;

  absl::Status deferred_build_status_;
  friend ResolvedColumnAnnotationsBuilder ToBuilder(
      std::unique_ptr<const ResolvedColumnAnnotations> node);

  ResolvedColumnAnnotationsBuilder(std::unique_ptr<ResolvedColumnAnnotations> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedColumnAnnotationsBuilder ToBuilder(
    std::unique_ptr<const ResolvedColumnAnnotations> node) {
  ResolvedColumnAnnotationsBuilder builder(absl::WrapUnique<ResolvedColumnAnnotations>(
      const_cast<ResolvedColumnAnnotations*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedGeneratedColumnInfoBuilder final {
 public:
    typedef ResolvedGeneratedColumnInfoEnums::StoredMode StoredMode;
  static const StoredMode NON_STORED = ResolvedGeneratedColumnInfoEnums::NON_STORED;
  static const StoredMode STORED = ResolvedGeneratedColumnInfoEnums::STORED;
  static const StoredMode STORED_VOLATILE = ResolvedGeneratedColumnInfoEnums::STORED_VOLATILE;

  ResolvedGeneratedColumnInfoBuilder() : ResolvedGeneratedColumnInfoBuilder(absl::WrapUnique(new ResolvedGeneratedColumnInfo)) {}

  ResolvedGeneratedColumnInfoBuilder(const ResolvedGeneratedColumnInfoBuilder&) = delete;
  ResolvedGeneratedColumnInfoBuilder& operator=(const ResolvedGeneratedColumnInfoBuilder&) = delete;
  ResolvedGeneratedColumnInfoBuilder(ResolvedGeneratedColumnInfoBuilder&& other)
      : ResolvedGeneratedColumnInfoBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedGeneratedColumnInfoBuilder& operator=(ResolvedGeneratedColumnInfoBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedGeneratedColumnInfo>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGeneratedColumnInfo::expression was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGeneratedColumnInfo::stored_mode was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* expression() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expression();
  }

  std::unique_ptr<const ResolvedExpr> release_expression() {
    return node_->release_expression();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGeneratedColumnInfoBuilder&& set_expression(T v) && {
    node_->set_expression(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGeneratedColumnInfoBuilder& set_expression(T v) & {
    node_->set_expression(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGeneratedColumnInfoBuilder&& set_expression(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGeneratedColumnInfoBuilder& set_expression(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

  ResolvedGeneratedColumnInfo::StoredMode stored_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->stored_mode();
  }

  ResolvedGeneratedColumnInfoBuilder&& set_stored_mode(ResolvedGeneratedColumnInfo::StoredMode v) && {
    node_->set_stored_mode(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedGeneratedColumnInfoBuilder& set_stored_mode(ResolvedGeneratedColumnInfo::StoredMode v) & {
    node_->set_stored_mode(v);
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedGeneratedColumnInfo> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedGeneratedColumnInfoBuilder ToBuilder(
      std::unique_ptr<const ResolvedGeneratedColumnInfo> node);

  ResolvedGeneratedColumnInfoBuilder(std::unique_ptr<ResolvedGeneratedColumnInfo> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedGeneratedColumnInfoBuilder ToBuilder(
    std::unique_ptr<const ResolvedGeneratedColumnInfo> node) {
  ResolvedGeneratedColumnInfoBuilder builder(absl::WrapUnique<ResolvedGeneratedColumnInfo>(
      const_cast<ResolvedGeneratedColumnInfo*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedColumnDefaultValueBuilder final {
 public:
  ResolvedColumnDefaultValueBuilder() : ResolvedColumnDefaultValueBuilder(absl::WrapUnique(new ResolvedColumnDefaultValue)) {}

  ResolvedColumnDefaultValueBuilder(const ResolvedColumnDefaultValueBuilder&) = delete;
  ResolvedColumnDefaultValueBuilder& operator=(const ResolvedColumnDefaultValueBuilder&) = delete;
  ResolvedColumnDefaultValueBuilder(ResolvedColumnDefaultValueBuilder&& other)
      : ResolvedColumnDefaultValueBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedColumnDefaultValueBuilder& operator=(ResolvedColumnDefaultValueBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedColumnDefaultValue>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedColumnDefaultValue::expression was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedColumnDefaultValue::sql was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* expression() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expression();
  }

  std::unique_ptr<const ResolvedExpr> release_expression() {
    return node_->release_expression();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedColumnDefaultValueBuilder&& set_expression(T v) && {
    node_->set_expression(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedColumnDefaultValueBuilder& set_expression(T v) & {
    node_->set_expression(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedColumnDefaultValueBuilder&& set_expression(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedColumnDefaultValueBuilder& set_expression(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

  const std::string& sql() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->sql();
  }

  ResolvedColumnDefaultValueBuilder&& set_sql(const std::string& v) && {
    node_->set_sql(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedColumnDefaultValueBuilder& set_sql(const std::string& v) & {
    node_->set_sql(v);
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedColumnDefaultValue> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedColumnDefaultValueBuilder ToBuilder(
      std::unique_ptr<const ResolvedColumnDefaultValue> node);

  ResolvedColumnDefaultValueBuilder(std::unique_ptr<ResolvedColumnDefaultValue> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedColumnDefaultValueBuilder ToBuilder(
    std::unique_ptr<const ResolvedColumnDefaultValue> node) {
  ResolvedColumnDefaultValueBuilder builder(absl::WrapUnique<ResolvedColumnDefaultValue>(
      const_cast<ResolvedColumnDefaultValue*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedColumnDefinitionBuilder final {
 public:
    // Get the full TypeParameters object for this column, including
  // parameters on nested fields. <annotations.type_parameters> includes
  // only parameters on the outermost type.
  absl::StatusOr<TypeParameters> GetFullTypeParameters() const;

  ResolvedColumnDefinitionBuilder() : ResolvedColumnDefinitionBuilder(absl::WrapUnique(new ResolvedColumnDefinition)) {}

  ResolvedColumnDefinitionBuilder(const ResolvedColumnDefinitionBuilder&) = delete;
  ResolvedColumnDefinitionBuilder& operator=(const ResolvedColumnDefinitionBuilder&) = delete;
  ResolvedColumnDefinitionBuilder(ResolvedColumnDefinitionBuilder&& other)
      : ResolvedColumnDefinitionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedColumnDefinitionBuilder& operator=(ResolvedColumnDefinitionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedColumnDefinition>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedColumnDefinition::name was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedColumnDefinition::type was not set on the builder");
    }
    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedColumnDefinition::column was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedColumnDefinitionBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedColumnDefinitionBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedColumnDefinitionBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedColumnDefinitionBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const ResolvedColumnAnnotations* annotations() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->annotations();
  }

  std::unique_ptr<const ResolvedColumnAnnotations> release_annotations() {
    return node_->release_annotations();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnAnnotations>>::value>>
  ResolvedColumnDefinitionBuilder&& set_annotations(T v) && {
    node_->set_annotations(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnAnnotations>>::value>>
  ResolvedColumnDefinitionBuilder& set_annotations(T v) & {
    node_->set_annotations(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnAnnotations>>::value>>
  ResolvedColumnDefinitionBuilder&& set_annotations(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_annotations(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnAnnotations>>::value>>
  ResolvedColumnDefinitionBuilder& set_annotations(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_annotations(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_hidden() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_hidden();
  }

  ResolvedColumnDefinitionBuilder&& set_is_hidden(bool v) && {
    node_->set_is_hidden(v);

    return std::move(*this);
  }

  ResolvedColumnDefinitionBuilder& set_is_hidden(bool v) & {
    node_->set_is_hidden(v);

    return *this;
  }

  const ResolvedColumn& column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column();
  }

  ResolvedColumnDefinitionBuilder&& set_column(const ResolvedColumn& v) && {
    node_->set_column(v);
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  ResolvedColumnDefinitionBuilder& set_column(const ResolvedColumn& v) & {
    node_->set_column(v);
    field_is_set_.set(4, true);

    return *this;
  }

  const ResolvedGeneratedColumnInfo* generated_column_info() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->generated_column_info();
  }

  std::unique_ptr<const ResolvedGeneratedColumnInfo> release_generated_column_info() {
    return node_->release_generated_column_info();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedGeneratedColumnInfo>>::value>>
  ResolvedColumnDefinitionBuilder&& set_generated_column_info(T v) && {
    node_->set_generated_column_info(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedGeneratedColumnInfo>>::value>>
  ResolvedColumnDefinitionBuilder& set_generated_column_info(T v) & {
    node_->set_generated_column_info(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedGeneratedColumnInfo>>::value>>
  ResolvedColumnDefinitionBuilder&& set_generated_column_info(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_generated_column_info(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedGeneratedColumnInfo>>::value>>
  ResolvedColumnDefinitionBuilder& set_generated_column_info(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_generated_column_info(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedColumnDefaultValue* default_value() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->default_value();
  }

  std::unique_ptr<const ResolvedColumnDefaultValue> release_default_value() {
    return node_->release_default_value();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefaultValue>>::value>>
  ResolvedColumnDefinitionBuilder&& set_default_value(T v) && {
    node_->set_default_value(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefaultValue>>::value>>
  ResolvedColumnDefinitionBuilder& set_default_value(T v) & {
    node_->set_default_value(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefaultValue>>::value>>
  ResolvedColumnDefinitionBuilder&& set_default_value(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_default_value(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefaultValue>>::value>>
  ResolvedColumnDefinitionBuilder& set_default_value(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_default_value(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedColumnDefinition> node_;

  absl::Status deferred_build_status_;
  std::bitset<7> field_is_set_ = {0};
  friend ResolvedColumnDefinitionBuilder ToBuilder(
      std::unique_ptr<const ResolvedColumnDefinition> node);

  ResolvedColumnDefinitionBuilder(std::unique_ptr<ResolvedColumnDefinition> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedColumnDefinitionBuilder ToBuilder(
    std::unique_ptr<const ResolvedColumnDefinition> node) {
  ResolvedColumnDefinitionBuilder builder(absl::WrapUnique<ResolvedColumnDefinition>(
      const_cast<ResolvedColumnDefinition*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedPrimaryKeyBuilder final {
 public:
  ResolvedPrimaryKeyBuilder() : ResolvedPrimaryKeyBuilder(absl::WrapUnique(new ResolvedPrimaryKey)) {}

  ResolvedPrimaryKeyBuilder(const ResolvedPrimaryKeyBuilder&) = delete;
  ResolvedPrimaryKeyBuilder& operator=(const ResolvedPrimaryKeyBuilder&) = delete;
  ResolvedPrimaryKeyBuilder(ResolvedPrimaryKeyBuilder&& other)
      : ResolvedPrimaryKeyBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedPrimaryKeyBuilder& operator=(ResolvedPrimaryKeyBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedPrimaryKey>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<int>& column_offset_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_offset_list();
  }

  int column_offset_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_offset_list_size();
  }

  int column_offset_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_offset_list(i);
  }

  ResolvedPrimaryKeyBuilder&& add_column_offset_list(int v) && {
    node_->add_column_offset_list(v);

    return std::move(*this);
  }

  ResolvedPrimaryKeyBuilder& add_column_offset_list(int v) & {
    node_->add_column_offset_list(v);

    return *this;
  }

  ResolvedPrimaryKeyBuilder&& set_column_offset_list(const std::vector<int>& v) && {
    node_->set_column_offset_list(v);

    return std::move(*this);
  }

  ResolvedPrimaryKeyBuilder& set_column_offset_list(const std::vector<int>& v) & {
    node_->set_column_offset_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedPrimaryKeyBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedPrimaryKeyBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedPrimaryKeyBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedPrimaryKeyBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedPrimaryKeyBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedPrimaryKeyBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedPrimaryKeyBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedPrimaryKeyBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool unenforced() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->unenforced();
  }

  ResolvedPrimaryKeyBuilder&& set_unenforced(bool v) && {
    node_->set_unenforced(v);

    return std::move(*this);
  }

  ResolvedPrimaryKeyBuilder& set_unenforced(bool v) & {
    node_->set_unenforced(v);

    return *this;
  }

  const std::string& constraint_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->constraint_name();
  }

  ResolvedPrimaryKeyBuilder&& set_constraint_name(const std::string& v) && {
    node_->set_constraint_name(v);

    return std::move(*this);
  }

  ResolvedPrimaryKeyBuilder& set_constraint_name(const std::string& v) & {
    node_->set_constraint_name(v);

    return *this;
  }

  const std::vector<std::string>& column_name_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_name_list();
  }

  int column_name_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_name_list_size();
  }

  const std::string& column_name_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_name_list(i);
  }

  ResolvedPrimaryKeyBuilder&& add_column_name_list(std::string v) && {
    node_->add_column_name_list(v);

    return std::move(*this);
  }

  ResolvedPrimaryKeyBuilder& add_column_name_list(std::string v) & {
    node_->add_column_name_list(v);

    return *this;
  }

  ResolvedPrimaryKeyBuilder&& set_column_name_list(const std::vector<std::string>& v) && {
    node_->set_column_name_list(v);

    return std::move(*this);
  }

  ResolvedPrimaryKeyBuilder& set_column_name_list(const std::vector<std::string>& v) & {
    node_->set_column_name_list(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedPrimaryKey> node_;

  absl::Status deferred_build_status_;
  friend ResolvedPrimaryKeyBuilder ToBuilder(
      std::unique_ptr<const ResolvedPrimaryKey> node);

  ResolvedPrimaryKeyBuilder(std::unique_ptr<ResolvedPrimaryKey> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedPrimaryKeyBuilder ToBuilder(
    std::unique_ptr<const ResolvedPrimaryKey> node) {
  ResolvedPrimaryKeyBuilder builder(absl::WrapUnique<ResolvedPrimaryKey>(
      const_cast<ResolvedPrimaryKey*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedForeignKeyBuilder final {
 public:
    typedef ResolvedForeignKeyEnums::MatchMode MatchMode;
  typedef ResolvedForeignKeyEnums::ActionOperation ActionOperation;
  static const MatchMode SIMPLE = ResolvedForeignKeyEnums::SIMPLE;
  static const MatchMode FULL = ResolvedForeignKeyEnums::FULL;
  static const MatchMode NOT_DISTINCT = ResolvedForeignKeyEnums::NOT_DISTINCT;
  static const ActionOperation NO_ACTION = ResolvedForeignKeyEnums::NO_ACTION;
  static const ActionOperation RESTRICT = ResolvedForeignKeyEnums::RESTRICT;
  static const ActionOperation CASCADE = ResolvedForeignKeyEnums::CASCADE;
  static const ActionOperation SET_NULL = ResolvedForeignKeyEnums::SET_NULL;

  ResolvedForeignKeyBuilder() : ResolvedForeignKeyBuilder(absl::WrapUnique(new ResolvedForeignKey)) {}

  ResolvedForeignKeyBuilder(const ResolvedForeignKeyBuilder&) = delete;
  ResolvedForeignKeyBuilder& operator=(const ResolvedForeignKeyBuilder&) = delete;
  ResolvedForeignKeyBuilder(ResolvedForeignKeyBuilder&& other)
      : ResolvedForeignKeyBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedForeignKeyBuilder& operator=(ResolvedForeignKeyBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedForeignKey>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedForeignKey::constraint_name was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedForeignKey::referenced_table was not set on the builder");
    }
    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedForeignKey::match_mode was not set on the builder");
    }
    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedForeignKey::update_action was not set on the builder");
    }
    if (!field_is_set_.test(6)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedForeignKey::delete_action was not set on the builder");
    }
    if (!field_is_set_.test(7)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedForeignKey::enforced was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& constraint_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->constraint_name();
  }

  ResolvedForeignKeyBuilder&& set_constraint_name(const std::string& v) && {
    node_->set_constraint_name(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedForeignKeyBuilder& set_constraint_name(const std::string& v) & {
    node_->set_constraint_name(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const std::vector<int>& referencing_column_offset_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->referencing_column_offset_list();
  }

  int referencing_column_offset_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->referencing_column_offset_list_size();
  }

  int referencing_column_offset_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->referencing_column_offset_list(i);
  }

  ResolvedForeignKeyBuilder&& add_referencing_column_offset_list(int v) && {
    node_->add_referencing_column_offset_list(v);

    return std::move(*this);
  }

  ResolvedForeignKeyBuilder& add_referencing_column_offset_list(int v) & {
    node_->add_referencing_column_offset_list(v);

    return *this;
  }

  ResolvedForeignKeyBuilder&& set_referencing_column_offset_list(const std::vector<int>& v) && {
    node_->set_referencing_column_offset_list(v);

    return std::move(*this);
  }

  ResolvedForeignKeyBuilder& set_referencing_column_offset_list(const std::vector<int>& v) & {
    node_->set_referencing_column_offset_list(v);

    return *this;
  }

  const Table* referenced_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->referenced_table();
  }

  ResolvedForeignKeyBuilder&& set_referenced_table(const Table* v) && {
    node_->set_referenced_table(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedForeignKeyBuilder& set_referenced_table(const Table* v) & {
    node_->set_referenced_table(v);
    field_is_set_.set(2, true);

    return *this;
  }

  const std::vector<int>& referenced_column_offset_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->referenced_column_offset_list();
  }

  int referenced_column_offset_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->referenced_column_offset_list_size();
  }

  int referenced_column_offset_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->referenced_column_offset_list(i);
  }

  ResolvedForeignKeyBuilder&& add_referenced_column_offset_list(int v) && {
    node_->add_referenced_column_offset_list(v);

    return std::move(*this);
  }

  ResolvedForeignKeyBuilder& add_referenced_column_offset_list(int v) & {
    node_->add_referenced_column_offset_list(v);

    return *this;
  }

  ResolvedForeignKeyBuilder&& set_referenced_column_offset_list(const std::vector<int>& v) && {
    node_->set_referenced_column_offset_list(v);

    return std::move(*this);
  }

  ResolvedForeignKeyBuilder& set_referenced_column_offset_list(const std::vector<int>& v) & {
    node_->set_referenced_column_offset_list(v);

    return *this;
  }

  ResolvedForeignKey::MatchMode match_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->match_mode();
  }

  ResolvedForeignKeyBuilder&& set_match_mode(ResolvedForeignKey::MatchMode v) && {
    node_->set_match_mode(v);
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  ResolvedForeignKeyBuilder& set_match_mode(ResolvedForeignKey::MatchMode v) & {
    node_->set_match_mode(v);
    field_is_set_.set(4, true);

    return *this;
  }

  ResolvedForeignKey::ActionOperation update_action() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->update_action();
  }

  ResolvedForeignKeyBuilder&& set_update_action(ResolvedForeignKey::ActionOperation v) && {
    node_->set_update_action(v);
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  ResolvedForeignKeyBuilder& set_update_action(ResolvedForeignKey::ActionOperation v) & {
    node_->set_update_action(v);
    field_is_set_.set(5, true);

    return *this;
  }

  ResolvedForeignKey::ActionOperation delete_action() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->delete_action();
  }

  ResolvedForeignKeyBuilder&& set_delete_action(ResolvedForeignKey::ActionOperation v) && {
    node_->set_delete_action(v);
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  ResolvedForeignKeyBuilder& set_delete_action(ResolvedForeignKey::ActionOperation v) & {
    node_->set_delete_action(v);
    field_is_set_.set(6, true);

    return *this;
  }

  bool enforced() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->enforced();
  }

  ResolvedForeignKeyBuilder&& set_enforced(bool v) && {
    node_->set_enforced(v);
    field_is_set_.set(7, true);

    return std::move(*this);
  }

  ResolvedForeignKeyBuilder& set_enforced(bool v) & {
    node_->set_enforced(v);
    field_is_set_.set(7, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedForeignKeyBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedForeignKeyBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedForeignKeyBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedForeignKeyBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedForeignKeyBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedForeignKeyBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedForeignKeyBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedForeignKeyBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& referencing_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->referencing_column_list();
  }

  int referencing_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->referencing_column_list_size();
  }

  const std::string& referencing_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->referencing_column_list(i);
  }

  ResolvedForeignKeyBuilder&& add_referencing_column_list(std::string v) && {
    node_->add_referencing_column_list(v);

    return std::move(*this);
  }

  ResolvedForeignKeyBuilder& add_referencing_column_list(std::string v) & {
    node_->add_referencing_column_list(v);

    return *this;
  }

  ResolvedForeignKeyBuilder&& set_referencing_column_list(const std::vector<std::string>& v) && {
    node_->set_referencing_column_list(v);

    return std::move(*this);
  }

  ResolvedForeignKeyBuilder& set_referencing_column_list(const std::vector<std::string>& v) & {
    node_->set_referencing_column_list(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedForeignKey> node_;

  absl::Status deferred_build_status_;
  std::bitset<10> field_is_set_ = {0};
  friend ResolvedForeignKeyBuilder ToBuilder(
      std::unique_ptr<const ResolvedForeignKey> node);

  ResolvedForeignKeyBuilder(std::unique_ptr<ResolvedForeignKey> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedForeignKeyBuilder ToBuilder(
    std::unique_ptr<const ResolvedForeignKey> node) {
  ResolvedForeignKeyBuilder builder(absl::WrapUnique<ResolvedForeignKey>(
      const_cast<ResolvedForeignKey*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  builder.field_is_set_.set(4, true);
  builder.field_is_set_.set(5, true);
  builder.field_is_set_.set(6, true);
  builder.field_is_set_.set(7, true);
  return builder;
}

class ResolvedCheckConstraintBuilder final {
 public:
  ResolvedCheckConstraintBuilder() : ResolvedCheckConstraintBuilder(absl::WrapUnique(new ResolvedCheckConstraint)) {}

  ResolvedCheckConstraintBuilder(const ResolvedCheckConstraintBuilder&) = delete;
  ResolvedCheckConstraintBuilder& operator=(const ResolvedCheckConstraintBuilder&) = delete;
  ResolvedCheckConstraintBuilder(ResolvedCheckConstraintBuilder&& other)
      : ResolvedCheckConstraintBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCheckConstraintBuilder& operator=(ResolvedCheckConstraintBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCheckConstraint>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCheckConstraint::constraint_name was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCheckConstraint::expression was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCheckConstraint::enforced was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& constraint_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->constraint_name();
  }

  ResolvedCheckConstraintBuilder&& set_constraint_name(const std::string& v) && {
    node_->set_constraint_name(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedCheckConstraintBuilder& set_constraint_name(const std::string& v) & {
    node_->set_constraint_name(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedExpr* expression() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expression();
  }

  std::unique_ptr<const ResolvedExpr> release_expression() {
    return node_->release_expression();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCheckConstraintBuilder&& set_expression(T v) && {
    node_->set_expression(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCheckConstraintBuilder& set_expression(T v) & {
    node_->set_expression(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCheckConstraintBuilder&& set_expression(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCheckConstraintBuilder& set_expression(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

  bool enforced() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->enforced();
  }

  ResolvedCheckConstraintBuilder&& set_enforced(bool v) && {
    node_->set_enforced(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedCheckConstraintBuilder& set_enforced(bool v) & {
    node_->set_enforced(v);
    field_is_set_.set(2, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCheckConstraintBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCheckConstraintBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCheckConstraintBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCheckConstraintBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCheckConstraintBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCheckConstraintBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCheckConstraintBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCheckConstraintBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCheckConstraint> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedCheckConstraintBuilder ToBuilder(
      std::unique_ptr<const ResolvedCheckConstraint> node);

  ResolvedCheckConstraintBuilder(std::unique_ptr<ResolvedCheckConstraint> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCheckConstraintBuilder ToBuilder(
    std::unique_ptr<const ResolvedCheckConstraint> node) {
  ResolvedCheckConstraintBuilder builder(absl::WrapUnique<ResolvedCheckConstraint>(
      const_cast<ResolvedCheckConstraint*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedOutputColumnBuilder final {
 public:
  ResolvedOutputColumnBuilder() : ResolvedOutputColumnBuilder(absl::WrapUnique(new ResolvedOutputColumn)) {}

  ResolvedOutputColumnBuilder(const ResolvedOutputColumnBuilder&) = delete;
  ResolvedOutputColumnBuilder& operator=(const ResolvedOutputColumnBuilder&) = delete;
  ResolvedOutputColumnBuilder(ResolvedOutputColumnBuilder&& other)
      : ResolvedOutputColumnBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedOutputColumnBuilder& operator=(ResolvedOutputColumnBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedOutputColumn>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedOutputColumn::name was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedOutputColumn::column was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedOutputColumnBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedOutputColumnBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedColumn& column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column();
  }

  ResolvedOutputColumnBuilder&& set_column(const ResolvedColumn& v) && {
    node_->set_column(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedOutputColumnBuilder& set_column(const ResolvedColumn& v) & {
    node_->set_column(v);
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedOutputColumn> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedOutputColumnBuilder ToBuilder(
      std::unique_ptr<const ResolvedOutputColumn> node);

  ResolvedOutputColumnBuilder(std::unique_ptr<ResolvedOutputColumn> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedOutputColumnBuilder ToBuilder(
    std::unique_ptr<const ResolvedOutputColumn> node) {
  ResolvedOutputColumnBuilder builder(absl::WrapUnique<ResolvedOutputColumn>(
      const_cast<ResolvedOutputColumn*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedProjectScanBuilder final {
 public:
  ResolvedProjectScanBuilder() : ResolvedProjectScanBuilder(absl::WrapUnique(new ResolvedProjectScan)) {}

  ResolvedProjectScanBuilder(const ResolvedProjectScanBuilder&) = delete;
  ResolvedProjectScanBuilder& operator=(const ResolvedProjectScanBuilder&) = delete;
  ResolvedProjectScanBuilder(ResolvedProjectScanBuilder&& other)
      : ResolvedProjectScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedProjectScanBuilder& operator=(ResolvedProjectScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedProjectScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedProjectScan::input_scan was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& expr_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr_list();
  }

  int expr_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr_list_size();
  }

  const ResolvedComputedColumn* expr_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedProjectScanBuilder&& add_expr_list(T v) && {
    node_->add_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedProjectScanBuilder& add_expr_list(T v) & {
    node_->add_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedProjectScanBuilder&& add_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedProjectScanBuilder& add_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_expr_list() {
    return node_->release_expr_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedProjectScanBuilder&& set_expr_list(T v) && {
    node_->set_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedProjectScanBuilder& set_expr_list(T v) & {
    node_->set_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedProjectScanBuilder&& set_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedProjectScanBuilder& set_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedScan* input_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_scan();
  }

  std::unique_ptr<const ResolvedScan> release_input_scan() {
    return node_->release_input_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedProjectScanBuilder&& set_input_scan(T v) && {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedProjectScanBuilder& set_input_scan(T v) & {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(4, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedProjectScanBuilder&& set_input_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedProjectScanBuilder& set_input_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedProjectScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedProjectScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedProjectScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedProjectScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedProjectScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedProjectScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedProjectScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedProjectScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedProjectScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedProjectScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedProjectScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedProjectScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedProjectScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedProjectScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedProjectScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedProjectScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedProjectScan> node);

  ResolvedProjectScanBuilder(std::unique_ptr<ResolvedProjectScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedProjectScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedProjectScan> node) {
  ResolvedProjectScanBuilder builder(absl::WrapUnique<ResolvedProjectScan>(
      const_cast<ResolvedProjectScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedTVFScanBuilder final {
 public:
  ResolvedTVFScanBuilder() : ResolvedTVFScanBuilder(absl::WrapUnique(new ResolvedTVFScan)) {}

  ResolvedTVFScanBuilder(const ResolvedTVFScanBuilder&) = delete;
  ResolvedTVFScanBuilder& operator=(const ResolvedTVFScanBuilder&) = delete;
  ResolvedTVFScanBuilder(ResolvedTVFScanBuilder&& other)
      : ResolvedTVFScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedTVFScanBuilder& operator=(ResolvedTVFScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedTVFScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedTVFScan::tvf was not set on the builder");
    }
    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedTVFScan::signature was not set on the builder");
    }
    if (!field_is_set_.test(7)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedTVFScan::alias was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const TableValuedFunction* tvf() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->tvf();
  }

  ResolvedTVFScanBuilder&& set_tvf(const TableValuedFunction* v) && {
    node_->set_tvf(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedTVFScanBuilder& set_tvf(const TableValuedFunction* v) & {
    node_->set_tvf(v);
    field_is_set_.set(3, true);

    return *this;
  }

  const std::shared_ptr<TVFSignature>& signature() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->signature();
  }

  ResolvedTVFScanBuilder&& set_signature(const std::shared_ptr<TVFSignature>& v) && {
    node_->set_signature(v);
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  ResolvedTVFScanBuilder& set_signature(const std::shared_ptr<TVFSignature>& v) & {
    node_->set_signature(v);
    field_is_set_.set(4, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedFunctionArgument>>& argument_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list();
  }

  int argument_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list_size();
  }

  const ResolvedFunctionArgument* argument_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedTVFScanBuilder&& add_argument_list(T v) && {
    node_->add_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedTVFScanBuilder& add_argument_list(T v) & {
    node_->add_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedTVFScanBuilder&& add_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedFunctionArgument>>::value>>
  ResolvedTVFScanBuilder& add_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedFunctionArgument>> release_argument_list() {
    return node_->release_argument_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedTVFScanBuilder&& set_argument_list(T v) && {
    node_->set_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedTVFScanBuilder& set_argument_list(T v) & {
    node_->set_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedTVFScanBuilder&& set_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedFunctionArgument>>>::value>>
  ResolvedTVFScanBuilder& set_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<int>& column_index_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_index_list();
  }

  int column_index_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_index_list_size();
  }

  int column_index_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_index_list(i);
  }

  ResolvedTVFScanBuilder&& add_column_index_list(int v) && {
    node_->add_column_index_list(v);

    return std::move(*this);
  }

  ResolvedTVFScanBuilder& add_column_index_list(int v) & {
    node_->add_column_index_list(v);

    return *this;
  }

  ResolvedTVFScanBuilder&& set_column_index_list(const std::vector<int>& v) && {
    node_->set_column_index_list(v);

    return std::move(*this);
  }

  ResolvedTVFScanBuilder& set_column_index_list(const std::vector<int>& v) & {
    node_->set_column_index_list(v);

    return *this;
  }

  const std::string& alias() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alias();
  }

  ResolvedTVFScanBuilder&& set_alias(const std::string& v) && {
    node_->set_alias(v);
    field_is_set_.set(7, true);

    return std::move(*this);
  }

  ResolvedTVFScanBuilder& set_alias(const std::string& v) & {
    node_->set_alias(v);
    field_is_set_.set(7, true);

    return *this;
  }

  const std::shared_ptr<FunctionSignature>& function_call_signature() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->function_call_signature();
  }

  ResolvedTVFScanBuilder&& set_function_call_signature(const std::shared_ptr<FunctionSignature>& v) && {
    node_->set_function_call_signature(v);

    return std::move(*this);
  }

  ResolvedTVFScanBuilder& set_function_call_signature(const std::shared_ptr<FunctionSignature>& v) & {
    node_->set_function_call_signature(v);

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedTVFScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedTVFScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedTVFScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedTVFScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedTVFScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedTVFScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedTVFScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedTVFScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedTVFScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedTVFScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedTVFScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedTVFScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedTVFScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedTVFScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedTVFScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<9> field_is_set_ = {0};
  friend ResolvedTVFScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedTVFScan> node);

  ResolvedTVFScanBuilder(std::unique_ptr<ResolvedTVFScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedTVFScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedTVFScan> node) {
  ResolvedTVFScanBuilder builder(absl::WrapUnique<ResolvedTVFScan>(
      const_cast<ResolvedTVFScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  builder.field_is_set_.set(4, true);
  builder.field_is_set_.set(7, true);
  return builder;
}

class ResolvedGroupRowsScanBuilder final {
 public:
  ResolvedGroupRowsScanBuilder() : ResolvedGroupRowsScanBuilder(absl::WrapUnique(new ResolvedGroupRowsScan)) {}

  ResolvedGroupRowsScanBuilder(const ResolvedGroupRowsScanBuilder&) = delete;
  ResolvedGroupRowsScanBuilder& operator=(const ResolvedGroupRowsScanBuilder&) = delete;
  ResolvedGroupRowsScanBuilder(ResolvedGroupRowsScanBuilder&& other)
      : ResolvedGroupRowsScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedGroupRowsScanBuilder& operator=(ResolvedGroupRowsScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedGroupRowsScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGroupRowsScan::alias was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& input_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_column_list();
  }

  int input_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_column_list_size();
  }

  const ResolvedComputedColumn* input_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedGroupRowsScanBuilder&& add_input_column_list(T v) && {
    node_->add_input_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedGroupRowsScanBuilder& add_input_column_list(T v) & {
    node_->add_input_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedGroupRowsScanBuilder&& add_input_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_input_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedGroupRowsScanBuilder& add_input_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_input_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_input_column_list() {
    return node_->release_input_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedGroupRowsScanBuilder&& set_input_column_list(T v) && {
    node_->set_input_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedGroupRowsScanBuilder& set_input_column_list(T v) & {
    node_->set_input_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedGroupRowsScanBuilder&& set_input_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedGroupRowsScanBuilder& set_input_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::string& alias() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alias();
  }

  ResolvedGroupRowsScanBuilder&& set_alias(const std::string& v) && {
    node_->set_alias(v);
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  ResolvedGroupRowsScanBuilder& set_alias(const std::string& v) & {
    node_->set_alias(v);
    field_is_set_.set(4, true);

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedGroupRowsScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedGroupRowsScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedGroupRowsScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedGroupRowsScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedGroupRowsScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedGroupRowsScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedGroupRowsScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedGroupRowsScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedGroupRowsScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedGroupRowsScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedGroupRowsScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedGroupRowsScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedGroupRowsScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedGroupRowsScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedGroupRowsScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedGroupRowsScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedGroupRowsScan> node);

  ResolvedGroupRowsScanBuilder(std::unique_ptr<ResolvedGroupRowsScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedGroupRowsScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedGroupRowsScan> node) {
  ResolvedGroupRowsScanBuilder builder(absl::WrapUnique<ResolvedGroupRowsScan>(
      const_cast<ResolvedGroupRowsScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedFunctionArgumentBuilder final {
 public:
  ResolvedFunctionArgumentBuilder() : ResolvedFunctionArgumentBuilder(absl::WrapUnique(new ResolvedFunctionArgument)) {}

  ResolvedFunctionArgumentBuilder(const ResolvedFunctionArgumentBuilder&) = delete;
  ResolvedFunctionArgumentBuilder& operator=(const ResolvedFunctionArgumentBuilder&) = delete;
  ResolvedFunctionArgumentBuilder(ResolvedFunctionArgumentBuilder&& other)
      : ResolvedFunctionArgumentBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedFunctionArgumentBuilder& operator=(ResolvedFunctionArgumentBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedFunctionArgument>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFunctionArgumentBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFunctionArgumentBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFunctionArgumentBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFunctionArgumentBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedScan* scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->scan();
  }

  std::unique_ptr<const ResolvedScan> release_scan() {
    return node_->release_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedFunctionArgumentBuilder&& set_scan(T v) && {
    node_->set_scan(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedFunctionArgumentBuilder& set_scan(T v) & {
    node_->set_scan(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedFunctionArgumentBuilder&& set_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedFunctionArgumentBuilder& set_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedModel* model() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->model();
  }

  std::unique_ptr<const ResolvedModel> release_model() {
    return node_->release_model();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedModel>>::value>>
  ResolvedFunctionArgumentBuilder&& set_model(T v) && {
    node_->set_model(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedModel>>::value>>
  ResolvedFunctionArgumentBuilder& set_model(T v) & {
    node_->set_model(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedModel>>::value>>
  ResolvedFunctionArgumentBuilder&& set_model(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_model(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedModel>>::value>>
  ResolvedFunctionArgumentBuilder& set_model(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_model(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedConnection* connection() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->connection();
  }

  std::unique_ptr<const ResolvedConnection> release_connection() {
    return node_->release_connection();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedFunctionArgumentBuilder&& set_connection(T v) && {
    node_->set_connection(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedFunctionArgumentBuilder& set_connection(T v) & {
    node_->set_connection(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedFunctionArgumentBuilder&& set_connection(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedFunctionArgumentBuilder& set_connection(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedDescriptor* descriptor_arg() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->descriptor_arg();
  }

  std::unique_ptr<const ResolvedDescriptor> release_descriptor_arg() {
    return node_->release_descriptor_arg();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedDescriptor>>::value>>
  ResolvedFunctionArgumentBuilder&& set_descriptor_arg(T v) && {
    node_->set_descriptor_arg(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedDescriptor>>::value>>
  ResolvedFunctionArgumentBuilder& set_descriptor_arg(T v) & {
    node_->set_descriptor_arg(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedDescriptor>>::value>>
  ResolvedFunctionArgumentBuilder&& set_descriptor_arg(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_descriptor_arg(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedDescriptor>>::value>>
  ResolvedFunctionArgumentBuilder& set_descriptor_arg(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_descriptor_arg(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& argument_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_column_list();
  }

  int argument_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_column_list_size();
  }

  const ResolvedColumn& argument_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_column_list(i);
  }

  ResolvedFunctionArgumentBuilder&& add_argument_column_list(ResolvedColumn v) && {
    node_->add_argument_column_list(v);

    return std::move(*this);
  }

  ResolvedFunctionArgumentBuilder& add_argument_column_list(ResolvedColumn v) & {
    node_->add_argument_column_list(v);

    return *this;
  }

  ResolvedFunctionArgumentBuilder&& set_argument_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_argument_column_list(v);

    return std::move(*this);
  }

  ResolvedFunctionArgumentBuilder& set_argument_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_argument_column_list(v);

    return *this;
  }

  const ResolvedInlineLambda* inline_lambda() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->inline_lambda();
  }

  std::unique_ptr<const ResolvedInlineLambda> release_inline_lambda() {
    return node_->release_inline_lambda();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedInlineLambda>>::value>>
  ResolvedFunctionArgumentBuilder&& set_inline_lambda(T v) && {
    node_->set_inline_lambda(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedInlineLambda>>::value>>
  ResolvedFunctionArgumentBuilder& set_inline_lambda(T v) & {
    node_->set_inline_lambda(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedInlineLambda>>::value>>
  ResolvedFunctionArgumentBuilder&& set_inline_lambda(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_inline_lambda(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedInlineLambda>>::value>>
  ResolvedFunctionArgumentBuilder& set_inline_lambda(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_inline_lambda(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedFunctionArgument> node_;

  absl::Status deferred_build_status_;
  friend ResolvedFunctionArgumentBuilder ToBuilder(
      std::unique_ptr<const ResolvedFunctionArgument> node);

  ResolvedFunctionArgumentBuilder(std::unique_ptr<ResolvedFunctionArgument> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedFunctionArgumentBuilder ToBuilder(
    std::unique_ptr<const ResolvedFunctionArgument> node) {
  ResolvedFunctionArgumentBuilder builder(absl::WrapUnique<ResolvedFunctionArgument>(
      const_cast<ResolvedFunctionArgument*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedExplainStmtBuilder final {
 public:
  ResolvedExplainStmtBuilder() : ResolvedExplainStmtBuilder(absl::WrapUnique(new ResolvedExplainStmt)) {}

  ResolvedExplainStmtBuilder(const ResolvedExplainStmtBuilder&) = delete;
  ResolvedExplainStmtBuilder& operator=(const ResolvedExplainStmtBuilder&) = delete;
  ResolvedExplainStmtBuilder(ResolvedExplainStmtBuilder&& other)
      : ResolvedExplainStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedExplainStmtBuilder& operator=(ResolvedExplainStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedExplainStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedExplainStmt::statement was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedStatement* statement() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->statement();
  }

  std::unique_ptr<const ResolvedStatement> release_statement() {
    return node_->release_statement();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedStatement>>::value>>
  ResolvedExplainStmtBuilder&& set_statement(T v) && {
    node_->set_statement(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedStatement>>::value>>
  ResolvedExplainStmtBuilder& set_statement(T v) & {
    node_->set_statement(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedStatement>>::value>>
  ResolvedExplainStmtBuilder&& set_statement(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_statement(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedStatement>>::value>>
  ResolvedExplainStmtBuilder& set_statement(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_statement(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExplainStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExplainStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExplainStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExplainStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExplainStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExplainStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExplainStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExplainStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedExplainStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedExplainStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedExplainStmt> node);

  ResolvedExplainStmtBuilder(std::unique_ptr<ResolvedExplainStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedExplainStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedExplainStmt> node) {
  ResolvedExplainStmtBuilder builder(absl::WrapUnique<ResolvedExplainStmt>(
      const_cast<ResolvedExplainStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedQueryStmtBuilder final {
 public:
  ResolvedQueryStmtBuilder() : ResolvedQueryStmtBuilder(absl::WrapUnique(new ResolvedQueryStmt)) {}

  ResolvedQueryStmtBuilder(const ResolvedQueryStmtBuilder&) = delete;
  ResolvedQueryStmtBuilder& operator=(const ResolvedQueryStmtBuilder&) = delete;
  ResolvedQueryStmtBuilder(ResolvedQueryStmtBuilder&& other)
      : ResolvedQueryStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedQueryStmtBuilder& operator=(ResolvedQueryStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedQueryStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedQueryStmt::query was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOutputColumn>>& output_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list();
  }

  int output_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list_size();
  }

  const ResolvedOutputColumn* output_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedQueryStmtBuilder&& add_output_column_list(T v) && {
    node_->add_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedQueryStmtBuilder& add_output_column_list(T v) & {
    node_->add_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedQueryStmtBuilder&& add_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedQueryStmtBuilder& add_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOutputColumn>> release_output_column_list() {
    return node_->release_output_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedQueryStmtBuilder&& set_output_column_list(T v) && {
    node_->set_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedQueryStmtBuilder& set_output_column_list(T v) & {
    node_->set_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedQueryStmtBuilder&& set_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedQueryStmtBuilder& set_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // If true, the result of this query is a value table. Rather than
  // producing rows with named columns, it produces rows with a single
  // unnamed value type.  output_column_list will have exactly one
  // column, with an empty name. See (broken link).
  bool is_value_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_value_table();
  }

  ResolvedQueryStmtBuilder&& set_is_value_table(bool v) && {
    node_->set_is_value_table(v);

    return std::move(*this);
  }

  ResolvedQueryStmtBuilder& set_is_value_table(bool v) & {
    node_->set_is_value_table(v);

    return *this;
  }

  const ResolvedScan* query() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query();
  }

  std::unique_ptr<const ResolvedScan> release_query() {
    return node_->release_query();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedQueryStmtBuilder&& set_query(T v) && {
    node_->set_query(std::move(v));
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedQueryStmtBuilder& set_query(T v) & {
    node_->set_query(std::move(v));
    field_is_set_.set(3, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedQueryStmtBuilder&& set_query(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedQueryStmtBuilder& set_query(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedQueryStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedQueryStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedQueryStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedQueryStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedQueryStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedQueryStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedQueryStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedQueryStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedQueryStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedQueryStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedQueryStmt> node);

  ResolvedQueryStmtBuilder(std::unique_ptr<ResolvedQueryStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedQueryStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedQueryStmt> node) {
  ResolvedQueryStmtBuilder builder(absl::WrapUnique<ResolvedQueryStmt>(
      const_cast<ResolvedQueryStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedCreateDatabaseStmtBuilder final {
 public:
  ResolvedCreateDatabaseStmtBuilder() : ResolvedCreateDatabaseStmtBuilder(absl::WrapUnique(new ResolvedCreateDatabaseStmt)) {}

  ResolvedCreateDatabaseStmtBuilder(const ResolvedCreateDatabaseStmtBuilder&) = delete;
  ResolvedCreateDatabaseStmtBuilder& operator=(const ResolvedCreateDatabaseStmtBuilder&) = delete;
  ResolvedCreateDatabaseStmtBuilder(ResolvedCreateDatabaseStmtBuilder&& other)
      : ResolvedCreateDatabaseStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedCreateDatabaseStmtBuilder& operator=(ResolvedCreateDatabaseStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateDatabaseStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateDatabaseStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateDatabaseStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateDatabaseStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateDatabaseStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateDatabaseStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateDatabaseStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateDatabaseStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateDatabaseStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateDatabaseStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateDatabaseStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateDatabaseStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateDatabaseStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateDatabaseStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateDatabaseStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateDatabaseStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateDatabaseStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateDatabaseStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateDatabaseStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateDatabaseStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateDatabaseStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateDatabaseStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedCreateDatabaseStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateDatabaseStmt> node);

  ResolvedCreateDatabaseStmtBuilder(std::unique_ptr<ResolvedCreateDatabaseStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateDatabaseStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateDatabaseStmt> node) {
  ResolvedCreateDatabaseStmtBuilder builder(absl::WrapUnique<ResolvedCreateDatabaseStmt>(
      const_cast<ResolvedCreateDatabaseStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedIndexItemBuilder final {
 public:
  ResolvedIndexItemBuilder() : ResolvedIndexItemBuilder(absl::WrapUnique(new ResolvedIndexItem)) {}

  ResolvedIndexItemBuilder(const ResolvedIndexItemBuilder&) = delete;
  ResolvedIndexItemBuilder& operator=(const ResolvedIndexItemBuilder&) = delete;
  ResolvedIndexItemBuilder(ResolvedIndexItemBuilder&& other)
      : ResolvedIndexItemBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedIndexItemBuilder& operator=(ResolvedIndexItemBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedIndexItem>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedIndexItem::column_ref was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedIndexItem::descending was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedColumnRef* column_ref() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_ref();
  }

  std::unique_ptr<const ResolvedColumnRef> release_column_ref() {
    return node_->release_column_ref();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedIndexItemBuilder&& set_column_ref(T v) && {
    node_->set_column_ref(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedIndexItemBuilder& set_column_ref(T v) & {
    node_->set_column_ref(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedIndexItemBuilder&& set_column_ref(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_ref(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedIndexItemBuilder& set_column_ref(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_ref(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

  bool descending() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->descending();
  }

  ResolvedIndexItemBuilder&& set_descending(bool v) && {
    node_->set_descending(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedIndexItemBuilder& set_descending(bool v) & {
    node_->set_descending(v);
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedIndexItem> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedIndexItemBuilder ToBuilder(
      std::unique_ptr<const ResolvedIndexItem> node);

  ResolvedIndexItemBuilder(std::unique_ptr<ResolvedIndexItem> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedIndexItemBuilder ToBuilder(
    std::unique_ptr<const ResolvedIndexItem> node) {
  ResolvedIndexItemBuilder builder(absl::WrapUnique<ResolvedIndexItem>(
      const_cast<ResolvedIndexItem*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedUnnestItemBuilder final {
 public:
  ResolvedUnnestItemBuilder() : ResolvedUnnestItemBuilder(absl::WrapUnique(new ResolvedUnnestItem)) {}

  ResolvedUnnestItemBuilder(const ResolvedUnnestItemBuilder&) = delete;
  ResolvedUnnestItemBuilder& operator=(const ResolvedUnnestItemBuilder&) = delete;
  ResolvedUnnestItemBuilder(ResolvedUnnestItemBuilder&& other)
      : ResolvedUnnestItemBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedUnnestItemBuilder& operator=(ResolvedUnnestItemBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedUnnestItem>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedUnnestItem::array_expr was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedUnnestItem::element_column was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* array_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->array_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_array_expr() {
    return node_->release_array_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUnnestItemBuilder&& set_array_expr(T v) && {
    node_->set_array_expr(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUnnestItemBuilder& set_array_expr(T v) & {
    node_->set_array_expr(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUnnestItemBuilder&& set_array_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUnnestItemBuilder& set_array_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedColumn& element_column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->element_column();
  }

  ResolvedUnnestItemBuilder&& set_element_column(const ResolvedColumn& v) && {
    node_->set_element_column(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedUnnestItemBuilder& set_element_column(const ResolvedColumn& v) & {
    node_->set_element_column(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const ResolvedColumnHolder* array_offset_column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->array_offset_column();
  }

  std::unique_ptr<const ResolvedColumnHolder> release_array_offset_column() {
    return node_->release_array_offset_column();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedUnnestItemBuilder&& set_array_offset_column(T v) && {
    node_->set_array_offset_column(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedUnnestItemBuilder& set_array_offset_column(T v) & {
    node_->set_array_offset_column(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedUnnestItemBuilder&& set_array_offset_column(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_offset_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedUnnestItemBuilder& set_array_offset_column(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_offset_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedUnnestItem> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedUnnestItemBuilder ToBuilder(
      std::unique_ptr<const ResolvedUnnestItem> node);

  ResolvedUnnestItemBuilder(std::unique_ptr<ResolvedUnnestItem> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedUnnestItemBuilder ToBuilder(
    std::unique_ptr<const ResolvedUnnestItem> node) {
  ResolvedUnnestItemBuilder builder(absl::WrapUnique<ResolvedUnnestItem>(
      const_cast<ResolvedUnnestItem*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedCreateIndexStmtBuilder final {
 public:
  ResolvedCreateIndexStmtBuilder() : ResolvedCreateIndexStmtBuilder(absl::WrapUnique(new ResolvedCreateIndexStmt)) {}

  ResolvedCreateIndexStmtBuilder(const ResolvedCreateIndexStmtBuilder&) = delete;
  ResolvedCreateIndexStmtBuilder& operator=(const ResolvedCreateIndexStmtBuilder&) = delete;
  ResolvedCreateIndexStmtBuilder(ResolvedCreateIndexStmtBuilder&& other)
      : ResolvedCreateIndexStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCreateIndexStmtBuilder& operator=(ResolvedCreateIndexStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateIndexStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateIndexStmt::table_scan was not set on the builder");
    }
    if (!field_is_set_.test(6)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateIndexStmt::is_unique was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::string>& table_name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_name_path();
  }

  int table_name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_name_path_size();
  }

  const std::string& table_name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_name_path(i);
  }

  ResolvedCreateIndexStmtBuilder&& add_table_name_path(std::string v) && {
    node_->add_table_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateIndexStmtBuilder& add_table_name_path(std::string v) & {
    node_->add_table_name_path(v);

    return *this;
  }

  ResolvedCreateIndexStmtBuilder&& set_table_name_path(const std::vector<std::string>& v) && {
    node_->set_table_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateIndexStmtBuilder& set_table_name_path(const std::vector<std::string>& v) & {
    node_->set_table_name_path(v);

    return *this;
  }

  const ResolvedTableScan* table_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_scan();
  }

  std::unique_ptr<const ResolvedTableScan> release_table_scan() {
    return node_->release_table_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_table_scan(T v) && {
    node_->set_table_scan(std::move(v));
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedCreateIndexStmtBuilder& set_table_scan(T v) & {
    node_->set_table_scan(std::move(v));
    field_is_set_.set(5, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_table_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedCreateIndexStmtBuilder& set_table_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return *this;
  }

  bool is_unique() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_unique();
  }

  ResolvedCreateIndexStmtBuilder&& set_is_unique(bool v) && {
    node_->set_is_unique(v);
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  ResolvedCreateIndexStmtBuilder& set_is_unique(bool v) & {
    node_->set_is_unique(v);
    field_is_set_.set(6, true);

    return *this;
  }

  bool is_search() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_search();
  }

  ResolvedCreateIndexStmtBuilder&& set_is_search(bool v) && {
    node_->set_is_search(v);

    return std::move(*this);
  }

  ResolvedCreateIndexStmtBuilder& set_is_search(bool v) & {
    node_->set_is_search(v);

    return *this;
  }

  bool index_all_columns() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->index_all_columns();
  }

  ResolvedCreateIndexStmtBuilder&& set_index_all_columns(bool v) && {
    node_->set_index_all_columns(v);

    return std::move(*this);
  }

  ResolvedCreateIndexStmtBuilder& set_index_all_columns(bool v) & {
    node_->set_index_all_columns(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedIndexItem>>& index_item_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->index_item_list();
  }

  int index_item_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->index_item_list_size();
  }

  const ResolvedIndexItem* index_item_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->index_item_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedIndexItem>>::value>>
  ResolvedCreateIndexStmtBuilder&& add_index_item_list(T v) && {
    node_->add_index_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedIndexItem>>::value>>
  ResolvedCreateIndexStmtBuilder& add_index_item_list(T v) & {
    node_->add_index_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedIndexItem>>::value>>
  ResolvedCreateIndexStmtBuilder&& add_index_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_index_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedIndexItem>>::value>>
  ResolvedCreateIndexStmtBuilder& add_index_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_index_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedIndexItem>> release_index_item_list() {
    return node_->release_index_item_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedIndexItem>>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_index_item_list(T v) && {
    node_->set_index_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedIndexItem>>>::value>>
  ResolvedCreateIndexStmtBuilder& set_index_item_list(T v) & {
    node_->set_index_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedIndexItem>>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_index_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_index_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedIndexItem>>>::value>>
  ResolvedCreateIndexStmtBuilder& set_index_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_index_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& storing_expression_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->storing_expression_list();
  }

  int storing_expression_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->storing_expression_list_size();
  }

  const ResolvedExpr* storing_expression_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->storing_expression_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateIndexStmtBuilder&& add_storing_expression_list(T v) && {
    node_->add_storing_expression_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateIndexStmtBuilder& add_storing_expression_list(T v) & {
    node_->add_storing_expression_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateIndexStmtBuilder&& add_storing_expression_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_storing_expression_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateIndexStmtBuilder& add_storing_expression_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_storing_expression_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_storing_expression_list() {
    return node_->release_storing_expression_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_storing_expression_list(T v) && {
    node_->set_storing_expression_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateIndexStmtBuilder& set_storing_expression_list(T v) & {
    node_->set_storing_expression_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_storing_expression_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_storing_expression_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateIndexStmtBuilder& set_storing_expression_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_storing_expression_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateIndexStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateIndexStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateIndexStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateIndexStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateIndexStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateIndexStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& computed_columns_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->computed_columns_list();
  }

  int computed_columns_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->computed_columns_list_size();
  }

  const ResolvedComputedColumn* computed_columns_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->computed_columns_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedCreateIndexStmtBuilder&& add_computed_columns_list(T v) && {
    node_->add_computed_columns_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedCreateIndexStmtBuilder& add_computed_columns_list(T v) & {
    node_->add_computed_columns_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedCreateIndexStmtBuilder&& add_computed_columns_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_computed_columns_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedCreateIndexStmtBuilder& add_computed_columns_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_computed_columns_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_computed_columns_list() {
    return node_->release_computed_columns_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_computed_columns_list(T v) && {
    node_->set_computed_columns_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedCreateIndexStmtBuilder& set_computed_columns_list(T v) & {
    node_->set_computed_columns_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_computed_columns_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_computed_columns_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedCreateIndexStmtBuilder& set_computed_columns_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_computed_columns_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedUnnestItem>>& unnest_expressions_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->unnest_expressions_list();
  }

  int unnest_expressions_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->unnest_expressions_list_size();
  }

  const ResolvedUnnestItem* unnest_expressions_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->unnest_expressions_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUnnestItem>>::value>>
  ResolvedCreateIndexStmtBuilder&& add_unnest_expressions_list(T v) && {
    node_->add_unnest_expressions_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUnnestItem>>::value>>
  ResolvedCreateIndexStmtBuilder& add_unnest_expressions_list(T v) & {
    node_->add_unnest_expressions_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUnnestItem>>::value>>
  ResolvedCreateIndexStmtBuilder&& add_unnest_expressions_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_unnest_expressions_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUnnestItem>>::value>>
  ResolvedCreateIndexStmtBuilder& add_unnest_expressions_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_unnest_expressions_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedUnnestItem>> release_unnest_expressions_list() {
    return node_->release_unnest_expressions_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedUnnestItem>>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_unnest_expressions_list(T v) && {
    node_->set_unnest_expressions_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedUnnestItem>>>::value>>
  ResolvedCreateIndexStmtBuilder& set_unnest_expressions_list(T v) & {
    node_->set_unnest_expressions_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedUnnestItem>>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_unnest_expressions_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_unnest_expressions_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedUnnestItem>>>::value>>
  ResolvedCreateIndexStmtBuilder& set_unnest_expressions_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_unnest_expressions_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateIndexStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateIndexStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateIndexStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateIndexStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateIndexStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateIndexStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateIndexStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateIndexStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateIndexStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateIndexStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateIndexStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateIndexStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateIndexStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateIndexStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateIndexStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateIndexStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<14> field_is_set_ = {0};
  friend ResolvedCreateIndexStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateIndexStmt> node);

  ResolvedCreateIndexStmtBuilder(std::unique_ptr<ResolvedCreateIndexStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateIndexStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateIndexStmt> node) {
  ResolvedCreateIndexStmtBuilder builder(absl::WrapUnique<ResolvedCreateIndexStmt>(
      const_cast<ResolvedCreateIndexStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(5, true);
  builder.field_is_set_.set(6, true);
  return builder;
}

class ResolvedCreateSchemaStmtBuilder final {
 public:
  ResolvedCreateSchemaStmtBuilder() : ResolvedCreateSchemaStmtBuilder(absl::WrapUnique(new ResolvedCreateSchemaStmt)) {}

  ResolvedCreateSchemaStmtBuilder(const ResolvedCreateSchemaStmtBuilder&) = delete;
  ResolvedCreateSchemaStmtBuilder& operator=(const ResolvedCreateSchemaStmtBuilder&) = delete;
  ResolvedCreateSchemaStmtBuilder(ResolvedCreateSchemaStmtBuilder&& other)
      : ResolvedCreateSchemaStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedCreateSchemaStmtBuilder& operator=(ResolvedCreateSchemaStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateSchemaStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* collation_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_name();
  }

  std::unique_ptr<const ResolvedExpr> release_collation_name() {
    return node_->release_collation_name();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateSchemaStmtBuilder&& set_collation_name(T v) && {
    node_->set_collation_name(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateSchemaStmtBuilder& set_collation_name(T v) & {
    node_->set_collation_name(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateSchemaStmtBuilder&& set_collation_name(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateSchemaStmtBuilder& set_collation_name(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSchemaStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSchemaStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSchemaStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSchemaStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSchemaStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSchemaStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSchemaStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSchemaStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSchemaStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSchemaStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSchemaStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSchemaStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSchemaStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSchemaStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSchemaStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSchemaStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateSchemaStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateSchemaStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateSchemaStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateSchemaStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateSchemaStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateSchemaStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateSchemaStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateSchemaStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateSchemaStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedCreateSchemaStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateSchemaStmt> node);

  ResolvedCreateSchemaStmtBuilder(std::unique_ptr<ResolvedCreateSchemaStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateSchemaStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateSchemaStmt> node) {
  ResolvedCreateSchemaStmtBuilder builder(absl::WrapUnique<ResolvedCreateSchemaStmt>(
      const_cast<ResolvedCreateSchemaStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedCreateTableStmtBuilder final {
 public:
  ResolvedCreateTableStmtBuilder() : ResolvedCreateTableStmtBuilder(absl::WrapUnique(new ResolvedCreateTableStmt)) {}

  ResolvedCreateTableStmtBuilder(const ResolvedCreateTableStmtBuilder&) = delete;
  ResolvedCreateTableStmtBuilder& operator=(const ResolvedCreateTableStmtBuilder&) = delete;
  ResolvedCreateTableStmtBuilder(ResolvedCreateTableStmtBuilder&& other)
      : ResolvedCreateTableStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedCreateTableStmtBuilder& operator=(ResolvedCreateTableStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateTableStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedScan* clone_from() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->clone_from();
  }

  std::unique_ptr<const ResolvedScan> release_clone_from() {
    return node_->release_clone_from();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableStmtBuilder&& set_clone_from(T v) && {
    node_->set_clone_from(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableStmtBuilder& set_clone_from(T v) & {
    node_->set_clone_from(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableStmtBuilder&& set_clone_from(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_clone_from(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableStmtBuilder& set_clone_from(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_clone_from(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedScan* copy_from() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->copy_from();
  }

  std::unique_ptr<const ResolvedScan> release_copy_from() {
    return node_->release_copy_from();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableStmtBuilder&& set_copy_from(T v) && {
    node_->set_copy_from(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableStmtBuilder& set_copy_from(T v) & {
    node_->set_copy_from(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableStmtBuilder&& set_copy_from(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_copy_from(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableStmtBuilder& set_copy_from(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_copy_from(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& partition_by_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list();
  }

  int partition_by_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list_size();
  }

  const ResolvedExpr* partition_by_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableStmtBuilder&& add_partition_by_list(T v) && {
    node_->add_partition_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableStmtBuilder& add_partition_by_list(T v) & {
    node_->add_partition_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableStmtBuilder&& add_partition_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableStmtBuilder& add_partition_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_partition_by_list() {
    return node_->release_partition_by_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_partition_by_list(T v) && {
    node_->set_partition_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableStmtBuilder& set_partition_by_list(T v) & {
    node_->set_partition_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_partition_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableStmtBuilder& set_partition_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& cluster_by_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->cluster_by_list();
  }

  int cluster_by_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->cluster_by_list_size();
  }

  const ResolvedExpr* cluster_by_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->cluster_by_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableStmtBuilder&& add_cluster_by_list(T v) && {
    node_->add_cluster_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableStmtBuilder& add_cluster_by_list(T v) & {
    node_->add_cluster_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableStmtBuilder&& add_cluster_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableStmtBuilder& add_cluster_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_cluster_by_list() {
    return node_->release_cluster_by_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_cluster_by_list(T v) && {
    node_->set_cluster_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableStmtBuilder& set_cluster_by_list(T v) & {
    node_->set_cluster_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_cluster_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableStmtBuilder& set_cluster_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateTableStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateTableStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateTableStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateTableStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateTableStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateTableStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateTableStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateTableStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedColumnDefinition>>& column_definition_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list();
  }

  int column_definition_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list_size();
  }

  const ResolvedColumnDefinition* column_definition_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateTableStmtBuilder&& add_column_definition_list(T v) && {
    node_->add_column_definition_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateTableStmtBuilder& add_column_definition_list(T v) & {
    node_->add_column_definition_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateTableStmtBuilder&& add_column_definition_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateTableStmtBuilder& add_column_definition_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> release_column_definition_list() {
    return node_->release_column_definition_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_column_definition_list(T v) && {
    node_->set_column_definition_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateTableStmtBuilder& set_column_definition_list(T v) & {
    node_->set_column_definition_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_column_definition_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateTableStmtBuilder& set_column_definition_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& pseudo_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pseudo_column_list();
  }

  int pseudo_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pseudo_column_list_size();
  }

  const ResolvedColumn& pseudo_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pseudo_column_list(i);
  }

  ResolvedCreateTableStmtBuilder&& add_pseudo_column_list(ResolvedColumn v) && {
    node_->add_pseudo_column_list(v);

    return std::move(*this);
  }

  ResolvedCreateTableStmtBuilder& add_pseudo_column_list(ResolvedColumn v) & {
    node_->add_pseudo_column_list(v);

    return *this;
  }

  ResolvedCreateTableStmtBuilder&& set_pseudo_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_pseudo_column_list(v);

    return std::move(*this);
  }

  ResolvedCreateTableStmtBuilder& set_pseudo_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_pseudo_column_list(v);

    return *this;
  }

  const ResolvedPrimaryKey* primary_key() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->primary_key();
  }

  std::unique_ptr<const ResolvedPrimaryKey> release_primary_key() {
    return node_->release_primary_key();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedCreateTableStmtBuilder&& set_primary_key(T v) && {
    node_->set_primary_key(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedCreateTableStmtBuilder& set_primary_key(T v) & {
    node_->set_primary_key(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedCreateTableStmtBuilder&& set_primary_key(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_primary_key(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedCreateTableStmtBuilder& set_primary_key(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_primary_key(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedForeignKey>>& foreign_key_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->foreign_key_list();
  }

  int foreign_key_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->foreign_key_list_size();
  }

  const ResolvedForeignKey* foreign_key_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->foreign_key_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedCreateTableStmtBuilder&& add_foreign_key_list(T v) && {
    node_->add_foreign_key_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedCreateTableStmtBuilder& add_foreign_key_list(T v) & {
    node_->add_foreign_key_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedCreateTableStmtBuilder&& add_foreign_key_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedCreateTableStmtBuilder& add_foreign_key_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedForeignKey>> release_foreign_key_list() {
    return node_->release_foreign_key_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_foreign_key_list(T v) && {
    node_->set_foreign_key_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedCreateTableStmtBuilder& set_foreign_key_list(T v) & {
    node_->set_foreign_key_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_foreign_key_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedCreateTableStmtBuilder& set_foreign_key_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedCheckConstraint>>& check_constraint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->check_constraint_list();
  }

  int check_constraint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->check_constraint_list_size();
  }

  const ResolvedCheckConstraint* check_constraint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->check_constraint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedCreateTableStmtBuilder&& add_check_constraint_list(T v) && {
    node_->add_check_constraint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedCreateTableStmtBuilder& add_check_constraint_list(T v) & {
    node_->add_check_constraint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedCreateTableStmtBuilder&& add_check_constraint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedCreateTableStmtBuilder& add_check_constraint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedCheckConstraint>> release_check_constraint_list() {
    return node_->release_check_constraint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_check_constraint_list(T v) && {
    node_->set_check_constraint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedCreateTableStmtBuilder& set_check_constraint_list(T v) & {
    node_->set_check_constraint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedCreateTableStmtBuilder&& set_check_constraint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedCreateTableStmtBuilder& set_check_constraint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_value_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_value_table();
  }

  ResolvedCreateTableStmtBuilder&& set_is_value_table(bool v) && {
    node_->set_is_value_table(v);

    return std::move(*this);
  }

  ResolvedCreateTableStmtBuilder& set_is_value_table(bool v) & {
    node_->set_is_value_table(v);

    return *this;
  }

  const Table* like_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->like_table();
  }

  ResolvedCreateTableStmtBuilder&& set_like_table(const Table* v) && {
    node_->set_like_table(v);

    return std::move(*this);
  }

  ResolvedCreateTableStmtBuilder& set_like_table(const Table* v) & {
    node_->set_like_table(v);

    return *this;
  }

  const ResolvedExpr* collation_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_name();
  }

  std::unique_ptr<const ResolvedExpr> release_collation_name() {
    return node_->release_collation_name();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableStmtBuilder&& set_collation_name(T v) && {
    node_->set_collation_name(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableStmtBuilder& set_collation_name(T v) & {
    node_->set_collation_name(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableStmtBuilder&& set_collation_name(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableStmtBuilder& set_collation_name(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateTableStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedCreateTableStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateTableStmt> node);

  ResolvedCreateTableStmtBuilder(std::unique_ptr<ResolvedCreateTableStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateTableStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateTableStmt> node) {
  ResolvedCreateTableStmtBuilder builder(absl::WrapUnique<ResolvedCreateTableStmt>(
      const_cast<ResolvedCreateTableStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedCreateTableAsSelectStmtBuilder final {
 public:
  ResolvedCreateTableAsSelectStmtBuilder() : ResolvedCreateTableAsSelectStmtBuilder(absl::WrapUnique(new ResolvedCreateTableAsSelectStmt)) {}

  ResolvedCreateTableAsSelectStmtBuilder(const ResolvedCreateTableAsSelectStmtBuilder&) = delete;
  ResolvedCreateTableAsSelectStmtBuilder& operator=(const ResolvedCreateTableAsSelectStmtBuilder&) = delete;
  ResolvedCreateTableAsSelectStmtBuilder(ResolvedCreateTableAsSelectStmtBuilder&& other)
      : ResolvedCreateTableAsSelectStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCreateTableAsSelectStmtBuilder& operator=(ResolvedCreateTableAsSelectStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateTableAsSelectStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(16)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateTableAsSelectStmt::query was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedExpr>>& partition_by_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list();
  }

  int partition_by_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list_size();
  }

  const ResolvedExpr* partition_by_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_partition_by_list(T v) && {
    node_->add_partition_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_partition_by_list(T v) & {
    node_->add_partition_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_partition_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_partition_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_partition_by_list() {
    return node_->release_partition_by_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_partition_by_list(T v) && {
    node_->set_partition_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_partition_by_list(T v) & {
    node_->set_partition_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_partition_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_partition_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& cluster_by_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->cluster_by_list();
  }

  int cluster_by_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->cluster_by_list_size();
  }

  const ResolvedExpr* cluster_by_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->cluster_by_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_cluster_by_list(T v) && {
    node_->add_cluster_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_cluster_by_list(T v) & {
    node_->add_cluster_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_cluster_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_cluster_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_cluster_by_list() {
    return node_->release_cluster_by_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_cluster_by_list(T v) && {
    node_->set_cluster_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_cluster_by_list(T v) & {
    node_->set_cluster_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_cluster_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_cluster_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOutputColumn>>& output_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list();
  }

  int output_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list_size();
  }

  const ResolvedOutputColumn* output_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_output_column_list(T v) && {
    node_->add_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_output_column_list(T v) & {
    node_->add_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOutputColumn>> release_output_column_list() {
    return node_->release_output_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_output_column_list(T v) && {
    node_->set_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_output_column_list(T v) & {
    node_->set_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedScan* query() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query();
  }

  std::unique_ptr<const ResolvedScan> release_query() {
    return node_->release_query();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_query(T v) && {
    node_->set_query(std::move(v));
    field_is_set_.set(16, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_query(T v) & {
    node_->set_query(std::move(v));
    field_is_set_.set(16, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_query(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(16, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_query(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(16, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateTableAsSelectStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateTableAsSelectStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateTableAsSelectStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateTableAsSelectStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateTableAsSelectStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateTableAsSelectStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateTableAsSelectStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateTableAsSelectStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedColumnDefinition>>& column_definition_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list();
  }

  int column_definition_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list_size();
  }

  const ResolvedColumnDefinition* column_definition_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_column_definition_list(T v) && {
    node_->add_column_definition_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_column_definition_list(T v) & {
    node_->add_column_definition_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_column_definition_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_column_definition_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> release_column_definition_list() {
    return node_->release_column_definition_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_column_definition_list(T v) && {
    node_->set_column_definition_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_column_definition_list(T v) & {
    node_->set_column_definition_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_column_definition_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_column_definition_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& pseudo_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pseudo_column_list();
  }

  int pseudo_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pseudo_column_list_size();
  }

  const ResolvedColumn& pseudo_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pseudo_column_list(i);
  }

  ResolvedCreateTableAsSelectStmtBuilder&& add_pseudo_column_list(ResolvedColumn v) && {
    node_->add_pseudo_column_list(v);

    return std::move(*this);
  }

  ResolvedCreateTableAsSelectStmtBuilder& add_pseudo_column_list(ResolvedColumn v) & {
    node_->add_pseudo_column_list(v);

    return *this;
  }

  ResolvedCreateTableAsSelectStmtBuilder&& set_pseudo_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_pseudo_column_list(v);

    return std::move(*this);
  }

  ResolvedCreateTableAsSelectStmtBuilder& set_pseudo_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_pseudo_column_list(v);

    return *this;
  }

  const ResolvedPrimaryKey* primary_key() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->primary_key();
  }

  std::unique_ptr<const ResolvedPrimaryKey> release_primary_key() {
    return node_->release_primary_key();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_primary_key(T v) && {
    node_->set_primary_key(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_primary_key(T v) & {
    node_->set_primary_key(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_primary_key(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_primary_key(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_primary_key(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_primary_key(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedForeignKey>>& foreign_key_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->foreign_key_list();
  }

  int foreign_key_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->foreign_key_list_size();
  }

  const ResolvedForeignKey* foreign_key_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->foreign_key_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_foreign_key_list(T v) && {
    node_->add_foreign_key_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_foreign_key_list(T v) & {
    node_->add_foreign_key_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_foreign_key_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_foreign_key_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedForeignKey>> release_foreign_key_list() {
    return node_->release_foreign_key_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_foreign_key_list(T v) && {
    node_->set_foreign_key_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_foreign_key_list(T v) & {
    node_->set_foreign_key_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_foreign_key_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_foreign_key_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedCheckConstraint>>& check_constraint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->check_constraint_list();
  }

  int check_constraint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->check_constraint_list_size();
  }

  const ResolvedCheckConstraint* check_constraint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->check_constraint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_check_constraint_list(T v) && {
    node_->add_check_constraint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_check_constraint_list(T v) & {
    node_->add_check_constraint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& add_check_constraint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& add_check_constraint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedCheckConstraint>> release_check_constraint_list() {
    return node_->release_check_constraint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_check_constraint_list(T v) && {
    node_->set_check_constraint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_check_constraint_list(T v) & {
    node_->set_check_constraint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_check_constraint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_check_constraint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_value_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_value_table();
  }

  ResolvedCreateTableAsSelectStmtBuilder&& set_is_value_table(bool v) && {
    node_->set_is_value_table(v);

    return std::move(*this);
  }

  ResolvedCreateTableAsSelectStmtBuilder& set_is_value_table(bool v) & {
    node_->set_is_value_table(v);

    return *this;
  }

  const Table* like_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->like_table();
  }

  ResolvedCreateTableAsSelectStmtBuilder&& set_like_table(const Table* v) && {
    node_->set_like_table(v);

    return std::move(*this);
  }

  ResolvedCreateTableAsSelectStmtBuilder& set_like_table(const Table* v) & {
    node_->set_like_table(v);

    return *this;
  }

  const ResolvedExpr* collation_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_name();
  }

  std::unique_ptr<const ResolvedExpr> release_collation_name() {
    return node_->release_collation_name();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_collation_name(T v) && {
    node_->set_collation_name(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_collation_name(T v) & {
    node_->set_collation_name(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder&& set_collation_name(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateTableAsSelectStmtBuilder& set_collation_name(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateTableAsSelectStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<17> field_is_set_ = {0};
  friend ResolvedCreateTableAsSelectStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateTableAsSelectStmt> node);

  ResolvedCreateTableAsSelectStmtBuilder(std::unique_ptr<ResolvedCreateTableAsSelectStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateTableAsSelectStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateTableAsSelectStmt> node) {
  ResolvedCreateTableAsSelectStmtBuilder builder(absl::WrapUnique<ResolvedCreateTableAsSelectStmt>(
      const_cast<ResolvedCreateTableAsSelectStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(16, true);
  return builder;
}

class ResolvedCreateModelStmtBuilder final {
 public:
  ResolvedCreateModelStmtBuilder() : ResolvedCreateModelStmtBuilder(absl::WrapUnique(new ResolvedCreateModelStmt)) {}

  ResolvedCreateModelStmtBuilder(const ResolvedCreateModelStmtBuilder&) = delete;
  ResolvedCreateModelStmtBuilder& operator=(const ResolvedCreateModelStmtBuilder&) = delete;
  ResolvedCreateModelStmtBuilder(ResolvedCreateModelStmtBuilder&& other)
      : ResolvedCreateModelStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCreateModelStmtBuilder& operator=(ResolvedCreateModelStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateModelStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(6)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateModelStmt::query was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateModelStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateModelStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateModelStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateModelStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateModelStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateModelStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOutputColumn>>& output_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list();
  }

  int output_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list_size();
  }

  const ResolvedOutputColumn* output_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateModelStmtBuilder&& add_output_column_list(T v) && {
    node_->add_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateModelStmtBuilder& add_output_column_list(T v) & {
    node_->add_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateModelStmtBuilder&& add_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateModelStmtBuilder& add_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOutputColumn>> release_output_column_list() {
    return node_->release_output_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_output_column_list(T v) && {
    node_->set_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateModelStmtBuilder& set_output_column_list(T v) & {
    node_->set_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateModelStmtBuilder& set_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedScan* query() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query();
  }

  std::unique_ptr<const ResolvedScan> release_query() {
    return node_->release_query();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateModelStmtBuilder&& set_query(T v) && {
    node_->set_query(std::move(v));
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateModelStmtBuilder& set_query(T v) & {
    node_->set_query(std::move(v));
    field_is_set_.set(6, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateModelStmtBuilder&& set_query(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateModelStmtBuilder& set_query(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(6, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedColumnDefinition>>& transform_input_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->transform_input_column_list();
  }

  int transform_input_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->transform_input_column_list_size();
  }

  const ResolvedColumnDefinition* transform_input_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->transform_input_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateModelStmtBuilder&& add_transform_input_column_list(T v) && {
    node_->add_transform_input_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateModelStmtBuilder& add_transform_input_column_list(T v) & {
    node_->add_transform_input_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateModelStmtBuilder&& add_transform_input_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_transform_input_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateModelStmtBuilder& add_transform_input_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_transform_input_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> release_transform_input_column_list() {
    return node_->release_transform_input_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_transform_input_column_list(T v) && {
    node_->set_transform_input_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateModelStmtBuilder& set_transform_input_column_list(T v) & {
    node_->set_transform_input_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_transform_input_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_transform_input_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateModelStmtBuilder& set_transform_input_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_transform_input_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& transform_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->transform_list();
  }

  int transform_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->transform_list_size();
  }

  const ResolvedComputedColumn* transform_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->transform_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedCreateModelStmtBuilder&& add_transform_list(T v) && {
    node_->add_transform_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedCreateModelStmtBuilder& add_transform_list(T v) & {
    node_->add_transform_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedCreateModelStmtBuilder&& add_transform_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_transform_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedCreateModelStmtBuilder& add_transform_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_transform_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_transform_list() {
    return node_->release_transform_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_transform_list(T v) && {
    node_->set_transform_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedCreateModelStmtBuilder& set_transform_list(T v) & {
    node_->set_transform_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_transform_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_transform_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedCreateModelStmtBuilder& set_transform_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_transform_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOutputColumn>>& transform_output_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->transform_output_column_list();
  }

  int transform_output_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->transform_output_column_list_size();
  }

  const ResolvedOutputColumn* transform_output_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->transform_output_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateModelStmtBuilder&& add_transform_output_column_list(T v) && {
    node_->add_transform_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateModelStmtBuilder& add_transform_output_column_list(T v) & {
    node_->add_transform_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateModelStmtBuilder&& add_transform_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_transform_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateModelStmtBuilder& add_transform_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_transform_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOutputColumn>> release_transform_output_column_list() {
    return node_->release_transform_output_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_transform_output_column_list(T v) && {
    node_->set_transform_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateModelStmtBuilder& set_transform_output_column_list(T v) & {
    node_->set_transform_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_transform_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_transform_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateModelStmtBuilder& set_transform_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_transform_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>>& transform_analytic_function_group_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->transform_analytic_function_group_list();
  }

  int transform_analytic_function_group_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->transform_analytic_function_group_list_size();
  }

  const ResolvedAnalyticFunctionGroup* transform_analytic_function_group_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->transform_analytic_function_group_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAnalyticFunctionGroup>>::value>>
  ResolvedCreateModelStmtBuilder&& add_transform_analytic_function_group_list(T v) && {
    node_->add_transform_analytic_function_group_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAnalyticFunctionGroup>>::value>>
  ResolvedCreateModelStmtBuilder& add_transform_analytic_function_group_list(T v) & {
    node_->add_transform_analytic_function_group_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAnalyticFunctionGroup>>::value>>
  ResolvedCreateModelStmtBuilder&& add_transform_analytic_function_group_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_transform_analytic_function_group_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAnalyticFunctionGroup>>::value>>
  ResolvedCreateModelStmtBuilder& add_transform_analytic_function_group_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_transform_analytic_function_group_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>> release_transform_analytic_function_group_list() {
    return node_->release_transform_analytic_function_group_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_transform_analytic_function_group_list(T v) && {
    node_->set_transform_analytic_function_group_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>>>::value>>
  ResolvedCreateModelStmtBuilder& set_transform_analytic_function_group_list(T v) & {
    node_->set_transform_analytic_function_group_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_transform_analytic_function_group_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_transform_analytic_function_group_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAnalyticFunctionGroup>>>::value>>
  ResolvedCreateModelStmtBuilder& set_transform_analytic_function_group_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_transform_analytic_function_group_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateModelStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateModelStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateModelStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateModelStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateModelStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateModelStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateModelStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateModelStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateModelStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateModelStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateModelStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateModelStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateModelStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateModelStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateModelStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateModelStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<11> field_is_set_ = {0};
  friend ResolvedCreateModelStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateModelStmt> node);

  ResolvedCreateModelStmtBuilder(std::unique_ptr<ResolvedCreateModelStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateModelStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateModelStmt> node) {
  ResolvedCreateModelStmtBuilder builder(absl::WrapUnique<ResolvedCreateModelStmt>(
      const_cast<ResolvedCreateModelStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(6, true);
  return builder;
}

class ResolvedCreateViewStmtBuilder final {
 public:
  ResolvedCreateViewStmtBuilder() : ResolvedCreateViewStmtBuilder(absl::WrapUnique(new ResolvedCreateViewStmt)) {}

  ResolvedCreateViewStmtBuilder(const ResolvedCreateViewStmtBuilder&) = delete;
  ResolvedCreateViewStmtBuilder& operator=(const ResolvedCreateViewStmtBuilder&) = delete;
  ResolvedCreateViewStmtBuilder(ResolvedCreateViewStmtBuilder&& other)
      : ResolvedCreateViewStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCreateViewStmtBuilder& operator=(ResolvedCreateViewStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateViewStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(7)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateViewStmt::query was not set on the builder");
    }
    if (!field_is_set_.test(8)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateViewStmt::sql was not set on the builder");
    }
    if (!field_is_set_.test(11)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateViewStmt::recursive was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateViewStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateViewStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateViewStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateViewStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateViewStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateViewStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateViewStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateViewStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateViewStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateViewStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateViewStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateViewStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateViewStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateViewStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateViewStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateViewStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateViewStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateViewStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateViewStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateViewStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateViewStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateViewStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateViewStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateViewStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOutputColumn>>& output_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list();
  }

  int output_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list_size();
  }

  const ResolvedOutputColumn* output_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateViewStmtBuilder&& add_output_column_list(T v) && {
    node_->add_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateViewStmtBuilder& add_output_column_list(T v) & {
    node_->add_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateViewStmtBuilder&& add_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateViewStmtBuilder& add_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOutputColumn>> release_output_column_list() {
    return node_->release_output_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateViewStmtBuilder&& set_output_column_list(T v) && {
    node_->set_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateViewStmtBuilder& set_output_column_list(T v) & {
    node_->set_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateViewStmtBuilder&& set_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateViewStmtBuilder& set_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool has_explicit_columns() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->has_explicit_columns();
  }

  ResolvedCreateViewStmtBuilder&& set_has_explicit_columns(bool v) && {
    node_->set_has_explicit_columns(v);

    return std::move(*this);
  }

  ResolvedCreateViewStmtBuilder& set_has_explicit_columns(bool v) & {
    node_->set_has_explicit_columns(v);

    return *this;
  }

  const ResolvedScan* query() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query();
  }

  std::unique_ptr<const ResolvedScan> release_query() {
    return node_->release_query();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateViewStmtBuilder&& set_query(T v) && {
    node_->set_query(std::move(v));
    field_is_set_.set(7, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateViewStmtBuilder& set_query(T v) & {
    node_->set_query(std::move(v));
    field_is_set_.set(7, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateViewStmtBuilder&& set_query(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(7, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateViewStmtBuilder& set_query(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(7, true);

    return *this;
  }

  const std::string& sql() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->sql();
  }

  ResolvedCreateViewStmtBuilder&& set_sql(const std::string& v) && {
    node_->set_sql(v);
    field_is_set_.set(8, true);

    return std::move(*this);
  }

  ResolvedCreateViewStmtBuilder& set_sql(const std::string& v) & {
    node_->set_sql(v);
    field_is_set_.set(8, true);

    return *this;
  }

  ResolvedCreateStatement::SqlSecurity sql_security() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->sql_security();
  }

  ResolvedCreateViewStmtBuilder&& set_sql_security(ResolvedCreateStatement::SqlSecurity v) && {
    node_->set_sql_security(v);

    return std::move(*this);
  }

  ResolvedCreateViewStmtBuilder& set_sql_security(ResolvedCreateStatement::SqlSecurity v) & {
    node_->set_sql_security(v);

    return *this;
  }

  // If true, this view produces a value table. Rather than producing
  // rows with named columns, it produces rows with a single unnamed
  // value type.  output_column_list will have exactly one column, with
  // an empty name. See (broken link).
  bool is_value_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_value_table();
  }

  ResolvedCreateViewStmtBuilder&& set_is_value_table(bool v) && {
    node_->set_is_value_table(v);

    return std::move(*this);
  }

  ResolvedCreateViewStmtBuilder& set_is_value_table(bool v) & {
    node_->set_is_value_table(v);

    return *this;
  }

  // True if the view uses the RECURSIVE keyword. <query>
  // can be a ResolvedRecursiveScan only if this is true.
  bool recursive() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->recursive();
  }

  ResolvedCreateViewStmtBuilder&& set_recursive(bool v) && {
    node_->set_recursive(v);
    field_is_set_.set(11, true);

    return std::move(*this);
  }

  ResolvedCreateViewStmtBuilder& set_recursive(bool v) & {
    node_->set_recursive(v);
    field_is_set_.set(11, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateViewStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<12> field_is_set_ = {0};
  friend ResolvedCreateViewStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateViewStmt> node);

  ResolvedCreateViewStmtBuilder(std::unique_ptr<ResolvedCreateViewStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateViewStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateViewStmt> node) {
  ResolvedCreateViewStmtBuilder builder(absl::WrapUnique<ResolvedCreateViewStmt>(
      const_cast<ResolvedCreateViewStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(7, true);
  builder.field_is_set_.set(8, true);
  builder.field_is_set_.set(11, true);
  return builder;
}

class ResolvedWithPartitionColumnsBuilder final {
 public:
  ResolvedWithPartitionColumnsBuilder() : ResolvedWithPartitionColumnsBuilder(absl::WrapUnique(new ResolvedWithPartitionColumns)) {}

  ResolvedWithPartitionColumnsBuilder(const ResolvedWithPartitionColumnsBuilder&) = delete;
  ResolvedWithPartitionColumnsBuilder& operator=(const ResolvedWithPartitionColumnsBuilder&) = delete;
  ResolvedWithPartitionColumnsBuilder(ResolvedWithPartitionColumnsBuilder&& other)
      : ResolvedWithPartitionColumnsBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedWithPartitionColumnsBuilder& operator=(ResolvedWithPartitionColumnsBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedWithPartitionColumns>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedColumnDefinition>>& column_definition_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list();
  }

  int column_definition_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list_size();
  }

  const ResolvedColumnDefinition* column_definition_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedWithPartitionColumnsBuilder&& add_column_definition_list(T v) && {
    node_->add_column_definition_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedWithPartitionColumnsBuilder& add_column_definition_list(T v) & {
    node_->add_column_definition_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedWithPartitionColumnsBuilder&& add_column_definition_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedWithPartitionColumnsBuilder& add_column_definition_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> release_column_definition_list() {
    return node_->release_column_definition_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedWithPartitionColumnsBuilder&& set_column_definition_list(T v) && {
    node_->set_column_definition_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedWithPartitionColumnsBuilder& set_column_definition_list(T v) & {
    node_->set_column_definition_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedWithPartitionColumnsBuilder&& set_column_definition_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedWithPartitionColumnsBuilder& set_column_definition_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedWithPartitionColumns> node_;

  absl::Status deferred_build_status_;
  friend ResolvedWithPartitionColumnsBuilder ToBuilder(
      std::unique_ptr<const ResolvedWithPartitionColumns> node);

  ResolvedWithPartitionColumnsBuilder(std::unique_ptr<ResolvedWithPartitionColumns> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedWithPartitionColumnsBuilder ToBuilder(
    std::unique_ptr<const ResolvedWithPartitionColumns> node) {
  ResolvedWithPartitionColumnsBuilder builder(absl::WrapUnique<ResolvedWithPartitionColumns>(
      const_cast<ResolvedWithPartitionColumns*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedCreateSnapshotTableStmtBuilder final {
 public:
  ResolvedCreateSnapshotTableStmtBuilder() : ResolvedCreateSnapshotTableStmtBuilder(absl::WrapUnique(new ResolvedCreateSnapshotTableStmt)) {}

  ResolvedCreateSnapshotTableStmtBuilder(const ResolvedCreateSnapshotTableStmtBuilder&) = delete;
  ResolvedCreateSnapshotTableStmtBuilder& operator=(const ResolvedCreateSnapshotTableStmtBuilder&) = delete;
  ResolvedCreateSnapshotTableStmtBuilder(ResolvedCreateSnapshotTableStmtBuilder&& other)
      : ResolvedCreateSnapshotTableStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCreateSnapshotTableStmtBuilder& operator=(ResolvedCreateSnapshotTableStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateSnapshotTableStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateSnapshotTableStmt::clone_from was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedScan* clone_from() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->clone_from();
  }

  std::unique_ptr<const ResolvedScan> release_clone_from() {
    return node_->release_clone_from();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder&& set_clone_from(T v) && {
    node_->set_clone_from(std::move(v));
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder& set_clone_from(T v) & {
    node_->set_clone_from(std::move(v));
    field_is_set_.set(4, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder&& set_clone_from(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_clone_from(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder& set_clone_from(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_clone_from(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateSnapshotTableStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateSnapshotTableStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateSnapshotTableStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateSnapshotTableStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateSnapshotTableStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateSnapshotTableStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateSnapshotTableStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateSnapshotTableStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateSnapshotTableStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateSnapshotTableStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<6> field_is_set_ = {0};
  friend ResolvedCreateSnapshotTableStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateSnapshotTableStmt> node);

  ResolvedCreateSnapshotTableStmtBuilder(std::unique_ptr<ResolvedCreateSnapshotTableStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateSnapshotTableStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateSnapshotTableStmt> node) {
  ResolvedCreateSnapshotTableStmtBuilder builder(absl::WrapUnique<ResolvedCreateSnapshotTableStmt>(
      const_cast<ResolvedCreateSnapshotTableStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedCreateExternalTableStmtBuilder final {
 public:
  ResolvedCreateExternalTableStmtBuilder() : ResolvedCreateExternalTableStmtBuilder(absl::WrapUnique(new ResolvedCreateExternalTableStmt)) {}

  ResolvedCreateExternalTableStmtBuilder(const ResolvedCreateExternalTableStmtBuilder&) = delete;
  ResolvedCreateExternalTableStmtBuilder& operator=(const ResolvedCreateExternalTableStmtBuilder&) = delete;
  ResolvedCreateExternalTableStmtBuilder(ResolvedCreateExternalTableStmtBuilder&& other)
      : ResolvedCreateExternalTableStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedCreateExternalTableStmtBuilder& operator=(ResolvedCreateExternalTableStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateExternalTableStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedWithPartitionColumns* with_partition_columns() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_partition_columns();
  }

  std::unique_ptr<const ResolvedWithPartitionColumns> release_with_partition_columns() {
    return node_->release_with_partition_columns();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWithPartitionColumns>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_with_partition_columns(T v) && {
    node_->set_with_partition_columns(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWithPartitionColumns>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_with_partition_columns(T v) & {
    node_->set_with_partition_columns(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWithPartitionColumns>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_with_partition_columns(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_partition_columns(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWithPartitionColumns>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_with_partition_columns(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_partition_columns(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedConnection* connection() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->connection();
  }

  std::unique_ptr<const ResolvedConnection> release_connection() {
    return node_->release_connection();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_connection(T v) && {
    node_->set_connection(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_connection(T v) & {
    node_->set_connection(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_connection(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_connection(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateExternalTableStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateExternalTableStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateExternalTableStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateExternalTableStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateExternalTableStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateExternalTableStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateExternalTableStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateExternalTableStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateExternalTableStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateExternalTableStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateExternalTableStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateExternalTableStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedColumnDefinition>>& column_definition_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list();
  }

  int column_definition_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list_size();
  }

  const ResolvedColumnDefinition* column_definition_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& add_column_definition_list(T v) && {
    node_->add_column_definition_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateExternalTableStmtBuilder& add_column_definition_list(T v) & {
    node_->add_column_definition_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& add_column_definition_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateExternalTableStmtBuilder& add_column_definition_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> release_column_definition_list() {
    return node_->release_column_definition_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_column_definition_list(T v) && {
    node_->set_column_definition_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_column_definition_list(T v) & {
    node_->set_column_definition_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_column_definition_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_column_definition_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& pseudo_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pseudo_column_list();
  }

  int pseudo_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pseudo_column_list_size();
  }

  const ResolvedColumn& pseudo_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pseudo_column_list(i);
  }

  ResolvedCreateExternalTableStmtBuilder&& add_pseudo_column_list(ResolvedColumn v) && {
    node_->add_pseudo_column_list(v);

    return std::move(*this);
  }

  ResolvedCreateExternalTableStmtBuilder& add_pseudo_column_list(ResolvedColumn v) & {
    node_->add_pseudo_column_list(v);

    return *this;
  }

  ResolvedCreateExternalTableStmtBuilder&& set_pseudo_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_pseudo_column_list(v);

    return std::move(*this);
  }

  ResolvedCreateExternalTableStmtBuilder& set_pseudo_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_pseudo_column_list(v);

    return *this;
  }

  const ResolvedPrimaryKey* primary_key() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->primary_key();
  }

  std::unique_ptr<const ResolvedPrimaryKey> release_primary_key() {
    return node_->release_primary_key();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_primary_key(T v) && {
    node_->set_primary_key(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_primary_key(T v) & {
    node_->set_primary_key(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_primary_key(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_primary_key(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_primary_key(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_primary_key(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedForeignKey>>& foreign_key_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->foreign_key_list();
  }

  int foreign_key_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->foreign_key_list_size();
  }

  const ResolvedForeignKey* foreign_key_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->foreign_key_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& add_foreign_key_list(T v) && {
    node_->add_foreign_key_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedCreateExternalTableStmtBuilder& add_foreign_key_list(T v) & {
    node_->add_foreign_key_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& add_foreign_key_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedCreateExternalTableStmtBuilder& add_foreign_key_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedForeignKey>> release_foreign_key_list() {
    return node_->release_foreign_key_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_foreign_key_list(T v) && {
    node_->set_foreign_key_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_foreign_key_list(T v) & {
    node_->set_foreign_key_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_foreign_key_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_foreign_key_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedCheckConstraint>>& check_constraint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->check_constraint_list();
  }

  int check_constraint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->check_constraint_list_size();
  }

  const ResolvedCheckConstraint* check_constraint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->check_constraint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& add_check_constraint_list(T v) && {
    node_->add_check_constraint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedCreateExternalTableStmtBuilder& add_check_constraint_list(T v) & {
    node_->add_check_constraint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& add_check_constraint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedCreateExternalTableStmtBuilder& add_check_constraint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedCheckConstraint>> release_check_constraint_list() {
    return node_->release_check_constraint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_check_constraint_list(T v) && {
    node_->set_check_constraint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_check_constraint_list(T v) & {
    node_->set_check_constraint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_check_constraint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_check_constraint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_value_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_value_table();
  }

  ResolvedCreateExternalTableStmtBuilder&& set_is_value_table(bool v) && {
    node_->set_is_value_table(v);

    return std::move(*this);
  }

  ResolvedCreateExternalTableStmtBuilder& set_is_value_table(bool v) & {
    node_->set_is_value_table(v);

    return *this;
  }

  const Table* like_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->like_table();
  }

  ResolvedCreateExternalTableStmtBuilder&& set_like_table(const Table* v) && {
    node_->set_like_table(v);

    return std::move(*this);
  }

  ResolvedCreateExternalTableStmtBuilder& set_like_table(const Table* v) & {
    node_->set_like_table(v);

    return *this;
  }

  const ResolvedExpr* collation_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_name();
  }

  std::unique_ptr<const ResolvedExpr> release_collation_name() {
    return node_->release_collation_name();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_collation_name(T v) && {
    node_->set_collation_name(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_collation_name(T v) & {
    node_->set_collation_name(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateExternalTableStmtBuilder&& set_collation_name(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateExternalTableStmtBuilder& set_collation_name(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateExternalTableStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedCreateExternalTableStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateExternalTableStmt> node);

  ResolvedCreateExternalTableStmtBuilder(std::unique_ptr<ResolvedCreateExternalTableStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateExternalTableStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateExternalTableStmt> node) {
  ResolvedCreateExternalTableStmtBuilder builder(absl::WrapUnique<ResolvedCreateExternalTableStmt>(
      const_cast<ResolvedCreateExternalTableStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedExportModelStmtBuilder final {
 public:
  ResolvedExportModelStmtBuilder() : ResolvedExportModelStmtBuilder(absl::WrapUnique(new ResolvedExportModelStmt)) {}

  ResolvedExportModelStmtBuilder(const ResolvedExportModelStmtBuilder&) = delete;
  ResolvedExportModelStmtBuilder& operator=(const ResolvedExportModelStmtBuilder&) = delete;
  ResolvedExportModelStmtBuilder(ResolvedExportModelStmtBuilder&& other)
      : ResolvedExportModelStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedExportModelStmtBuilder& operator=(ResolvedExportModelStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedExportModelStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::string>& model_name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->model_name_path();
  }

  int model_name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->model_name_path_size();
  }

  const std::string& model_name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->model_name_path(i);
  }

  ResolvedExportModelStmtBuilder&& add_model_name_path(std::string v) && {
    node_->add_model_name_path(v);

    return std::move(*this);
  }

  ResolvedExportModelStmtBuilder& add_model_name_path(std::string v) & {
    node_->add_model_name_path(v);

    return *this;
  }

  ResolvedExportModelStmtBuilder&& set_model_name_path(const std::vector<std::string>& v) && {
    node_->set_model_name_path(v);

    return std::move(*this);
  }

  ResolvedExportModelStmtBuilder& set_model_name_path(const std::vector<std::string>& v) & {
    node_->set_model_name_path(v);

    return *this;
  }

  const ResolvedConnection* connection() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->connection();
  }

  std::unique_ptr<const ResolvedConnection> release_connection() {
    return node_->release_connection();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedExportModelStmtBuilder&& set_connection(T v) && {
    node_->set_connection(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedExportModelStmtBuilder& set_connection(T v) & {
    node_->set_connection(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedExportModelStmtBuilder&& set_connection(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedExportModelStmtBuilder& set_connection(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportModelStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportModelStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportModelStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportModelStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportModelStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportModelStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportModelStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportModelStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportModelStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportModelStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportModelStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportModelStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportModelStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportModelStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportModelStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportModelStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedExportModelStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedExportModelStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedExportModelStmt> node);

  ResolvedExportModelStmtBuilder(std::unique_ptr<ResolvedExportModelStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedExportModelStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedExportModelStmt> node) {
  ResolvedExportModelStmtBuilder builder(absl::WrapUnique<ResolvedExportModelStmt>(
      const_cast<ResolvedExportModelStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedExportDataStmtBuilder final {
 public:
  ResolvedExportDataStmtBuilder() : ResolvedExportDataStmtBuilder(absl::WrapUnique(new ResolvedExportDataStmt)) {}

  ResolvedExportDataStmtBuilder(const ResolvedExportDataStmtBuilder&) = delete;
  ResolvedExportDataStmtBuilder& operator=(const ResolvedExportDataStmtBuilder&) = delete;
  ResolvedExportDataStmtBuilder(ResolvedExportDataStmtBuilder&& other)
      : ResolvedExportDataStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedExportDataStmtBuilder& operator=(ResolvedExportDataStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedExportDataStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedExportDataStmt::query was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedConnection* connection() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->connection();
  }

  std::unique_ptr<const ResolvedConnection> release_connection() {
    return node_->release_connection();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedExportDataStmtBuilder&& set_connection(T v) && {
    node_->set_connection(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedExportDataStmtBuilder& set_connection(T v) & {
    node_->set_connection(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedExportDataStmtBuilder&& set_connection(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedExportDataStmtBuilder& set_connection(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportDataStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportDataStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportDataStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportDataStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportDataStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportDataStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportDataStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportDataStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOutputColumn>>& output_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list();
  }

  int output_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list_size();
  }

  const ResolvedOutputColumn* output_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedExportDataStmtBuilder&& add_output_column_list(T v) && {
    node_->add_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedExportDataStmtBuilder& add_output_column_list(T v) & {
    node_->add_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedExportDataStmtBuilder&& add_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedExportDataStmtBuilder& add_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOutputColumn>> release_output_column_list() {
    return node_->release_output_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedExportDataStmtBuilder&& set_output_column_list(T v) && {
    node_->set_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedExportDataStmtBuilder& set_output_column_list(T v) & {
    node_->set_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedExportDataStmtBuilder&& set_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedExportDataStmtBuilder& set_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // If true, the result of this query is a value table. Rather than
  // producing rows with named columns, it produces rows with a single
  // unnamed value type.  output_column_list will have exactly one
  // column, with an empty name. See (broken link).
  bool is_value_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_value_table();
  }

  ResolvedExportDataStmtBuilder&& set_is_value_table(bool v) && {
    node_->set_is_value_table(v);

    return std::move(*this);
  }

  ResolvedExportDataStmtBuilder& set_is_value_table(bool v) & {
    node_->set_is_value_table(v);

    return *this;
  }

  const ResolvedScan* query() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query();
  }

  std::unique_ptr<const ResolvedScan> release_query() {
    return node_->release_query();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedExportDataStmtBuilder&& set_query(T v) && {
    node_->set_query(std::move(v));
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedExportDataStmtBuilder& set_query(T v) & {
    node_->set_query(std::move(v));
    field_is_set_.set(5, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedExportDataStmtBuilder&& set_query(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedExportDataStmtBuilder& set_query(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportDataStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportDataStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportDataStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExportDataStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportDataStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportDataStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportDataStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExportDataStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedExportDataStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<6> field_is_set_ = {0};
  friend ResolvedExportDataStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedExportDataStmt> node);

  ResolvedExportDataStmtBuilder(std::unique_ptr<ResolvedExportDataStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedExportDataStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedExportDataStmt> node) {
  ResolvedExportDataStmtBuilder builder(absl::WrapUnique<ResolvedExportDataStmt>(
      const_cast<ResolvedExportDataStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(5, true);
  return builder;
}

class ResolvedDefineTableStmtBuilder final {
 public:
  ResolvedDefineTableStmtBuilder() : ResolvedDefineTableStmtBuilder(absl::WrapUnique(new ResolvedDefineTableStmt)) {}

  ResolvedDefineTableStmtBuilder(const ResolvedDefineTableStmtBuilder&) = delete;
  ResolvedDefineTableStmtBuilder& operator=(const ResolvedDefineTableStmtBuilder&) = delete;
  ResolvedDefineTableStmtBuilder(ResolvedDefineTableStmtBuilder&& other)
      : ResolvedDefineTableStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedDefineTableStmtBuilder& operator=(ResolvedDefineTableStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDefineTableStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedDefineTableStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedDefineTableStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedDefineTableStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedDefineTableStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDefineTableStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDefineTableStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDefineTableStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDefineTableStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDefineTableStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDefineTableStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDefineTableStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDefineTableStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDefineTableStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDefineTableStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDefineTableStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDefineTableStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDefineTableStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDefineTableStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDefineTableStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDefineTableStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDefineTableStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedDefineTableStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedDefineTableStmt> node);

  ResolvedDefineTableStmtBuilder(std::unique_ptr<ResolvedDefineTableStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDefineTableStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedDefineTableStmt> node) {
  ResolvedDefineTableStmtBuilder builder(absl::WrapUnique<ResolvedDefineTableStmt>(
      const_cast<ResolvedDefineTableStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedDescribeStmtBuilder final {
 public:
  ResolvedDescribeStmtBuilder() : ResolvedDescribeStmtBuilder(absl::WrapUnique(new ResolvedDescribeStmt)) {}

  ResolvedDescribeStmtBuilder(const ResolvedDescribeStmtBuilder&) = delete;
  ResolvedDescribeStmtBuilder& operator=(const ResolvedDescribeStmtBuilder&) = delete;
  ResolvedDescribeStmtBuilder(ResolvedDescribeStmtBuilder&& other)
      : ResolvedDescribeStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDescribeStmtBuilder& operator=(ResolvedDescribeStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDescribeStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDescribeStmt::object_type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& object_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->object_type();
  }

  ResolvedDescribeStmtBuilder&& set_object_type(const std::string& v) && {
    node_->set_object_type(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedDescribeStmtBuilder& set_object_type(const std::string& v) & {
    node_->set_object_type(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedDescribeStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedDescribeStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedDescribeStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedDescribeStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::string>& from_name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->from_name_path();
  }

  int from_name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->from_name_path_size();
  }

  const std::string& from_name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->from_name_path(i);
  }

  ResolvedDescribeStmtBuilder&& add_from_name_path(std::string v) && {
    node_->add_from_name_path(v);

    return std::move(*this);
  }

  ResolvedDescribeStmtBuilder& add_from_name_path(std::string v) & {
    node_->add_from_name_path(v);

    return *this;
  }

  ResolvedDescribeStmtBuilder&& set_from_name_path(const std::vector<std::string>& v) && {
    node_->set_from_name_path(v);

    return std::move(*this);
  }

  ResolvedDescribeStmtBuilder& set_from_name_path(const std::vector<std::string>& v) & {
    node_->set_from_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDescribeStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDescribeStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDescribeStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDescribeStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDescribeStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDescribeStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDescribeStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDescribeStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDescribeStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedDescribeStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedDescribeStmt> node);

  ResolvedDescribeStmtBuilder(std::unique_ptr<ResolvedDescribeStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDescribeStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedDescribeStmt> node) {
  ResolvedDescribeStmtBuilder builder(absl::WrapUnique<ResolvedDescribeStmt>(
      const_cast<ResolvedDescribeStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedShowStmtBuilder final {
 public:
  ResolvedShowStmtBuilder() : ResolvedShowStmtBuilder(absl::WrapUnique(new ResolvedShowStmt)) {}

  ResolvedShowStmtBuilder(const ResolvedShowStmtBuilder&) = delete;
  ResolvedShowStmtBuilder& operator=(const ResolvedShowStmtBuilder&) = delete;
  ResolvedShowStmtBuilder(ResolvedShowStmtBuilder&& other)
      : ResolvedShowStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedShowStmtBuilder& operator=(ResolvedShowStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedShowStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedShowStmt::identifier was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& identifier() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->identifier();
  }

  ResolvedShowStmtBuilder&& set_identifier(const std::string& v) && {
    node_->set_identifier(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedShowStmtBuilder& set_identifier(const std::string& v) & {
    node_->set_identifier(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedShowStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedShowStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedShowStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedShowStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const ResolvedLiteral* like_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->like_expr();
  }

  std::unique_ptr<const ResolvedLiteral> release_like_expr() {
    return node_->release_like_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedLiteral>>::value>>
  ResolvedShowStmtBuilder&& set_like_expr(T v) && {
    node_->set_like_expr(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedLiteral>>::value>>
  ResolvedShowStmtBuilder& set_like_expr(T v) & {
    node_->set_like_expr(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedLiteral>>::value>>
  ResolvedShowStmtBuilder&& set_like_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_like_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedLiteral>>::value>>
  ResolvedShowStmtBuilder& set_like_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_like_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedShowStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedShowStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedShowStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedShowStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedShowStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedShowStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedShowStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedShowStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedShowStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedShowStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedShowStmt> node);

  ResolvedShowStmtBuilder(std::unique_ptr<ResolvedShowStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedShowStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedShowStmt> node) {
  ResolvedShowStmtBuilder builder(absl::WrapUnique<ResolvedShowStmt>(
      const_cast<ResolvedShowStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedBeginStmtBuilder final {
 public:
    typedef ResolvedBeginStmtEnums::ReadWriteMode ReadWriteMode;
  static const ReadWriteMode MODE_UNSPECIFIED = ResolvedBeginStmtEnums::MODE_UNSPECIFIED;
  static const ReadWriteMode MODE_READ_ONLY = ResolvedBeginStmtEnums::MODE_READ_ONLY;
  static const ReadWriteMode MODE_READ_WRITE = ResolvedBeginStmtEnums::MODE_READ_WRITE;

  ResolvedBeginStmtBuilder() : ResolvedBeginStmtBuilder(absl::WrapUnique(new ResolvedBeginStmt)) {}

  ResolvedBeginStmtBuilder(const ResolvedBeginStmtBuilder&) = delete;
  ResolvedBeginStmtBuilder& operator=(const ResolvedBeginStmtBuilder&) = delete;
  ResolvedBeginStmtBuilder(ResolvedBeginStmtBuilder&& other)
      : ResolvedBeginStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedBeginStmtBuilder& operator=(ResolvedBeginStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedBeginStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  ResolvedBeginStmt::ReadWriteMode read_write_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->read_write_mode();
  }

  ResolvedBeginStmtBuilder&& set_read_write_mode(ResolvedBeginStmt::ReadWriteMode v) && {
    node_->set_read_write_mode(v);

    return std::move(*this);
  }

  ResolvedBeginStmtBuilder& set_read_write_mode(ResolvedBeginStmt::ReadWriteMode v) & {
    node_->set_read_write_mode(v);

    return *this;
  }

  const std::vector<std::string>& isolation_level_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->isolation_level_list();
  }

  int isolation_level_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->isolation_level_list_size();
  }

  const std::string& isolation_level_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->isolation_level_list(i);
  }

  ResolvedBeginStmtBuilder&& add_isolation_level_list(std::string v) && {
    node_->add_isolation_level_list(v);

    return std::move(*this);
  }

  ResolvedBeginStmtBuilder& add_isolation_level_list(std::string v) & {
    node_->add_isolation_level_list(v);

    return *this;
  }

  ResolvedBeginStmtBuilder&& set_isolation_level_list(const std::vector<std::string>& v) && {
    node_->set_isolation_level_list(v);

    return std::move(*this);
  }

  ResolvedBeginStmtBuilder& set_isolation_level_list(const std::vector<std::string>& v) & {
    node_->set_isolation_level_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedBeginStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedBeginStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedBeginStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedBeginStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedBeginStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedBeginStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedBeginStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedBeginStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedBeginStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedBeginStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedBeginStmt> node);

  ResolvedBeginStmtBuilder(std::unique_ptr<ResolvedBeginStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedBeginStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedBeginStmt> node) {
  ResolvedBeginStmtBuilder builder(absl::WrapUnique<ResolvedBeginStmt>(
      const_cast<ResolvedBeginStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedSetTransactionStmtBuilder final {
 public:
    typedef ResolvedBeginStmt::ReadWriteMode ReadWriteMode;

  ResolvedSetTransactionStmtBuilder() : ResolvedSetTransactionStmtBuilder(absl::WrapUnique(new ResolvedSetTransactionStmt)) {}

  ResolvedSetTransactionStmtBuilder(const ResolvedSetTransactionStmtBuilder&) = delete;
  ResolvedSetTransactionStmtBuilder& operator=(const ResolvedSetTransactionStmtBuilder&) = delete;
  ResolvedSetTransactionStmtBuilder(ResolvedSetTransactionStmtBuilder&& other)
      : ResolvedSetTransactionStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedSetTransactionStmtBuilder& operator=(ResolvedSetTransactionStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedSetTransactionStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  ResolvedBeginStmt::ReadWriteMode read_write_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->read_write_mode();
  }

  ResolvedSetTransactionStmtBuilder&& set_read_write_mode(ResolvedBeginStmt::ReadWriteMode v) && {
    node_->set_read_write_mode(v);

    return std::move(*this);
  }

  ResolvedSetTransactionStmtBuilder& set_read_write_mode(ResolvedBeginStmt::ReadWriteMode v) & {
    node_->set_read_write_mode(v);

    return *this;
  }

  const std::vector<std::string>& isolation_level_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->isolation_level_list();
  }

  int isolation_level_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->isolation_level_list_size();
  }

  const std::string& isolation_level_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->isolation_level_list(i);
  }

  ResolvedSetTransactionStmtBuilder&& add_isolation_level_list(std::string v) && {
    node_->add_isolation_level_list(v);

    return std::move(*this);
  }

  ResolvedSetTransactionStmtBuilder& add_isolation_level_list(std::string v) & {
    node_->add_isolation_level_list(v);

    return *this;
  }

  ResolvedSetTransactionStmtBuilder&& set_isolation_level_list(const std::vector<std::string>& v) && {
    node_->set_isolation_level_list(v);

    return std::move(*this);
  }

  ResolvedSetTransactionStmtBuilder& set_isolation_level_list(const std::vector<std::string>& v) & {
    node_->set_isolation_level_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSetTransactionStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSetTransactionStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSetTransactionStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSetTransactionStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSetTransactionStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSetTransactionStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSetTransactionStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSetTransactionStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedSetTransactionStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedSetTransactionStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedSetTransactionStmt> node);

  ResolvedSetTransactionStmtBuilder(std::unique_ptr<ResolvedSetTransactionStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedSetTransactionStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedSetTransactionStmt> node) {
  ResolvedSetTransactionStmtBuilder builder(absl::WrapUnique<ResolvedSetTransactionStmt>(
      const_cast<ResolvedSetTransactionStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedCommitStmtBuilder final {
 public:
  ResolvedCommitStmtBuilder() : ResolvedCommitStmtBuilder(absl::WrapUnique(new ResolvedCommitStmt)) {}

  ResolvedCommitStmtBuilder(const ResolvedCommitStmtBuilder&) = delete;
  ResolvedCommitStmtBuilder& operator=(const ResolvedCommitStmtBuilder&) = delete;
  ResolvedCommitStmtBuilder(ResolvedCommitStmtBuilder&& other)
      : ResolvedCommitStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedCommitStmtBuilder& operator=(ResolvedCommitStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCommitStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCommitStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCommitStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCommitStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCommitStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCommitStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCommitStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCommitStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCommitStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCommitStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedCommitStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCommitStmt> node);

  ResolvedCommitStmtBuilder(std::unique_ptr<ResolvedCommitStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCommitStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCommitStmt> node) {
  ResolvedCommitStmtBuilder builder(absl::WrapUnique<ResolvedCommitStmt>(
      const_cast<ResolvedCommitStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedRollbackStmtBuilder final {
 public:
  ResolvedRollbackStmtBuilder() : ResolvedRollbackStmtBuilder(absl::WrapUnique(new ResolvedRollbackStmt)) {}

  ResolvedRollbackStmtBuilder(const ResolvedRollbackStmtBuilder&) = delete;
  ResolvedRollbackStmtBuilder& operator=(const ResolvedRollbackStmtBuilder&) = delete;
  ResolvedRollbackStmtBuilder(ResolvedRollbackStmtBuilder&& other)
      : ResolvedRollbackStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedRollbackStmtBuilder& operator=(ResolvedRollbackStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedRollbackStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRollbackStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRollbackStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRollbackStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRollbackStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRollbackStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRollbackStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRollbackStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRollbackStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedRollbackStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedRollbackStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedRollbackStmt> node);

  ResolvedRollbackStmtBuilder(std::unique_ptr<ResolvedRollbackStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedRollbackStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedRollbackStmt> node) {
  ResolvedRollbackStmtBuilder builder(absl::WrapUnique<ResolvedRollbackStmt>(
      const_cast<ResolvedRollbackStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedStartBatchStmtBuilder final {
 public:
  ResolvedStartBatchStmtBuilder() : ResolvedStartBatchStmtBuilder(absl::WrapUnique(new ResolvedStartBatchStmt)) {}

  ResolvedStartBatchStmtBuilder(const ResolvedStartBatchStmtBuilder&) = delete;
  ResolvedStartBatchStmtBuilder& operator=(const ResolvedStartBatchStmtBuilder&) = delete;
  ResolvedStartBatchStmtBuilder(ResolvedStartBatchStmtBuilder&& other)
      : ResolvedStartBatchStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedStartBatchStmtBuilder& operator=(ResolvedStartBatchStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedStartBatchStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& batch_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->batch_type();
  }

  ResolvedStartBatchStmtBuilder&& set_batch_type(const std::string& v) && {
    node_->set_batch_type(v);

    return std::move(*this);
  }

  ResolvedStartBatchStmtBuilder& set_batch_type(const std::string& v) & {
    node_->set_batch_type(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedStartBatchStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedStartBatchStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedStartBatchStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedStartBatchStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedStartBatchStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedStartBatchStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedStartBatchStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedStartBatchStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedStartBatchStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedStartBatchStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedStartBatchStmt> node);

  ResolvedStartBatchStmtBuilder(std::unique_ptr<ResolvedStartBatchStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedStartBatchStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedStartBatchStmt> node) {
  ResolvedStartBatchStmtBuilder builder(absl::WrapUnique<ResolvedStartBatchStmt>(
      const_cast<ResolvedStartBatchStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedRunBatchStmtBuilder final {
 public:
  ResolvedRunBatchStmtBuilder() : ResolvedRunBatchStmtBuilder(absl::WrapUnique(new ResolvedRunBatchStmt)) {}

  ResolvedRunBatchStmtBuilder(const ResolvedRunBatchStmtBuilder&) = delete;
  ResolvedRunBatchStmtBuilder& operator=(const ResolvedRunBatchStmtBuilder&) = delete;
  ResolvedRunBatchStmtBuilder(ResolvedRunBatchStmtBuilder&& other)
      : ResolvedRunBatchStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedRunBatchStmtBuilder& operator=(ResolvedRunBatchStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedRunBatchStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRunBatchStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRunBatchStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRunBatchStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRunBatchStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRunBatchStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRunBatchStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRunBatchStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRunBatchStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedRunBatchStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedRunBatchStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedRunBatchStmt> node);

  ResolvedRunBatchStmtBuilder(std::unique_ptr<ResolvedRunBatchStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedRunBatchStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedRunBatchStmt> node) {
  ResolvedRunBatchStmtBuilder builder(absl::WrapUnique<ResolvedRunBatchStmt>(
      const_cast<ResolvedRunBatchStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedAbortBatchStmtBuilder final {
 public:
  ResolvedAbortBatchStmtBuilder() : ResolvedAbortBatchStmtBuilder(absl::WrapUnique(new ResolvedAbortBatchStmt)) {}

  ResolvedAbortBatchStmtBuilder(const ResolvedAbortBatchStmtBuilder&) = delete;
  ResolvedAbortBatchStmtBuilder& operator=(const ResolvedAbortBatchStmtBuilder&) = delete;
  ResolvedAbortBatchStmtBuilder(ResolvedAbortBatchStmtBuilder&& other)
      : ResolvedAbortBatchStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedAbortBatchStmtBuilder& operator=(ResolvedAbortBatchStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAbortBatchStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAbortBatchStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAbortBatchStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAbortBatchStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAbortBatchStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAbortBatchStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAbortBatchStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAbortBatchStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAbortBatchStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAbortBatchStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedAbortBatchStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAbortBatchStmt> node);

  ResolvedAbortBatchStmtBuilder(std::unique_ptr<ResolvedAbortBatchStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAbortBatchStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAbortBatchStmt> node) {
  ResolvedAbortBatchStmtBuilder builder(absl::WrapUnique<ResolvedAbortBatchStmt>(
      const_cast<ResolvedAbortBatchStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedDropStmtBuilder final {
 public:
    typedef ResolvedDropStmtEnums::DropMode DropMode;
  static const DropMode DROP_MODE_UNSPECIFIED = ResolvedDropStmtEnums::DROP_MODE_UNSPECIFIED;
  static const DropMode RESTRICT = ResolvedDropStmtEnums::RESTRICT;
  static const DropMode CASCADE = ResolvedDropStmtEnums::CASCADE;

  ResolvedDropStmtBuilder() : ResolvedDropStmtBuilder(absl::WrapUnique(new ResolvedDropStmt)) {}

  ResolvedDropStmtBuilder(const ResolvedDropStmtBuilder&) = delete;
  ResolvedDropStmtBuilder& operator=(const ResolvedDropStmtBuilder&) = delete;
  ResolvedDropStmtBuilder(ResolvedDropStmtBuilder&& other)
      : ResolvedDropStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDropStmtBuilder& operator=(ResolvedDropStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDropStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropStmt::object_type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropStmt::is_if_exists was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& object_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->object_type();
  }

  ResolvedDropStmtBuilder&& set_object_type(const std::string& v) && {
    node_->set_object_type(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedDropStmtBuilder& set_object_type(const std::string& v) & {
    node_->set_object_type(v);
    field_is_set_.set(1, true);

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedDropStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedDropStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);
    field_is_set_.set(2, true);

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedDropStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedDropStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedDropStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedDropStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedDropStmt::DropMode drop_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->drop_mode();
  }

  ResolvedDropStmtBuilder&& set_drop_mode(ResolvedDropStmt::DropMode v) && {
    node_->set_drop_mode(v);

    return std::move(*this);
  }

  ResolvedDropStmtBuilder& set_drop_mode(ResolvedDropStmt::DropMode v) & {
    node_->set_drop_mode(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDropStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedDropStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedDropStmt> node);

  ResolvedDropStmtBuilder(std::unique_ptr<ResolvedDropStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDropStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedDropStmt> node) {
  ResolvedDropStmtBuilder builder(absl::WrapUnique<ResolvedDropStmt>(
      const_cast<ResolvedDropStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedDropMaterializedViewStmtBuilder final {
 public:
  ResolvedDropMaterializedViewStmtBuilder() : ResolvedDropMaterializedViewStmtBuilder(absl::WrapUnique(new ResolvedDropMaterializedViewStmt)) {}

  ResolvedDropMaterializedViewStmtBuilder(const ResolvedDropMaterializedViewStmtBuilder&) = delete;
  ResolvedDropMaterializedViewStmtBuilder& operator=(const ResolvedDropMaterializedViewStmtBuilder&) = delete;
  ResolvedDropMaterializedViewStmtBuilder(ResolvedDropMaterializedViewStmtBuilder&& other)
      : ResolvedDropMaterializedViewStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDropMaterializedViewStmtBuilder& operator=(ResolvedDropMaterializedViewStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDropMaterializedViewStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropMaterializedViewStmt::is_if_exists was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedDropMaterializedViewStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedDropMaterializedViewStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedDropMaterializedViewStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedDropMaterializedViewStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedDropMaterializedViewStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedDropMaterializedViewStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropMaterializedViewStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropMaterializedViewStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropMaterializedViewStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropMaterializedViewStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropMaterializedViewStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropMaterializedViewStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropMaterializedViewStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropMaterializedViewStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDropMaterializedViewStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedDropMaterializedViewStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedDropMaterializedViewStmt> node);

  ResolvedDropMaterializedViewStmtBuilder(std::unique_ptr<ResolvedDropMaterializedViewStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDropMaterializedViewStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedDropMaterializedViewStmt> node) {
  ResolvedDropMaterializedViewStmtBuilder builder(absl::WrapUnique<ResolvedDropMaterializedViewStmt>(
      const_cast<ResolvedDropMaterializedViewStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedDropSnapshotTableStmtBuilder final {
 public:
  ResolvedDropSnapshotTableStmtBuilder() : ResolvedDropSnapshotTableStmtBuilder(absl::WrapUnique(new ResolvedDropSnapshotTableStmt)) {}

  ResolvedDropSnapshotTableStmtBuilder(const ResolvedDropSnapshotTableStmtBuilder&) = delete;
  ResolvedDropSnapshotTableStmtBuilder& operator=(const ResolvedDropSnapshotTableStmtBuilder&) = delete;
  ResolvedDropSnapshotTableStmtBuilder(ResolvedDropSnapshotTableStmtBuilder&& other)
      : ResolvedDropSnapshotTableStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDropSnapshotTableStmtBuilder& operator=(ResolvedDropSnapshotTableStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDropSnapshotTableStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropSnapshotTableStmt::is_if_exists was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedDropSnapshotTableStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedDropSnapshotTableStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedDropSnapshotTableStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedDropSnapshotTableStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedDropSnapshotTableStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedDropSnapshotTableStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropSnapshotTableStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropSnapshotTableStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropSnapshotTableStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropSnapshotTableStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropSnapshotTableStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropSnapshotTableStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropSnapshotTableStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropSnapshotTableStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDropSnapshotTableStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedDropSnapshotTableStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedDropSnapshotTableStmt> node);

  ResolvedDropSnapshotTableStmtBuilder(std::unique_ptr<ResolvedDropSnapshotTableStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDropSnapshotTableStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedDropSnapshotTableStmt> node) {
  ResolvedDropSnapshotTableStmtBuilder builder(absl::WrapUnique<ResolvedDropSnapshotTableStmt>(
      const_cast<ResolvedDropSnapshotTableStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedRecursiveRefScanBuilder final {
 public:
  ResolvedRecursiveRefScanBuilder() : ResolvedRecursiveRefScanBuilder(absl::WrapUnique(new ResolvedRecursiveRefScan)) {}

  ResolvedRecursiveRefScanBuilder(const ResolvedRecursiveRefScanBuilder&) = delete;
  ResolvedRecursiveRefScanBuilder& operator=(const ResolvedRecursiveRefScanBuilder&) = delete;
  ResolvedRecursiveRefScanBuilder(ResolvedRecursiveRefScanBuilder&& other)
      : ResolvedRecursiveRefScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedRecursiveRefScanBuilder& operator=(ResolvedRecursiveRefScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedRecursiveRefScan>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedRecursiveRefScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedRecursiveRefScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedRecursiveRefScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedRecursiveRefScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRecursiveRefScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRecursiveRefScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRecursiveRefScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRecursiveRefScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRecursiveRefScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRecursiveRefScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRecursiveRefScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRecursiveRefScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedRecursiveRefScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedRecursiveRefScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedRecursiveRefScan> node_;

  absl::Status deferred_build_status_;
  friend ResolvedRecursiveRefScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedRecursiveRefScan> node);

  ResolvedRecursiveRefScanBuilder(std::unique_ptr<ResolvedRecursiveRefScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedRecursiveRefScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedRecursiveRefScan> node) {
  ResolvedRecursiveRefScanBuilder builder(absl::WrapUnique<ResolvedRecursiveRefScan>(
      const_cast<ResolvedRecursiveRefScan*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedRecursiveScanBuilder final {
 public:
    typedef ResolvedRecursiveScanEnums::RecursiveSetOperationType RecursiveSetOperationType;
  static const RecursiveSetOperationType UNION_ALL = ResolvedRecursiveScanEnums::UNION_ALL;
  static const RecursiveSetOperationType UNION_DISTINCT = ResolvedRecursiveScanEnums::UNION_DISTINCT;

  ResolvedRecursiveScanBuilder() : ResolvedRecursiveScanBuilder(absl::WrapUnique(new ResolvedRecursiveScan)) {}

  ResolvedRecursiveScanBuilder(const ResolvedRecursiveScanBuilder&) = delete;
  ResolvedRecursiveScanBuilder& operator=(const ResolvedRecursiveScanBuilder&) = delete;
  ResolvedRecursiveScanBuilder(ResolvedRecursiveScanBuilder&& other)
      : ResolvedRecursiveScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedRecursiveScanBuilder& operator=(ResolvedRecursiveScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedRecursiveScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedRecursiveScan::op_type was not set on the builder");
    }
    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedRecursiveScan::non_recursive_term was not set on the builder");
    }
    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedRecursiveScan::recursive_term was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  ResolvedRecursiveScan::RecursiveSetOperationType op_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->op_type();
  }

  ResolvedRecursiveScanBuilder&& set_op_type(ResolvedRecursiveScan::RecursiveSetOperationType v) && {
    node_->set_op_type(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedRecursiveScanBuilder& set_op_type(ResolvedRecursiveScan::RecursiveSetOperationType v) & {
    node_->set_op_type(v);
    field_is_set_.set(3, true);

    return *this;
  }

  const ResolvedSetOperationItem* non_recursive_term() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->non_recursive_term();
  }

  std::unique_ptr<const ResolvedSetOperationItem> release_non_recursive_term() {
    return node_->release_non_recursive_term();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedSetOperationItem>>::value>>
  ResolvedRecursiveScanBuilder&& set_non_recursive_term(T v) && {
    node_->set_non_recursive_term(std::move(v));
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedSetOperationItem>>::value>>
  ResolvedRecursiveScanBuilder& set_non_recursive_term(T v) & {
    node_->set_non_recursive_term(std::move(v));
    field_is_set_.set(4, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedSetOperationItem>>::value>>
  ResolvedRecursiveScanBuilder&& set_non_recursive_term(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_non_recursive_term(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedSetOperationItem>>::value>>
  ResolvedRecursiveScanBuilder& set_non_recursive_term(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_non_recursive_term(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return *this;
  }

  const ResolvedSetOperationItem* recursive_term() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->recursive_term();
  }

  std::unique_ptr<const ResolvedSetOperationItem> release_recursive_term() {
    return node_->release_recursive_term();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedSetOperationItem>>::value>>
  ResolvedRecursiveScanBuilder&& set_recursive_term(T v) && {
    node_->set_recursive_term(std::move(v));
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedSetOperationItem>>::value>>
  ResolvedRecursiveScanBuilder& set_recursive_term(T v) & {
    node_->set_recursive_term(std::move(v));
    field_is_set_.set(5, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedSetOperationItem>>::value>>
  ResolvedRecursiveScanBuilder&& set_recursive_term(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_recursive_term(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedSetOperationItem>>::value>>
  ResolvedRecursiveScanBuilder& set_recursive_term(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_recursive_term(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedRecursiveScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedRecursiveScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedRecursiveScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedRecursiveScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRecursiveScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRecursiveScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRecursiveScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRecursiveScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRecursiveScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRecursiveScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRecursiveScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRecursiveScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedRecursiveScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedRecursiveScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedRecursiveScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<6> field_is_set_ = {0};
  friend ResolvedRecursiveScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedRecursiveScan> node);

  ResolvedRecursiveScanBuilder(std::unique_ptr<ResolvedRecursiveScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedRecursiveScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedRecursiveScan> node) {
  ResolvedRecursiveScanBuilder builder(absl::WrapUnique<ResolvedRecursiveScan>(
      const_cast<ResolvedRecursiveScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  builder.field_is_set_.set(4, true);
  builder.field_is_set_.set(5, true);
  return builder;
}

class ResolvedWithScanBuilder final {
 public:
  ResolvedWithScanBuilder() : ResolvedWithScanBuilder(absl::WrapUnique(new ResolvedWithScan)) {}

  ResolvedWithScanBuilder(const ResolvedWithScanBuilder&) = delete;
  ResolvedWithScanBuilder& operator=(const ResolvedWithScanBuilder&) = delete;
  ResolvedWithScanBuilder(ResolvedWithScanBuilder&& other)
      : ResolvedWithScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedWithScanBuilder& operator=(ResolvedWithScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedWithScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedWithScan::query was not set on the builder");
    }
    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedWithScan::recursive was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedWithEntry>>& with_entry_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_entry_list();
  }

  int with_entry_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_entry_list_size();
  }

  const ResolvedWithEntry* with_entry_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_entry_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWithEntry>>::value>>
  ResolvedWithScanBuilder&& add_with_entry_list(T v) && {
    node_->add_with_entry_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWithEntry>>::value>>
  ResolvedWithScanBuilder& add_with_entry_list(T v) & {
    node_->add_with_entry_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWithEntry>>::value>>
  ResolvedWithScanBuilder&& add_with_entry_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_with_entry_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWithEntry>>::value>>
  ResolvedWithScanBuilder& add_with_entry_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_with_entry_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedWithEntry>> release_with_entry_list() {
    return node_->release_with_entry_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedWithEntry>>>::value>>
  ResolvedWithScanBuilder&& set_with_entry_list(T v) && {
    node_->set_with_entry_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedWithEntry>>>::value>>
  ResolvedWithScanBuilder& set_with_entry_list(T v) & {
    node_->set_with_entry_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedWithEntry>>>::value>>
  ResolvedWithScanBuilder&& set_with_entry_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_entry_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedWithEntry>>>::value>>
  ResolvedWithScanBuilder& set_with_entry_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_entry_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedScan* query() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query();
  }

  std::unique_ptr<const ResolvedScan> release_query() {
    return node_->release_query();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedWithScanBuilder&& set_query(T v) && {
    node_->set_query(std::move(v));
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedWithScanBuilder& set_query(T v) & {
    node_->set_query(std::move(v));
    field_is_set_.set(4, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedWithScanBuilder&& set_query(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedWithScanBuilder& set_query(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return *this;
  }

  // True if the WITH clause uses the recursive keyword.
  bool recursive() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->recursive();
  }

  ResolvedWithScanBuilder&& set_recursive(bool v) && {
    node_->set_recursive(v);
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  ResolvedWithScanBuilder& set_recursive(bool v) & {
    node_->set_recursive(v);
    field_is_set_.set(5, true);

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedWithScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedWithScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedWithScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedWithScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWithScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWithScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWithScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWithScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWithScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWithScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWithScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWithScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedWithScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedWithScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedWithScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<6> field_is_set_ = {0};
  friend ResolvedWithScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedWithScan> node);

  ResolvedWithScanBuilder(std::unique_ptr<ResolvedWithScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedWithScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedWithScan> node) {
  ResolvedWithScanBuilder builder(absl::WrapUnique<ResolvedWithScan>(
      const_cast<ResolvedWithScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(4, true);
  builder.field_is_set_.set(5, true);
  return builder;
}

class ResolvedWithEntryBuilder final {
 public:
  ResolvedWithEntryBuilder() : ResolvedWithEntryBuilder(absl::WrapUnique(new ResolvedWithEntry)) {}

  ResolvedWithEntryBuilder(const ResolvedWithEntryBuilder&) = delete;
  ResolvedWithEntryBuilder& operator=(const ResolvedWithEntryBuilder&) = delete;
  ResolvedWithEntryBuilder(ResolvedWithEntryBuilder&& other)
      : ResolvedWithEntryBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedWithEntryBuilder& operator=(ResolvedWithEntryBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedWithEntry>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedWithEntry::with_query_name was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedWithEntry::with_subquery was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& with_query_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_query_name();
  }

  ResolvedWithEntryBuilder&& set_with_query_name(const std::string& v) && {
    node_->set_with_query_name(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedWithEntryBuilder& set_with_query_name(const std::string& v) & {
    node_->set_with_query_name(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedScan* with_subquery() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_subquery();
  }

  std::unique_ptr<const ResolvedScan> release_with_subquery() {
    return node_->release_with_subquery();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedWithEntryBuilder&& set_with_subquery(T v) && {
    node_->set_with_subquery(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedWithEntryBuilder& set_with_subquery(T v) & {
    node_->set_with_subquery(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedWithEntryBuilder&& set_with_subquery(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_subquery(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedWithEntryBuilder& set_with_subquery(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_subquery(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedWithEntry> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedWithEntryBuilder ToBuilder(
      std::unique_ptr<const ResolvedWithEntry> node);

  ResolvedWithEntryBuilder(std::unique_ptr<ResolvedWithEntry> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedWithEntryBuilder ToBuilder(
    std::unique_ptr<const ResolvedWithEntry> node) {
  ResolvedWithEntryBuilder builder(absl::WrapUnique<ResolvedWithEntry>(
      const_cast<ResolvedWithEntry*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedOptionBuilder final {
 public:
  ResolvedOptionBuilder() : ResolvedOptionBuilder(absl::WrapUnique(new ResolvedOption)) {}

  ResolvedOptionBuilder(const ResolvedOptionBuilder&) = delete;
  ResolvedOptionBuilder& operator=(const ResolvedOptionBuilder&) = delete;
  ResolvedOptionBuilder(ResolvedOptionBuilder&& other)
      : ResolvedOptionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedOptionBuilder& operator=(ResolvedOptionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedOption>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedOption::name was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedOption::value was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& qualifier() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->qualifier();
  }

  ResolvedOptionBuilder&& set_qualifier(const std::string& v) && {
    node_->set_qualifier(v);

    return std::move(*this);
  }

  ResolvedOptionBuilder& set_qualifier(const std::string& v) & {
    node_->set_qualifier(v);

    return *this;
  }

  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedOptionBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedOptionBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const ResolvedExpr* value() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->value();
  }

  std::unique_ptr<const ResolvedExpr> release_value() {
    return node_->release_value();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedOptionBuilder&& set_value(T v) && {
    node_->set_value(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedOptionBuilder& set_value(T v) & {
    node_->set_value(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedOptionBuilder&& set_value(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_value(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedOptionBuilder& set_value(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_value(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedOption> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedOptionBuilder ToBuilder(
      std::unique_ptr<const ResolvedOption> node);

  ResolvedOptionBuilder(std::unique_ptr<ResolvedOption> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedOptionBuilder ToBuilder(
    std::unique_ptr<const ResolvedOption> node) {
  ResolvedOptionBuilder builder(absl::WrapUnique<ResolvedOption>(
      const_cast<ResolvedOption*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedWindowPartitioningBuilder final {
 public:
  ResolvedWindowPartitioningBuilder() : ResolvedWindowPartitioningBuilder(absl::WrapUnique(new ResolvedWindowPartitioning)) {}

  ResolvedWindowPartitioningBuilder(const ResolvedWindowPartitioningBuilder&) = delete;
  ResolvedWindowPartitioningBuilder& operator=(const ResolvedWindowPartitioningBuilder&) = delete;
  ResolvedWindowPartitioningBuilder(ResolvedWindowPartitioningBuilder&& other)
      : ResolvedWindowPartitioningBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedWindowPartitioningBuilder& operator=(ResolvedWindowPartitioningBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedWindowPartitioning>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedColumnRef>>& partition_by_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list();
  }

  int partition_by_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list_size();
  }

  const ResolvedColumnRef* partition_by_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedWindowPartitioningBuilder&& add_partition_by_list(T v) && {
    node_->add_partition_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedWindowPartitioningBuilder& add_partition_by_list(T v) & {
    node_->add_partition_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedWindowPartitioningBuilder&& add_partition_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedWindowPartitioningBuilder& add_partition_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnRef>> release_partition_by_list() {
    return node_->release_partition_by_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedWindowPartitioningBuilder&& set_partition_by_list(T v) && {
    node_->set_partition_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedWindowPartitioningBuilder& set_partition_by_list(T v) & {
    node_->set_partition_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedWindowPartitioningBuilder&& set_partition_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedWindowPartitioningBuilder& set_partition_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWindowPartitioningBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWindowPartitioningBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWindowPartitioningBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWindowPartitioningBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWindowPartitioningBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWindowPartitioningBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWindowPartitioningBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWindowPartitioningBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedWindowPartitioning> node_;

  absl::Status deferred_build_status_;
  friend ResolvedWindowPartitioningBuilder ToBuilder(
      std::unique_ptr<const ResolvedWindowPartitioning> node);

  ResolvedWindowPartitioningBuilder(std::unique_ptr<ResolvedWindowPartitioning> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedWindowPartitioningBuilder ToBuilder(
    std::unique_ptr<const ResolvedWindowPartitioning> node) {
  ResolvedWindowPartitioningBuilder builder(absl::WrapUnique<ResolvedWindowPartitioning>(
      const_cast<ResolvedWindowPartitioning*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedWindowOrderingBuilder final {
 public:
  ResolvedWindowOrderingBuilder() : ResolvedWindowOrderingBuilder(absl::WrapUnique(new ResolvedWindowOrdering)) {}

  ResolvedWindowOrderingBuilder(const ResolvedWindowOrderingBuilder&) = delete;
  ResolvedWindowOrderingBuilder& operator=(const ResolvedWindowOrderingBuilder&) = delete;
  ResolvedWindowOrderingBuilder(ResolvedWindowOrderingBuilder&& other)
      : ResolvedWindowOrderingBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedWindowOrderingBuilder& operator=(ResolvedWindowOrderingBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedWindowOrdering>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOrderByItem>>& order_by_item_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->order_by_item_list();
  }

  int order_by_item_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->order_by_item_list_size();
  }

  const ResolvedOrderByItem* order_by_item_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->order_by_item_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOrderByItem>>::value>>
  ResolvedWindowOrderingBuilder&& add_order_by_item_list(T v) && {
    node_->add_order_by_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOrderByItem>>::value>>
  ResolvedWindowOrderingBuilder& add_order_by_item_list(T v) & {
    node_->add_order_by_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOrderByItem>>::value>>
  ResolvedWindowOrderingBuilder&& add_order_by_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_order_by_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOrderByItem>>::value>>
  ResolvedWindowOrderingBuilder& add_order_by_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_order_by_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOrderByItem>> release_order_by_item_list() {
    return node_->release_order_by_item_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOrderByItem>>>::value>>
  ResolvedWindowOrderingBuilder&& set_order_by_item_list(T v) && {
    node_->set_order_by_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOrderByItem>>>::value>>
  ResolvedWindowOrderingBuilder& set_order_by_item_list(T v) & {
    node_->set_order_by_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOrderByItem>>>::value>>
  ResolvedWindowOrderingBuilder&& set_order_by_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_order_by_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOrderByItem>>>::value>>
  ResolvedWindowOrderingBuilder& set_order_by_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_order_by_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWindowOrderingBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWindowOrderingBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWindowOrderingBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedWindowOrderingBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWindowOrderingBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWindowOrderingBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWindowOrderingBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedWindowOrderingBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedWindowOrdering> node_;

  absl::Status deferred_build_status_;
  friend ResolvedWindowOrderingBuilder ToBuilder(
      std::unique_ptr<const ResolvedWindowOrdering> node);

  ResolvedWindowOrderingBuilder(std::unique_ptr<ResolvedWindowOrdering> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedWindowOrderingBuilder ToBuilder(
    std::unique_ptr<const ResolvedWindowOrdering> node) {
  ResolvedWindowOrderingBuilder builder(absl::WrapUnique<ResolvedWindowOrdering>(
      const_cast<ResolvedWindowOrdering*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedWindowFrameBuilder final {
 public:
    typedef ResolvedWindowFrameEnums::FrameUnit FrameUnit;
  static const FrameUnit ROWS = ResolvedWindowFrameEnums::ROWS;
  static const FrameUnit RANGE = ResolvedWindowFrameEnums::RANGE;

  std::string GetFrameUnitString() const;
  static std::string FrameUnitToString(FrameUnit frame_unit);

  ResolvedWindowFrameBuilder() : ResolvedWindowFrameBuilder(absl::WrapUnique(new ResolvedWindowFrame)) {}

  ResolvedWindowFrameBuilder(const ResolvedWindowFrameBuilder&) = delete;
  ResolvedWindowFrameBuilder& operator=(const ResolvedWindowFrameBuilder&) = delete;
  ResolvedWindowFrameBuilder(ResolvedWindowFrameBuilder&& other)
      : ResolvedWindowFrameBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedWindowFrameBuilder& operator=(ResolvedWindowFrameBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedWindowFrame>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedWindowFrame::frame_unit was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedWindowFrame::start_expr was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedWindowFrame::end_expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  ResolvedWindowFrame::FrameUnit frame_unit() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->frame_unit();
  }

  ResolvedWindowFrameBuilder&& set_frame_unit(ResolvedWindowFrame::FrameUnit v) && {
    node_->set_frame_unit(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedWindowFrameBuilder& set_frame_unit(ResolvedWindowFrame::FrameUnit v) & {
    node_->set_frame_unit(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedWindowFrameExpr* start_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->start_expr();
  }

  std::unique_ptr<const ResolvedWindowFrameExpr> release_start_expr() {
    return node_->release_start_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWindowFrameExpr>>::value>>
  ResolvedWindowFrameBuilder&& set_start_expr(T v) && {
    node_->set_start_expr(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWindowFrameExpr>>::value>>
  ResolvedWindowFrameBuilder& set_start_expr(T v) & {
    node_->set_start_expr(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWindowFrameExpr>>::value>>
  ResolvedWindowFrameBuilder&& set_start_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_start_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWindowFrameExpr>>::value>>
  ResolvedWindowFrameBuilder& set_start_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_start_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

  const ResolvedWindowFrameExpr* end_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->end_expr();
  }

  std::unique_ptr<const ResolvedWindowFrameExpr> release_end_expr() {
    return node_->release_end_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWindowFrameExpr>>::value>>
  ResolvedWindowFrameBuilder&& set_end_expr(T v) && {
    node_->set_end_expr(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWindowFrameExpr>>::value>>
  ResolvedWindowFrameBuilder& set_end_expr(T v) & {
    node_->set_end_expr(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWindowFrameExpr>>::value>>
  ResolvedWindowFrameBuilder&& set_end_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_end_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWindowFrameExpr>>::value>>
  ResolvedWindowFrameBuilder& set_end_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_end_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedWindowFrame> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedWindowFrameBuilder ToBuilder(
      std::unique_ptr<const ResolvedWindowFrame> node);

  ResolvedWindowFrameBuilder(std::unique_ptr<ResolvedWindowFrame> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedWindowFrameBuilder ToBuilder(
    std::unique_ptr<const ResolvedWindowFrame> node) {
  ResolvedWindowFrameBuilder builder(absl::WrapUnique<ResolvedWindowFrame>(
      const_cast<ResolvedWindowFrame*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedAnalyticFunctionGroupBuilder final {
 public:
  ResolvedAnalyticFunctionGroupBuilder() : ResolvedAnalyticFunctionGroupBuilder(absl::WrapUnique(new ResolvedAnalyticFunctionGroup)) {}

  ResolvedAnalyticFunctionGroupBuilder(const ResolvedAnalyticFunctionGroupBuilder&) = delete;
  ResolvedAnalyticFunctionGroupBuilder& operator=(const ResolvedAnalyticFunctionGroupBuilder&) = delete;
  ResolvedAnalyticFunctionGroupBuilder(ResolvedAnalyticFunctionGroupBuilder&& other)
      : ResolvedAnalyticFunctionGroupBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAnalyticFunctionGroupBuilder& operator=(ResolvedAnalyticFunctionGroupBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAnalyticFunctionGroup>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAnalyticFunctionGroup::partition_by was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAnalyticFunctionGroup::order_by was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedWindowPartitioning* partition_by() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by();
  }

  std::unique_ptr<const ResolvedWindowPartitioning> release_partition_by() {
    return node_->release_partition_by();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWindowPartitioning>>::value>>
  ResolvedAnalyticFunctionGroupBuilder&& set_partition_by(T v) && {
    node_->set_partition_by(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWindowPartitioning>>::value>>
  ResolvedAnalyticFunctionGroupBuilder& set_partition_by(T v) & {
    node_->set_partition_by(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWindowPartitioning>>::value>>
  ResolvedAnalyticFunctionGroupBuilder&& set_partition_by(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWindowPartitioning>>::value>>
  ResolvedAnalyticFunctionGroupBuilder& set_partition_by(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedWindowOrdering* order_by() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->order_by();
  }

  std::unique_ptr<const ResolvedWindowOrdering> release_order_by() {
    return node_->release_order_by();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWindowOrdering>>::value>>
  ResolvedAnalyticFunctionGroupBuilder&& set_order_by(T v) && {
    node_->set_order_by(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWindowOrdering>>::value>>
  ResolvedAnalyticFunctionGroupBuilder& set_order_by(T v) & {
    node_->set_order_by(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWindowOrdering>>::value>>
  ResolvedAnalyticFunctionGroupBuilder&& set_order_by(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_order_by(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWindowOrdering>>::value>>
  ResolvedAnalyticFunctionGroupBuilder& set_order_by(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_order_by(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& analytic_function_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->analytic_function_list();
  }

  int analytic_function_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->analytic_function_list_size();
  }

  const ResolvedComputedColumn* analytic_function_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->analytic_function_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAnalyticFunctionGroupBuilder&& add_analytic_function_list(T v) && {
    node_->add_analytic_function_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAnalyticFunctionGroupBuilder& add_analytic_function_list(T v) & {
    node_->add_analytic_function_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAnalyticFunctionGroupBuilder&& add_analytic_function_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_analytic_function_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedAnalyticFunctionGroupBuilder& add_analytic_function_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_analytic_function_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_analytic_function_list() {
    return node_->release_analytic_function_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAnalyticFunctionGroupBuilder&& set_analytic_function_list(T v) && {
    node_->set_analytic_function_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAnalyticFunctionGroupBuilder& set_analytic_function_list(T v) & {
    node_->set_analytic_function_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAnalyticFunctionGroupBuilder&& set_analytic_function_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_analytic_function_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedAnalyticFunctionGroupBuilder& set_analytic_function_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_analytic_function_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAnalyticFunctionGroup> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedAnalyticFunctionGroupBuilder ToBuilder(
      std::unique_ptr<const ResolvedAnalyticFunctionGroup> node);

  ResolvedAnalyticFunctionGroupBuilder(std::unique_ptr<ResolvedAnalyticFunctionGroup> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAnalyticFunctionGroupBuilder ToBuilder(
    std::unique_ptr<const ResolvedAnalyticFunctionGroup> node) {
  ResolvedAnalyticFunctionGroupBuilder builder(absl::WrapUnique<ResolvedAnalyticFunctionGroup>(
      const_cast<ResolvedAnalyticFunctionGroup*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedWindowFrameExprBuilder final {
 public:
    typedef ResolvedWindowFrameExprEnums::BoundaryType BoundaryType;
  static const BoundaryType UNBOUNDED_PRECEDING = ResolvedWindowFrameExprEnums::UNBOUNDED_PRECEDING;
  static const BoundaryType OFFSET_PRECEDING = ResolvedWindowFrameExprEnums::OFFSET_PRECEDING;
  static const BoundaryType CURRENT_ROW = ResolvedWindowFrameExprEnums::CURRENT_ROW;
  static const BoundaryType OFFSET_FOLLOWING = ResolvedWindowFrameExprEnums::OFFSET_FOLLOWING;
  static const BoundaryType UNBOUNDED_FOLLOWING = ResolvedWindowFrameExprEnums::UNBOUNDED_FOLLOWING;

  std::string GetBoundaryTypeString() const;
  static std::string BoundaryTypeToString(BoundaryType boundary_type);

  ResolvedWindowFrameExprBuilder() : ResolvedWindowFrameExprBuilder(absl::WrapUnique(new ResolvedWindowFrameExpr)) {}

  ResolvedWindowFrameExprBuilder(const ResolvedWindowFrameExprBuilder&) = delete;
  ResolvedWindowFrameExprBuilder& operator=(const ResolvedWindowFrameExprBuilder&) = delete;
  ResolvedWindowFrameExprBuilder(ResolvedWindowFrameExprBuilder&& other)
      : ResolvedWindowFrameExprBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedWindowFrameExprBuilder& operator=(ResolvedWindowFrameExprBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedWindowFrameExpr>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedWindowFrameExpr::boundary_type was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedWindowFrameExpr::expression was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  ResolvedWindowFrameExpr::BoundaryType boundary_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->boundary_type();
  }

  ResolvedWindowFrameExprBuilder&& set_boundary_type(ResolvedWindowFrameExpr::BoundaryType v) && {
    node_->set_boundary_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedWindowFrameExprBuilder& set_boundary_type(ResolvedWindowFrameExpr::BoundaryType v) & {
    node_->set_boundary_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedExpr* expression() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expression();
  }

  std::unique_ptr<const ResolvedExpr> release_expression() {
    return node_->release_expression();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedWindowFrameExprBuilder&& set_expression(T v) && {
    node_->set_expression(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedWindowFrameExprBuilder& set_expression(T v) & {
    node_->set_expression(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedWindowFrameExprBuilder&& set_expression(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedWindowFrameExprBuilder& set_expression(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedWindowFrameExpr> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedWindowFrameExprBuilder ToBuilder(
      std::unique_ptr<const ResolvedWindowFrameExpr> node);

  ResolvedWindowFrameExprBuilder(std::unique_ptr<ResolvedWindowFrameExpr> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedWindowFrameExprBuilder ToBuilder(
    std::unique_ptr<const ResolvedWindowFrameExpr> node) {
  ResolvedWindowFrameExprBuilder builder(absl::WrapUnique<ResolvedWindowFrameExpr>(
      const_cast<ResolvedWindowFrameExpr*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedDMLValueBuilder final {
 public:
  ResolvedDMLValueBuilder() : ResolvedDMLValueBuilder(absl::WrapUnique(new ResolvedDMLValue)) {}

  ResolvedDMLValueBuilder(const ResolvedDMLValueBuilder&) = delete;
  ResolvedDMLValueBuilder& operator=(const ResolvedDMLValueBuilder&) = delete;
  ResolvedDMLValueBuilder(ResolvedDMLValueBuilder&& other)
      : ResolvedDMLValueBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDMLValueBuilder& operator=(ResolvedDMLValueBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDMLValue>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDMLValue::value was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* value() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->value();
  }

  std::unique_ptr<const ResolvedExpr> release_value() {
    return node_->release_value();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedDMLValueBuilder&& set_value(T v) && {
    node_->set_value(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedDMLValueBuilder& set_value(T v) & {
    node_->set_value(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedDMLValueBuilder&& set_value(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_value(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedDMLValueBuilder& set_value(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_value(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDMLValue> node_;

  absl::Status deferred_build_status_;
  std::bitset<1> field_is_set_ = {0};
  friend ResolvedDMLValueBuilder ToBuilder(
      std::unique_ptr<const ResolvedDMLValue> node);

  ResolvedDMLValueBuilder(std::unique_ptr<ResolvedDMLValue> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDMLValueBuilder ToBuilder(
    std::unique_ptr<const ResolvedDMLValue> node) {
  ResolvedDMLValueBuilder builder(absl::WrapUnique<ResolvedDMLValue>(
      const_cast<ResolvedDMLValue*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedDMLDefaultBuilder final {
 public:
  ResolvedDMLDefaultBuilder() : ResolvedDMLDefaultBuilder(absl::WrapUnique(new ResolvedDMLDefault)) {}

  ResolvedDMLDefaultBuilder(const ResolvedDMLDefaultBuilder&) = delete;
  ResolvedDMLDefaultBuilder& operator=(const ResolvedDMLDefaultBuilder&) = delete;
  ResolvedDMLDefaultBuilder(ResolvedDMLDefaultBuilder&& other)
      : ResolvedDMLDefaultBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDMLDefaultBuilder& operator=(ResolvedDMLDefaultBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDMLDefault>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDMLDefault::type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedDMLDefaultBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedDMLDefaultBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedDMLDefaultBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedDMLDefaultBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDMLDefault> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedDMLDefaultBuilder ToBuilder(
      std::unique_ptr<const ResolvedDMLDefault> node);

  ResolvedDMLDefaultBuilder(std::unique_ptr<ResolvedDMLDefault> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDMLDefaultBuilder ToBuilder(
    std::unique_ptr<const ResolvedDMLDefault> node) {
  ResolvedDMLDefaultBuilder builder(absl::WrapUnique<ResolvedDMLDefault>(
      const_cast<ResolvedDMLDefault*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedAssertStmtBuilder final {
 public:
  ResolvedAssertStmtBuilder() : ResolvedAssertStmtBuilder(absl::WrapUnique(new ResolvedAssertStmt)) {}

  ResolvedAssertStmtBuilder(const ResolvedAssertStmtBuilder&) = delete;
  ResolvedAssertStmtBuilder& operator=(const ResolvedAssertStmtBuilder&) = delete;
  ResolvedAssertStmtBuilder(ResolvedAssertStmtBuilder&& other)
      : ResolvedAssertStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAssertStmtBuilder& operator=(ResolvedAssertStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAssertStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAssertStmt::expression was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* expression() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expression();
  }

  std::unique_ptr<const ResolvedExpr> release_expression() {
    return node_->release_expression();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssertStmtBuilder&& set_expression(T v) && {
    node_->set_expression(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssertStmtBuilder& set_expression(T v) & {
    node_->set_expression(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssertStmtBuilder&& set_expression(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssertStmtBuilder& set_expression(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

  const std::string& description() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->description();
  }

  ResolvedAssertStmtBuilder&& set_description(const std::string& v) && {
    node_->set_description(v);

    return std::move(*this);
  }

  ResolvedAssertStmtBuilder& set_description(const std::string& v) & {
    node_->set_description(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAssertStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAssertStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAssertStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAssertStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAssertStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAssertStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAssertStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAssertStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAssertStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedAssertStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAssertStmt> node);

  ResolvedAssertStmtBuilder(std::unique_ptr<ResolvedAssertStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAssertStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAssertStmt> node) {
  ResolvedAssertStmtBuilder builder(absl::WrapUnique<ResolvedAssertStmt>(
      const_cast<ResolvedAssertStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedAssertRowsModifiedBuilder final {
 public:
  ResolvedAssertRowsModifiedBuilder() : ResolvedAssertRowsModifiedBuilder(absl::WrapUnique(new ResolvedAssertRowsModified)) {}

  ResolvedAssertRowsModifiedBuilder(const ResolvedAssertRowsModifiedBuilder&) = delete;
  ResolvedAssertRowsModifiedBuilder& operator=(const ResolvedAssertRowsModifiedBuilder&) = delete;
  ResolvedAssertRowsModifiedBuilder(ResolvedAssertRowsModifiedBuilder&& other)
      : ResolvedAssertRowsModifiedBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAssertRowsModifiedBuilder& operator=(ResolvedAssertRowsModifiedBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAssertRowsModified>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAssertRowsModified::rows was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* rows() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->rows();
  }

  std::unique_ptr<const ResolvedExpr> release_rows() {
    return node_->release_rows();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssertRowsModifiedBuilder&& set_rows(T v) && {
    node_->set_rows(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssertRowsModifiedBuilder& set_rows(T v) & {
    node_->set_rows(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssertRowsModifiedBuilder&& set_rows(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_rows(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssertRowsModifiedBuilder& set_rows(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_rows(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAssertRowsModified> node_;

  absl::Status deferred_build_status_;
  std::bitset<1> field_is_set_ = {0};
  friend ResolvedAssertRowsModifiedBuilder ToBuilder(
      std::unique_ptr<const ResolvedAssertRowsModified> node);

  ResolvedAssertRowsModifiedBuilder(std::unique_ptr<ResolvedAssertRowsModified> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAssertRowsModifiedBuilder ToBuilder(
    std::unique_ptr<const ResolvedAssertRowsModified> node) {
  ResolvedAssertRowsModifiedBuilder builder(absl::WrapUnique<ResolvedAssertRowsModified>(
      const_cast<ResolvedAssertRowsModified*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedInsertRowBuilder final {
 public:
  ResolvedInsertRowBuilder() : ResolvedInsertRowBuilder(absl::WrapUnique(new ResolvedInsertRow)) {}

  ResolvedInsertRowBuilder(const ResolvedInsertRowBuilder&) = delete;
  ResolvedInsertRowBuilder& operator=(const ResolvedInsertRowBuilder&) = delete;
  ResolvedInsertRowBuilder(ResolvedInsertRowBuilder&& other)
      : ResolvedInsertRowBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedInsertRowBuilder& operator=(ResolvedInsertRowBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedInsertRow>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedDMLValue>>& value_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->value_list();
  }

  int value_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->value_list_size();
  }

  const ResolvedDMLValue* value_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->value_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedDMLValue>>::value>>
  ResolvedInsertRowBuilder&& add_value_list(T v) && {
    node_->add_value_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedDMLValue>>::value>>
  ResolvedInsertRowBuilder& add_value_list(T v) & {
    node_->add_value_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedDMLValue>>::value>>
  ResolvedInsertRowBuilder&& add_value_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_value_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedDMLValue>>::value>>
  ResolvedInsertRowBuilder& add_value_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_value_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedDMLValue>> release_value_list() {
    return node_->release_value_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedDMLValue>>>::value>>
  ResolvedInsertRowBuilder&& set_value_list(T v) && {
    node_->set_value_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedDMLValue>>>::value>>
  ResolvedInsertRowBuilder& set_value_list(T v) & {
    node_->set_value_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedDMLValue>>>::value>>
  ResolvedInsertRowBuilder&& set_value_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_value_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedDMLValue>>>::value>>
  ResolvedInsertRowBuilder& set_value_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_value_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedInsertRow> node_;

  absl::Status deferred_build_status_;
  friend ResolvedInsertRowBuilder ToBuilder(
      std::unique_ptr<const ResolvedInsertRow> node);

  ResolvedInsertRowBuilder(std::unique_ptr<ResolvedInsertRow> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedInsertRowBuilder ToBuilder(
    std::unique_ptr<const ResolvedInsertRow> node) {
  ResolvedInsertRowBuilder builder(absl::WrapUnique<ResolvedInsertRow>(
      const_cast<ResolvedInsertRow*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedInsertStmtBuilder final {
 public:
    typedef ResolvedInsertStmtEnums::InsertMode InsertMode;
  static const InsertMode OR_ERROR = ResolvedInsertStmtEnums::OR_ERROR;
  static const InsertMode OR_IGNORE = ResolvedInsertStmtEnums::OR_IGNORE;
  static const InsertMode OR_REPLACE = ResolvedInsertStmtEnums::OR_REPLACE;
  static const InsertMode OR_UPDATE = ResolvedInsertStmtEnums::OR_UPDATE;

  std::string GetInsertModeString() const;
  static std::string InsertModeToString(InsertMode boundary_type);

  ResolvedInsertStmtBuilder() : ResolvedInsertStmtBuilder(absl::WrapUnique(new ResolvedInsertStmt)) {}

  ResolvedInsertStmtBuilder(const ResolvedInsertStmtBuilder&) = delete;
  ResolvedInsertStmtBuilder& operator=(const ResolvedInsertStmtBuilder&) = delete;
  ResolvedInsertStmtBuilder(ResolvedInsertStmtBuilder&& other)
      : ResolvedInsertStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedInsertStmtBuilder& operator=(ResolvedInsertStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedInsertStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedTableScan* table_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_scan();
  }

  std::unique_ptr<const ResolvedTableScan> release_table_scan() {
    return node_->release_table_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedInsertStmtBuilder&& set_table_scan(T v) && {
    node_->set_table_scan(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedInsertStmtBuilder& set_table_scan(T v) & {
    node_->set_table_scan(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedInsertStmtBuilder&& set_table_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedInsertStmtBuilder& set_table_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Behavior on duplicate rows (normally defined to mean duplicate
  // primary keys).
  ResolvedInsertStmt::InsertMode insert_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->insert_mode();
  }

  ResolvedInsertStmtBuilder&& set_insert_mode(ResolvedInsertStmt::InsertMode v) && {
    node_->set_insert_mode(v);

    return std::move(*this);
  }

  ResolvedInsertStmtBuilder& set_insert_mode(ResolvedInsertStmt::InsertMode v) & {
    node_->set_insert_mode(v);

    return *this;
  }

  const ResolvedAssertRowsModified* assert_rows_modified() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->assert_rows_modified();
  }

  std::unique_ptr<const ResolvedAssertRowsModified> release_assert_rows_modified() {
    return node_->release_assert_rows_modified();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAssertRowsModified>>::value>>
  ResolvedInsertStmtBuilder&& set_assert_rows_modified(T v) && {
    node_->set_assert_rows_modified(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAssertRowsModified>>::value>>
  ResolvedInsertStmtBuilder& set_assert_rows_modified(T v) & {
    node_->set_assert_rows_modified(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAssertRowsModified>>::value>>
  ResolvedInsertStmtBuilder&& set_assert_rows_modified(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_assert_rows_modified(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAssertRowsModified>>::value>>
  ResolvedInsertStmtBuilder& set_assert_rows_modified(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_assert_rows_modified(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedReturningClause* returning() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->returning();
  }

  std::unique_ptr<const ResolvedReturningClause> release_returning() {
    return node_->release_returning();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedReturningClause>>::value>>
  ResolvedInsertStmtBuilder&& set_returning(T v) && {
    node_->set_returning(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedReturningClause>>::value>>
  ResolvedInsertStmtBuilder& set_returning(T v) & {
    node_->set_returning(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedReturningClause>>::value>>
  ResolvedInsertStmtBuilder&& set_returning(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_returning(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedReturningClause>>::value>>
  ResolvedInsertStmtBuilder& set_returning(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_returning(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& insert_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->insert_column_list();
  }

  int insert_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->insert_column_list_size();
  }

  const ResolvedColumn& insert_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->insert_column_list(i);
  }

  ResolvedInsertStmtBuilder&& add_insert_column_list(ResolvedColumn v) && {
    node_->add_insert_column_list(v);

    return std::move(*this);
  }

  ResolvedInsertStmtBuilder& add_insert_column_list(ResolvedColumn v) & {
    node_->add_insert_column_list(v);

    return *this;
  }

  ResolvedInsertStmtBuilder&& set_insert_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_insert_column_list(v);

    return std::move(*this);
  }

  ResolvedInsertStmtBuilder& set_insert_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_insert_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedColumnRef>>& query_parameter_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query_parameter_list();
  }

  int query_parameter_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query_parameter_list_size();
  }

  const ResolvedColumnRef* query_parameter_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query_parameter_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedInsertStmtBuilder&& add_query_parameter_list(T v) && {
    node_->add_query_parameter_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedInsertStmtBuilder& add_query_parameter_list(T v) & {
    node_->add_query_parameter_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedInsertStmtBuilder&& add_query_parameter_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_query_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedInsertStmtBuilder& add_query_parameter_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_query_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnRef>> release_query_parameter_list() {
    return node_->release_query_parameter_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedInsertStmtBuilder&& set_query_parameter_list(T v) && {
    node_->set_query_parameter_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedInsertStmtBuilder& set_query_parameter_list(T v) & {
    node_->set_query_parameter_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedInsertStmtBuilder&& set_query_parameter_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedInsertStmtBuilder& set_query_parameter_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query_parameter_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedScan* query() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query();
  }

  std::unique_ptr<const ResolvedScan> release_query() {
    return node_->release_query();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedInsertStmtBuilder&& set_query(T v) && {
    node_->set_query(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedInsertStmtBuilder& set_query(T v) & {
    node_->set_query(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedInsertStmtBuilder&& set_query(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedInsertStmtBuilder& set_query(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& query_output_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query_output_column_list();
  }

  int query_output_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query_output_column_list_size();
  }

  const ResolvedColumn& query_output_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query_output_column_list(i);
  }

  ResolvedInsertStmtBuilder&& add_query_output_column_list(ResolvedColumn v) && {
    node_->add_query_output_column_list(v);

    return std::move(*this);
  }

  ResolvedInsertStmtBuilder& add_query_output_column_list(ResolvedColumn v) & {
    node_->add_query_output_column_list(v);

    return *this;
  }

  ResolvedInsertStmtBuilder&& set_query_output_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_query_output_column_list(v);

    return std::move(*this);
  }

  ResolvedInsertStmtBuilder& set_query_output_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_query_output_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedInsertRow>>& row_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->row_list();
  }

  int row_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->row_list_size();
  }

  const ResolvedInsertRow* row_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->row_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedInsertRow>>::value>>
  ResolvedInsertStmtBuilder&& add_row_list(T v) && {
    node_->add_row_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedInsertRow>>::value>>
  ResolvedInsertStmtBuilder& add_row_list(T v) & {
    node_->add_row_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedInsertRow>>::value>>
  ResolvedInsertStmtBuilder&& add_row_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_row_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedInsertRow>>::value>>
  ResolvedInsertStmtBuilder& add_row_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_row_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedInsertRow>> release_row_list() {
    return node_->release_row_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedInsertRow>>>::value>>
  ResolvedInsertStmtBuilder&& set_row_list(T v) && {
    node_->set_row_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedInsertRow>>>::value>>
  ResolvedInsertStmtBuilder& set_row_list(T v) & {
    node_->set_row_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedInsertRow>>>::value>>
  ResolvedInsertStmtBuilder&& set_row_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_row_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedInsertRow>>>::value>>
  ResolvedInsertStmtBuilder& set_row_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_row_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedStatement::ObjectAccess>& column_access_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_access_list();
  }

  int column_access_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_access_list_size();
  }

  ResolvedStatement::ObjectAccess column_access_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_access_list(i);
  }

  ResolvedInsertStmtBuilder&& add_column_access_list(ResolvedStatement::ObjectAccess v) && {
    node_->add_column_access_list(v);

    return std::move(*this);
  }

  ResolvedInsertStmtBuilder& add_column_access_list(ResolvedStatement::ObjectAccess v) & {
    node_->add_column_access_list(v);

    return *this;
  }

  ResolvedInsertStmtBuilder&& set_column_access_list(const std::vector<ResolvedStatement::ObjectAccess>& v) && {
    node_->set_column_access_list(v);

    return std::move(*this);
  }

  ResolvedInsertStmtBuilder& set_column_access_list(const std::vector<ResolvedStatement::ObjectAccess>& v) & {
    node_->set_column_access_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedInsertStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedInsertStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedInsertStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedInsertStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedInsertStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedInsertStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedInsertStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedInsertStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedInsertStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedInsertStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedInsertStmt> node);

  ResolvedInsertStmtBuilder(std::unique_ptr<ResolvedInsertStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedInsertStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedInsertStmt> node) {
  ResolvedInsertStmtBuilder builder(absl::WrapUnique<ResolvedInsertStmt>(
      const_cast<ResolvedInsertStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedDeleteStmtBuilder final {
 public:
  ResolvedDeleteStmtBuilder() : ResolvedDeleteStmtBuilder(absl::WrapUnique(new ResolvedDeleteStmt)) {}

  ResolvedDeleteStmtBuilder(const ResolvedDeleteStmtBuilder&) = delete;
  ResolvedDeleteStmtBuilder& operator=(const ResolvedDeleteStmtBuilder&) = delete;
  ResolvedDeleteStmtBuilder(ResolvedDeleteStmtBuilder&& other)
      : ResolvedDeleteStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDeleteStmtBuilder& operator=(ResolvedDeleteStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDeleteStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(6)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDeleteStmt::where_expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedTableScan* table_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_scan();
  }

  std::unique_ptr<const ResolvedTableScan> release_table_scan() {
    return node_->release_table_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedDeleteStmtBuilder&& set_table_scan(T v) && {
    node_->set_table_scan(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedDeleteStmtBuilder& set_table_scan(T v) & {
    node_->set_table_scan(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedDeleteStmtBuilder&& set_table_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedDeleteStmtBuilder& set_table_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedAssertRowsModified* assert_rows_modified() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->assert_rows_modified();
  }

  std::unique_ptr<const ResolvedAssertRowsModified> release_assert_rows_modified() {
    return node_->release_assert_rows_modified();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAssertRowsModified>>::value>>
  ResolvedDeleteStmtBuilder&& set_assert_rows_modified(T v) && {
    node_->set_assert_rows_modified(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAssertRowsModified>>::value>>
  ResolvedDeleteStmtBuilder& set_assert_rows_modified(T v) & {
    node_->set_assert_rows_modified(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAssertRowsModified>>::value>>
  ResolvedDeleteStmtBuilder&& set_assert_rows_modified(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_assert_rows_modified(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAssertRowsModified>>::value>>
  ResolvedDeleteStmtBuilder& set_assert_rows_modified(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_assert_rows_modified(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedReturningClause* returning() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->returning();
  }

  std::unique_ptr<const ResolvedReturningClause> release_returning() {
    return node_->release_returning();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedReturningClause>>::value>>
  ResolvedDeleteStmtBuilder&& set_returning(T v) && {
    node_->set_returning(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedReturningClause>>::value>>
  ResolvedDeleteStmtBuilder& set_returning(T v) & {
    node_->set_returning(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedReturningClause>>::value>>
  ResolvedDeleteStmtBuilder&& set_returning(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_returning(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedReturningClause>>::value>>
  ResolvedDeleteStmtBuilder& set_returning(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_returning(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedStatement::ObjectAccess>& column_access_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_access_list();
  }

  int column_access_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_access_list_size();
  }

  ResolvedStatement::ObjectAccess column_access_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_access_list(i);
  }

  ResolvedDeleteStmtBuilder&& add_column_access_list(ResolvedStatement::ObjectAccess v) && {
    node_->add_column_access_list(v);

    return std::move(*this);
  }

  ResolvedDeleteStmtBuilder& add_column_access_list(ResolvedStatement::ObjectAccess v) & {
    node_->add_column_access_list(v);

    return *this;
  }

  ResolvedDeleteStmtBuilder&& set_column_access_list(const std::vector<ResolvedStatement::ObjectAccess>& v) && {
    node_->set_column_access_list(v);

    return std::move(*this);
  }

  ResolvedDeleteStmtBuilder& set_column_access_list(const std::vector<ResolvedStatement::ObjectAccess>& v) & {
    node_->set_column_access_list(v);

    return *this;
  }

  const ResolvedColumnHolder* array_offset_column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->array_offset_column();
  }

  std::unique_ptr<const ResolvedColumnHolder> release_array_offset_column() {
    return node_->release_array_offset_column();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedDeleteStmtBuilder&& set_array_offset_column(T v) && {
    node_->set_array_offset_column(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedDeleteStmtBuilder& set_array_offset_column(T v) & {
    node_->set_array_offset_column(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedDeleteStmtBuilder&& set_array_offset_column(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_offset_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedDeleteStmtBuilder& set_array_offset_column(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_offset_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedExpr* where_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->where_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_where_expr() {
    return node_->release_where_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedDeleteStmtBuilder&& set_where_expr(T v) && {
    node_->set_where_expr(std::move(v));
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedDeleteStmtBuilder& set_where_expr(T v) & {
    node_->set_where_expr(std::move(v));
    field_is_set_.set(6, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedDeleteStmtBuilder&& set_where_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_where_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedDeleteStmtBuilder& set_where_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_where_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(6, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDeleteStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDeleteStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDeleteStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDeleteStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDeleteStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDeleteStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDeleteStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDeleteStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDeleteStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<7> field_is_set_ = {0};
  friend ResolvedDeleteStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedDeleteStmt> node);

  ResolvedDeleteStmtBuilder(std::unique_ptr<ResolvedDeleteStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDeleteStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedDeleteStmt> node) {
  ResolvedDeleteStmtBuilder builder(absl::WrapUnique<ResolvedDeleteStmt>(
      const_cast<ResolvedDeleteStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(6, true);
  return builder;
}

class ResolvedUpdateItemBuilder final {
 public:
  ResolvedUpdateItemBuilder() : ResolvedUpdateItemBuilder(absl::WrapUnique(new ResolvedUpdateItem)) {}

  ResolvedUpdateItemBuilder(const ResolvedUpdateItemBuilder&) = delete;
  ResolvedUpdateItemBuilder& operator=(const ResolvedUpdateItemBuilder&) = delete;
  ResolvedUpdateItemBuilder(ResolvedUpdateItemBuilder&& other)
      : ResolvedUpdateItemBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedUpdateItemBuilder& operator=(ResolvedUpdateItemBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedUpdateItem>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedUpdateItem::target was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedUpdateItem::element_column was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // The target entity to be updated.
  //
  // This is an expression evaluated using the ResolvedColumns visible
  // inside this statement.  This expression can contain only
  // ResolvedColumnRefs, ResolvedGetProtoField and
  // ResolvedGetStructField nodes.
  //
  // In a top-level UPDATE, the expression always starts with a
  // ResolvedColumnRef referencing a column from the statement's
  // TableScan.
  //
  // In a nested UPDATE, the expression always starts with a
  // ResolvedColumnRef referencing the element_column from the
  // ResolvedUpdateItem containing this scan.
  //
  // This node is also used to represent a modification of a single
  // array element (when it occurs as a child of a
  // ResolvedUpdateArrayItem node).  In that case, the expression
  // starts with a ResolvedColumnRef referencing the <element_column>
  // from its grandparent ResolvedUpdateItem. (E.g., for "SET a[<expr>]
  // = 5", the grandparent ResolvedUpdateItem has <target> "a", the
  // parent ResolvedUpdateArrayItem has offset <expr>, and this node
  // has <set_value> 5 and target corresponding to the grandparent's
  // <element_column> field.)
  //
  // For either a nested UPDATE or an array modification, there may be
  // a path of field accesses after the initial ResolvedColumnRef,
  // represented by a chain of GetField nodes.
  //
  // NOTE: We use the same GetField nodes as we do for queries, but
  // they are not treated the same.  Here, they express a path inside
  // an object that is being mutated, so they have reference semantics.
  const ResolvedExpr* target() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->target();
  }

  std::unique_ptr<const ResolvedExpr> release_target() {
    return node_->release_target();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUpdateItemBuilder&& set_target(T v) && {
    node_->set_target(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUpdateItemBuilder& set_target(T v) & {
    node_->set_target(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUpdateItemBuilder&& set_target(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_target(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUpdateItemBuilder& set_target(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_target(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

  // Set the target entity to this value.  The types must match.
  // This can contain the same columns that can appear in the
  // <where_expr> of the enclosing ResolvedUpdateStmt.
  //
  // This is mutually exclusive with all fields below, which are used
  // for nested updates only.
  const ResolvedDMLValue* set_value() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->set_value();
  }

  std::unique_ptr<const ResolvedDMLValue> release_set_value() {
    return node_->release_set_value();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedDMLValue>>::value>>
  ResolvedUpdateItemBuilder&& set_set_value(T v) && {
    node_->set_set_value(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedDMLValue>>::value>>
  ResolvedUpdateItemBuilder& set_set_value(T v) & {
    node_->set_set_value(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedDMLValue>>::value>>
  ResolvedUpdateItemBuilder&& set_set_value(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_set_value(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedDMLValue>>::value>>
  ResolvedUpdateItemBuilder& set_set_value(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_set_value(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // The ResolvedColumn introduced to represent the elements of the
  // array being updated.  This works similarly to
  // ArrayScan::element_column.
  //
  // <target> must have array type, and this column has the array's
  // element type.
  //
  // This column can be referenced inside the nested statements below.
  const ResolvedColumnHolder* element_column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->element_column();
  }

  std::unique_ptr<const ResolvedColumnHolder> release_element_column() {
    return node_->release_element_column();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedUpdateItemBuilder&& set_element_column(T v) && {
    node_->set_element_column(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedUpdateItemBuilder& set_element_column(T v) & {
    node_->set_element_column(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedUpdateItemBuilder&& set_element_column(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_element_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedUpdateItemBuilder& set_element_column(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_element_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

  // Array element modifications to apply. Each item runs on the value
  // of <element_column> specified by ResolvedUpdateArrayItem.offset.
  // This field is always empty if the analyzer option
  // FEATURE_V_1_2_ARRAY_ELEMENTS_WITH_SET is disabled.
  //
  // The engine must fail if two elements in this list have offset
  // expressions that evaluate to the same value.
  // TODO: Consider generalizing this to allow
  // SET a[<expr1>].b = ..., a[<expr2>].c = ...
  const std::vector<std::unique_ptr<const ResolvedUpdateArrayItem>>& array_update_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->array_update_list();
  }

  int array_update_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->array_update_list_size();
  }

  const ResolvedUpdateArrayItem* array_update_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->array_update_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUpdateArrayItem>>::value>>
  ResolvedUpdateItemBuilder&& add_array_update_list(T v) && {
    node_->add_array_update_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUpdateArrayItem>>::value>>
  ResolvedUpdateItemBuilder& add_array_update_list(T v) & {
    node_->add_array_update_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUpdateArrayItem>>::value>>
  ResolvedUpdateItemBuilder&& add_array_update_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_array_update_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUpdateArrayItem>>::value>>
  ResolvedUpdateItemBuilder& add_array_update_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_array_update_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedUpdateArrayItem>> release_array_update_list() {
    return node_->release_array_update_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedUpdateArrayItem>>>::value>>
  ResolvedUpdateItemBuilder&& set_array_update_list(T v) && {
    node_->set_array_update_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedUpdateArrayItem>>>::value>>
  ResolvedUpdateItemBuilder& set_array_update_list(T v) & {
    node_->set_array_update_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedUpdateArrayItem>>>::value>>
  ResolvedUpdateItemBuilder&& set_array_update_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_update_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedUpdateArrayItem>>>::value>>
  ResolvedUpdateItemBuilder& set_array_update_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_update_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Nested DELETE statements to apply.  Each delete runs on one value
  // of <element_column> and may choose to delete that array element.
  //
  // DELETEs are applied before INSERTs or UPDATEs.
  //
  // It is legal for the same input element to match multiple DELETEs.
  const std::vector<std::unique_ptr<const ResolvedDeleteStmt>>& delete_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->delete_list();
  }

  int delete_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->delete_list_size();
  }

  const ResolvedDeleteStmt* delete_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->delete_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedDeleteStmt>>::value>>
  ResolvedUpdateItemBuilder&& add_delete_list(T v) && {
    node_->add_delete_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedDeleteStmt>>::value>>
  ResolvedUpdateItemBuilder& add_delete_list(T v) & {
    node_->add_delete_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedDeleteStmt>>::value>>
  ResolvedUpdateItemBuilder&& add_delete_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_delete_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedDeleteStmt>>::value>>
  ResolvedUpdateItemBuilder& add_delete_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_delete_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedDeleteStmt>> release_delete_list() {
    return node_->release_delete_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedDeleteStmt>>>::value>>
  ResolvedUpdateItemBuilder&& set_delete_list(T v) && {
    node_->set_delete_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedDeleteStmt>>>::value>>
  ResolvedUpdateItemBuilder& set_delete_list(T v) & {
    node_->set_delete_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedDeleteStmt>>>::value>>
  ResolvedUpdateItemBuilder&& set_delete_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_delete_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedDeleteStmt>>>::value>>
  ResolvedUpdateItemBuilder& set_delete_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_delete_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Nested UPDATE statements to apply.  Each update runs on one value
  // of <element_column> and may choose to update that array element.
  //
  // UPDATEs are applied after DELETEs and before INSERTs.
  //
  // It is an error if any element is matched by multiple UPDATEs.
  const std::vector<std::unique_ptr<const ResolvedUpdateStmt>>& update_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->update_list();
  }

  int update_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->update_list_size();
  }

  const ResolvedUpdateStmt* update_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->update_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUpdateStmt>>::value>>
  ResolvedUpdateItemBuilder&& add_update_list(T v) && {
    node_->add_update_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUpdateStmt>>::value>>
  ResolvedUpdateItemBuilder& add_update_list(T v) & {
    node_->add_update_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUpdateStmt>>::value>>
  ResolvedUpdateItemBuilder&& add_update_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_update_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUpdateStmt>>::value>>
  ResolvedUpdateItemBuilder& add_update_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_update_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedUpdateStmt>> release_update_list() {
    return node_->release_update_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedUpdateStmt>>>::value>>
  ResolvedUpdateItemBuilder&& set_update_list(T v) && {
    node_->set_update_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedUpdateStmt>>>::value>>
  ResolvedUpdateItemBuilder& set_update_list(T v) & {
    node_->set_update_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedUpdateStmt>>>::value>>
  ResolvedUpdateItemBuilder&& set_update_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_update_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedUpdateStmt>>>::value>>
  ResolvedUpdateItemBuilder& set_update_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_update_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Nested INSERT statements to apply.  Each insert will produce zero
  // or more values for <element_column>.
  //
  // INSERTs are applied after DELETEs and UPDATEs.
  //
  // For nested UPDATEs, insert_mode will always be the default, and
  // has no effect.
  const std::vector<std::unique_ptr<const ResolvedInsertStmt>>& insert_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->insert_list();
  }

  int insert_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->insert_list_size();
  }

  const ResolvedInsertStmt* insert_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->insert_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedInsertStmt>>::value>>
  ResolvedUpdateItemBuilder&& add_insert_list(T v) && {
    node_->add_insert_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedInsertStmt>>::value>>
  ResolvedUpdateItemBuilder& add_insert_list(T v) & {
    node_->add_insert_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedInsertStmt>>::value>>
  ResolvedUpdateItemBuilder&& add_insert_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_insert_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedInsertStmt>>::value>>
  ResolvedUpdateItemBuilder& add_insert_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_insert_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedInsertStmt>> release_insert_list() {
    return node_->release_insert_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedInsertStmt>>>::value>>
  ResolvedUpdateItemBuilder&& set_insert_list(T v) && {
    node_->set_insert_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedInsertStmt>>>::value>>
  ResolvedUpdateItemBuilder& set_insert_list(T v) & {
    node_->set_insert_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedInsertStmt>>>::value>>
  ResolvedUpdateItemBuilder&& set_insert_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_insert_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedInsertStmt>>>::value>>
  ResolvedUpdateItemBuilder& set_insert_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_insert_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedUpdateItem> node_;

  absl::Status deferred_build_status_;
  std::bitset<7> field_is_set_ = {0};
  friend ResolvedUpdateItemBuilder ToBuilder(
      std::unique_ptr<const ResolvedUpdateItem> node);

  ResolvedUpdateItemBuilder(std::unique_ptr<ResolvedUpdateItem> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedUpdateItemBuilder ToBuilder(
    std::unique_ptr<const ResolvedUpdateItem> node) {
  ResolvedUpdateItemBuilder builder(absl::WrapUnique<ResolvedUpdateItem>(
      const_cast<ResolvedUpdateItem*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedUpdateArrayItemBuilder final {
 public:
  ResolvedUpdateArrayItemBuilder() : ResolvedUpdateArrayItemBuilder(absl::WrapUnique(new ResolvedUpdateArrayItem)) {}

  ResolvedUpdateArrayItemBuilder(const ResolvedUpdateArrayItemBuilder&) = delete;
  ResolvedUpdateArrayItemBuilder& operator=(const ResolvedUpdateArrayItemBuilder&) = delete;
  ResolvedUpdateArrayItemBuilder(ResolvedUpdateArrayItemBuilder&& other)
      : ResolvedUpdateArrayItemBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedUpdateArrayItemBuilder& operator=(ResolvedUpdateArrayItemBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedUpdateArrayItem>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedUpdateArrayItem::offset was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedUpdateArrayItem::update_item was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // The array offset to be modified.
  const ResolvedExpr* offset() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->offset();
  }

  std::unique_ptr<const ResolvedExpr> release_offset() {
    return node_->release_offset();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUpdateArrayItemBuilder&& set_offset(T v) && {
    node_->set_offset(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUpdateArrayItemBuilder& set_offset(T v) & {
    node_->set_offset(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUpdateArrayItemBuilder&& set_offset(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_offset(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUpdateArrayItemBuilder& set_offset(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_offset(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

  // The modification to perform to the array element.
  const ResolvedUpdateItem* update_item() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->update_item();
  }

  std::unique_ptr<const ResolvedUpdateItem> release_update_item() {
    return node_->release_update_item();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUpdateItem>>::value>>
  ResolvedUpdateArrayItemBuilder&& set_update_item(T v) && {
    node_->set_update_item(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUpdateItem>>::value>>
  ResolvedUpdateArrayItemBuilder& set_update_item(T v) & {
    node_->set_update_item(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUpdateItem>>::value>>
  ResolvedUpdateArrayItemBuilder&& set_update_item(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_update_item(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUpdateItem>>::value>>
  ResolvedUpdateArrayItemBuilder& set_update_item(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_update_item(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedUpdateArrayItem> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedUpdateArrayItemBuilder ToBuilder(
      std::unique_ptr<const ResolvedUpdateArrayItem> node);

  ResolvedUpdateArrayItemBuilder(std::unique_ptr<ResolvedUpdateArrayItem> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedUpdateArrayItemBuilder ToBuilder(
    std::unique_ptr<const ResolvedUpdateArrayItem> node) {
  ResolvedUpdateArrayItemBuilder builder(absl::WrapUnique<ResolvedUpdateArrayItem>(
      const_cast<ResolvedUpdateArrayItem*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedUpdateStmtBuilder final {
 public:
  ResolvedUpdateStmtBuilder() : ResolvedUpdateStmtBuilder(absl::WrapUnique(new ResolvedUpdateStmt)) {}

  ResolvedUpdateStmtBuilder(const ResolvedUpdateStmtBuilder&) = delete;
  ResolvedUpdateStmtBuilder& operator=(const ResolvedUpdateStmtBuilder&) = delete;
  ResolvedUpdateStmtBuilder(ResolvedUpdateStmtBuilder&& other)
      : ResolvedUpdateStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedUpdateStmtBuilder& operator=(ResolvedUpdateStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedUpdateStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(6)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedUpdateStmt::where_expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedTableScan* table_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_scan();
  }

  std::unique_ptr<const ResolvedTableScan> release_table_scan() {
    return node_->release_table_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedUpdateStmtBuilder&& set_table_scan(T v) && {
    node_->set_table_scan(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedUpdateStmtBuilder& set_table_scan(T v) & {
    node_->set_table_scan(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedUpdateStmtBuilder&& set_table_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedUpdateStmtBuilder& set_table_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedStatement::ObjectAccess>& column_access_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_access_list();
  }

  int column_access_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_access_list_size();
  }

  ResolvedStatement::ObjectAccess column_access_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_access_list(i);
  }

  ResolvedUpdateStmtBuilder&& add_column_access_list(ResolvedStatement::ObjectAccess v) && {
    node_->add_column_access_list(v);

    return std::move(*this);
  }

  ResolvedUpdateStmtBuilder& add_column_access_list(ResolvedStatement::ObjectAccess v) & {
    node_->add_column_access_list(v);

    return *this;
  }

  ResolvedUpdateStmtBuilder&& set_column_access_list(const std::vector<ResolvedStatement::ObjectAccess>& v) && {
    node_->set_column_access_list(v);

    return std::move(*this);
  }

  ResolvedUpdateStmtBuilder& set_column_access_list(const std::vector<ResolvedStatement::ObjectAccess>& v) & {
    node_->set_column_access_list(v);

    return *this;
  }

  const ResolvedAssertRowsModified* assert_rows_modified() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->assert_rows_modified();
  }

  std::unique_ptr<const ResolvedAssertRowsModified> release_assert_rows_modified() {
    return node_->release_assert_rows_modified();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAssertRowsModified>>::value>>
  ResolvedUpdateStmtBuilder&& set_assert_rows_modified(T v) && {
    node_->set_assert_rows_modified(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAssertRowsModified>>::value>>
  ResolvedUpdateStmtBuilder& set_assert_rows_modified(T v) & {
    node_->set_assert_rows_modified(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAssertRowsModified>>::value>>
  ResolvedUpdateStmtBuilder&& set_assert_rows_modified(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_assert_rows_modified(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAssertRowsModified>>::value>>
  ResolvedUpdateStmtBuilder& set_assert_rows_modified(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_assert_rows_modified(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedReturningClause* returning() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->returning();
  }

  std::unique_ptr<const ResolvedReturningClause> release_returning() {
    return node_->release_returning();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedReturningClause>>::value>>
  ResolvedUpdateStmtBuilder&& set_returning(T v) && {
    node_->set_returning(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedReturningClause>>::value>>
  ResolvedUpdateStmtBuilder& set_returning(T v) & {
    node_->set_returning(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedReturningClause>>::value>>
  ResolvedUpdateStmtBuilder&& set_returning(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_returning(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedReturningClause>>::value>>
  ResolvedUpdateStmtBuilder& set_returning(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_returning(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedColumnHolder* array_offset_column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->array_offset_column();
  }

  std::unique_ptr<const ResolvedColumnHolder> release_array_offset_column() {
    return node_->release_array_offset_column();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedUpdateStmtBuilder&& set_array_offset_column(T v) && {
    node_->set_array_offset_column(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedUpdateStmtBuilder& set_array_offset_column(T v) & {
    node_->set_array_offset_column(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedUpdateStmtBuilder&& set_array_offset_column(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_offset_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedUpdateStmtBuilder& set_array_offset_column(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_array_offset_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedExpr* where_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->where_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_where_expr() {
    return node_->release_where_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUpdateStmtBuilder&& set_where_expr(T v) && {
    node_->set_where_expr(std::move(v));
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUpdateStmtBuilder& set_where_expr(T v) & {
    node_->set_where_expr(std::move(v));
    field_is_set_.set(6, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUpdateStmtBuilder&& set_where_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_where_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedUpdateStmtBuilder& set_where_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_where_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(6, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedUpdateItem>>& update_item_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->update_item_list();
  }

  int update_item_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->update_item_list_size();
  }

  const ResolvedUpdateItem* update_item_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->update_item_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUpdateItem>>::value>>
  ResolvedUpdateStmtBuilder&& add_update_item_list(T v) && {
    node_->add_update_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUpdateItem>>::value>>
  ResolvedUpdateStmtBuilder& add_update_item_list(T v) & {
    node_->add_update_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUpdateItem>>::value>>
  ResolvedUpdateStmtBuilder&& add_update_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_update_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUpdateItem>>::value>>
  ResolvedUpdateStmtBuilder& add_update_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_update_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedUpdateItem>> release_update_item_list() {
    return node_->release_update_item_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedUpdateItem>>>::value>>
  ResolvedUpdateStmtBuilder&& set_update_item_list(T v) && {
    node_->set_update_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedUpdateItem>>>::value>>
  ResolvedUpdateStmtBuilder& set_update_item_list(T v) & {
    node_->set_update_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedUpdateItem>>>::value>>
  ResolvedUpdateStmtBuilder&& set_update_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_update_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedUpdateItem>>>::value>>
  ResolvedUpdateStmtBuilder& set_update_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_update_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedScan* from_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->from_scan();
  }

  std::unique_ptr<const ResolvedScan> release_from_scan() {
    return node_->release_from_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedUpdateStmtBuilder&& set_from_scan(T v) && {
    node_->set_from_scan(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedUpdateStmtBuilder& set_from_scan(T v) & {
    node_->set_from_scan(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedUpdateStmtBuilder&& set_from_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_from_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedUpdateStmtBuilder& set_from_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_from_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedUpdateStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedUpdateStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedUpdateStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedUpdateStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedUpdateStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedUpdateStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedUpdateStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedUpdateStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedUpdateStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<9> field_is_set_ = {0};
  friend ResolvedUpdateStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedUpdateStmt> node);

  ResolvedUpdateStmtBuilder(std::unique_ptr<ResolvedUpdateStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedUpdateStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedUpdateStmt> node) {
  ResolvedUpdateStmtBuilder builder(absl::WrapUnique<ResolvedUpdateStmt>(
      const_cast<ResolvedUpdateStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(6, true);
  return builder;
}

class ResolvedMergeWhenBuilder final {
 public:
    typedef ResolvedMergeWhenEnums::MatchType MatchType;
  typedef ResolvedMergeWhenEnums::ActionType ActionType;
  static const MatchType MATCHED = ResolvedMergeWhenEnums::MATCHED;
  static const MatchType NOT_MATCHED_BY_SOURCE = ResolvedMergeWhenEnums::NOT_MATCHED_BY_SOURCE;
  static const MatchType NOT_MATCHED_BY_TARGET = ResolvedMergeWhenEnums::NOT_MATCHED_BY_TARGET;
  static const ActionType INSERT = ResolvedMergeWhenEnums::INSERT;
  static const ActionType UPDATE = ResolvedMergeWhenEnums::UPDATE;
  static const ActionType DELETE = ResolvedMergeWhenEnums::DELETE;

  ResolvedMergeWhenBuilder() : ResolvedMergeWhenBuilder(absl::WrapUnique(new ResolvedMergeWhen)) {}

  ResolvedMergeWhenBuilder(const ResolvedMergeWhenBuilder&) = delete;
  ResolvedMergeWhenBuilder& operator=(const ResolvedMergeWhenBuilder&) = delete;
  ResolvedMergeWhenBuilder(ResolvedMergeWhenBuilder&& other)
      : ResolvedMergeWhenBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedMergeWhenBuilder& operator=(ResolvedMergeWhenBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedMergeWhen>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedMergeWhen::match_type was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedMergeWhen::match_expr was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedMergeWhen::action_type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  ResolvedMergeWhen::MatchType match_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->match_type();
  }

  ResolvedMergeWhenBuilder&& set_match_type(ResolvedMergeWhen::MatchType v) && {
    node_->set_match_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedMergeWhenBuilder& set_match_type(ResolvedMergeWhen::MatchType v) & {
    node_->set_match_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedExpr* match_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->match_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_match_expr() {
    return node_->release_match_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMergeWhenBuilder&& set_match_expr(T v) && {
    node_->set_match_expr(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMergeWhenBuilder& set_match_expr(T v) & {
    node_->set_match_expr(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMergeWhenBuilder&& set_match_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_match_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMergeWhenBuilder& set_match_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_match_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

  ResolvedMergeWhen::ActionType action_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->action_type();
  }

  ResolvedMergeWhenBuilder&& set_action_type(ResolvedMergeWhen::ActionType v) && {
    node_->set_action_type(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedMergeWhenBuilder& set_action_type(ResolvedMergeWhen::ActionType v) & {
    node_->set_action_type(v);
    field_is_set_.set(2, true);

    return *this;
  }

  const std::vector<ResolvedColumn>& insert_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->insert_column_list();
  }

  int insert_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->insert_column_list_size();
  }

  const ResolvedColumn& insert_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->insert_column_list(i);
  }

  ResolvedMergeWhenBuilder&& add_insert_column_list(ResolvedColumn v) && {
    node_->add_insert_column_list(v);

    return std::move(*this);
  }

  ResolvedMergeWhenBuilder& add_insert_column_list(ResolvedColumn v) & {
    node_->add_insert_column_list(v);

    return *this;
  }

  ResolvedMergeWhenBuilder&& set_insert_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_insert_column_list(v);

    return std::move(*this);
  }

  ResolvedMergeWhenBuilder& set_insert_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_insert_column_list(v);

    return *this;
  }

  const ResolvedInsertRow* insert_row() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->insert_row();
  }

  std::unique_ptr<const ResolvedInsertRow> release_insert_row() {
    return node_->release_insert_row();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedInsertRow>>::value>>
  ResolvedMergeWhenBuilder&& set_insert_row(T v) && {
    node_->set_insert_row(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedInsertRow>>::value>>
  ResolvedMergeWhenBuilder& set_insert_row(T v) & {
    node_->set_insert_row(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedInsertRow>>::value>>
  ResolvedMergeWhenBuilder&& set_insert_row(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_insert_row(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedInsertRow>>::value>>
  ResolvedMergeWhenBuilder& set_insert_row(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_insert_row(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedUpdateItem>>& update_item_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->update_item_list();
  }

  int update_item_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->update_item_list_size();
  }

  const ResolvedUpdateItem* update_item_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->update_item_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUpdateItem>>::value>>
  ResolvedMergeWhenBuilder&& add_update_item_list(T v) && {
    node_->add_update_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUpdateItem>>::value>>
  ResolvedMergeWhenBuilder& add_update_item_list(T v) & {
    node_->add_update_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUpdateItem>>::value>>
  ResolvedMergeWhenBuilder&& add_update_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_update_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUpdateItem>>::value>>
  ResolvedMergeWhenBuilder& add_update_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_update_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedUpdateItem>> release_update_item_list() {
    return node_->release_update_item_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedUpdateItem>>>::value>>
  ResolvedMergeWhenBuilder&& set_update_item_list(T v) && {
    node_->set_update_item_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedUpdateItem>>>::value>>
  ResolvedMergeWhenBuilder& set_update_item_list(T v) & {
    node_->set_update_item_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedUpdateItem>>>::value>>
  ResolvedMergeWhenBuilder&& set_update_item_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_update_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedUpdateItem>>>::value>>
  ResolvedMergeWhenBuilder& set_update_item_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_update_item_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedMergeWhen> node_;

  absl::Status deferred_build_status_;
  std::bitset<6> field_is_set_ = {0};
  friend ResolvedMergeWhenBuilder ToBuilder(
      std::unique_ptr<const ResolvedMergeWhen> node);

  ResolvedMergeWhenBuilder(std::unique_ptr<ResolvedMergeWhen> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedMergeWhenBuilder ToBuilder(
    std::unique_ptr<const ResolvedMergeWhen> node) {
  ResolvedMergeWhenBuilder builder(absl::WrapUnique<ResolvedMergeWhen>(
      const_cast<ResolvedMergeWhen*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedMergeStmtBuilder final {
 public:
  ResolvedMergeStmtBuilder() : ResolvedMergeStmtBuilder(absl::WrapUnique(new ResolvedMergeStmt)) {}

  ResolvedMergeStmtBuilder(const ResolvedMergeStmtBuilder&) = delete;
  ResolvedMergeStmtBuilder& operator=(const ResolvedMergeStmtBuilder&) = delete;
  ResolvedMergeStmtBuilder(ResolvedMergeStmtBuilder&& other)
      : ResolvedMergeStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedMergeStmtBuilder& operator=(ResolvedMergeStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedMergeStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedMergeStmt::table_scan was not set on the builder");
    }
    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedMergeStmt::from_scan was not set on the builder");
    }
    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedMergeStmt::merge_expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedTableScan* table_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_scan();
  }

  std::unique_ptr<const ResolvedTableScan> release_table_scan() {
    return node_->release_table_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedMergeStmtBuilder&& set_table_scan(T v) && {
    node_->set_table_scan(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedMergeStmtBuilder& set_table_scan(T v) & {
    node_->set_table_scan(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedMergeStmtBuilder&& set_table_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedMergeStmtBuilder& set_table_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<ResolvedStatement::ObjectAccess>& column_access_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_access_list();
  }

  int column_access_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_access_list_size();
  }

  ResolvedStatement::ObjectAccess column_access_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_access_list(i);
  }

  ResolvedMergeStmtBuilder&& add_column_access_list(ResolvedStatement::ObjectAccess v) && {
    node_->add_column_access_list(v);

    return std::move(*this);
  }

  ResolvedMergeStmtBuilder& add_column_access_list(ResolvedStatement::ObjectAccess v) & {
    node_->add_column_access_list(v);

    return *this;
  }

  ResolvedMergeStmtBuilder&& set_column_access_list(const std::vector<ResolvedStatement::ObjectAccess>& v) && {
    node_->set_column_access_list(v);

    return std::move(*this);
  }

  ResolvedMergeStmtBuilder& set_column_access_list(const std::vector<ResolvedStatement::ObjectAccess>& v) & {
    node_->set_column_access_list(v);

    return *this;
  }

  const ResolvedScan* from_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->from_scan();
  }

  std::unique_ptr<const ResolvedScan> release_from_scan() {
    return node_->release_from_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedMergeStmtBuilder&& set_from_scan(T v) && {
    node_->set_from_scan(std::move(v));
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedMergeStmtBuilder& set_from_scan(T v) & {
    node_->set_from_scan(std::move(v));
    field_is_set_.set(3, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedMergeStmtBuilder&& set_from_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_from_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedMergeStmtBuilder& set_from_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_from_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return *this;
  }

  const ResolvedExpr* merge_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->merge_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_merge_expr() {
    return node_->release_merge_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMergeStmtBuilder&& set_merge_expr(T v) && {
    node_->set_merge_expr(std::move(v));
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMergeStmtBuilder& set_merge_expr(T v) & {
    node_->set_merge_expr(std::move(v));
    field_is_set_.set(4, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMergeStmtBuilder&& set_merge_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_merge_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedMergeStmtBuilder& set_merge_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_merge_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedMergeWhen>>& when_clause_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->when_clause_list();
  }

  int when_clause_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->when_clause_list_size();
  }

  const ResolvedMergeWhen* when_clause_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->when_clause_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedMergeWhen>>::value>>
  ResolvedMergeStmtBuilder&& add_when_clause_list(T v) && {
    node_->add_when_clause_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedMergeWhen>>::value>>
  ResolvedMergeStmtBuilder& add_when_clause_list(T v) & {
    node_->add_when_clause_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedMergeWhen>>::value>>
  ResolvedMergeStmtBuilder&& add_when_clause_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_when_clause_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedMergeWhen>>::value>>
  ResolvedMergeStmtBuilder& add_when_clause_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_when_clause_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedMergeWhen>> release_when_clause_list() {
    return node_->release_when_clause_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedMergeWhen>>>::value>>
  ResolvedMergeStmtBuilder&& set_when_clause_list(T v) && {
    node_->set_when_clause_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedMergeWhen>>>::value>>
  ResolvedMergeStmtBuilder& set_when_clause_list(T v) & {
    node_->set_when_clause_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedMergeWhen>>>::value>>
  ResolvedMergeStmtBuilder&& set_when_clause_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_when_clause_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedMergeWhen>>>::value>>
  ResolvedMergeStmtBuilder& set_when_clause_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_when_clause_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedMergeStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedMergeStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedMergeStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedMergeStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedMergeStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedMergeStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedMergeStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedMergeStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedMergeStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<6> field_is_set_ = {0};
  friend ResolvedMergeStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedMergeStmt> node);

  ResolvedMergeStmtBuilder(std::unique_ptr<ResolvedMergeStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedMergeStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedMergeStmt> node) {
  ResolvedMergeStmtBuilder builder(absl::WrapUnique<ResolvedMergeStmt>(
      const_cast<ResolvedMergeStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(3, true);
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedTruncateStmtBuilder final {
 public:
  ResolvedTruncateStmtBuilder() : ResolvedTruncateStmtBuilder(absl::WrapUnique(new ResolvedTruncateStmt)) {}

  ResolvedTruncateStmtBuilder(const ResolvedTruncateStmtBuilder&) = delete;
  ResolvedTruncateStmtBuilder& operator=(const ResolvedTruncateStmtBuilder&) = delete;
  ResolvedTruncateStmtBuilder(ResolvedTruncateStmtBuilder&& other)
      : ResolvedTruncateStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedTruncateStmtBuilder& operator=(ResolvedTruncateStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedTruncateStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedTruncateStmt::table_scan was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedTruncateStmt::where_expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedTableScan* table_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_scan();
  }

  std::unique_ptr<const ResolvedTableScan> release_table_scan() {
    return node_->release_table_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedTruncateStmtBuilder&& set_table_scan(T v) && {
    node_->set_table_scan(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedTruncateStmtBuilder& set_table_scan(T v) & {
    node_->set_table_scan(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedTruncateStmtBuilder&& set_table_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedTruncateStmtBuilder& set_table_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

  const ResolvedExpr* where_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->where_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_where_expr() {
    return node_->release_where_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedTruncateStmtBuilder&& set_where_expr(T v) && {
    node_->set_where_expr(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedTruncateStmtBuilder& set_where_expr(T v) & {
    node_->set_where_expr(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedTruncateStmtBuilder&& set_where_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_where_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedTruncateStmtBuilder& set_where_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_where_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedTruncateStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedTruncateStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedTruncateStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedTruncateStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedTruncateStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedTruncateStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedTruncateStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedTruncateStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedTruncateStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedTruncateStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedTruncateStmt> node);

  ResolvedTruncateStmtBuilder(std::unique_ptr<ResolvedTruncateStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedTruncateStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedTruncateStmt> node) {
  ResolvedTruncateStmtBuilder builder(absl::WrapUnique<ResolvedTruncateStmt>(
      const_cast<ResolvedTruncateStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedObjectUnitBuilder final {
 public:
  ResolvedObjectUnitBuilder() : ResolvedObjectUnitBuilder(absl::WrapUnique(new ResolvedObjectUnit)) {}

  ResolvedObjectUnitBuilder(const ResolvedObjectUnitBuilder&) = delete;
  ResolvedObjectUnitBuilder& operator=(const ResolvedObjectUnitBuilder&) = delete;
  ResolvedObjectUnitBuilder(ResolvedObjectUnitBuilder&& other)
      : ResolvedObjectUnitBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedObjectUnitBuilder& operator=(ResolvedObjectUnitBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedObjectUnit>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedObjectUnitBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedObjectUnitBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedObjectUnitBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedObjectUnitBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedObjectUnit> node_;

  absl::Status deferred_build_status_;
  friend ResolvedObjectUnitBuilder ToBuilder(
      std::unique_ptr<const ResolvedObjectUnit> node);

  ResolvedObjectUnitBuilder(std::unique_ptr<ResolvedObjectUnit> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedObjectUnitBuilder ToBuilder(
    std::unique_ptr<const ResolvedObjectUnit> node) {
  ResolvedObjectUnitBuilder builder(absl::WrapUnique<ResolvedObjectUnit>(
      const_cast<ResolvedObjectUnit*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedPrivilegeBuilder final {
 public:
  ResolvedPrivilegeBuilder() : ResolvedPrivilegeBuilder(absl::WrapUnique(new ResolvedPrivilege)) {}

  ResolvedPrivilegeBuilder(const ResolvedPrivilegeBuilder&) = delete;
  ResolvedPrivilegeBuilder& operator=(const ResolvedPrivilegeBuilder&) = delete;
  ResolvedPrivilegeBuilder(ResolvedPrivilegeBuilder&& other)
      : ResolvedPrivilegeBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedPrivilegeBuilder& operator=(ResolvedPrivilegeBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedPrivilege>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedPrivilege::action_type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& action_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->action_type();
  }

  ResolvedPrivilegeBuilder&& set_action_type(const std::string& v) && {
    node_->set_action_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedPrivilegeBuilder& set_action_type(const std::string& v) & {
    node_->set_action_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedObjectUnit>>& unit_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->unit_list();
  }

  int unit_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->unit_list_size();
  }

  const ResolvedObjectUnit* unit_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->unit_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedObjectUnit>>::value>>
  ResolvedPrivilegeBuilder&& add_unit_list(T v) && {
    node_->add_unit_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedObjectUnit>>::value>>
  ResolvedPrivilegeBuilder& add_unit_list(T v) & {
    node_->add_unit_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedObjectUnit>>::value>>
  ResolvedPrivilegeBuilder&& add_unit_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_unit_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedObjectUnit>>::value>>
  ResolvedPrivilegeBuilder& add_unit_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_unit_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedObjectUnit>> release_unit_list() {
    return node_->release_unit_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedObjectUnit>>>::value>>
  ResolvedPrivilegeBuilder&& set_unit_list(T v) && {
    node_->set_unit_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedObjectUnit>>>::value>>
  ResolvedPrivilegeBuilder& set_unit_list(T v) & {
    node_->set_unit_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedObjectUnit>>>::value>>
  ResolvedPrivilegeBuilder&& set_unit_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_unit_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedObjectUnit>>>::value>>
  ResolvedPrivilegeBuilder& set_unit_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_unit_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedPrivilege> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedPrivilegeBuilder ToBuilder(
      std::unique_ptr<const ResolvedPrivilege> node);

  ResolvedPrivilegeBuilder(std::unique_ptr<ResolvedPrivilege> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedPrivilegeBuilder ToBuilder(
    std::unique_ptr<const ResolvedPrivilege> node) {
  ResolvedPrivilegeBuilder builder(absl::WrapUnique<ResolvedPrivilege>(
      const_cast<ResolvedPrivilege*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedGrantStmtBuilder final {
 public:
  ResolvedGrantStmtBuilder() : ResolvedGrantStmtBuilder(absl::WrapUnique(new ResolvedGrantStmt)) {}

  ResolvedGrantStmtBuilder(const ResolvedGrantStmtBuilder&) = delete;
  ResolvedGrantStmtBuilder& operator=(const ResolvedGrantStmtBuilder&) = delete;
  ResolvedGrantStmtBuilder(ResolvedGrantStmtBuilder&& other)
      : ResolvedGrantStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedGrantStmtBuilder& operator=(ResolvedGrantStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedGrantStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedGrantStmt::object_type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedGrantStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedGrantStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedGrantStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedGrantStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedGrantStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedGrantStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedGrantStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedGrantStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedPrivilege>>& privilege_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->privilege_list();
  }

  int privilege_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->privilege_list_size();
  }

  const ResolvedPrivilege* privilege_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->privilege_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedGrantStmtBuilder&& add_privilege_list(T v) && {
    node_->add_privilege_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedGrantStmtBuilder& add_privilege_list(T v) & {
    node_->add_privilege_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedGrantStmtBuilder&& add_privilege_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedGrantStmtBuilder& add_privilege_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedPrivilege>> release_privilege_list() {
    return node_->release_privilege_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedGrantStmtBuilder&& set_privilege_list(T v) && {
    node_->set_privilege_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedGrantStmtBuilder& set_privilege_list(T v) & {
    node_->set_privilege_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedGrantStmtBuilder&& set_privilege_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedGrantStmtBuilder& set_privilege_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::string& object_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->object_type();
  }

  ResolvedGrantStmtBuilder&& set_object_type(const std::string& v) && {
    node_->set_object_type(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedGrantStmtBuilder& set_object_type(const std::string& v) & {
    node_->set_object_type(v);
    field_is_set_.set(2, true);

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedGrantStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedGrantStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedGrantStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedGrantStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::string>& grantee_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_list();
  }

  int grantee_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_list_size();
  }

  const std::string& grantee_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_list(i);
  }

  ResolvedGrantStmtBuilder&& add_grantee_list(std::string v) && {
    node_->add_grantee_list(v);

    return std::move(*this);
  }

  ResolvedGrantStmtBuilder& add_grantee_list(std::string v) & {
    node_->add_grantee_list(v);

    return *this;
  }

  ResolvedGrantStmtBuilder&& set_grantee_list(const std::vector<std::string>& v) && {
    node_->set_grantee_list(v);

    return std::move(*this);
  }

  ResolvedGrantStmtBuilder& set_grantee_list(const std::vector<std::string>& v) & {
    node_->set_grantee_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& grantee_expr_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_expr_list();
  }

  int grantee_expr_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_expr_list_size();
  }

  const ResolvedExpr* grantee_expr_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_expr_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGrantStmtBuilder&& add_grantee_expr_list(T v) && {
    node_->add_grantee_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGrantStmtBuilder& add_grantee_expr_list(T v) & {
    node_->add_grantee_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGrantStmtBuilder&& add_grantee_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGrantStmtBuilder& add_grantee_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_grantee_expr_list() {
    return node_->release_grantee_expr_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedGrantStmtBuilder&& set_grantee_expr_list(T v) && {
    node_->set_grantee_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedGrantStmtBuilder& set_grantee_expr_list(T v) & {
    node_->set_grantee_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedGrantStmtBuilder&& set_grantee_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedGrantStmtBuilder& set_grantee_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedGrantStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<6> field_is_set_ = {0};
  friend ResolvedGrantStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedGrantStmt> node);

  ResolvedGrantStmtBuilder(std::unique_ptr<ResolvedGrantStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedGrantStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedGrantStmt> node) {
  ResolvedGrantStmtBuilder builder(absl::WrapUnique<ResolvedGrantStmt>(
      const_cast<ResolvedGrantStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedRevokeStmtBuilder final {
 public:
  ResolvedRevokeStmtBuilder() : ResolvedRevokeStmtBuilder(absl::WrapUnique(new ResolvedRevokeStmt)) {}

  ResolvedRevokeStmtBuilder(const ResolvedRevokeStmtBuilder&) = delete;
  ResolvedRevokeStmtBuilder& operator=(const ResolvedRevokeStmtBuilder&) = delete;
  ResolvedRevokeStmtBuilder(ResolvedRevokeStmtBuilder&& other)
      : ResolvedRevokeStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedRevokeStmtBuilder& operator=(ResolvedRevokeStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedRevokeStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedRevokeStmt::object_type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRevokeStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRevokeStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRevokeStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRevokeStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRevokeStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRevokeStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRevokeStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRevokeStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedPrivilege>>& privilege_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->privilege_list();
  }

  int privilege_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->privilege_list_size();
  }

  const ResolvedPrivilege* privilege_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->privilege_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedRevokeStmtBuilder&& add_privilege_list(T v) && {
    node_->add_privilege_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedRevokeStmtBuilder& add_privilege_list(T v) & {
    node_->add_privilege_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedRevokeStmtBuilder&& add_privilege_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedRevokeStmtBuilder& add_privilege_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedPrivilege>> release_privilege_list() {
    return node_->release_privilege_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedRevokeStmtBuilder&& set_privilege_list(T v) && {
    node_->set_privilege_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedRevokeStmtBuilder& set_privilege_list(T v) & {
    node_->set_privilege_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedRevokeStmtBuilder&& set_privilege_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedRevokeStmtBuilder& set_privilege_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::string& object_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->object_type();
  }

  ResolvedRevokeStmtBuilder&& set_object_type(const std::string& v) && {
    node_->set_object_type(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedRevokeStmtBuilder& set_object_type(const std::string& v) & {
    node_->set_object_type(v);
    field_is_set_.set(2, true);

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedRevokeStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedRevokeStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedRevokeStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedRevokeStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::string>& grantee_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_list();
  }

  int grantee_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_list_size();
  }

  const std::string& grantee_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_list(i);
  }

  ResolvedRevokeStmtBuilder&& add_grantee_list(std::string v) && {
    node_->add_grantee_list(v);

    return std::move(*this);
  }

  ResolvedRevokeStmtBuilder& add_grantee_list(std::string v) & {
    node_->add_grantee_list(v);

    return *this;
  }

  ResolvedRevokeStmtBuilder&& set_grantee_list(const std::vector<std::string>& v) && {
    node_->set_grantee_list(v);

    return std::move(*this);
  }

  ResolvedRevokeStmtBuilder& set_grantee_list(const std::vector<std::string>& v) & {
    node_->set_grantee_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& grantee_expr_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_expr_list();
  }

  int grantee_expr_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_expr_list_size();
  }

  const ResolvedExpr* grantee_expr_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_expr_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRevokeStmtBuilder&& add_grantee_expr_list(T v) && {
    node_->add_grantee_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRevokeStmtBuilder& add_grantee_expr_list(T v) & {
    node_->add_grantee_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRevokeStmtBuilder&& add_grantee_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRevokeStmtBuilder& add_grantee_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_grantee_expr_list() {
    return node_->release_grantee_expr_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRevokeStmtBuilder&& set_grantee_expr_list(T v) && {
    node_->set_grantee_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRevokeStmtBuilder& set_grantee_expr_list(T v) & {
    node_->set_grantee_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRevokeStmtBuilder&& set_grantee_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRevokeStmtBuilder& set_grantee_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedRevokeStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<6> field_is_set_ = {0};
  friend ResolvedRevokeStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedRevokeStmt> node);

  ResolvedRevokeStmtBuilder(std::unique_ptr<ResolvedRevokeStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedRevokeStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedRevokeStmt> node) {
  ResolvedRevokeStmtBuilder builder(absl::WrapUnique<ResolvedRevokeStmt>(
      const_cast<ResolvedRevokeStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedAlterDatabaseStmtBuilder final {
 public:
  ResolvedAlterDatabaseStmtBuilder() : ResolvedAlterDatabaseStmtBuilder(absl::WrapUnique(new ResolvedAlterDatabaseStmt)) {}

  ResolvedAlterDatabaseStmtBuilder(const ResolvedAlterDatabaseStmtBuilder&) = delete;
  ResolvedAlterDatabaseStmtBuilder& operator=(const ResolvedAlterDatabaseStmtBuilder&) = delete;
  ResolvedAlterDatabaseStmtBuilder(ResolvedAlterDatabaseStmtBuilder&& other)
      : ResolvedAlterDatabaseStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedAlterDatabaseStmtBuilder& operator=(ResolvedAlterDatabaseStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterDatabaseStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterDatabaseStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterDatabaseStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterDatabaseStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterDatabaseStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterDatabaseStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterDatabaseStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterDatabaseStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterDatabaseStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedAlterDatabaseStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterDatabaseStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedAlterDatabaseStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterDatabaseStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedAlterAction>>& alter_action_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list();
  }

  int alter_action_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list_size();
  }

  const ResolvedAlterAction* alter_action_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterDatabaseStmtBuilder&& add_alter_action_list(T v) && {
    node_->add_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterDatabaseStmtBuilder& add_alter_action_list(T v) & {
    node_->add_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterDatabaseStmtBuilder&& add_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterDatabaseStmtBuilder& add_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedAlterAction>> release_alter_action_list() {
    return node_->release_alter_action_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterDatabaseStmtBuilder&& set_alter_action_list(T v) && {
    node_->set_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterDatabaseStmtBuilder& set_alter_action_list(T v) & {
    node_->set_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterDatabaseStmtBuilder&& set_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterDatabaseStmtBuilder& set_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterDatabaseStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterDatabaseStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterDatabaseStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedAlterDatabaseStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterDatabaseStmt> node);

  ResolvedAlterDatabaseStmtBuilder(std::unique_ptr<ResolvedAlterDatabaseStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterDatabaseStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterDatabaseStmt> node) {
  ResolvedAlterDatabaseStmtBuilder builder(absl::WrapUnique<ResolvedAlterDatabaseStmt>(
      const_cast<ResolvedAlterDatabaseStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedAlterMaterializedViewStmtBuilder final {
 public:
  ResolvedAlterMaterializedViewStmtBuilder() : ResolvedAlterMaterializedViewStmtBuilder(absl::WrapUnique(new ResolvedAlterMaterializedViewStmt)) {}

  ResolvedAlterMaterializedViewStmtBuilder(const ResolvedAlterMaterializedViewStmtBuilder&) = delete;
  ResolvedAlterMaterializedViewStmtBuilder& operator=(const ResolvedAlterMaterializedViewStmtBuilder&) = delete;
  ResolvedAlterMaterializedViewStmtBuilder(ResolvedAlterMaterializedViewStmtBuilder&& other)
      : ResolvedAlterMaterializedViewStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedAlterMaterializedViewStmtBuilder& operator=(ResolvedAlterMaterializedViewStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterMaterializedViewStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedAlterMaterializedViewStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterMaterializedViewStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedAlterMaterializedViewStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterMaterializedViewStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedAlterAction>>& alter_action_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list();
  }

  int alter_action_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list_size();
  }

  const ResolvedAlterAction* alter_action_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder&& add_alter_action_list(T v) && {
    node_->add_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder& add_alter_action_list(T v) & {
    node_->add_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder&& add_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder& add_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedAlterAction>> release_alter_action_list() {
    return node_->release_alter_action_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder&& set_alter_action_list(T v) && {
    node_->set_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder& set_alter_action_list(T v) & {
    node_->set_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder&& set_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterMaterializedViewStmtBuilder& set_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterMaterializedViewStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterMaterializedViewStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterMaterializedViewStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedAlterMaterializedViewStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterMaterializedViewStmt> node);

  ResolvedAlterMaterializedViewStmtBuilder(std::unique_ptr<ResolvedAlterMaterializedViewStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterMaterializedViewStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterMaterializedViewStmt> node) {
  ResolvedAlterMaterializedViewStmtBuilder builder(absl::WrapUnique<ResolvedAlterMaterializedViewStmt>(
      const_cast<ResolvedAlterMaterializedViewStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedAlterSchemaStmtBuilder final {
 public:
  ResolvedAlterSchemaStmtBuilder() : ResolvedAlterSchemaStmtBuilder(absl::WrapUnique(new ResolvedAlterSchemaStmt)) {}

  ResolvedAlterSchemaStmtBuilder(const ResolvedAlterSchemaStmtBuilder&) = delete;
  ResolvedAlterSchemaStmtBuilder& operator=(const ResolvedAlterSchemaStmtBuilder&) = delete;
  ResolvedAlterSchemaStmtBuilder(ResolvedAlterSchemaStmtBuilder&& other)
      : ResolvedAlterSchemaStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedAlterSchemaStmtBuilder& operator=(ResolvedAlterSchemaStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterSchemaStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterSchemaStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterSchemaStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterSchemaStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterSchemaStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterSchemaStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterSchemaStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterSchemaStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterSchemaStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedAlterSchemaStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterSchemaStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedAlterSchemaStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterSchemaStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedAlterAction>>& alter_action_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list();
  }

  int alter_action_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list_size();
  }

  const ResolvedAlterAction* alter_action_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterSchemaStmtBuilder&& add_alter_action_list(T v) && {
    node_->add_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterSchemaStmtBuilder& add_alter_action_list(T v) & {
    node_->add_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterSchemaStmtBuilder&& add_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterSchemaStmtBuilder& add_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedAlterAction>> release_alter_action_list() {
    return node_->release_alter_action_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterSchemaStmtBuilder&& set_alter_action_list(T v) && {
    node_->set_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterSchemaStmtBuilder& set_alter_action_list(T v) & {
    node_->set_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterSchemaStmtBuilder&& set_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterSchemaStmtBuilder& set_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterSchemaStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterSchemaStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterSchemaStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedAlterSchemaStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterSchemaStmt> node);

  ResolvedAlterSchemaStmtBuilder(std::unique_ptr<ResolvedAlterSchemaStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterSchemaStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterSchemaStmt> node) {
  ResolvedAlterSchemaStmtBuilder builder(absl::WrapUnique<ResolvedAlterSchemaStmt>(
      const_cast<ResolvedAlterSchemaStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedAlterModelStmtBuilder final {
 public:
  ResolvedAlterModelStmtBuilder() : ResolvedAlterModelStmtBuilder(absl::WrapUnique(new ResolvedAlterModelStmt)) {}

  ResolvedAlterModelStmtBuilder(const ResolvedAlterModelStmtBuilder&) = delete;
  ResolvedAlterModelStmtBuilder& operator=(const ResolvedAlterModelStmtBuilder&) = delete;
  ResolvedAlterModelStmtBuilder(ResolvedAlterModelStmtBuilder&& other)
      : ResolvedAlterModelStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedAlterModelStmtBuilder& operator=(ResolvedAlterModelStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterModelStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterModelStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterModelStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterModelStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterModelStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterModelStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterModelStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterModelStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterModelStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedAlterModelStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterModelStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedAlterModelStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterModelStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedAlterAction>>& alter_action_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list();
  }

  int alter_action_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list_size();
  }

  const ResolvedAlterAction* alter_action_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterModelStmtBuilder&& add_alter_action_list(T v) && {
    node_->add_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterModelStmtBuilder& add_alter_action_list(T v) & {
    node_->add_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterModelStmtBuilder&& add_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterModelStmtBuilder& add_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedAlterAction>> release_alter_action_list() {
    return node_->release_alter_action_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterModelStmtBuilder&& set_alter_action_list(T v) && {
    node_->set_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterModelStmtBuilder& set_alter_action_list(T v) & {
    node_->set_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterModelStmtBuilder&& set_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterModelStmtBuilder& set_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterModelStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterModelStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterModelStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedAlterModelStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterModelStmt> node);

  ResolvedAlterModelStmtBuilder(std::unique_ptr<ResolvedAlterModelStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterModelStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterModelStmt> node) {
  ResolvedAlterModelStmtBuilder builder(absl::WrapUnique<ResolvedAlterModelStmt>(
      const_cast<ResolvedAlterModelStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedAlterTableStmtBuilder final {
 public:
  ResolvedAlterTableStmtBuilder() : ResolvedAlterTableStmtBuilder(absl::WrapUnique(new ResolvedAlterTableStmt)) {}

  ResolvedAlterTableStmtBuilder(const ResolvedAlterTableStmtBuilder&) = delete;
  ResolvedAlterTableStmtBuilder& operator=(const ResolvedAlterTableStmtBuilder&) = delete;
  ResolvedAlterTableStmtBuilder(ResolvedAlterTableStmtBuilder&& other)
      : ResolvedAlterTableStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedAlterTableStmtBuilder& operator=(ResolvedAlterTableStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterTableStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterTableStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterTableStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterTableStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterTableStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterTableStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterTableStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterTableStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterTableStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedAlterTableStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterTableStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedAlterTableStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterTableStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedAlterAction>>& alter_action_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list();
  }

  int alter_action_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list_size();
  }

  const ResolvedAlterAction* alter_action_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterTableStmtBuilder&& add_alter_action_list(T v) && {
    node_->add_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterTableStmtBuilder& add_alter_action_list(T v) & {
    node_->add_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterTableStmtBuilder&& add_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterTableStmtBuilder& add_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedAlterAction>> release_alter_action_list() {
    return node_->release_alter_action_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterTableStmtBuilder&& set_alter_action_list(T v) && {
    node_->set_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterTableStmtBuilder& set_alter_action_list(T v) & {
    node_->set_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterTableStmtBuilder&& set_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterTableStmtBuilder& set_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterTableStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterTableStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterTableStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedAlterTableStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterTableStmt> node);

  ResolvedAlterTableStmtBuilder(std::unique_ptr<ResolvedAlterTableStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterTableStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterTableStmt> node) {
  ResolvedAlterTableStmtBuilder builder(absl::WrapUnique<ResolvedAlterTableStmt>(
      const_cast<ResolvedAlterTableStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedAlterViewStmtBuilder final {
 public:
  ResolvedAlterViewStmtBuilder() : ResolvedAlterViewStmtBuilder(absl::WrapUnique(new ResolvedAlterViewStmt)) {}

  ResolvedAlterViewStmtBuilder(const ResolvedAlterViewStmtBuilder&) = delete;
  ResolvedAlterViewStmtBuilder& operator=(const ResolvedAlterViewStmtBuilder&) = delete;
  ResolvedAlterViewStmtBuilder(ResolvedAlterViewStmtBuilder&& other)
      : ResolvedAlterViewStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedAlterViewStmtBuilder& operator=(ResolvedAlterViewStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterViewStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterViewStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterViewStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterViewStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterViewStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterViewStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterViewStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterViewStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterViewStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedAlterViewStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterViewStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedAlterViewStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterViewStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedAlterAction>>& alter_action_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list();
  }

  int alter_action_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list_size();
  }

  const ResolvedAlterAction* alter_action_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterViewStmtBuilder&& add_alter_action_list(T v) && {
    node_->add_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterViewStmtBuilder& add_alter_action_list(T v) & {
    node_->add_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterViewStmtBuilder&& add_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterViewStmtBuilder& add_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedAlterAction>> release_alter_action_list() {
    return node_->release_alter_action_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterViewStmtBuilder&& set_alter_action_list(T v) && {
    node_->set_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterViewStmtBuilder& set_alter_action_list(T v) & {
    node_->set_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterViewStmtBuilder&& set_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterViewStmtBuilder& set_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterViewStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterViewStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterViewStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedAlterViewStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterViewStmt> node);

  ResolvedAlterViewStmtBuilder(std::unique_ptr<ResolvedAlterViewStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterViewStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterViewStmt> node) {
  ResolvedAlterViewStmtBuilder builder(absl::WrapUnique<ResolvedAlterViewStmt>(
      const_cast<ResolvedAlterViewStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedSetOptionsActionBuilder final {
 public:
  ResolvedSetOptionsActionBuilder() : ResolvedSetOptionsActionBuilder(absl::WrapUnique(new ResolvedSetOptionsAction)) {}

  ResolvedSetOptionsActionBuilder(const ResolvedSetOptionsActionBuilder&) = delete;
  ResolvedSetOptionsActionBuilder& operator=(const ResolvedSetOptionsActionBuilder&) = delete;
  ResolvedSetOptionsActionBuilder(ResolvedSetOptionsActionBuilder&& other)
      : ResolvedSetOptionsActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedSetOptionsActionBuilder& operator=(ResolvedSetOptionsActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedSetOptionsAction>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSetOptionsActionBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSetOptionsActionBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSetOptionsActionBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedSetOptionsActionBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSetOptionsActionBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSetOptionsActionBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSetOptionsActionBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedSetOptionsActionBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedSetOptionsAction> node_;

  absl::Status deferred_build_status_;
  friend ResolvedSetOptionsActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedSetOptionsAction> node);

  ResolvedSetOptionsActionBuilder(std::unique_ptr<ResolvedSetOptionsAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedSetOptionsActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedSetOptionsAction> node) {
  ResolvedSetOptionsActionBuilder builder(absl::WrapUnique<ResolvedSetOptionsAction>(
      const_cast<ResolvedSetOptionsAction*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedAlterSubEntityActionBuilder final {
 public:
  ResolvedAlterSubEntityActionBuilder() : ResolvedAlterSubEntityActionBuilder(absl::WrapUnique(new ResolvedAlterSubEntityAction)) {}

  ResolvedAlterSubEntityActionBuilder(const ResolvedAlterSubEntityActionBuilder&) = delete;
  ResolvedAlterSubEntityActionBuilder& operator=(const ResolvedAlterSubEntityActionBuilder&) = delete;
  ResolvedAlterSubEntityActionBuilder(ResolvedAlterSubEntityActionBuilder&& other)
      : ResolvedAlterSubEntityActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAlterSubEntityActionBuilder& operator=(ResolvedAlterSubEntityActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterSubEntityAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterSubEntityAction::entity_type was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterSubEntityAction::name was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterSubEntityAction::alter_action was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& entity_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->entity_type();
  }

  ResolvedAlterSubEntityActionBuilder&& set_entity_type(const std::string& v) && {
    node_->set_entity_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedAlterSubEntityActionBuilder& set_entity_type(const std::string& v) & {
    node_->set_entity_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedAlterSubEntityActionBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedAlterSubEntityActionBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const ResolvedAlterAction* alter_action() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action();
  }

  std::unique_ptr<const ResolvedAlterAction> release_alter_action() {
    return node_->release_alter_action();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterSubEntityActionBuilder&& set_alter_action(T v) && {
    node_->set_alter_action(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterSubEntityActionBuilder& set_alter_action(T v) & {
    node_->set_alter_action(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterSubEntityActionBuilder&& set_alter_action(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterSubEntityActionBuilder& set_alter_action(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterSubEntityActionBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterSubEntityActionBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterSubEntityAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedAlterSubEntityActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterSubEntityAction> node);

  ResolvedAlterSubEntityActionBuilder(std::unique_ptr<ResolvedAlterSubEntityAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterSubEntityActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterSubEntityAction> node) {
  ResolvedAlterSubEntityActionBuilder builder(absl::WrapUnique<ResolvedAlterSubEntityAction>(
      const_cast<ResolvedAlterSubEntityAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedAddSubEntityActionBuilder final {
 public:
  ResolvedAddSubEntityActionBuilder() : ResolvedAddSubEntityActionBuilder(absl::WrapUnique(new ResolvedAddSubEntityAction)) {}

  ResolvedAddSubEntityActionBuilder(const ResolvedAddSubEntityActionBuilder&) = delete;
  ResolvedAddSubEntityActionBuilder& operator=(const ResolvedAddSubEntityActionBuilder&) = delete;
  ResolvedAddSubEntityActionBuilder(ResolvedAddSubEntityActionBuilder&& other)
      : ResolvedAddSubEntityActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAddSubEntityActionBuilder& operator=(ResolvedAddSubEntityActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAddSubEntityAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAddSubEntityAction::entity_type was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAddSubEntityAction::name was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& entity_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->entity_type();
  }

  ResolvedAddSubEntityActionBuilder&& set_entity_type(const std::string& v) && {
    node_->set_entity_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedAddSubEntityActionBuilder& set_entity_type(const std::string& v) & {
    node_->set_entity_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedAddSubEntityActionBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedAddSubEntityActionBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& options_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->options_list();
  }

  int options_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->options_list_size();
  }

  const ResolvedOption* options_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->options_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAddSubEntityActionBuilder&& add_options_list(T v) && {
    node_->add_options_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAddSubEntityActionBuilder& add_options_list(T v) & {
    node_->add_options_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAddSubEntityActionBuilder&& add_options_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_options_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAddSubEntityActionBuilder& add_options_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_options_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_options_list() {
    return node_->release_options_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAddSubEntityActionBuilder&& set_options_list(T v) && {
    node_->set_options_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAddSubEntityActionBuilder& set_options_list(T v) & {
    node_->set_options_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAddSubEntityActionBuilder&& set_options_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_options_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAddSubEntityActionBuilder& set_options_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_options_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_if_not_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_not_exists();
  }

  ResolvedAddSubEntityActionBuilder&& set_is_if_not_exists(bool v) && {
    node_->set_is_if_not_exists(v);

    return std::move(*this);
  }

  ResolvedAddSubEntityActionBuilder& set_is_if_not_exists(bool v) & {
    node_->set_is_if_not_exists(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAddSubEntityAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedAddSubEntityActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedAddSubEntityAction> node);

  ResolvedAddSubEntityActionBuilder(std::unique_ptr<ResolvedAddSubEntityAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAddSubEntityActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedAddSubEntityAction> node) {
  ResolvedAddSubEntityActionBuilder builder(absl::WrapUnique<ResolvedAddSubEntityAction>(
      const_cast<ResolvedAddSubEntityAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedDropSubEntityActionBuilder final {
 public:
  ResolvedDropSubEntityActionBuilder() : ResolvedDropSubEntityActionBuilder(absl::WrapUnique(new ResolvedDropSubEntityAction)) {}

  ResolvedDropSubEntityActionBuilder(const ResolvedDropSubEntityActionBuilder&) = delete;
  ResolvedDropSubEntityActionBuilder& operator=(const ResolvedDropSubEntityActionBuilder&) = delete;
  ResolvedDropSubEntityActionBuilder(ResolvedDropSubEntityActionBuilder&& other)
      : ResolvedDropSubEntityActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDropSubEntityActionBuilder& operator=(ResolvedDropSubEntityActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDropSubEntityAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropSubEntityAction::entity_type was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropSubEntityAction::name was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& entity_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->entity_type();
  }

  ResolvedDropSubEntityActionBuilder&& set_entity_type(const std::string& v) && {
    node_->set_entity_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedDropSubEntityActionBuilder& set_entity_type(const std::string& v) & {
    node_->set_entity_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedDropSubEntityActionBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedDropSubEntityActionBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedDropSubEntityActionBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedDropSubEntityActionBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDropSubEntityAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedDropSubEntityActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedDropSubEntityAction> node);

  ResolvedDropSubEntityActionBuilder(std::unique_ptr<ResolvedDropSubEntityAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDropSubEntityActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedDropSubEntityAction> node) {
  ResolvedDropSubEntityActionBuilder builder(absl::WrapUnique<ResolvedDropSubEntityAction>(
      const_cast<ResolvedDropSubEntityAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedAddColumnActionBuilder final {
 public:
  ResolvedAddColumnActionBuilder() : ResolvedAddColumnActionBuilder(absl::WrapUnique(new ResolvedAddColumnAction)) {}

  ResolvedAddColumnActionBuilder(const ResolvedAddColumnActionBuilder&) = delete;
  ResolvedAddColumnActionBuilder& operator=(const ResolvedAddColumnActionBuilder&) = delete;
  ResolvedAddColumnActionBuilder(ResolvedAddColumnActionBuilder&& other)
      : ResolvedAddColumnActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAddColumnActionBuilder& operator=(ResolvedAddColumnActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAddColumnAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAddColumnAction::is_if_not_exists was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAddColumnAction::column_definition was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_not_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_not_exists();
  }

  ResolvedAddColumnActionBuilder&& set_is_if_not_exists(bool v) && {
    node_->set_is_if_not_exists(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedAddColumnActionBuilder& set_is_if_not_exists(bool v) & {
    node_->set_is_if_not_exists(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedColumnDefinition* column_definition() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition();
  }

  std::unique_ptr<const ResolvedColumnDefinition> release_column_definition() {
    return node_->release_column_definition();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedAddColumnActionBuilder&& set_column_definition(T v) && {
    node_->set_column_definition(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedAddColumnActionBuilder& set_column_definition(T v) & {
    node_->set_column_definition(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedAddColumnActionBuilder&& set_column_definition(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedAddColumnActionBuilder& set_column_definition(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAddColumnAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedAddColumnActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedAddColumnAction> node);

  ResolvedAddColumnActionBuilder(std::unique_ptr<ResolvedAddColumnAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAddColumnActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedAddColumnAction> node) {
  ResolvedAddColumnActionBuilder builder(absl::WrapUnique<ResolvedAddColumnAction>(
      const_cast<ResolvedAddColumnAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedAddConstraintActionBuilder final {
 public:
  ResolvedAddConstraintActionBuilder() : ResolvedAddConstraintActionBuilder(absl::WrapUnique(new ResolvedAddConstraintAction)) {}

  ResolvedAddConstraintActionBuilder(const ResolvedAddConstraintActionBuilder&) = delete;
  ResolvedAddConstraintActionBuilder& operator=(const ResolvedAddConstraintActionBuilder&) = delete;
  ResolvedAddConstraintActionBuilder(ResolvedAddConstraintActionBuilder&& other)
      : ResolvedAddConstraintActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAddConstraintActionBuilder& operator=(ResolvedAddConstraintActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAddConstraintAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAddConstraintAction::is_if_not_exists was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAddConstraintAction::constraint was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_not_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_not_exists();
  }

  ResolvedAddConstraintActionBuilder&& set_is_if_not_exists(bool v) && {
    node_->set_is_if_not_exists(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedAddConstraintActionBuilder& set_is_if_not_exists(bool v) & {
    node_->set_is_if_not_exists(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedConstraint* constraint() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->constraint();
  }

  std::unique_ptr<const ResolvedConstraint> release_constraint() {
    return node_->release_constraint();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConstraint>>::value>>
  ResolvedAddConstraintActionBuilder&& set_constraint(T v) && {
    node_->set_constraint(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConstraint>>::value>>
  ResolvedAddConstraintActionBuilder& set_constraint(T v) & {
    node_->set_constraint(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConstraint>>::value>>
  ResolvedAddConstraintActionBuilder&& set_constraint(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_constraint(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConstraint>>::value>>
  ResolvedAddConstraintActionBuilder& set_constraint(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_constraint(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

  const Table* table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table();
  }

  ResolvedAddConstraintActionBuilder&& set_table(const Table* v) && {
    node_->set_table(v);

    return std::move(*this);
  }

  ResolvedAddConstraintActionBuilder& set_table(const Table* v) & {
    node_->set_table(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAddConstraintAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedAddConstraintActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedAddConstraintAction> node);

  ResolvedAddConstraintActionBuilder(std::unique_ptr<ResolvedAddConstraintAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAddConstraintActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedAddConstraintAction> node) {
  ResolvedAddConstraintActionBuilder builder(absl::WrapUnique<ResolvedAddConstraintAction>(
      const_cast<ResolvedAddConstraintAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedDropConstraintActionBuilder final {
 public:
  ResolvedDropConstraintActionBuilder() : ResolvedDropConstraintActionBuilder(absl::WrapUnique(new ResolvedDropConstraintAction)) {}

  ResolvedDropConstraintActionBuilder(const ResolvedDropConstraintActionBuilder&) = delete;
  ResolvedDropConstraintActionBuilder& operator=(const ResolvedDropConstraintActionBuilder&) = delete;
  ResolvedDropConstraintActionBuilder(ResolvedDropConstraintActionBuilder&& other)
      : ResolvedDropConstraintActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDropConstraintActionBuilder& operator=(ResolvedDropConstraintActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDropConstraintAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropConstraintAction::is_if_exists was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropConstraintAction::name was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedDropConstraintActionBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedDropConstraintActionBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedDropConstraintActionBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedDropConstraintActionBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDropConstraintAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedDropConstraintActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedDropConstraintAction> node);

  ResolvedDropConstraintActionBuilder(std::unique_ptr<ResolvedDropConstraintAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDropConstraintActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedDropConstraintAction> node) {
  ResolvedDropConstraintActionBuilder builder(absl::WrapUnique<ResolvedDropConstraintAction>(
      const_cast<ResolvedDropConstraintAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedDropPrimaryKeyActionBuilder final {
 public:
  ResolvedDropPrimaryKeyActionBuilder() : ResolvedDropPrimaryKeyActionBuilder(absl::WrapUnique(new ResolvedDropPrimaryKeyAction)) {}

  ResolvedDropPrimaryKeyActionBuilder(const ResolvedDropPrimaryKeyActionBuilder&) = delete;
  ResolvedDropPrimaryKeyActionBuilder& operator=(const ResolvedDropPrimaryKeyActionBuilder&) = delete;
  ResolvedDropPrimaryKeyActionBuilder(ResolvedDropPrimaryKeyActionBuilder&& other)
      : ResolvedDropPrimaryKeyActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDropPrimaryKeyActionBuilder& operator=(ResolvedDropPrimaryKeyActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDropPrimaryKeyAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropPrimaryKeyAction::is_if_exists was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedDropPrimaryKeyActionBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedDropPrimaryKeyActionBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);
    field_is_set_.set(0, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDropPrimaryKeyAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<1> field_is_set_ = {0};
  friend ResolvedDropPrimaryKeyActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedDropPrimaryKeyAction> node);

  ResolvedDropPrimaryKeyActionBuilder(std::unique_ptr<ResolvedDropPrimaryKeyAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDropPrimaryKeyActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedDropPrimaryKeyAction> node) {
  ResolvedDropPrimaryKeyActionBuilder builder(absl::WrapUnique<ResolvedDropPrimaryKeyAction>(
      const_cast<ResolvedDropPrimaryKeyAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedAlterColumnOptionsActionBuilder final {
 public:
  ResolvedAlterColumnOptionsActionBuilder() : ResolvedAlterColumnOptionsActionBuilder(absl::WrapUnique(new ResolvedAlterColumnOptionsAction)) {}

  ResolvedAlterColumnOptionsActionBuilder(const ResolvedAlterColumnOptionsActionBuilder&) = delete;
  ResolvedAlterColumnOptionsActionBuilder& operator=(const ResolvedAlterColumnOptionsActionBuilder&) = delete;
  ResolvedAlterColumnOptionsActionBuilder(ResolvedAlterColumnOptionsActionBuilder&& other)
      : ResolvedAlterColumnOptionsActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAlterColumnOptionsActionBuilder& operator=(ResolvedAlterColumnOptionsActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterColumnOptionsAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterColumnOptionsAction::column was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterColumnOptionsActionBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterColumnOptionsActionBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterColumnOptionsActionBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterColumnOptionsActionBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterColumnOptionsActionBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterColumnOptionsActionBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterColumnOptionsActionBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterColumnOptionsActionBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterColumnOptionsActionBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterColumnOptionsActionBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

  const std::string& column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column();
  }

  ResolvedAlterColumnOptionsActionBuilder&& set_column(const std::string& v) && {
    node_->set_column(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedAlterColumnOptionsActionBuilder& set_column(const std::string& v) & {
    node_->set_column(v);
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterColumnOptionsAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedAlterColumnOptionsActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterColumnOptionsAction> node);

  ResolvedAlterColumnOptionsActionBuilder(std::unique_ptr<ResolvedAlterColumnOptionsAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterColumnOptionsActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterColumnOptionsAction> node) {
  ResolvedAlterColumnOptionsActionBuilder builder(absl::WrapUnique<ResolvedAlterColumnOptionsAction>(
      const_cast<ResolvedAlterColumnOptionsAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedAlterColumnDropNotNullActionBuilder final {
 public:
  ResolvedAlterColumnDropNotNullActionBuilder() : ResolvedAlterColumnDropNotNullActionBuilder(absl::WrapUnique(new ResolvedAlterColumnDropNotNullAction)) {}

  ResolvedAlterColumnDropNotNullActionBuilder(const ResolvedAlterColumnDropNotNullActionBuilder&) = delete;
  ResolvedAlterColumnDropNotNullActionBuilder& operator=(const ResolvedAlterColumnDropNotNullActionBuilder&) = delete;
  ResolvedAlterColumnDropNotNullActionBuilder(ResolvedAlterColumnDropNotNullActionBuilder&& other)
      : ResolvedAlterColumnDropNotNullActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAlterColumnDropNotNullActionBuilder& operator=(ResolvedAlterColumnDropNotNullActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterColumnDropNotNullAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterColumnDropNotNullAction::column was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterColumnDropNotNullActionBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterColumnDropNotNullActionBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

  const std::string& column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column();
  }

  ResolvedAlterColumnDropNotNullActionBuilder&& set_column(const std::string& v) && {
    node_->set_column(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedAlterColumnDropNotNullActionBuilder& set_column(const std::string& v) & {
    node_->set_column(v);
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterColumnDropNotNullAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedAlterColumnDropNotNullActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterColumnDropNotNullAction> node);

  ResolvedAlterColumnDropNotNullActionBuilder(std::unique_ptr<ResolvedAlterColumnDropNotNullAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterColumnDropNotNullActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterColumnDropNotNullAction> node) {
  ResolvedAlterColumnDropNotNullActionBuilder builder(absl::WrapUnique<ResolvedAlterColumnDropNotNullAction>(
      const_cast<ResolvedAlterColumnDropNotNullAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedAlterColumnSetDataTypeActionBuilder final {
 public:
  ResolvedAlterColumnSetDataTypeActionBuilder() : ResolvedAlterColumnSetDataTypeActionBuilder(absl::WrapUnique(new ResolvedAlterColumnSetDataTypeAction)) {}

  ResolvedAlterColumnSetDataTypeActionBuilder(const ResolvedAlterColumnSetDataTypeActionBuilder&) = delete;
  ResolvedAlterColumnSetDataTypeActionBuilder& operator=(const ResolvedAlterColumnSetDataTypeActionBuilder&) = delete;
  ResolvedAlterColumnSetDataTypeActionBuilder(ResolvedAlterColumnSetDataTypeActionBuilder&& other)
      : ResolvedAlterColumnSetDataTypeActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAlterColumnSetDataTypeActionBuilder& operator=(ResolvedAlterColumnSetDataTypeActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterColumnSetDataTypeAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterColumnSetDataTypeAction::column was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterColumnSetDataTypeAction::updated_type was not set on the builder");
    }
    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterColumnSetDataTypeAction::updated_annotations was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // The new type for the column.
  const Type* updated_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->updated_type();
  }

  ResolvedAlterColumnSetDataTypeActionBuilder&& set_updated_type(const Type* v) && {
    node_->set_updated_type(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedAlterColumnSetDataTypeActionBuilder& set_updated_type(const Type* v) & {
    node_->set_updated_type(v);
    field_is_set_.set(2, true);

    return *this;
  }

  // The new type parameters for the column, if the new type has
  // parameters. Note that unlike with CREATE TABLE, the child_list is
  // populated for ARRAY and STRUCT types.
  // TODO Use updated_annotations to pass type parameters.
  const TypeParameters& updated_type_parameters() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->updated_type_parameters();
  }

  ResolvedAlterColumnSetDataTypeActionBuilder&& set_updated_type_parameters(const TypeParameters& v) && {
    node_->set_updated_type_parameters(v);

    return std::move(*this);
  }

  ResolvedAlterColumnSetDataTypeActionBuilder& set_updated_type_parameters(const TypeParameters& v) & {
    node_->set_updated_type_parameters(v);

    return *this;
  }

  // The new annotations for the column including the new collation
  // specifications. Changing options using SET DATA TYPE action is not
  // allowed.
  const ResolvedColumnAnnotations* updated_annotations() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->updated_annotations();
  }

  std::unique_ptr<const ResolvedColumnAnnotations> release_updated_annotations() {
    return node_->release_updated_annotations();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnAnnotations>>::value>>
  ResolvedAlterColumnSetDataTypeActionBuilder&& set_updated_annotations(T v) && {
    node_->set_updated_annotations(std::move(v));
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnAnnotations>>::value>>
  ResolvedAlterColumnSetDataTypeActionBuilder& set_updated_annotations(T v) & {
    node_->set_updated_annotations(std::move(v));
    field_is_set_.set(4, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnAnnotations>>::value>>
  ResolvedAlterColumnSetDataTypeActionBuilder&& set_updated_annotations(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_updated_annotations(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnAnnotations>>::value>>
  ResolvedAlterColumnSetDataTypeActionBuilder& set_updated_annotations(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_updated_annotations(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterColumnSetDataTypeActionBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterColumnSetDataTypeActionBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

  const std::string& column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column();
  }

  ResolvedAlterColumnSetDataTypeActionBuilder&& set_column(const std::string& v) && {
    node_->set_column(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedAlterColumnSetDataTypeActionBuilder& set_column(const std::string& v) & {
    node_->set_column(v);
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterColumnSetDataTypeAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedAlterColumnSetDataTypeActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterColumnSetDataTypeAction> node);

  ResolvedAlterColumnSetDataTypeActionBuilder(std::unique_ptr<ResolvedAlterColumnSetDataTypeAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterColumnSetDataTypeActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterColumnSetDataTypeAction> node) {
  ResolvedAlterColumnSetDataTypeActionBuilder builder(absl::WrapUnique<ResolvedAlterColumnSetDataTypeAction>(
      const_cast<ResolvedAlterColumnSetDataTypeAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedAlterColumnSetDefaultActionBuilder final {
 public:
  ResolvedAlterColumnSetDefaultActionBuilder() : ResolvedAlterColumnSetDefaultActionBuilder(absl::WrapUnique(new ResolvedAlterColumnSetDefaultAction)) {}

  ResolvedAlterColumnSetDefaultActionBuilder(const ResolvedAlterColumnSetDefaultActionBuilder&) = delete;
  ResolvedAlterColumnSetDefaultActionBuilder& operator=(const ResolvedAlterColumnSetDefaultActionBuilder&) = delete;
  ResolvedAlterColumnSetDefaultActionBuilder(ResolvedAlterColumnSetDefaultActionBuilder&& other)
      : ResolvedAlterColumnSetDefaultActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAlterColumnSetDefaultActionBuilder& operator=(ResolvedAlterColumnSetDefaultActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterColumnSetDefaultAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterColumnSetDefaultAction::column was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterColumnSetDefaultAction::default_value was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedColumnDefaultValue* default_value() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->default_value();
  }

  std::unique_ptr<const ResolvedColumnDefaultValue> release_default_value() {
    return node_->release_default_value();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefaultValue>>::value>>
  ResolvedAlterColumnSetDefaultActionBuilder&& set_default_value(T v) && {
    node_->set_default_value(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefaultValue>>::value>>
  ResolvedAlterColumnSetDefaultActionBuilder& set_default_value(T v) & {
    node_->set_default_value(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefaultValue>>::value>>
  ResolvedAlterColumnSetDefaultActionBuilder&& set_default_value(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_default_value(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefaultValue>>::value>>
  ResolvedAlterColumnSetDefaultActionBuilder& set_default_value(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_default_value(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterColumnSetDefaultActionBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterColumnSetDefaultActionBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

  const std::string& column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column();
  }

  ResolvedAlterColumnSetDefaultActionBuilder&& set_column(const std::string& v) && {
    node_->set_column(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedAlterColumnSetDefaultActionBuilder& set_column(const std::string& v) & {
    node_->set_column(v);
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterColumnSetDefaultAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedAlterColumnSetDefaultActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterColumnSetDefaultAction> node);

  ResolvedAlterColumnSetDefaultActionBuilder(std::unique_ptr<ResolvedAlterColumnSetDefaultAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterColumnSetDefaultActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterColumnSetDefaultAction> node) {
  ResolvedAlterColumnSetDefaultActionBuilder builder(absl::WrapUnique<ResolvedAlterColumnSetDefaultAction>(
      const_cast<ResolvedAlterColumnSetDefaultAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedAlterColumnDropDefaultActionBuilder final {
 public:
  ResolvedAlterColumnDropDefaultActionBuilder() : ResolvedAlterColumnDropDefaultActionBuilder(absl::WrapUnique(new ResolvedAlterColumnDropDefaultAction)) {}

  ResolvedAlterColumnDropDefaultActionBuilder(const ResolvedAlterColumnDropDefaultActionBuilder&) = delete;
  ResolvedAlterColumnDropDefaultActionBuilder& operator=(const ResolvedAlterColumnDropDefaultActionBuilder&) = delete;
  ResolvedAlterColumnDropDefaultActionBuilder(ResolvedAlterColumnDropDefaultActionBuilder&& other)
      : ResolvedAlterColumnDropDefaultActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAlterColumnDropDefaultActionBuilder& operator=(ResolvedAlterColumnDropDefaultActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterColumnDropDefaultAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterColumnDropDefaultAction::column was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterColumnDropDefaultActionBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterColumnDropDefaultActionBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

  const std::string& column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column();
  }

  ResolvedAlterColumnDropDefaultActionBuilder&& set_column(const std::string& v) && {
    node_->set_column(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedAlterColumnDropDefaultActionBuilder& set_column(const std::string& v) & {
    node_->set_column(v);
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterColumnDropDefaultAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedAlterColumnDropDefaultActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterColumnDropDefaultAction> node);

  ResolvedAlterColumnDropDefaultActionBuilder(std::unique_ptr<ResolvedAlterColumnDropDefaultAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterColumnDropDefaultActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterColumnDropDefaultAction> node) {
  ResolvedAlterColumnDropDefaultActionBuilder builder(absl::WrapUnique<ResolvedAlterColumnDropDefaultAction>(
      const_cast<ResolvedAlterColumnDropDefaultAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedDropColumnActionBuilder final {
 public:
  ResolvedDropColumnActionBuilder() : ResolvedDropColumnActionBuilder(absl::WrapUnique(new ResolvedDropColumnAction)) {}

  ResolvedDropColumnActionBuilder(const ResolvedDropColumnActionBuilder&) = delete;
  ResolvedDropColumnActionBuilder& operator=(const ResolvedDropColumnActionBuilder&) = delete;
  ResolvedDropColumnActionBuilder(ResolvedDropColumnActionBuilder&& other)
      : ResolvedDropColumnActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDropColumnActionBuilder& operator=(ResolvedDropColumnActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDropColumnAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropColumnAction::is_if_exists was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropColumnAction::name was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedDropColumnActionBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedDropColumnActionBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedDropColumnActionBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedDropColumnActionBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDropColumnAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedDropColumnActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedDropColumnAction> node);

  ResolvedDropColumnActionBuilder(std::unique_ptr<ResolvedDropColumnAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDropColumnActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedDropColumnAction> node) {
  ResolvedDropColumnActionBuilder builder(absl::WrapUnique<ResolvedDropColumnAction>(
      const_cast<ResolvedDropColumnAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedRenameColumnActionBuilder final {
 public:
  ResolvedRenameColumnActionBuilder() : ResolvedRenameColumnActionBuilder(absl::WrapUnique(new ResolvedRenameColumnAction)) {}

  ResolvedRenameColumnActionBuilder(const ResolvedRenameColumnActionBuilder&) = delete;
  ResolvedRenameColumnActionBuilder& operator=(const ResolvedRenameColumnActionBuilder&) = delete;
  ResolvedRenameColumnActionBuilder(ResolvedRenameColumnActionBuilder&& other)
      : ResolvedRenameColumnActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedRenameColumnActionBuilder& operator=(ResolvedRenameColumnActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedRenameColumnAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedRenameColumnAction::name was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedRenameColumnAction::new_name was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedRenameColumnActionBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedRenameColumnActionBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedRenameColumnActionBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedRenameColumnActionBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const std::string& new_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->new_name();
  }

  ResolvedRenameColumnActionBuilder&& set_new_name(const std::string& v) && {
    node_->set_new_name(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedRenameColumnActionBuilder& set_new_name(const std::string& v) & {
    node_->set_new_name(v);
    field_is_set_.set(2, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedRenameColumnAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedRenameColumnActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedRenameColumnAction> node);

  ResolvedRenameColumnActionBuilder(std::unique_ptr<ResolvedRenameColumnAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedRenameColumnActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedRenameColumnAction> node) {
  ResolvedRenameColumnActionBuilder builder(absl::WrapUnique<ResolvedRenameColumnAction>(
      const_cast<ResolvedRenameColumnAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedSetAsActionBuilder final {
 public:
  ResolvedSetAsActionBuilder() : ResolvedSetAsActionBuilder(absl::WrapUnique(new ResolvedSetAsAction)) {}

  ResolvedSetAsActionBuilder(const ResolvedSetAsActionBuilder&) = delete;
  ResolvedSetAsActionBuilder& operator=(const ResolvedSetAsActionBuilder&) = delete;
  ResolvedSetAsActionBuilder(ResolvedSetAsActionBuilder&& other)
      : ResolvedSetAsActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedSetAsActionBuilder& operator=(ResolvedSetAsActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedSetAsAction>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& entity_body_json() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->entity_body_json();
  }

  ResolvedSetAsActionBuilder&& set_entity_body_json(const std::string& v) && {
    node_->set_entity_body_json(v);

    return std::move(*this);
  }

  ResolvedSetAsActionBuilder& set_entity_body_json(const std::string& v) & {
    node_->set_entity_body_json(v);

    return *this;
  }

  const std::string& entity_body_text() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->entity_body_text();
  }

  ResolvedSetAsActionBuilder&& set_entity_body_text(const std::string& v) && {
    node_->set_entity_body_text(v);

    return std::move(*this);
  }

  ResolvedSetAsActionBuilder& set_entity_body_text(const std::string& v) & {
    node_->set_entity_body_text(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedSetAsAction> node_;

  absl::Status deferred_build_status_;
  friend ResolvedSetAsActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedSetAsAction> node);

  ResolvedSetAsActionBuilder(std::unique_ptr<ResolvedSetAsAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedSetAsActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedSetAsAction> node) {
  ResolvedSetAsActionBuilder builder(absl::WrapUnique<ResolvedSetAsAction>(
      const_cast<ResolvedSetAsAction*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedSetCollateClauseBuilder final {
 public:
  ResolvedSetCollateClauseBuilder() : ResolvedSetCollateClauseBuilder(absl::WrapUnique(new ResolvedSetCollateClause)) {}

  ResolvedSetCollateClauseBuilder(const ResolvedSetCollateClauseBuilder&) = delete;
  ResolvedSetCollateClauseBuilder& operator=(const ResolvedSetCollateClauseBuilder&) = delete;
  ResolvedSetCollateClauseBuilder(ResolvedSetCollateClauseBuilder&& other)
      : ResolvedSetCollateClauseBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedSetCollateClauseBuilder& operator=(ResolvedSetCollateClauseBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedSetCollateClause>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedSetCollateClause::collation_name was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* collation_name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->collation_name();
  }

  std::unique_ptr<const ResolvedExpr> release_collation_name() {
    return node_->release_collation_name();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSetCollateClauseBuilder&& set_collation_name(T v) && {
    node_->set_collation_name(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSetCollateClauseBuilder& set_collation_name(T v) & {
    node_->set_collation_name(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSetCollateClauseBuilder&& set_collation_name(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedSetCollateClauseBuilder& set_collation_name(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_collation_name(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedSetCollateClause> node_;

  absl::Status deferred_build_status_;
  std::bitset<1> field_is_set_ = {0};
  friend ResolvedSetCollateClauseBuilder ToBuilder(
      std::unique_ptr<const ResolvedSetCollateClause> node);

  ResolvedSetCollateClauseBuilder(std::unique_ptr<ResolvedSetCollateClause> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedSetCollateClauseBuilder ToBuilder(
    std::unique_ptr<const ResolvedSetCollateClause> node) {
  ResolvedSetCollateClauseBuilder builder(absl::WrapUnique<ResolvedSetCollateClause>(
      const_cast<ResolvedSetCollateClause*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedAlterTableSetOptionsStmtBuilder final {
 public:
  ResolvedAlterTableSetOptionsStmtBuilder() : ResolvedAlterTableSetOptionsStmtBuilder(absl::WrapUnique(new ResolvedAlterTableSetOptionsStmt)) {}

  ResolvedAlterTableSetOptionsStmtBuilder(const ResolvedAlterTableSetOptionsStmtBuilder&) = delete;
  ResolvedAlterTableSetOptionsStmtBuilder& operator=(const ResolvedAlterTableSetOptionsStmtBuilder&) = delete;
  ResolvedAlterTableSetOptionsStmtBuilder(ResolvedAlterTableSetOptionsStmtBuilder&& other)
      : ResolvedAlterTableSetOptionsStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedAlterTableSetOptionsStmtBuilder& operator=(ResolvedAlterTableSetOptionsStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterTableSetOptionsStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedAlterTableSetOptionsStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterTableSetOptionsStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedAlterTableSetOptionsStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterTableSetOptionsStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterTableSetOptionsStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterTableSetOptionsStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterTableSetOptionsStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterTableSetOptionsStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedAlterTableSetOptionsStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterTableSetOptionsStmt> node);

  ResolvedAlterTableSetOptionsStmtBuilder(std::unique_ptr<ResolvedAlterTableSetOptionsStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterTableSetOptionsStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterTableSetOptionsStmt> node) {
  ResolvedAlterTableSetOptionsStmtBuilder builder(absl::WrapUnique<ResolvedAlterTableSetOptionsStmt>(
      const_cast<ResolvedAlterTableSetOptionsStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedRenameStmtBuilder final {
 public:
  ResolvedRenameStmtBuilder() : ResolvedRenameStmtBuilder(absl::WrapUnique(new ResolvedRenameStmt)) {}

  ResolvedRenameStmtBuilder(const ResolvedRenameStmtBuilder&) = delete;
  ResolvedRenameStmtBuilder& operator=(const ResolvedRenameStmtBuilder&) = delete;
  ResolvedRenameStmtBuilder(ResolvedRenameStmtBuilder&& other)
      : ResolvedRenameStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedRenameStmtBuilder& operator=(ResolvedRenameStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedRenameStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedRenameStmt::object_type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& object_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->object_type();
  }

  ResolvedRenameStmtBuilder&& set_object_type(const std::string& v) && {
    node_->set_object_type(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedRenameStmtBuilder& set_object_type(const std::string& v) & {
    node_->set_object_type(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<std::string>& old_name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->old_name_path();
  }

  int old_name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->old_name_path_size();
  }

  const std::string& old_name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->old_name_path(i);
  }

  ResolvedRenameStmtBuilder&& add_old_name_path(std::string v) && {
    node_->add_old_name_path(v);

    return std::move(*this);
  }

  ResolvedRenameStmtBuilder& add_old_name_path(std::string v) & {
    node_->add_old_name_path(v);

    return *this;
  }

  ResolvedRenameStmtBuilder&& set_old_name_path(const std::vector<std::string>& v) && {
    node_->set_old_name_path(v);

    return std::move(*this);
  }

  ResolvedRenameStmtBuilder& set_old_name_path(const std::vector<std::string>& v) & {
    node_->set_old_name_path(v);

    return *this;
  }

  const std::vector<std::string>& new_name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->new_name_path();
  }

  int new_name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->new_name_path_size();
  }

  const std::string& new_name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->new_name_path(i);
  }

  ResolvedRenameStmtBuilder&& add_new_name_path(std::string v) && {
    node_->add_new_name_path(v);

    return std::move(*this);
  }

  ResolvedRenameStmtBuilder& add_new_name_path(std::string v) & {
    node_->add_new_name_path(v);

    return *this;
  }

  ResolvedRenameStmtBuilder&& set_new_name_path(const std::vector<std::string>& v) && {
    node_->set_new_name_path(v);

    return std::move(*this);
  }

  ResolvedRenameStmtBuilder& set_new_name_path(const std::vector<std::string>& v) & {
    node_->set_new_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRenameStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRenameStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRenameStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRenameStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRenameStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRenameStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRenameStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRenameStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedRenameStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedRenameStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedRenameStmt> node);

  ResolvedRenameStmtBuilder(std::unique_ptr<ResolvedRenameStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedRenameStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedRenameStmt> node) {
  ResolvedRenameStmtBuilder builder(absl::WrapUnique<ResolvedRenameStmt>(
      const_cast<ResolvedRenameStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedCreatePrivilegeRestrictionStmtBuilder final {
 public:
  ResolvedCreatePrivilegeRestrictionStmtBuilder() : ResolvedCreatePrivilegeRestrictionStmtBuilder(absl::WrapUnique(new ResolvedCreatePrivilegeRestrictionStmt)) {}

  ResolvedCreatePrivilegeRestrictionStmtBuilder(const ResolvedCreatePrivilegeRestrictionStmtBuilder&) = delete;
  ResolvedCreatePrivilegeRestrictionStmtBuilder& operator=(const ResolvedCreatePrivilegeRestrictionStmtBuilder&) = delete;
  ResolvedCreatePrivilegeRestrictionStmtBuilder(ResolvedCreatePrivilegeRestrictionStmtBuilder&& other)
      : ResolvedCreatePrivilegeRestrictionStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCreatePrivilegeRestrictionStmtBuilder& operator=(ResolvedCreatePrivilegeRestrictionStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreatePrivilegeRestrictionStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreatePrivilegeRestrictionStmt::object_type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedPrivilege>>& column_privilege_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_privilege_list();
  }

  int column_privilege_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_privilege_list_size();
  }

  const ResolvedPrivilege* column_privilege_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_privilege_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder&& add_column_privilege_list(T v) && {
    node_->add_column_privilege_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder& add_column_privilege_list(T v) & {
    node_->add_column_privilege_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder&& add_column_privilege_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder& add_column_privilege_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedPrivilege>> release_column_privilege_list() {
    return node_->release_column_privilege_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder&& set_column_privilege_list(T v) && {
    node_->set_column_privilege_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder& set_column_privilege_list(T v) & {
    node_->set_column_privilege_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder&& set_column_privilege_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder& set_column_privilege_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::string& object_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->object_type();
  }

  ResolvedCreatePrivilegeRestrictionStmtBuilder&& set_object_type(const std::string& v) && {
    node_->set_object_type(v);
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  ResolvedCreatePrivilegeRestrictionStmtBuilder& set_object_type(const std::string& v) & {
    node_->set_object_type(v);
    field_is_set_.set(5, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& restrictee_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->restrictee_list();
  }

  int restrictee_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->restrictee_list_size();
  }

  const ResolvedExpr* restrictee_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->restrictee_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder&& add_restrictee_list(T v) && {
    node_->add_restrictee_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder& add_restrictee_list(T v) & {
    node_->add_restrictee_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder&& add_restrictee_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder& add_restrictee_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_restrictee_list() {
    return node_->release_restrictee_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder&& set_restrictee_list(T v) && {
    node_->set_restrictee_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder& set_restrictee_list(T v) & {
    node_->set_restrictee_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder&& set_restrictee_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder& set_restrictee_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreatePrivilegeRestrictionStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreatePrivilegeRestrictionStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreatePrivilegeRestrictionStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreatePrivilegeRestrictionStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreatePrivilegeRestrictionStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreatePrivilegeRestrictionStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreatePrivilegeRestrictionStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreatePrivilegeRestrictionStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreatePrivilegeRestrictionStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreatePrivilegeRestrictionStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<7> field_is_set_ = {0};
  friend ResolvedCreatePrivilegeRestrictionStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreatePrivilegeRestrictionStmt> node);

  ResolvedCreatePrivilegeRestrictionStmtBuilder(std::unique_ptr<ResolvedCreatePrivilegeRestrictionStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreatePrivilegeRestrictionStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreatePrivilegeRestrictionStmt> node) {
  ResolvedCreatePrivilegeRestrictionStmtBuilder builder(absl::WrapUnique<ResolvedCreatePrivilegeRestrictionStmt>(
      const_cast<ResolvedCreatePrivilegeRestrictionStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(5, true);
  return builder;
}

class ResolvedCreateRowAccessPolicyStmtBuilder final {
 public:
    typedef ResolvedCreateStatement::CreateMode CreateMode;

  ResolvedCreateRowAccessPolicyStmtBuilder() : ResolvedCreateRowAccessPolicyStmtBuilder(absl::WrapUnique(new ResolvedCreateRowAccessPolicyStmt)) {}

  ResolvedCreateRowAccessPolicyStmtBuilder(const ResolvedCreateRowAccessPolicyStmtBuilder&) = delete;
  ResolvedCreateRowAccessPolicyStmtBuilder& operator=(const ResolvedCreateRowAccessPolicyStmtBuilder&) = delete;
  ResolvedCreateRowAccessPolicyStmtBuilder(ResolvedCreateRowAccessPolicyStmtBuilder&& other)
      : ResolvedCreateRowAccessPolicyStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCreateRowAccessPolicyStmtBuilder& operator=(ResolvedCreateRowAccessPolicyStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateRowAccessPolicyStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(6)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateRowAccessPolicyStmt::table_scan was not set on the builder");
    }
    if (!field_is_set_.test(7)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateRowAccessPolicyStmt::predicate was not set on the builder");
    }
    if (!field_is_set_.test(8)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateRowAccessPolicyStmt::predicate_str was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateRowAccessPolicyStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateRowAccessPolicyStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedCreateRowAccessPolicyStmtBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);

    return std::move(*this);
  }

  ResolvedCreateRowAccessPolicyStmtBuilder& set_name(const std::string& v) & {
    node_->set_name(v);

    return *this;
  }

  const std::vector<std::string>& target_name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->target_name_path();
  }

  int target_name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->target_name_path_size();
  }

  const std::string& target_name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->target_name_path(i);
  }

  ResolvedCreateRowAccessPolicyStmtBuilder&& add_target_name_path(std::string v) && {
    node_->add_target_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateRowAccessPolicyStmtBuilder& add_target_name_path(std::string v) & {
    node_->add_target_name_path(v);

    return *this;
  }

  ResolvedCreateRowAccessPolicyStmtBuilder&& set_target_name_path(const std::vector<std::string>& v) && {
    node_->set_target_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateRowAccessPolicyStmtBuilder& set_target_name_path(const std::vector<std::string>& v) & {
    node_->set_target_name_path(v);

    return *this;
  }

  const std::vector<std::string>& grantee_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_list();
  }

  int grantee_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_list_size();
  }

  const std::string& grantee_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_list(i);
  }

  ResolvedCreateRowAccessPolicyStmtBuilder&& add_grantee_list(std::string v) && {
    node_->add_grantee_list(v);

    return std::move(*this);
  }

  ResolvedCreateRowAccessPolicyStmtBuilder& add_grantee_list(std::string v) & {
    node_->add_grantee_list(v);

    return *this;
  }

  ResolvedCreateRowAccessPolicyStmtBuilder&& set_grantee_list(const std::vector<std::string>& v) && {
    node_->set_grantee_list(v);

    return std::move(*this);
  }

  ResolvedCreateRowAccessPolicyStmtBuilder& set_grantee_list(const std::vector<std::string>& v) & {
    node_->set_grantee_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& grantee_expr_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_expr_list();
  }

  int grantee_expr_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_expr_list_size();
  }

  const ResolvedExpr* grantee_expr_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_expr_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder&& add_grantee_expr_list(T v) && {
    node_->add_grantee_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder& add_grantee_expr_list(T v) & {
    node_->add_grantee_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder&& add_grantee_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder& add_grantee_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_grantee_expr_list() {
    return node_->release_grantee_expr_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder&& set_grantee_expr_list(T v) && {
    node_->set_grantee_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder& set_grantee_expr_list(T v) & {
    node_->set_grantee_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder&& set_grantee_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder& set_grantee_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedTableScan* table_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_scan();
  }

  std::unique_ptr<const ResolvedTableScan> release_table_scan() {
    return node_->release_table_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder&& set_table_scan(T v) && {
    node_->set_table_scan(std::move(v));
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder& set_table_scan(T v) & {
    node_->set_table_scan(std::move(v));
    field_is_set_.set(6, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder&& set_table_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder& set_table_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(6, true);

    return *this;
  }

  const ResolvedExpr* predicate() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->predicate();
  }

  std::unique_ptr<const ResolvedExpr> release_predicate() {
    return node_->release_predicate();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder&& set_predicate(T v) && {
    node_->set_predicate(std::move(v));
    field_is_set_.set(7, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder& set_predicate(T v) & {
    node_->set_predicate(std::move(v));
    field_is_set_.set(7, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder&& set_predicate(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_predicate(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(7, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder& set_predicate(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_predicate(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(7, true);

    return *this;
  }

  const std::string& predicate_str() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->predicate_str();
  }

  ResolvedCreateRowAccessPolicyStmtBuilder&& set_predicate_str(const std::string& v) && {
    node_->set_predicate_str(v);
    field_is_set_.set(8, true);

    return std::move(*this);
  }

  ResolvedCreateRowAccessPolicyStmtBuilder& set_predicate_str(const std::string& v) & {
    node_->set_predicate_str(v);
    field_is_set_.set(8, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateRowAccessPolicyStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateRowAccessPolicyStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<9> field_is_set_ = {0};
  friend ResolvedCreateRowAccessPolicyStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateRowAccessPolicyStmt> node);

  ResolvedCreateRowAccessPolicyStmtBuilder(std::unique_ptr<ResolvedCreateRowAccessPolicyStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateRowAccessPolicyStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateRowAccessPolicyStmt> node) {
  ResolvedCreateRowAccessPolicyStmtBuilder builder(absl::WrapUnique<ResolvedCreateRowAccessPolicyStmt>(
      const_cast<ResolvedCreateRowAccessPolicyStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(6, true);
  builder.field_is_set_.set(7, true);
  builder.field_is_set_.set(8, true);
  return builder;
}

class ResolvedDropPrivilegeRestrictionStmtBuilder final {
 public:
  ResolvedDropPrivilegeRestrictionStmtBuilder() : ResolvedDropPrivilegeRestrictionStmtBuilder(absl::WrapUnique(new ResolvedDropPrivilegeRestrictionStmt)) {}

  ResolvedDropPrivilegeRestrictionStmtBuilder(const ResolvedDropPrivilegeRestrictionStmtBuilder&) = delete;
  ResolvedDropPrivilegeRestrictionStmtBuilder& operator=(const ResolvedDropPrivilegeRestrictionStmtBuilder&) = delete;
  ResolvedDropPrivilegeRestrictionStmtBuilder(ResolvedDropPrivilegeRestrictionStmtBuilder&& other)
      : ResolvedDropPrivilegeRestrictionStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDropPrivilegeRestrictionStmtBuilder& operator=(ResolvedDropPrivilegeRestrictionStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDropPrivilegeRestrictionStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropPrivilegeRestrictionStmt::object_type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& object_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->object_type();
  }

  ResolvedDropPrivilegeRestrictionStmtBuilder&& set_object_type(const std::string& v) && {
    node_->set_object_type(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedDropPrivilegeRestrictionStmtBuilder& set_object_type(const std::string& v) & {
    node_->set_object_type(v);
    field_is_set_.set(1, true);

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedDropPrivilegeRestrictionStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedDropPrivilegeRestrictionStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedDropPrivilegeRestrictionStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedDropPrivilegeRestrictionStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedDropPrivilegeRestrictionStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedDropPrivilegeRestrictionStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedPrivilege>>& column_privilege_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_privilege_list();
  }

  int column_privilege_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_privilege_list_size();
  }

  const ResolvedPrivilege* column_privilege_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_privilege_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder&& add_column_privilege_list(T v) && {
    node_->add_column_privilege_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder& add_column_privilege_list(T v) & {
    node_->add_column_privilege_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder&& add_column_privilege_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder& add_column_privilege_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedPrivilege>> release_column_privilege_list() {
    return node_->release_column_privilege_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder&& set_column_privilege_list(T v) && {
    node_->set_column_privilege_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder& set_column_privilege_list(T v) & {
    node_->set_column_privilege_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder&& set_column_privilege_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder& set_column_privilege_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropPrivilegeRestrictionStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDropPrivilegeRestrictionStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedDropPrivilegeRestrictionStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedDropPrivilegeRestrictionStmt> node);

  ResolvedDropPrivilegeRestrictionStmtBuilder(std::unique_ptr<ResolvedDropPrivilegeRestrictionStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDropPrivilegeRestrictionStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedDropPrivilegeRestrictionStmt> node) {
  ResolvedDropPrivilegeRestrictionStmtBuilder builder(absl::WrapUnique<ResolvedDropPrivilegeRestrictionStmt>(
      const_cast<ResolvedDropPrivilegeRestrictionStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedDropRowAccessPolicyStmtBuilder final {
 public:
  ResolvedDropRowAccessPolicyStmtBuilder() : ResolvedDropRowAccessPolicyStmtBuilder(absl::WrapUnique(new ResolvedDropRowAccessPolicyStmt)) {}

  ResolvedDropRowAccessPolicyStmtBuilder(const ResolvedDropRowAccessPolicyStmtBuilder&) = delete;
  ResolvedDropRowAccessPolicyStmtBuilder& operator=(const ResolvedDropRowAccessPolicyStmtBuilder&) = delete;
  ResolvedDropRowAccessPolicyStmtBuilder(ResolvedDropRowAccessPolicyStmtBuilder&& other)
      : ResolvedDropRowAccessPolicyStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedDropRowAccessPolicyStmtBuilder& operator=(ResolvedDropRowAccessPolicyStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDropRowAccessPolicyStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_drop_all() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_drop_all();
  }

  ResolvedDropRowAccessPolicyStmtBuilder&& set_is_drop_all(bool v) && {
    node_->set_is_drop_all(v);

    return std::move(*this);
  }

  ResolvedDropRowAccessPolicyStmtBuilder& set_is_drop_all(bool v) & {
    node_->set_is_drop_all(v);

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedDropRowAccessPolicyStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedDropRowAccessPolicyStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedDropRowAccessPolicyStmtBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);

    return std::move(*this);
  }

  ResolvedDropRowAccessPolicyStmtBuilder& set_name(const std::string& v) & {
    node_->set_name(v);

    return *this;
  }

  const std::vector<std::string>& target_name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->target_name_path();
  }

  int target_name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->target_name_path_size();
  }

  const std::string& target_name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->target_name_path(i);
  }

  ResolvedDropRowAccessPolicyStmtBuilder&& add_target_name_path(std::string v) && {
    node_->add_target_name_path(v);

    return std::move(*this);
  }

  ResolvedDropRowAccessPolicyStmtBuilder& add_target_name_path(std::string v) & {
    node_->add_target_name_path(v);

    return *this;
  }

  ResolvedDropRowAccessPolicyStmtBuilder&& set_target_name_path(const std::vector<std::string>& v) && {
    node_->set_target_name_path(v);

    return std::move(*this);
  }

  ResolvedDropRowAccessPolicyStmtBuilder& set_target_name_path(const std::vector<std::string>& v) & {
    node_->set_target_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropRowAccessPolicyStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropRowAccessPolicyStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropRowAccessPolicyStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropRowAccessPolicyStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropRowAccessPolicyStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropRowAccessPolicyStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropRowAccessPolicyStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropRowAccessPolicyStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDropRowAccessPolicyStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedDropRowAccessPolicyStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedDropRowAccessPolicyStmt> node);

  ResolvedDropRowAccessPolicyStmtBuilder(std::unique_ptr<ResolvedDropRowAccessPolicyStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDropRowAccessPolicyStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedDropRowAccessPolicyStmt> node) {
  ResolvedDropRowAccessPolicyStmtBuilder builder(absl::WrapUnique<ResolvedDropRowAccessPolicyStmt>(
      const_cast<ResolvedDropRowAccessPolicyStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedDropSearchIndexStmtBuilder final {
 public:
  ResolvedDropSearchIndexStmtBuilder() : ResolvedDropSearchIndexStmtBuilder(absl::WrapUnique(new ResolvedDropSearchIndexStmt)) {}

  ResolvedDropSearchIndexStmtBuilder(const ResolvedDropSearchIndexStmtBuilder&) = delete;
  ResolvedDropSearchIndexStmtBuilder& operator=(const ResolvedDropSearchIndexStmtBuilder&) = delete;
  ResolvedDropSearchIndexStmtBuilder(ResolvedDropSearchIndexStmtBuilder&& other)
      : ResolvedDropSearchIndexStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDropSearchIndexStmtBuilder& operator=(ResolvedDropSearchIndexStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDropSearchIndexStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropSearchIndexStmt::is_if_exists was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropSearchIndexStmt::name was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedDropSearchIndexStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedDropSearchIndexStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedDropSearchIndexStmtBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedDropSearchIndexStmtBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(2, true);

    return *this;
  }

  const std::vector<std::string>& table_name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_name_path();
  }

  int table_name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_name_path_size();
  }

  const std::string& table_name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_name_path(i);
  }

  ResolvedDropSearchIndexStmtBuilder&& add_table_name_path(std::string v) && {
    node_->add_table_name_path(v);

    return std::move(*this);
  }

  ResolvedDropSearchIndexStmtBuilder& add_table_name_path(std::string v) & {
    node_->add_table_name_path(v);

    return *this;
  }

  ResolvedDropSearchIndexStmtBuilder&& set_table_name_path(const std::vector<std::string>& v) && {
    node_->set_table_name_path(v);

    return std::move(*this);
  }

  ResolvedDropSearchIndexStmtBuilder& set_table_name_path(const std::vector<std::string>& v) & {
    node_->set_table_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropSearchIndexStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropSearchIndexStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropSearchIndexStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropSearchIndexStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropSearchIndexStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropSearchIndexStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropSearchIndexStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropSearchIndexStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDropSearchIndexStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedDropSearchIndexStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedDropSearchIndexStmt> node);

  ResolvedDropSearchIndexStmtBuilder(std::unique_ptr<ResolvedDropSearchIndexStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDropSearchIndexStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedDropSearchIndexStmt> node) {
  ResolvedDropSearchIndexStmtBuilder builder(absl::WrapUnique<ResolvedDropSearchIndexStmt>(
      const_cast<ResolvedDropSearchIndexStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedGrantToActionBuilder final {
 public:
  ResolvedGrantToActionBuilder() : ResolvedGrantToActionBuilder(absl::WrapUnique(new ResolvedGrantToAction)) {}

  ResolvedGrantToActionBuilder(const ResolvedGrantToActionBuilder&) = delete;
  ResolvedGrantToActionBuilder& operator=(const ResolvedGrantToActionBuilder&) = delete;
  ResolvedGrantToActionBuilder(ResolvedGrantToActionBuilder&& other)
      : ResolvedGrantToActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedGrantToActionBuilder& operator=(ResolvedGrantToActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedGrantToAction>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedExpr>>& grantee_expr_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_expr_list();
  }

  int grantee_expr_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_expr_list_size();
  }

  const ResolvedExpr* grantee_expr_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->grantee_expr_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGrantToActionBuilder&& add_grantee_expr_list(T v) && {
    node_->add_grantee_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGrantToActionBuilder& add_grantee_expr_list(T v) & {
    node_->add_grantee_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGrantToActionBuilder&& add_grantee_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedGrantToActionBuilder& add_grantee_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_grantee_expr_list() {
    return node_->release_grantee_expr_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedGrantToActionBuilder&& set_grantee_expr_list(T v) && {
    node_->set_grantee_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedGrantToActionBuilder& set_grantee_expr_list(T v) & {
    node_->set_grantee_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedGrantToActionBuilder&& set_grantee_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedGrantToActionBuilder& set_grantee_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_grantee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedGrantToAction> node_;

  absl::Status deferred_build_status_;
  friend ResolvedGrantToActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedGrantToAction> node);

  ResolvedGrantToActionBuilder(std::unique_ptr<ResolvedGrantToAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedGrantToActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedGrantToAction> node) {
  ResolvedGrantToActionBuilder builder(absl::WrapUnique<ResolvedGrantToAction>(
      const_cast<ResolvedGrantToAction*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedRestrictToActionBuilder final {
 public:
  ResolvedRestrictToActionBuilder() : ResolvedRestrictToActionBuilder(absl::WrapUnique(new ResolvedRestrictToAction)) {}

  ResolvedRestrictToActionBuilder(const ResolvedRestrictToActionBuilder&) = delete;
  ResolvedRestrictToActionBuilder& operator=(const ResolvedRestrictToActionBuilder&) = delete;
  ResolvedRestrictToActionBuilder(ResolvedRestrictToActionBuilder&& other)
      : ResolvedRestrictToActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedRestrictToActionBuilder& operator=(ResolvedRestrictToActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedRestrictToAction>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedExpr>>& restrictee_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->restrictee_list();
  }

  int restrictee_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->restrictee_list_size();
  }

  const ResolvedExpr* restrictee_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->restrictee_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRestrictToActionBuilder&& add_restrictee_list(T v) && {
    node_->add_restrictee_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRestrictToActionBuilder& add_restrictee_list(T v) & {
    node_->add_restrictee_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRestrictToActionBuilder&& add_restrictee_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRestrictToActionBuilder& add_restrictee_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_restrictee_list() {
    return node_->release_restrictee_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRestrictToActionBuilder&& set_restrictee_list(T v) && {
    node_->set_restrictee_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRestrictToActionBuilder& set_restrictee_list(T v) & {
    node_->set_restrictee_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRestrictToActionBuilder&& set_restrictee_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRestrictToActionBuilder& set_restrictee_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedRestrictToAction> node_;

  absl::Status deferred_build_status_;
  friend ResolvedRestrictToActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedRestrictToAction> node);

  ResolvedRestrictToActionBuilder(std::unique_ptr<ResolvedRestrictToAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedRestrictToActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedRestrictToAction> node) {
  ResolvedRestrictToActionBuilder builder(absl::WrapUnique<ResolvedRestrictToAction>(
      const_cast<ResolvedRestrictToAction*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedAddToRestricteeListActionBuilder final {
 public:
  ResolvedAddToRestricteeListActionBuilder() : ResolvedAddToRestricteeListActionBuilder(absl::WrapUnique(new ResolvedAddToRestricteeListAction)) {}

  ResolvedAddToRestricteeListActionBuilder(const ResolvedAddToRestricteeListActionBuilder&) = delete;
  ResolvedAddToRestricteeListActionBuilder& operator=(const ResolvedAddToRestricteeListActionBuilder&) = delete;
  ResolvedAddToRestricteeListActionBuilder(ResolvedAddToRestricteeListActionBuilder&& other)
      : ResolvedAddToRestricteeListActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedAddToRestricteeListActionBuilder& operator=(ResolvedAddToRestricteeListActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAddToRestricteeListAction>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_not_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_not_exists();
  }

  ResolvedAddToRestricteeListActionBuilder&& set_is_if_not_exists(bool v) && {
    node_->set_is_if_not_exists(v);

    return std::move(*this);
  }

  ResolvedAddToRestricteeListActionBuilder& set_is_if_not_exists(bool v) & {
    node_->set_is_if_not_exists(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& restrictee_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->restrictee_list();
  }

  int restrictee_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->restrictee_list_size();
  }

  const ResolvedExpr* restrictee_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->restrictee_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAddToRestricteeListActionBuilder&& add_restrictee_list(T v) && {
    node_->add_restrictee_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAddToRestricteeListActionBuilder& add_restrictee_list(T v) & {
    node_->add_restrictee_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAddToRestricteeListActionBuilder&& add_restrictee_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAddToRestricteeListActionBuilder& add_restrictee_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_restrictee_list() {
    return node_->release_restrictee_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAddToRestricteeListActionBuilder&& set_restrictee_list(T v) && {
    node_->set_restrictee_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAddToRestricteeListActionBuilder& set_restrictee_list(T v) & {
    node_->set_restrictee_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAddToRestricteeListActionBuilder&& set_restrictee_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAddToRestricteeListActionBuilder& set_restrictee_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAddToRestricteeListAction> node_;

  absl::Status deferred_build_status_;
  friend ResolvedAddToRestricteeListActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedAddToRestricteeListAction> node);

  ResolvedAddToRestricteeListActionBuilder(std::unique_ptr<ResolvedAddToRestricteeListAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAddToRestricteeListActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedAddToRestricteeListAction> node) {
  ResolvedAddToRestricteeListActionBuilder builder(absl::WrapUnique<ResolvedAddToRestricteeListAction>(
      const_cast<ResolvedAddToRestricteeListAction*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedRemoveFromRestricteeListActionBuilder final {
 public:
  ResolvedRemoveFromRestricteeListActionBuilder() : ResolvedRemoveFromRestricteeListActionBuilder(absl::WrapUnique(new ResolvedRemoveFromRestricteeListAction)) {}

  ResolvedRemoveFromRestricteeListActionBuilder(const ResolvedRemoveFromRestricteeListActionBuilder&) = delete;
  ResolvedRemoveFromRestricteeListActionBuilder& operator=(const ResolvedRemoveFromRestricteeListActionBuilder&) = delete;
  ResolvedRemoveFromRestricteeListActionBuilder(ResolvedRemoveFromRestricteeListActionBuilder&& other)
      : ResolvedRemoveFromRestricteeListActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedRemoveFromRestricteeListActionBuilder& operator=(ResolvedRemoveFromRestricteeListActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedRemoveFromRestricteeListAction>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedRemoveFromRestricteeListActionBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedRemoveFromRestricteeListActionBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& restrictee_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->restrictee_list();
  }

  int restrictee_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->restrictee_list_size();
  }

  const ResolvedExpr* restrictee_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->restrictee_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRemoveFromRestricteeListActionBuilder&& add_restrictee_list(T v) && {
    node_->add_restrictee_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRemoveFromRestricteeListActionBuilder& add_restrictee_list(T v) & {
    node_->add_restrictee_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRemoveFromRestricteeListActionBuilder&& add_restrictee_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRemoveFromRestricteeListActionBuilder& add_restrictee_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_restrictee_list() {
    return node_->release_restrictee_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRemoveFromRestricteeListActionBuilder&& set_restrictee_list(T v) && {
    node_->set_restrictee_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRemoveFromRestricteeListActionBuilder& set_restrictee_list(T v) & {
    node_->set_restrictee_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRemoveFromRestricteeListActionBuilder&& set_restrictee_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRemoveFromRestricteeListActionBuilder& set_restrictee_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_restrictee_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedRemoveFromRestricteeListAction> node_;

  absl::Status deferred_build_status_;
  friend ResolvedRemoveFromRestricteeListActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedRemoveFromRestricteeListAction> node);

  ResolvedRemoveFromRestricteeListActionBuilder(std::unique_ptr<ResolvedRemoveFromRestricteeListAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedRemoveFromRestricteeListActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedRemoveFromRestricteeListAction> node) {
  ResolvedRemoveFromRestricteeListActionBuilder builder(absl::WrapUnique<ResolvedRemoveFromRestricteeListAction>(
      const_cast<ResolvedRemoveFromRestricteeListAction*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedFilterUsingActionBuilder final {
 public:
  ResolvedFilterUsingActionBuilder() : ResolvedFilterUsingActionBuilder(absl::WrapUnique(new ResolvedFilterUsingAction)) {}

  ResolvedFilterUsingActionBuilder(const ResolvedFilterUsingActionBuilder&) = delete;
  ResolvedFilterUsingActionBuilder& operator=(const ResolvedFilterUsingActionBuilder&) = delete;
  ResolvedFilterUsingActionBuilder(ResolvedFilterUsingActionBuilder&& other)
      : ResolvedFilterUsingActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedFilterUsingActionBuilder& operator=(ResolvedFilterUsingActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedFilterUsingAction>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFilterUsingAction::predicate was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFilterUsingAction::predicate_str was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* predicate() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->predicate();
  }

  std::unique_ptr<const ResolvedExpr> release_predicate() {
    return node_->release_predicate();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFilterUsingActionBuilder&& set_predicate(T v) && {
    node_->set_predicate(std::move(v));
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFilterUsingActionBuilder& set_predicate(T v) & {
    node_->set_predicate(std::move(v));
    field_is_set_.set(0, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFilterUsingActionBuilder&& set_predicate(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_predicate(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedFilterUsingActionBuilder& set_predicate(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_predicate(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(0, true);

    return *this;
  }

  const std::string& predicate_str() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->predicate_str();
  }

  ResolvedFilterUsingActionBuilder&& set_predicate_str(const std::string& v) && {
    node_->set_predicate_str(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedFilterUsingActionBuilder& set_predicate_str(const std::string& v) & {
    node_->set_predicate_str(v);
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedFilterUsingAction> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedFilterUsingActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedFilterUsingAction> node);

  ResolvedFilterUsingActionBuilder(std::unique_ptr<ResolvedFilterUsingAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedFilterUsingActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedFilterUsingAction> node) {
  ResolvedFilterUsingActionBuilder builder(absl::WrapUnique<ResolvedFilterUsingAction>(
      const_cast<ResolvedFilterUsingAction*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedRevokeFromActionBuilder final {
 public:
  ResolvedRevokeFromActionBuilder() : ResolvedRevokeFromActionBuilder(absl::WrapUnique(new ResolvedRevokeFromAction)) {}

  ResolvedRevokeFromActionBuilder(const ResolvedRevokeFromActionBuilder&) = delete;
  ResolvedRevokeFromActionBuilder& operator=(const ResolvedRevokeFromActionBuilder&) = delete;
  ResolvedRevokeFromActionBuilder(ResolvedRevokeFromActionBuilder&& other)
      : ResolvedRevokeFromActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedRevokeFromActionBuilder& operator=(ResolvedRevokeFromActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedRevokeFromAction>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedExpr>>& revokee_expr_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->revokee_expr_list();
  }

  int revokee_expr_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->revokee_expr_list_size();
  }

  const ResolvedExpr* revokee_expr_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->revokee_expr_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRevokeFromActionBuilder&& add_revokee_expr_list(T v) && {
    node_->add_revokee_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRevokeFromActionBuilder& add_revokee_expr_list(T v) & {
    node_->add_revokee_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRevokeFromActionBuilder&& add_revokee_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_revokee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedRevokeFromActionBuilder& add_revokee_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_revokee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_revokee_expr_list() {
    return node_->release_revokee_expr_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRevokeFromActionBuilder&& set_revokee_expr_list(T v) && {
    node_->set_revokee_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRevokeFromActionBuilder& set_revokee_expr_list(T v) & {
    node_->set_revokee_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRevokeFromActionBuilder&& set_revokee_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_revokee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedRevokeFromActionBuilder& set_revokee_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_revokee_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_revoke_from_all() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_revoke_from_all();
  }

  ResolvedRevokeFromActionBuilder&& set_is_revoke_from_all(bool v) && {
    node_->set_is_revoke_from_all(v);

    return std::move(*this);
  }

  ResolvedRevokeFromActionBuilder& set_is_revoke_from_all(bool v) & {
    node_->set_is_revoke_from_all(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedRevokeFromAction> node_;

  absl::Status deferred_build_status_;
  friend ResolvedRevokeFromActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedRevokeFromAction> node);

  ResolvedRevokeFromActionBuilder(std::unique_ptr<ResolvedRevokeFromAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedRevokeFromActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedRevokeFromAction> node) {
  ResolvedRevokeFromActionBuilder builder(absl::WrapUnique<ResolvedRevokeFromAction>(
      const_cast<ResolvedRevokeFromAction*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedRenameToActionBuilder final {
 public:
  ResolvedRenameToActionBuilder() : ResolvedRenameToActionBuilder(absl::WrapUnique(new ResolvedRenameToAction)) {}

  ResolvedRenameToActionBuilder(const ResolvedRenameToActionBuilder&) = delete;
  ResolvedRenameToActionBuilder& operator=(const ResolvedRenameToActionBuilder&) = delete;
  ResolvedRenameToActionBuilder(ResolvedRenameToActionBuilder&& other)
      : ResolvedRenameToActionBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedRenameToActionBuilder& operator=(ResolvedRenameToActionBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedRenameToAction>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::string>& new_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->new_path();
  }

  int new_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->new_path_size();
  }

  const std::string& new_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->new_path(i);
  }

  ResolvedRenameToActionBuilder&& add_new_path(std::string v) && {
    node_->add_new_path(v);

    return std::move(*this);
  }

  ResolvedRenameToActionBuilder& add_new_path(std::string v) & {
    node_->add_new_path(v);

    return *this;
  }

  ResolvedRenameToActionBuilder&& set_new_path(const std::vector<std::string>& v) && {
    node_->set_new_path(v);

    return std::move(*this);
  }

  ResolvedRenameToActionBuilder& set_new_path(const std::vector<std::string>& v) & {
    node_->set_new_path(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedRenameToAction> node_;

  absl::Status deferred_build_status_;
  friend ResolvedRenameToActionBuilder ToBuilder(
      std::unique_ptr<const ResolvedRenameToAction> node);

  ResolvedRenameToActionBuilder(std::unique_ptr<ResolvedRenameToAction> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedRenameToActionBuilder ToBuilder(
    std::unique_ptr<const ResolvedRenameToAction> node) {
  ResolvedRenameToActionBuilder builder(absl::WrapUnique<ResolvedRenameToAction>(
      const_cast<ResolvedRenameToAction*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedAlterPrivilegeRestrictionStmtBuilder final {
 public:
  ResolvedAlterPrivilegeRestrictionStmtBuilder() : ResolvedAlterPrivilegeRestrictionStmtBuilder(absl::WrapUnique(new ResolvedAlterPrivilegeRestrictionStmt)) {}

  ResolvedAlterPrivilegeRestrictionStmtBuilder(const ResolvedAlterPrivilegeRestrictionStmtBuilder&) = delete;
  ResolvedAlterPrivilegeRestrictionStmtBuilder& operator=(const ResolvedAlterPrivilegeRestrictionStmtBuilder&) = delete;
  ResolvedAlterPrivilegeRestrictionStmtBuilder(ResolvedAlterPrivilegeRestrictionStmtBuilder&& other)
      : ResolvedAlterPrivilegeRestrictionStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAlterPrivilegeRestrictionStmtBuilder& operator=(ResolvedAlterPrivilegeRestrictionStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterPrivilegeRestrictionStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterPrivilegeRestrictionStmt::object_type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedPrivilege>>& column_privilege_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_privilege_list();
  }

  int column_privilege_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_privilege_list_size();
  }

  const ResolvedPrivilege* column_privilege_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_privilege_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder&& add_column_privilege_list(T v) && {
    node_->add_column_privilege_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder& add_column_privilege_list(T v) & {
    node_->add_column_privilege_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder&& add_column_privilege_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrivilege>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder& add_column_privilege_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedPrivilege>> release_column_privilege_list() {
    return node_->release_column_privilege_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder&& set_column_privilege_list(T v) && {
    node_->set_column_privilege_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder& set_column_privilege_list(T v) & {
    node_->set_column_privilege_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder&& set_column_privilege_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedPrivilege>>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder& set_column_privilege_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_privilege_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::string& object_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->object_type();
  }

  ResolvedAlterPrivilegeRestrictionStmtBuilder&& set_object_type(const std::string& v) && {
    node_->set_object_type(v);
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  ResolvedAlterPrivilegeRestrictionStmtBuilder& set_object_type(const std::string& v) & {
    node_->set_object_type(v);
    field_is_set_.set(5, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedAlterPrivilegeRestrictionStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterPrivilegeRestrictionStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedAlterPrivilegeRestrictionStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterPrivilegeRestrictionStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedAlterAction>>& alter_action_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list();
  }

  int alter_action_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list_size();
  }

  const ResolvedAlterAction* alter_action_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder&& add_alter_action_list(T v) && {
    node_->add_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder& add_alter_action_list(T v) & {
    node_->add_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder&& add_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder& add_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedAlterAction>> release_alter_action_list() {
    return node_->release_alter_action_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder&& set_alter_action_list(T v) && {
    node_->set_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder& set_alter_action_list(T v) & {
    node_->set_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder&& set_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterPrivilegeRestrictionStmtBuilder& set_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterPrivilegeRestrictionStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterPrivilegeRestrictionStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterPrivilegeRestrictionStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<6> field_is_set_ = {0};
  friend ResolvedAlterPrivilegeRestrictionStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterPrivilegeRestrictionStmt> node);

  ResolvedAlterPrivilegeRestrictionStmtBuilder(std::unique_ptr<ResolvedAlterPrivilegeRestrictionStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterPrivilegeRestrictionStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterPrivilegeRestrictionStmt> node) {
  ResolvedAlterPrivilegeRestrictionStmtBuilder builder(absl::WrapUnique<ResolvedAlterPrivilegeRestrictionStmt>(
      const_cast<ResolvedAlterPrivilegeRestrictionStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(5, true);
  return builder;
}

class ResolvedAlterRowAccessPolicyStmtBuilder final {
 public:
  ResolvedAlterRowAccessPolicyStmtBuilder() : ResolvedAlterRowAccessPolicyStmtBuilder(absl::WrapUnique(new ResolvedAlterRowAccessPolicyStmt)) {}

  ResolvedAlterRowAccessPolicyStmtBuilder(const ResolvedAlterRowAccessPolicyStmtBuilder&) = delete;
  ResolvedAlterRowAccessPolicyStmtBuilder& operator=(const ResolvedAlterRowAccessPolicyStmtBuilder&) = delete;
  ResolvedAlterRowAccessPolicyStmtBuilder(ResolvedAlterRowAccessPolicyStmtBuilder&& other)
      : ResolvedAlterRowAccessPolicyStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAlterRowAccessPolicyStmtBuilder& operator=(ResolvedAlterRowAccessPolicyStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterRowAccessPolicyStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterRowAccessPolicyStmt::name was not set on the builder");
    }
    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterRowAccessPolicyStmt::table_scan was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedAlterRowAccessPolicyStmtBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  ResolvedAlterRowAccessPolicyStmtBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(4, true);

    return *this;
  }

  const ResolvedTableScan* table_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_scan();
  }

  std::unique_ptr<const ResolvedTableScan> release_table_scan() {
    return node_->release_table_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder&& set_table_scan(T v) && {
    node_->set_table_scan(std::move(v));
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder& set_table_scan(T v) & {
    node_->set_table_scan(std::move(v));
    field_is_set_.set(5, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder&& set_table_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder& set_table_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(5, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedAlterRowAccessPolicyStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterRowAccessPolicyStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedAlterRowAccessPolicyStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterRowAccessPolicyStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedAlterAction>>& alter_action_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list();
  }

  int alter_action_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list_size();
  }

  const ResolvedAlterAction* alter_action_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder&& add_alter_action_list(T v) && {
    node_->add_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder& add_alter_action_list(T v) & {
    node_->add_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder&& add_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder& add_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedAlterAction>> release_alter_action_list() {
    return node_->release_alter_action_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder&& set_alter_action_list(T v) && {
    node_->set_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder& set_alter_action_list(T v) & {
    node_->set_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder&& set_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterRowAccessPolicyStmtBuilder& set_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterRowAccessPolicyStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterRowAccessPolicyStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterRowAccessPolicyStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<6> field_is_set_ = {0};
  friend ResolvedAlterRowAccessPolicyStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterRowAccessPolicyStmt> node);

  ResolvedAlterRowAccessPolicyStmtBuilder(std::unique_ptr<ResolvedAlterRowAccessPolicyStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterRowAccessPolicyStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterRowAccessPolicyStmt> node) {
  ResolvedAlterRowAccessPolicyStmtBuilder builder(absl::WrapUnique<ResolvedAlterRowAccessPolicyStmt>(
      const_cast<ResolvedAlterRowAccessPolicyStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(4, true);
  builder.field_is_set_.set(5, true);
  return builder;
}

class ResolvedAlterAllRowAccessPoliciesStmtBuilder final {
 public:
  ResolvedAlterAllRowAccessPoliciesStmtBuilder() : ResolvedAlterAllRowAccessPoliciesStmtBuilder(absl::WrapUnique(new ResolvedAlterAllRowAccessPoliciesStmt)) {}

  ResolvedAlterAllRowAccessPoliciesStmtBuilder(const ResolvedAlterAllRowAccessPoliciesStmtBuilder&) = delete;
  ResolvedAlterAllRowAccessPoliciesStmtBuilder& operator=(const ResolvedAlterAllRowAccessPoliciesStmtBuilder&) = delete;
  ResolvedAlterAllRowAccessPoliciesStmtBuilder(ResolvedAlterAllRowAccessPoliciesStmtBuilder&& other)
      : ResolvedAlterAllRowAccessPoliciesStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAlterAllRowAccessPoliciesStmtBuilder& operator=(ResolvedAlterAllRowAccessPoliciesStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterAllRowAccessPoliciesStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterAllRowAccessPoliciesStmt::table_scan was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedTableScan* table_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_scan();
  }

  std::unique_ptr<const ResolvedTableScan> release_table_scan() {
    return node_->release_table_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder&& set_table_scan(T v) && {
    node_->set_table_scan(std::move(v));
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder& set_table_scan(T v) & {
    node_->set_table_scan(std::move(v));
    field_is_set_.set(4, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder&& set_table_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder& set_table_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedAlterAllRowAccessPoliciesStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterAllRowAccessPoliciesStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedAlterAllRowAccessPoliciesStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterAllRowAccessPoliciesStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedAlterAction>>& alter_action_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list();
  }

  int alter_action_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list_size();
  }

  const ResolvedAlterAction* alter_action_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder&& add_alter_action_list(T v) && {
    node_->add_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder& add_alter_action_list(T v) & {
    node_->add_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder&& add_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder& add_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedAlterAction>> release_alter_action_list() {
    return node_->release_alter_action_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder&& set_alter_action_list(T v) && {
    node_->set_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder& set_alter_action_list(T v) & {
    node_->set_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder&& set_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterAllRowAccessPoliciesStmtBuilder& set_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterAllRowAccessPoliciesStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterAllRowAccessPoliciesStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterAllRowAccessPoliciesStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedAlterAllRowAccessPoliciesStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterAllRowAccessPoliciesStmt> node);

  ResolvedAlterAllRowAccessPoliciesStmtBuilder(std::unique_ptr<ResolvedAlterAllRowAccessPoliciesStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterAllRowAccessPoliciesStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterAllRowAccessPoliciesStmt> node) {
  ResolvedAlterAllRowAccessPoliciesStmtBuilder builder(absl::WrapUnique<ResolvedAlterAllRowAccessPoliciesStmt>(
      const_cast<ResolvedAlterAllRowAccessPoliciesStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedCreateConstantStmtBuilder final {
 public:
  ResolvedCreateConstantStmtBuilder() : ResolvedCreateConstantStmtBuilder(absl::WrapUnique(new ResolvedCreateConstantStmt)) {}

  ResolvedCreateConstantStmtBuilder(const ResolvedCreateConstantStmtBuilder&) = delete;
  ResolvedCreateConstantStmtBuilder& operator=(const ResolvedCreateConstantStmtBuilder&) = delete;
  ResolvedCreateConstantStmtBuilder(ResolvedCreateConstantStmtBuilder&& other)
      : ResolvedCreateConstantStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCreateConstantStmtBuilder& operator=(ResolvedCreateConstantStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateConstantStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateConstantStmt::expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateConstantStmtBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateConstantStmtBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));
    field_is_set_.set(4, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateConstantStmtBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateConstantStmtBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateConstantStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateConstantStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateConstantStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateConstantStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateConstantStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateConstantStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateConstantStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateConstantStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateConstantStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateConstantStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateConstantStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateConstantStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateConstantStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateConstantStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateConstantStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateConstantStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateConstantStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedCreateConstantStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateConstantStmt> node);

  ResolvedCreateConstantStmtBuilder(std::unique_ptr<ResolvedCreateConstantStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateConstantStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateConstantStmt> node) {
  ResolvedCreateConstantStmtBuilder builder(absl::WrapUnique<ResolvedCreateConstantStmt>(
      const_cast<ResolvedCreateConstantStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedCreateFunctionStmtBuilder final {
 public:
    // Converts the function's determinism level into a volatility.
  // Functions with unspecified/non deterministic/volatile
  // specifiers are considered volatile, functions with deterministic
  // and immutable specifiers are considered immutable and functions
  // with the stable specifier are considered stable.
  FunctionEnums::Volatility volatility() const;

  ResolvedCreateFunctionStmtBuilder() : ResolvedCreateFunctionStmtBuilder(absl::WrapUnique(new ResolvedCreateFunctionStmt)) {}

  ResolvedCreateFunctionStmtBuilder(const ResolvedCreateFunctionStmtBuilder&) = delete;
  ResolvedCreateFunctionStmtBuilder& operator=(const ResolvedCreateFunctionStmtBuilder&) = delete;
  ResolvedCreateFunctionStmtBuilder(ResolvedCreateFunctionStmtBuilder&& other)
      : ResolvedCreateFunctionStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCreateFunctionStmtBuilder& operator=(ResolvedCreateFunctionStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateFunctionStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateFunctionStmt::has_explicit_return_type was not set on the builder");
    }
    if (!field_is_set_.test(7)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateFunctionStmt::signature was not set on the builder");
    }
    if (!field_is_set_.test(10)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateFunctionStmt::code was not set on the builder");
    }
    if (!field_is_set_.test(12)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateFunctionStmt::function_expression was not set on the builder");
    }
    if (!field_is_set_.test(16)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateFunctionStmt::is_remote was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool has_explicit_return_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->has_explicit_return_type();
  }

  ResolvedCreateFunctionStmtBuilder&& set_has_explicit_return_type(bool v) && {
    node_->set_has_explicit_return_type(v);
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& set_has_explicit_return_type(bool v) & {
    node_->set_has_explicit_return_type(v);
    field_is_set_.set(4, true);

    return *this;
  }

  const Type* return_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->return_type();
  }

  ResolvedCreateFunctionStmtBuilder&& set_return_type(const Type* v) && {
    node_->set_return_type(v);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& set_return_type(const Type* v) & {
    node_->set_return_type(v);

    return *this;
  }

  const std::vector<std::string>& argument_name_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_name_list();
  }

  int argument_name_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_name_list_size();
  }

  const std::string& argument_name_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_name_list(i);
  }

  ResolvedCreateFunctionStmtBuilder&& add_argument_name_list(std::string v) && {
    node_->add_argument_name_list(v);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& add_argument_name_list(std::string v) & {
    node_->add_argument_name_list(v);

    return *this;
  }

  ResolvedCreateFunctionStmtBuilder&& set_argument_name_list(const std::vector<std::string>& v) && {
    node_->set_argument_name_list(v);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& set_argument_name_list(const std::vector<std::string>& v) & {
    node_->set_argument_name_list(v);

    return *this;
  }

  const FunctionSignature& signature() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->signature();
  }

  ResolvedCreateFunctionStmtBuilder&& set_signature(const FunctionSignature& v) && {
    node_->set_signature(v);
    field_is_set_.set(7, true);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& set_signature(const FunctionSignature& v) & {
    node_->set_signature(v);
    field_is_set_.set(7, true);

    return *this;
  }

  bool is_aggregate() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_aggregate();
  }

  ResolvedCreateFunctionStmtBuilder&& set_is_aggregate(bool v) && {
    node_->set_is_aggregate(v);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& set_is_aggregate(bool v) & {
    node_->set_is_aggregate(v);

    return *this;
  }

  const std::string& language() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->language();
  }

  ResolvedCreateFunctionStmtBuilder&& set_language(const std::string& v) && {
    node_->set_language(v);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& set_language(const std::string& v) & {
    node_->set_language(v);

    return *this;
  }

  const std::string& code() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->code();
  }

  ResolvedCreateFunctionStmtBuilder&& set_code(const std::string& v) && {
    node_->set_code(v);
    field_is_set_.set(10, true);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& set_code(const std::string& v) & {
    node_->set_code(v);
    field_is_set_.set(10, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& aggregate_expression_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->aggregate_expression_list();
  }

  int aggregate_expression_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->aggregate_expression_list_size();
  }

  const ResolvedComputedColumn* aggregate_expression_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->aggregate_expression_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedCreateFunctionStmtBuilder&& add_aggregate_expression_list(T v) && {
    node_->add_aggregate_expression_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedCreateFunctionStmtBuilder& add_aggregate_expression_list(T v) & {
    node_->add_aggregate_expression_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedCreateFunctionStmtBuilder&& add_aggregate_expression_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_aggregate_expression_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedCreateFunctionStmtBuilder& add_aggregate_expression_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_aggregate_expression_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_aggregate_expression_list() {
    return node_->release_aggregate_expression_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedCreateFunctionStmtBuilder&& set_aggregate_expression_list(T v) && {
    node_->set_aggregate_expression_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedCreateFunctionStmtBuilder& set_aggregate_expression_list(T v) & {
    node_->set_aggregate_expression_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedCreateFunctionStmtBuilder&& set_aggregate_expression_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_aggregate_expression_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedCreateFunctionStmtBuilder& set_aggregate_expression_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_aggregate_expression_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedExpr* function_expression() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->function_expression();
  }

  std::unique_ptr<const ResolvedExpr> release_function_expression() {
    return node_->release_function_expression();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateFunctionStmtBuilder&& set_function_expression(T v) && {
    node_->set_function_expression(std::move(v));
    field_is_set_.set(12, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateFunctionStmtBuilder& set_function_expression(T v) & {
    node_->set_function_expression(std::move(v));
    field_is_set_.set(12, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateFunctionStmtBuilder&& set_function_expression(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_function_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(12, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateFunctionStmtBuilder& set_function_expression(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_function_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(12, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateFunctionStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateFunctionStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateFunctionStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateFunctionStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateFunctionStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateFunctionStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateFunctionStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateFunctionStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  ResolvedCreateStatement::SqlSecurity sql_security() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->sql_security();
  }

  ResolvedCreateFunctionStmtBuilder&& set_sql_security(ResolvedCreateStatement::SqlSecurity v) && {
    node_->set_sql_security(v);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& set_sql_security(ResolvedCreateStatement::SqlSecurity v) & {
    node_->set_sql_security(v);

    return *this;
  }

  ResolvedCreateStatement::DeterminismLevel determinism_level() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->determinism_level();
  }

  ResolvedCreateFunctionStmtBuilder&& set_determinism_level(ResolvedCreateStatement::DeterminismLevel v) && {
    node_->set_determinism_level(v);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& set_determinism_level(ResolvedCreateStatement::DeterminismLevel v) & {
    node_->set_determinism_level(v);

    return *this;
  }

  bool is_remote() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_remote();
  }

  ResolvedCreateFunctionStmtBuilder&& set_is_remote(bool v) && {
    node_->set_is_remote(v);
    field_is_set_.set(16, true);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& set_is_remote(bool v) & {
    node_->set_is_remote(v);
    field_is_set_.set(16, true);

    return *this;
  }

  const ResolvedConnection* connection() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->connection();
  }

  std::unique_ptr<const ResolvedConnection> release_connection() {
    return node_->release_connection();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedCreateFunctionStmtBuilder&& set_connection(T v) && {
    node_->set_connection(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedCreateFunctionStmtBuilder& set_connection(T v) & {
    node_->set_connection(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedCreateFunctionStmtBuilder&& set_connection(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedCreateFunctionStmtBuilder& set_connection(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateFunctionStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateFunctionStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateFunctionStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateFunctionStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateFunctionStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateFunctionStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateFunctionStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateFunctionStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateFunctionStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateFunctionStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateFunctionStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateFunctionStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateFunctionStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateFunctionStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<18> field_is_set_ = {0};
  friend ResolvedCreateFunctionStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateFunctionStmt> node);

  ResolvedCreateFunctionStmtBuilder(std::unique_ptr<ResolvedCreateFunctionStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateFunctionStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateFunctionStmt> node) {
  ResolvedCreateFunctionStmtBuilder builder(absl::WrapUnique<ResolvedCreateFunctionStmt>(
      const_cast<ResolvedCreateFunctionStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(4, true);
  builder.field_is_set_.set(7, true);
  builder.field_is_set_.set(10, true);
  builder.field_is_set_.set(12, true);
  builder.field_is_set_.set(16, true);
  return builder;
}

class ResolvedArgumentDefBuilder final {
 public:
    typedef ResolvedArgumentDefEnums::ArgumentKind ArgumentKind;
  static const ArgumentKind SCALAR = ResolvedArgumentDefEnums::SCALAR;
  static const ArgumentKind AGGREGATE = ResolvedArgumentDefEnums::AGGREGATE;
  static const ArgumentKind NOT_AGGREGATE = ResolvedArgumentDefEnums::NOT_AGGREGATE;

  ResolvedArgumentDefBuilder() : ResolvedArgumentDefBuilder(absl::WrapUnique(new ResolvedArgumentDef)) {}

  ResolvedArgumentDefBuilder(const ResolvedArgumentDefBuilder&) = delete;
  ResolvedArgumentDefBuilder& operator=(const ResolvedArgumentDefBuilder&) = delete;
  ResolvedArgumentDefBuilder(ResolvedArgumentDefBuilder&& other)
      : ResolvedArgumentDefBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedArgumentDefBuilder& operator=(ResolvedArgumentDefBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedArgumentDef>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedArgumentDef::name was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedArgumentDef::type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedArgumentDefBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedArgumentDefBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedArgumentDefBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedArgumentDefBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(1, true);

    return *this;
  }

  ResolvedArgumentDef::ArgumentKind argument_kind() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_kind();
  }

  ResolvedArgumentDefBuilder&& set_argument_kind(ResolvedArgumentDef::ArgumentKind v) && {
    node_->set_argument_kind(v);

    return std::move(*this);
  }

  ResolvedArgumentDefBuilder& set_argument_kind(ResolvedArgumentDef::ArgumentKind v) & {
    node_->set_argument_kind(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedArgumentDef> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedArgumentDefBuilder ToBuilder(
      std::unique_ptr<const ResolvedArgumentDef> node);

  ResolvedArgumentDefBuilder(std::unique_ptr<ResolvedArgumentDef> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedArgumentDefBuilder ToBuilder(
    std::unique_ptr<const ResolvedArgumentDef> node) {
  ResolvedArgumentDefBuilder builder(absl::WrapUnique<ResolvedArgumentDef>(
      const_cast<ResolvedArgumentDef*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedArgumentRefBuilder final {
 public:
    typedef ResolvedArgumentDefEnums::ArgumentKind ArgumentKind;
  static const ArgumentKind SCALAR = ResolvedArgumentDefEnums::SCALAR;
  static const ArgumentKind AGGREGATE = ResolvedArgumentDefEnums::AGGREGATE;
  static const ArgumentKind NOT_AGGREGATE = ResolvedArgumentDefEnums::NOT_AGGREGATE;

  ResolvedArgumentRefBuilder() : ResolvedArgumentRefBuilder(absl::WrapUnique(new ResolvedArgumentRef)) {}

  ResolvedArgumentRefBuilder(const ResolvedArgumentRefBuilder&) = delete;
  ResolvedArgumentRefBuilder& operator=(const ResolvedArgumentRefBuilder&) = delete;
  ResolvedArgumentRefBuilder(ResolvedArgumentRefBuilder&& other)
      : ResolvedArgumentRefBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedArgumentRefBuilder& operator=(ResolvedArgumentRefBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedArgumentRef>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedArgumentRef::type was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedArgumentRef::name was not set on the builder");
    }
    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedArgumentRef::argument_kind was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedArgumentRefBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedArgumentRefBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(2, true);

    return *this;
  }

  ResolvedArgumentDef::ArgumentKind argument_kind() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_kind();
  }

  ResolvedArgumentRefBuilder&& set_argument_kind(ResolvedArgumentDef::ArgumentKind v) && {
    node_->set_argument_kind(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedArgumentRefBuilder& set_argument_kind(ResolvedArgumentDef::ArgumentKind v) & {
    node_->set_argument_kind(v);
    field_is_set_.set(3, true);

    return *this;
  }

  const Type* type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type();
  }

  ResolvedArgumentRefBuilder&& set_type(const Type* v) && {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedArgumentRefBuilder& set_type(const Type* v) & {
    node_->set_type(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const AnnotationMap* type_annotation_map() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->type_annotation_map();
  }

  ResolvedArgumentRefBuilder&& set_type_annotation_map(const AnnotationMap* v) && {
    node_->set_type_annotation_map(v);

    return std::move(*this);
  }

  ResolvedArgumentRefBuilder& set_type_annotation_map(const AnnotationMap* v) & {
    node_->set_type_annotation_map(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedArgumentRef> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedArgumentRefBuilder ToBuilder(
      std::unique_ptr<const ResolvedArgumentRef> node);

  ResolvedArgumentRefBuilder(std::unique_ptr<ResolvedArgumentRef> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedArgumentRefBuilder ToBuilder(
    std::unique_ptr<const ResolvedArgumentRef> node) {
  ResolvedArgumentRefBuilder builder(absl::WrapUnique<ResolvedArgumentRef>(
      const_cast<ResolvedArgumentRef*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(2, true);
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedCreateTableFunctionStmtBuilder final {
 public:
  ResolvedCreateTableFunctionStmtBuilder() : ResolvedCreateTableFunctionStmtBuilder(absl::WrapUnique(new ResolvedCreateTableFunctionStmt)) {}

  ResolvedCreateTableFunctionStmtBuilder(const ResolvedCreateTableFunctionStmtBuilder&) = delete;
  ResolvedCreateTableFunctionStmtBuilder& operator=(const ResolvedCreateTableFunctionStmtBuilder&) = delete;
  ResolvedCreateTableFunctionStmtBuilder(ResolvedCreateTableFunctionStmtBuilder&& other)
      : ResolvedCreateTableFunctionStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCreateTableFunctionStmtBuilder& operator=(ResolvedCreateTableFunctionStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateTableFunctionStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateTableFunctionStmt::signature was not set on the builder");
    }
    if (!field_is_set_.test(6)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateTableFunctionStmt::has_explicit_return_schema was not set on the builder");
    }
    if (!field_is_set_.test(9)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateTableFunctionStmt::code was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::string>& argument_name_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_name_list();
  }

  int argument_name_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_name_list_size();
  }

  const std::string& argument_name_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_name_list(i);
  }

  ResolvedCreateTableFunctionStmtBuilder&& add_argument_name_list(std::string v) && {
    node_->add_argument_name_list(v);

    return std::move(*this);
  }

  ResolvedCreateTableFunctionStmtBuilder& add_argument_name_list(std::string v) & {
    node_->add_argument_name_list(v);

    return *this;
  }

  ResolvedCreateTableFunctionStmtBuilder&& set_argument_name_list(const std::vector<std::string>& v) && {
    node_->set_argument_name_list(v);

    return std::move(*this);
  }

  ResolvedCreateTableFunctionStmtBuilder& set_argument_name_list(const std::vector<std::string>& v) & {
    node_->set_argument_name_list(v);

    return *this;
  }

  const FunctionSignature& signature() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->signature();
  }

  ResolvedCreateTableFunctionStmtBuilder&& set_signature(const FunctionSignature& v) && {
    node_->set_signature(v);
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  ResolvedCreateTableFunctionStmtBuilder& set_signature(const FunctionSignature& v) & {
    node_->set_signature(v);
    field_is_set_.set(5, true);

    return *this;
  }

  bool has_explicit_return_schema() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->has_explicit_return_schema();
  }

  ResolvedCreateTableFunctionStmtBuilder&& set_has_explicit_return_schema(bool v) && {
    node_->set_has_explicit_return_schema(v);
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  ResolvedCreateTableFunctionStmtBuilder& set_has_explicit_return_schema(bool v) & {
    node_->set_has_explicit_return_schema(v);
    field_is_set_.set(6, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::string& language() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->language();
  }

  ResolvedCreateTableFunctionStmtBuilder&& set_language(const std::string& v) && {
    node_->set_language(v);

    return std::move(*this);
  }

  ResolvedCreateTableFunctionStmtBuilder& set_language(const std::string& v) & {
    node_->set_language(v);

    return *this;
  }

  const std::string& code() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->code();
  }

  ResolvedCreateTableFunctionStmtBuilder&& set_code(const std::string& v) && {
    node_->set_code(v);
    field_is_set_.set(9, true);

    return std::move(*this);
  }

  ResolvedCreateTableFunctionStmtBuilder& set_code(const std::string& v) & {
    node_->set_code(v);
    field_is_set_.set(9, true);

    return *this;
  }

  const ResolvedScan* query() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query();
  }

  std::unique_ptr<const ResolvedScan> release_query() {
    return node_->release_query();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& set_query(T v) && {
    node_->set_query(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& set_query(T v) & {
    node_->set_query(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& set_query(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& set_query(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOutputColumn>>& output_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list();
  }

  int output_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list_size();
  }

  const ResolvedOutputColumn* output_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& add_output_column_list(T v) && {
    node_->add_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& add_output_column_list(T v) & {
    node_->add_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& add_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& add_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOutputColumn>> release_output_column_list() {
    return node_->release_output_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& set_output_column_list(T v) && {
    node_->set_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& set_output_column_list(T v) & {
    node_->set_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& set_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& set_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_value_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_value_table();
  }

  ResolvedCreateTableFunctionStmtBuilder&& set_is_value_table(bool v) && {
    node_->set_is_value_table(v);

    return std::move(*this);
  }

  ResolvedCreateTableFunctionStmtBuilder& set_is_value_table(bool v) & {
    node_->set_is_value_table(v);

    return *this;
  }

  ResolvedCreateStatement::SqlSecurity sql_security() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->sql_security();
  }

  ResolvedCreateTableFunctionStmtBuilder&& set_sql_security(ResolvedCreateStatement::SqlSecurity v) && {
    node_->set_sql_security(v);

    return std::move(*this);
  }

  ResolvedCreateTableFunctionStmtBuilder& set_sql_security(ResolvedCreateStatement::SqlSecurity v) & {
    node_->set_sql_security(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableFunctionStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateTableFunctionStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateTableFunctionStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateTableFunctionStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateTableFunctionStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateTableFunctionStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateTableFunctionStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateTableFunctionStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateTableFunctionStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateTableFunctionStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateTableFunctionStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<14> field_is_set_ = {0};
  friend ResolvedCreateTableFunctionStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateTableFunctionStmt> node);

  ResolvedCreateTableFunctionStmtBuilder(std::unique_ptr<ResolvedCreateTableFunctionStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateTableFunctionStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateTableFunctionStmt> node) {
  ResolvedCreateTableFunctionStmtBuilder builder(absl::WrapUnique<ResolvedCreateTableFunctionStmt>(
      const_cast<ResolvedCreateTableFunctionStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(5, true);
  builder.field_is_set_.set(6, true);
  builder.field_is_set_.set(9, true);
  return builder;
}

class ResolvedRelationArgumentScanBuilder final {
 public:
  ResolvedRelationArgumentScanBuilder() : ResolvedRelationArgumentScanBuilder(absl::WrapUnique(new ResolvedRelationArgumentScan)) {}

  ResolvedRelationArgumentScanBuilder(const ResolvedRelationArgumentScanBuilder&) = delete;
  ResolvedRelationArgumentScanBuilder& operator=(const ResolvedRelationArgumentScanBuilder&) = delete;
  ResolvedRelationArgumentScanBuilder(ResolvedRelationArgumentScanBuilder&& other)
      : ResolvedRelationArgumentScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedRelationArgumentScanBuilder& operator=(ResolvedRelationArgumentScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedRelationArgumentScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedRelationArgumentScan::name was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // This is the name of the relation argument for the table-valued
  // function.  It is used to match this relation argument reference in
  // a TVF SQL function body with one of possibly several relation
  // arguments in the TVF call.
  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedRelationArgumentScanBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  ResolvedRelationArgumentScanBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(3, true);

    return *this;
  }

  // If true, the result of this query is a value table. Rather than
  // producing rows with named columns, it produces rows with a single
  // unnamed value type. See (broken link).
  bool is_value_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_value_table();
  }

  ResolvedRelationArgumentScanBuilder&& set_is_value_table(bool v) && {
    node_->set_is_value_table(v);

    return std::move(*this);
  }

  ResolvedRelationArgumentScanBuilder& set_is_value_table(bool v) & {
    node_->set_is_value_table(v);

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedRelationArgumentScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedRelationArgumentScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedRelationArgumentScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedRelationArgumentScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRelationArgumentScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRelationArgumentScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRelationArgumentScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedRelationArgumentScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRelationArgumentScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRelationArgumentScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRelationArgumentScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedRelationArgumentScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedRelationArgumentScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedRelationArgumentScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedRelationArgumentScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedRelationArgumentScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedRelationArgumentScan> node);

  ResolvedRelationArgumentScanBuilder(std::unique_ptr<ResolvedRelationArgumentScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedRelationArgumentScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedRelationArgumentScan> node) {
  ResolvedRelationArgumentScanBuilder builder(absl::WrapUnique<ResolvedRelationArgumentScan>(
      const_cast<ResolvedRelationArgumentScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  return builder;
}

class ResolvedArgumentListBuilder final {
 public:
  ResolvedArgumentListBuilder() : ResolvedArgumentListBuilder(absl::WrapUnique(new ResolvedArgumentList)) {}

  ResolvedArgumentListBuilder(const ResolvedArgumentListBuilder&) = delete;
  ResolvedArgumentListBuilder& operator=(const ResolvedArgumentListBuilder&) = delete;
  ResolvedArgumentListBuilder(ResolvedArgumentListBuilder&& other)
      : ResolvedArgumentListBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedArgumentListBuilder& operator=(ResolvedArgumentListBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedArgumentList>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedArgumentDef>>& arg_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->arg_list();
  }

  int arg_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->arg_list_size();
  }

  const ResolvedArgumentDef* arg_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->arg_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedArgumentDef>>::value>>
  ResolvedArgumentListBuilder&& add_arg_list(T v) && {
    node_->add_arg_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedArgumentDef>>::value>>
  ResolvedArgumentListBuilder& add_arg_list(T v) & {
    node_->add_arg_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedArgumentDef>>::value>>
  ResolvedArgumentListBuilder&& add_arg_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_arg_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedArgumentDef>>::value>>
  ResolvedArgumentListBuilder& add_arg_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_arg_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedArgumentDef>> release_arg_list() {
    return node_->release_arg_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedArgumentDef>>>::value>>
  ResolvedArgumentListBuilder&& set_arg_list(T v) && {
    node_->set_arg_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedArgumentDef>>>::value>>
  ResolvedArgumentListBuilder& set_arg_list(T v) & {
    node_->set_arg_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedArgumentDef>>>::value>>
  ResolvedArgumentListBuilder&& set_arg_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_arg_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedArgumentDef>>>::value>>
  ResolvedArgumentListBuilder& set_arg_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_arg_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedArgumentList> node_;

  absl::Status deferred_build_status_;
  friend ResolvedArgumentListBuilder ToBuilder(
      std::unique_ptr<const ResolvedArgumentList> node);

  ResolvedArgumentListBuilder(std::unique_ptr<ResolvedArgumentList> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedArgumentListBuilder ToBuilder(
    std::unique_ptr<const ResolvedArgumentList> node) {
  ResolvedArgumentListBuilder builder(absl::WrapUnique<ResolvedArgumentList>(
      const_cast<ResolvedArgumentList*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedFunctionSignatureHolderBuilder final {
 public:
  ResolvedFunctionSignatureHolderBuilder() : ResolvedFunctionSignatureHolderBuilder(absl::WrapUnique(new ResolvedFunctionSignatureHolder)) {}

  ResolvedFunctionSignatureHolderBuilder(const ResolvedFunctionSignatureHolderBuilder&) = delete;
  ResolvedFunctionSignatureHolderBuilder& operator=(const ResolvedFunctionSignatureHolderBuilder&) = delete;
  ResolvedFunctionSignatureHolderBuilder(ResolvedFunctionSignatureHolderBuilder&& other)
      : ResolvedFunctionSignatureHolderBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedFunctionSignatureHolderBuilder& operator=(ResolvedFunctionSignatureHolderBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedFunctionSignatureHolder>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedFunctionSignatureHolder::signature was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const FunctionSignature& signature() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->signature();
  }

  ResolvedFunctionSignatureHolderBuilder&& set_signature(const FunctionSignature& v) && {
    node_->set_signature(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedFunctionSignatureHolderBuilder& set_signature(const FunctionSignature& v) & {
    node_->set_signature(v);
    field_is_set_.set(0, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedFunctionSignatureHolder> node_;

  absl::Status deferred_build_status_;
  std::bitset<1> field_is_set_ = {0};
  friend ResolvedFunctionSignatureHolderBuilder ToBuilder(
      std::unique_ptr<const ResolvedFunctionSignatureHolder> node);

  ResolvedFunctionSignatureHolderBuilder(std::unique_ptr<ResolvedFunctionSignatureHolder> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedFunctionSignatureHolderBuilder ToBuilder(
    std::unique_ptr<const ResolvedFunctionSignatureHolder> node) {
  ResolvedFunctionSignatureHolderBuilder builder(absl::WrapUnique<ResolvedFunctionSignatureHolder>(
      const_cast<ResolvedFunctionSignatureHolder*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  return builder;
}

class ResolvedDropFunctionStmtBuilder final {
 public:
  ResolvedDropFunctionStmtBuilder() : ResolvedDropFunctionStmtBuilder(absl::WrapUnique(new ResolvedDropFunctionStmt)) {}

  ResolvedDropFunctionStmtBuilder(const ResolvedDropFunctionStmtBuilder&) = delete;
  ResolvedDropFunctionStmtBuilder& operator=(const ResolvedDropFunctionStmtBuilder&) = delete;
  ResolvedDropFunctionStmtBuilder(ResolvedDropFunctionStmtBuilder&& other)
      : ResolvedDropFunctionStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDropFunctionStmtBuilder& operator=(ResolvedDropFunctionStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDropFunctionStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropFunctionStmt::is_if_exists was not set on the builder");
    }
    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropFunctionStmt::arguments was not set on the builder");
    }
    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropFunctionStmt::signature was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedDropFunctionStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedDropFunctionStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedDropFunctionStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedDropFunctionStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedDropFunctionStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedDropFunctionStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  // NOTE: arguments for DROP FUNCTION statements are matched only on
  // type; names for any arguments in ResolvedArgumentList will be set
  // to the empty string irrespective of whether or not argument names
  // were given in the DROP FUNCTION statement.
  const ResolvedArgumentList* arguments() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->arguments();
  }

  std::unique_ptr<const ResolvedArgumentList> release_arguments() {
    return node_->release_arguments();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedArgumentList>>::value>>
  ResolvedDropFunctionStmtBuilder&& set_arguments(T v) && {
    node_->set_arguments(std::move(v));
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedArgumentList>>::value>>
  ResolvedDropFunctionStmtBuilder& set_arguments(T v) & {
    node_->set_arguments(std::move(v));
    field_is_set_.set(3, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedArgumentList>>::value>>
  ResolvedDropFunctionStmtBuilder&& set_arguments(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_arguments(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedArgumentList>>::value>>
  ResolvedDropFunctionStmtBuilder& set_arguments(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_arguments(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return *this;
  }

  // NOTE: arguments for DROP FUNCTION statements are matched only on
  // type; names are irrelevant, so no argument names are saved to use
  // with this signature.  Additionally, the return type will always be
  // <void>, since return types are ignored for DROP FUNCTION.
  const ResolvedFunctionSignatureHolder* signature() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->signature();
  }

  std::unique_ptr<const ResolvedFunctionSignatureHolder> release_signature() {
    return node_->release_signature();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedFunctionSignatureHolder>>::value>>
  ResolvedDropFunctionStmtBuilder&& set_signature(T v) && {
    node_->set_signature(std::move(v));
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedFunctionSignatureHolder>>::value>>
  ResolvedDropFunctionStmtBuilder& set_signature(T v) & {
    node_->set_signature(std::move(v));
    field_is_set_.set(4, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedFunctionSignatureHolder>>::value>>
  ResolvedDropFunctionStmtBuilder&& set_signature(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_signature(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedFunctionSignatureHolder>>::value>>
  ResolvedDropFunctionStmtBuilder& set_signature(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_signature(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(4, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropFunctionStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropFunctionStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropFunctionStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropFunctionStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropFunctionStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropFunctionStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropFunctionStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropFunctionStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDropFunctionStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedDropFunctionStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedDropFunctionStmt> node);

  ResolvedDropFunctionStmtBuilder(std::unique_ptr<ResolvedDropFunctionStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDropFunctionStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedDropFunctionStmt> node) {
  ResolvedDropFunctionStmtBuilder builder(absl::WrapUnique<ResolvedDropFunctionStmt>(
      const_cast<ResolvedDropFunctionStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(3, true);
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedDropTableFunctionStmtBuilder final {
 public:
  ResolvedDropTableFunctionStmtBuilder() : ResolvedDropTableFunctionStmtBuilder(absl::WrapUnique(new ResolvedDropTableFunctionStmt)) {}

  ResolvedDropTableFunctionStmtBuilder(const ResolvedDropTableFunctionStmtBuilder&) = delete;
  ResolvedDropTableFunctionStmtBuilder& operator=(const ResolvedDropTableFunctionStmtBuilder&) = delete;
  ResolvedDropTableFunctionStmtBuilder(ResolvedDropTableFunctionStmtBuilder&& other)
      : ResolvedDropTableFunctionStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedDropTableFunctionStmtBuilder& operator=(ResolvedDropTableFunctionStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedDropTableFunctionStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedDropTableFunctionStmt::is_if_exists was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedDropTableFunctionStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedDropTableFunctionStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedDropTableFunctionStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedDropTableFunctionStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedDropTableFunctionStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedDropTableFunctionStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropTableFunctionStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropTableFunctionStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropTableFunctionStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedDropTableFunctionStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropTableFunctionStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropTableFunctionStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropTableFunctionStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedDropTableFunctionStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedDropTableFunctionStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedDropTableFunctionStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedDropTableFunctionStmt> node);

  ResolvedDropTableFunctionStmtBuilder(std::unique_ptr<ResolvedDropTableFunctionStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedDropTableFunctionStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedDropTableFunctionStmt> node) {
  ResolvedDropTableFunctionStmtBuilder builder(absl::WrapUnique<ResolvedDropTableFunctionStmt>(
      const_cast<ResolvedDropTableFunctionStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedCallStmtBuilder final {
 public:
  ResolvedCallStmtBuilder() : ResolvedCallStmtBuilder(absl::WrapUnique(new ResolvedCallStmt)) {}

  ResolvedCallStmtBuilder(const ResolvedCallStmtBuilder&) = delete;
  ResolvedCallStmtBuilder& operator=(const ResolvedCallStmtBuilder&) = delete;
  ResolvedCallStmtBuilder(ResolvedCallStmtBuilder&& other)
      : ResolvedCallStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCallStmtBuilder& operator=(ResolvedCallStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCallStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCallStmt::procedure was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCallStmt::signature was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const Procedure* procedure() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->procedure();
  }

  ResolvedCallStmtBuilder&& set_procedure(const Procedure* v) && {
    node_->set_procedure(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedCallStmtBuilder& set_procedure(const Procedure* v) & {
    node_->set_procedure(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const FunctionSignature& signature() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->signature();
  }

  ResolvedCallStmtBuilder&& set_signature(const FunctionSignature& v) && {
    node_->set_signature(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedCallStmtBuilder& set_signature(const FunctionSignature& v) & {
    node_->set_signature(v);
    field_is_set_.set(2, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& argument_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list();
  }

  int argument_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list_size();
  }

  const ResolvedExpr* argument_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCallStmtBuilder&& add_argument_list(T v) && {
    node_->add_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCallStmtBuilder& add_argument_list(T v) & {
    node_->add_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCallStmtBuilder&& add_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCallStmtBuilder& add_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_argument_list() {
    return node_->release_argument_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCallStmtBuilder&& set_argument_list(T v) && {
    node_->set_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCallStmtBuilder& set_argument_list(T v) & {
    node_->set_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCallStmtBuilder&& set_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCallStmtBuilder& set_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCallStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCallStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCallStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCallStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCallStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCallStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCallStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCallStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCallStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedCallStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCallStmt> node);

  ResolvedCallStmtBuilder(std::unique_ptr<ResolvedCallStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCallStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCallStmt> node) {
  ResolvedCallStmtBuilder builder(absl::WrapUnique<ResolvedCallStmt>(
      const_cast<ResolvedCallStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedImportStmtBuilder final {
 public:
    typedef ResolvedImportStmtEnums::ImportKind ImportKind;
  static const ImportKind MODULE = ResolvedImportStmtEnums::MODULE;
  static const ImportKind PROTO = ResolvedImportStmtEnums::PROTO;
  static const ImportKind __ImportKind__switch_must_have_a_default__ = ResolvedImportStmtEnums::__ImportKind__switch_must_have_a_default__;

  std::string GetImportKindString() const;
  static std::string ImportKindToString(ImportKind kind);

  ResolvedImportStmtBuilder() : ResolvedImportStmtBuilder(absl::WrapUnique(new ResolvedImportStmt)) {}

  ResolvedImportStmtBuilder(const ResolvedImportStmtBuilder&) = delete;
  ResolvedImportStmtBuilder& operator=(const ResolvedImportStmtBuilder&) = delete;
  ResolvedImportStmtBuilder(ResolvedImportStmtBuilder&& other)
      : ResolvedImportStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedImportStmtBuilder& operator=(ResolvedImportStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedImportStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedImportStmt::import_kind was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  ResolvedImportStmt::ImportKind import_kind() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->import_kind();
  }

  ResolvedImportStmtBuilder&& set_import_kind(ResolvedImportStmt::ImportKind v) && {
    node_->set_import_kind(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedImportStmtBuilder& set_import_kind(ResolvedImportStmt::ImportKind v) & {
    node_->set_import_kind(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedImportStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedImportStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedImportStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedImportStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::string& file_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->file_path();
  }

  ResolvedImportStmtBuilder&& set_file_path(const std::string& v) && {
    node_->set_file_path(v);

    return std::move(*this);
  }

  ResolvedImportStmtBuilder& set_file_path(const std::string& v) & {
    node_->set_file_path(v);

    return *this;
  }

  const std::vector<std::string>& alias_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alias_path();
  }

  int alias_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alias_path_size();
  }

  const std::string& alias_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alias_path(i);
  }

  ResolvedImportStmtBuilder&& add_alias_path(std::string v) && {
    node_->add_alias_path(v);

    return std::move(*this);
  }

  ResolvedImportStmtBuilder& add_alias_path(std::string v) & {
    node_->add_alias_path(v);

    return *this;
  }

  ResolvedImportStmtBuilder&& set_alias_path(const std::vector<std::string>& v) && {
    node_->set_alias_path(v);

    return std::move(*this);
  }

  ResolvedImportStmtBuilder& set_alias_path(const std::vector<std::string>& v) & {
    node_->set_alias_path(v);

    return *this;
  }

  const std::vector<std::string>& into_alias_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->into_alias_path();
  }

  int into_alias_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->into_alias_path_size();
  }

  const std::string& into_alias_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->into_alias_path(i);
  }

  ResolvedImportStmtBuilder&& add_into_alias_path(std::string v) && {
    node_->add_into_alias_path(v);

    return std::move(*this);
  }

  ResolvedImportStmtBuilder& add_into_alias_path(std::string v) & {
    node_->add_into_alias_path(v);

    return *this;
  }

  ResolvedImportStmtBuilder&& set_into_alias_path(const std::vector<std::string>& v) && {
    node_->set_into_alias_path(v);

    return std::move(*this);
  }

  ResolvedImportStmtBuilder& set_into_alias_path(const std::vector<std::string>& v) & {
    node_->set_into_alias_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedImportStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedImportStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedImportStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedImportStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedImportStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedImportStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedImportStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedImportStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedImportStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedImportStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedImportStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedImportStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedImportStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedImportStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedImportStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedImportStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedImportStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<7> field_is_set_ = {0};
  friend ResolvedImportStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedImportStmt> node);

  ResolvedImportStmtBuilder(std::unique_ptr<ResolvedImportStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedImportStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedImportStmt> node) {
  ResolvedImportStmtBuilder builder(absl::WrapUnique<ResolvedImportStmt>(
      const_cast<ResolvedImportStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedModuleStmtBuilder final {
 public:
  ResolvedModuleStmtBuilder() : ResolvedModuleStmtBuilder(absl::WrapUnique(new ResolvedModuleStmt)) {}

  ResolvedModuleStmtBuilder(const ResolvedModuleStmtBuilder&) = delete;
  ResolvedModuleStmtBuilder& operator=(const ResolvedModuleStmtBuilder&) = delete;
  ResolvedModuleStmtBuilder(ResolvedModuleStmtBuilder&& other)
      : ResolvedModuleStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedModuleStmtBuilder& operator=(ResolvedModuleStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedModuleStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedModuleStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedModuleStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedModuleStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedModuleStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedModuleStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedModuleStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedModuleStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedModuleStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedModuleStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedModuleStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedModuleStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedModuleStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedModuleStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedModuleStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedModuleStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedModuleStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedModuleStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedModuleStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedModuleStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedModuleStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedModuleStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedModuleStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedModuleStmt> node);

  ResolvedModuleStmtBuilder(std::unique_ptr<ResolvedModuleStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedModuleStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedModuleStmt> node) {
  ResolvedModuleStmtBuilder builder(absl::WrapUnique<ResolvedModuleStmt>(
      const_cast<ResolvedModuleStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedAggregateHavingModifierBuilder final {
 public:
    typedef ResolvedAggregateHavingModifierEnums::HavingModifierKind HavingModifierKind;
  static const HavingModifierKind INVALID = ResolvedAggregateHavingModifierEnums::INVALID;
  static const HavingModifierKind MAX = ResolvedAggregateHavingModifierEnums::MAX;
  static const HavingModifierKind MIN = ResolvedAggregateHavingModifierEnums::MIN;

  std::string GetHavingModifierKindString() const;
  static std::string HavingModifierKindToString(HavingModifierKind kind);

  ResolvedAggregateHavingModifierBuilder() : ResolvedAggregateHavingModifierBuilder(absl::WrapUnique(new ResolvedAggregateHavingModifier)) {}

  ResolvedAggregateHavingModifierBuilder(const ResolvedAggregateHavingModifierBuilder&) = delete;
  ResolvedAggregateHavingModifierBuilder& operator=(const ResolvedAggregateHavingModifierBuilder&) = delete;
  ResolvedAggregateHavingModifierBuilder(ResolvedAggregateHavingModifierBuilder&& other)
      : ResolvedAggregateHavingModifierBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAggregateHavingModifierBuilder& operator=(ResolvedAggregateHavingModifierBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAggregateHavingModifier>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAggregateHavingModifier::kind was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAggregateHavingModifier::having_expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  ResolvedAggregateHavingModifier::HavingModifierKind kind() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->kind();
  }

  ResolvedAggregateHavingModifierBuilder&& set_kind(ResolvedAggregateHavingModifier::HavingModifierKind v) && {
    node_->set_kind(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedAggregateHavingModifierBuilder& set_kind(ResolvedAggregateHavingModifier::HavingModifierKind v) & {
    node_->set_kind(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedExpr* having_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->having_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_having_expr() {
    return node_->release_having_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAggregateHavingModifierBuilder&& set_having_expr(T v) && {
    node_->set_having_expr(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAggregateHavingModifierBuilder& set_having_expr(T v) & {
    node_->set_having_expr(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAggregateHavingModifierBuilder&& set_having_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_having_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAggregateHavingModifierBuilder& set_having_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_having_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAggregateHavingModifier> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedAggregateHavingModifierBuilder ToBuilder(
      std::unique_ptr<const ResolvedAggregateHavingModifier> node);

  ResolvedAggregateHavingModifierBuilder(std::unique_ptr<ResolvedAggregateHavingModifier> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAggregateHavingModifierBuilder ToBuilder(
    std::unique_ptr<const ResolvedAggregateHavingModifier> node) {
  ResolvedAggregateHavingModifierBuilder builder(absl::WrapUnique<ResolvedAggregateHavingModifier>(
      const_cast<ResolvedAggregateHavingModifier*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedCreateMaterializedViewStmtBuilder final {
 public:
  ResolvedCreateMaterializedViewStmtBuilder() : ResolvedCreateMaterializedViewStmtBuilder(absl::WrapUnique(new ResolvedCreateMaterializedViewStmt)) {}

  ResolvedCreateMaterializedViewStmtBuilder(const ResolvedCreateMaterializedViewStmtBuilder&) = delete;
  ResolvedCreateMaterializedViewStmtBuilder& operator=(const ResolvedCreateMaterializedViewStmtBuilder&) = delete;
  ResolvedCreateMaterializedViewStmtBuilder(ResolvedCreateMaterializedViewStmtBuilder&& other)
      : ResolvedCreateMaterializedViewStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCreateMaterializedViewStmtBuilder& operator=(ResolvedCreateMaterializedViewStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateMaterializedViewStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(7)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateMaterializedViewStmt::query was not set on the builder");
    }
    if (!field_is_set_.test(8)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateMaterializedViewStmt::sql was not set on the builder");
    }
    if (!field_is_set_.test(11)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateMaterializedViewStmt::recursive was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedColumnDefinition>>& column_definition_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list();
  }

  int column_definition_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list_size();
  }

  const ResolvedColumnDefinition* column_definition_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& add_column_definition_list(T v) && {
    node_->add_column_definition_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& add_column_definition_list(T v) & {
    node_->add_column_definition_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& add_column_definition_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& add_column_definition_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> release_column_definition_list() {
    return node_->release_column_definition_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_column_definition_list(T v) && {
    node_->set_column_definition_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_column_definition_list(T v) & {
    node_->set_column_definition_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_column_definition_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_column_definition_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& partition_by_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list();
  }

  int partition_by_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list_size();
  }

  const ResolvedExpr* partition_by_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& add_partition_by_list(T v) && {
    node_->add_partition_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& add_partition_by_list(T v) & {
    node_->add_partition_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& add_partition_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& add_partition_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_partition_by_list() {
    return node_->release_partition_by_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_partition_by_list(T v) && {
    node_->set_partition_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_partition_by_list(T v) & {
    node_->set_partition_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_partition_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_partition_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& cluster_by_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->cluster_by_list();
  }

  int cluster_by_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->cluster_by_list_size();
  }

  const ResolvedExpr* cluster_by_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->cluster_by_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& add_cluster_by_list(T v) && {
    node_->add_cluster_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& add_cluster_by_list(T v) & {
    node_->add_cluster_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& add_cluster_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& add_cluster_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_cluster_by_list() {
    return node_->release_cluster_by_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_cluster_by_list(T v) && {
    node_->set_cluster_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_cluster_by_list(T v) & {
    node_->set_cluster_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_cluster_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_cluster_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateMaterializedViewStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateMaterializedViewStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateMaterializedViewStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateMaterializedViewStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateMaterializedViewStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateMaterializedViewStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateMaterializedViewStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateMaterializedViewStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOutputColumn>>& output_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list();
  }

  int output_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list_size();
  }

  const ResolvedOutputColumn* output_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& add_output_column_list(T v) && {
    node_->add_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& add_output_column_list(T v) & {
    node_->add_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& add_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& add_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOutputColumn>> release_output_column_list() {
    return node_->release_output_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_output_column_list(T v) && {
    node_->set_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_output_column_list(T v) & {
    node_->set_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool has_explicit_columns() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->has_explicit_columns();
  }

  ResolvedCreateMaterializedViewStmtBuilder&& set_has_explicit_columns(bool v) && {
    node_->set_has_explicit_columns(v);

    return std::move(*this);
  }

  ResolvedCreateMaterializedViewStmtBuilder& set_has_explicit_columns(bool v) & {
    node_->set_has_explicit_columns(v);

    return *this;
  }

  const ResolvedScan* query() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->query();
  }

  std::unique_ptr<const ResolvedScan> release_query() {
    return node_->release_query();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_query(T v) && {
    node_->set_query(std::move(v));
    field_is_set_.set(7, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_query(T v) & {
    node_->set_query(std::move(v));
    field_is_set_.set(7, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder&& set_query(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(7, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCreateMaterializedViewStmtBuilder& set_query(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_query(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(7, true);

    return *this;
  }

  const std::string& sql() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->sql();
  }

  ResolvedCreateMaterializedViewStmtBuilder&& set_sql(const std::string& v) && {
    node_->set_sql(v);
    field_is_set_.set(8, true);

    return std::move(*this);
  }

  ResolvedCreateMaterializedViewStmtBuilder& set_sql(const std::string& v) & {
    node_->set_sql(v);
    field_is_set_.set(8, true);

    return *this;
  }

  ResolvedCreateStatement::SqlSecurity sql_security() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->sql_security();
  }

  ResolvedCreateMaterializedViewStmtBuilder&& set_sql_security(ResolvedCreateStatement::SqlSecurity v) && {
    node_->set_sql_security(v);

    return std::move(*this);
  }

  ResolvedCreateMaterializedViewStmtBuilder& set_sql_security(ResolvedCreateStatement::SqlSecurity v) & {
    node_->set_sql_security(v);

    return *this;
  }

  // If true, this view produces a value table. Rather than producing
  // rows with named columns, it produces rows with a single unnamed
  // value type.  output_column_list will have exactly one column, with
  // an empty name. See (broken link).
  bool is_value_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_value_table();
  }

  ResolvedCreateMaterializedViewStmtBuilder&& set_is_value_table(bool v) && {
    node_->set_is_value_table(v);

    return std::move(*this);
  }

  ResolvedCreateMaterializedViewStmtBuilder& set_is_value_table(bool v) & {
    node_->set_is_value_table(v);

    return *this;
  }

  // True if the view uses the RECURSIVE keyword. <query>
  // can be a ResolvedRecursiveScan only if this is true.
  bool recursive() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->recursive();
  }

  ResolvedCreateMaterializedViewStmtBuilder&& set_recursive(bool v) && {
    node_->set_recursive(v);
    field_is_set_.set(11, true);

    return std::move(*this);
  }

  ResolvedCreateMaterializedViewStmtBuilder& set_recursive(bool v) & {
    node_->set_recursive(v);
    field_is_set_.set(11, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateMaterializedViewStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<15> field_is_set_ = {0};
  friend ResolvedCreateMaterializedViewStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateMaterializedViewStmt> node);

  ResolvedCreateMaterializedViewStmtBuilder(std::unique_ptr<ResolvedCreateMaterializedViewStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateMaterializedViewStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateMaterializedViewStmt> node) {
  ResolvedCreateMaterializedViewStmtBuilder builder(absl::WrapUnique<ResolvedCreateMaterializedViewStmt>(
      const_cast<ResolvedCreateMaterializedViewStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(7, true);
  builder.field_is_set_.set(8, true);
  builder.field_is_set_.set(11, true);
  return builder;
}

class ResolvedCreateProcedureStmtBuilder final {
 public:
  ResolvedCreateProcedureStmtBuilder() : ResolvedCreateProcedureStmtBuilder(absl::WrapUnique(new ResolvedCreateProcedureStmt)) {}

  ResolvedCreateProcedureStmtBuilder(const ResolvedCreateProcedureStmtBuilder&) = delete;
  ResolvedCreateProcedureStmtBuilder& operator=(const ResolvedCreateProcedureStmtBuilder&) = delete;
  ResolvedCreateProcedureStmtBuilder(ResolvedCreateProcedureStmtBuilder&& other)
      : ResolvedCreateProcedureStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCreateProcedureStmtBuilder& operator=(ResolvedCreateProcedureStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateProcedureStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateProcedureStmt::signature was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::string>& argument_name_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_name_list();
  }

  int argument_name_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_name_list_size();
  }

  const std::string& argument_name_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->argument_name_list(i);
  }

  ResolvedCreateProcedureStmtBuilder&& add_argument_name_list(std::string v) && {
    node_->add_argument_name_list(v);

    return std::move(*this);
  }

  ResolvedCreateProcedureStmtBuilder& add_argument_name_list(std::string v) & {
    node_->add_argument_name_list(v);

    return *this;
  }

  ResolvedCreateProcedureStmtBuilder&& set_argument_name_list(const std::vector<std::string>& v) && {
    node_->set_argument_name_list(v);

    return std::move(*this);
  }

  ResolvedCreateProcedureStmtBuilder& set_argument_name_list(const std::vector<std::string>& v) & {
    node_->set_argument_name_list(v);

    return *this;
  }

  const FunctionSignature& signature() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->signature();
  }

  ResolvedCreateProcedureStmtBuilder&& set_signature(const FunctionSignature& v) && {
    node_->set_signature(v);
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  ResolvedCreateProcedureStmtBuilder& set_signature(const FunctionSignature& v) & {
    node_->set_signature(v);
    field_is_set_.set(5, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateProcedureStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateProcedureStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateProcedureStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateProcedureStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateProcedureStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateProcedureStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateProcedureStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateProcedureStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::string& procedure_body() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->procedure_body();
  }

  ResolvedCreateProcedureStmtBuilder&& set_procedure_body(const std::string& v) && {
    node_->set_procedure_body(v);

    return std::move(*this);
  }

  ResolvedCreateProcedureStmtBuilder& set_procedure_body(const std::string& v) & {
    node_->set_procedure_body(v);

    return *this;
  }

  const ResolvedConnection* connection() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->connection();
  }

  std::unique_ptr<const ResolvedConnection> release_connection() {
    return node_->release_connection();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedCreateProcedureStmtBuilder&& set_connection(T v) && {
    node_->set_connection(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedCreateProcedureStmtBuilder& set_connection(T v) & {
    node_->set_connection(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedCreateProcedureStmtBuilder&& set_connection(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedCreateProcedureStmtBuilder& set_connection(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::string& language() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->language();
  }

  ResolvedCreateProcedureStmtBuilder&& set_language(const std::string& v) && {
    node_->set_language(v);

    return std::move(*this);
  }

  ResolvedCreateProcedureStmtBuilder& set_language(const std::string& v) & {
    node_->set_language(v);

    return *this;
  }

  const std::string& code() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->code();
  }

  ResolvedCreateProcedureStmtBuilder&& set_code(const std::string& v) && {
    node_->set_code(v);

    return std::move(*this);
  }

  ResolvedCreateProcedureStmtBuilder& set_code(const std::string& v) & {
    node_->set_code(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateProcedureStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateProcedureStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateProcedureStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateProcedureStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateProcedureStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateProcedureStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateProcedureStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateProcedureStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateProcedureStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateProcedureStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateProcedureStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateProcedureStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateProcedureStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateProcedureStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateProcedureStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateProcedureStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateProcedureStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<11> field_is_set_ = {0};
  friend ResolvedCreateProcedureStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateProcedureStmt> node);

  ResolvedCreateProcedureStmtBuilder(std::unique_ptr<ResolvedCreateProcedureStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateProcedureStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateProcedureStmt> node) {
  ResolvedCreateProcedureStmtBuilder builder(absl::WrapUnique<ResolvedCreateProcedureStmt>(
      const_cast<ResolvedCreateProcedureStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(5, true);
  return builder;
}

class ResolvedExecuteImmediateArgumentBuilder final {
 public:
  ResolvedExecuteImmediateArgumentBuilder() : ResolvedExecuteImmediateArgumentBuilder(absl::WrapUnique(new ResolvedExecuteImmediateArgument)) {}

  ResolvedExecuteImmediateArgumentBuilder(const ResolvedExecuteImmediateArgumentBuilder&) = delete;
  ResolvedExecuteImmediateArgumentBuilder& operator=(const ResolvedExecuteImmediateArgumentBuilder&) = delete;
  ResolvedExecuteImmediateArgumentBuilder(ResolvedExecuteImmediateArgumentBuilder&& other)
      : ResolvedExecuteImmediateArgumentBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedExecuteImmediateArgumentBuilder& operator=(ResolvedExecuteImmediateArgumentBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedExecuteImmediateArgument>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedExecuteImmediateArgument::name was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedExecuteImmediateArgument::expression was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& name() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name();
  }

  ResolvedExecuteImmediateArgumentBuilder&& set_name(const std::string& v) && {
    node_->set_name(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedExecuteImmediateArgumentBuilder& set_name(const std::string& v) & {
    node_->set_name(v);
    field_is_set_.set(0, true);

    return *this;
  }

  const ResolvedExpr* expression() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expression();
  }

  std::unique_ptr<const ResolvedExpr> release_expression() {
    return node_->release_expression();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedExecuteImmediateArgumentBuilder&& set_expression(T v) && {
    node_->set_expression(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedExecuteImmediateArgumentBuilder& set_expression(T v) & {
    node_->set_expression(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedExecuteImmediateArgumentBuilder&& set_expression(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedExecuteImmediateArgumentBuilder& set_expression(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expression(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedExecuteImmediateArgument> node_;

  absl::Status deferred_build_status_;
  std::bitset<2> field_is_set_ = {0};
  friend ResolvedExecuteImmediateArgumentBuilder ToBuilder(
      std::unique_ptr<const ResolvedExecuteImmediateArgument> node);

  ResolvedExecuteImmediateArgumentBuilder(std::unique_ptr<ResolvedExecuteImmediateArgument> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedExecuteImmediateArgumentBuilder ToBuilder(
    std::unique_ptr<const ResolvedExecuteImmediateArgument> node) {
  ResolvedExecuteImmediateArgumentBuilder builder(absl::WrapUnique<ResolvedExecuteImmediateArgument>(
      const_cast<ResolvedExecuteImmediateArgument*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedExecuteImmediateStmtBuilder final {
 public:
  ResolvedExecuteImmediateStmtBuilder() : ResolvedExecuteImmediateStmtBuilder(absl::WrapUnique(new ResolvedExecuteImmediateStmt)) {}

  ResolvedExecuteImmediateStmtBuilder(const ResolvedExecuteImmediateStmtBuilder&) = delete;
  ResolvedExecuteImmediateStmtBuilder& operator=(const ResolvedExecuteImmediateStmtBuilder&) = delete;
  ResolvedExecuteImmediateStmtBuilder(ResolvedExecuteImmediateStmtBuilder&& other)
      : ResolvedExecuteImmediateStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedExecuteImmediateStmtBuilder& operator=(ResolvedExecuteImmediateStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedExecuteImmediateStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedExecuteImmediateStmt::sql was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedExpr* sql() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->sql();
  }

  std::unique_ptr<const ResolvedExpr> release_sql() {
    return node_->release_sql();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedExecuteImmediateStmtBuilder&& set_sql(T v) && {
    node_->set_sql(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedExecuteImmediateStmtBuilder& set_sql(T v) & {
    node_->set_sql(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedExecuteImmediateStmtBuilder&& set_sql(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_sql(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedExecuteImmediateStmtBuilder& set_sql(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_sql(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<std::string>& into_identifier_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->into_identifier_list();
  }

  int into_identifier_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->into_identifier_list_size();
  }

  const std::string& into_identifier_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->into_identifier_list(i);
  }

  ResolvedExecuteImmediateStmtBuilder&& add_into_identifier_list(std::string v) && {
    node_->add_into_identifier_list(v);

    return std::move(*this);
  }

  ResolvedExecuteImmediateStmtBuilder& add_into_identifier_list(std::string v) & {
    node_->add_into_identifier_list(v);

    return *this;
  }

  ResolvedExecuteImmediateStmtBuilder&& set_into_identifier_list(const std::vector<std::string>& v) && {
    node_->set_into_identifier_list(v);

    return std::move(*this);
  }

  ResolvedExecuteImmediateStmtBuilder& set_into_identifier_list(const std::vector<std::string>& v) & {
    node_->set_into_identifier_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExecuteImmediateArgument>>& using_argument_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->using_argument_list();
  }

  int using_argument_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->using_argument_list_size();
  }

  const ResolvedExecuteImmediateArgument* using_argument_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->using_argument_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExecuteImmediateArgument>>::value>>
  ResolvedExecuteImmediateStmtBuilder&& add_using_argument_list(T v) && {
    node_->add_using_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExecuteImmediateArgument>>::value>>
  ResolvedExecuteImmediateStmtBuilder& add_using_argument_list(T v) & {
    node_->add_using_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExecuteImmediateArgument>>::value>>
  ResolvedExecuteImmediateStmtBuilder&& add_using_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_using_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExecuteImmediateArgument>>::value>>
  ResolvedExecuteImmediateStmtBuilder& add_using_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_using_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExecuteImmediateArgument>> release_using_argument_list() {
    return node_->release_using_argument_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExecuteImmediateArgument>>>::value>>
  ResolvedExecuteImmediateStmtBuilder&& set_using_argument_list(T v) && {
    node_->set_using_argument_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExecuteImmediateArgument>>>::value>>
  ResolvedExecuteImmediateStmtBuilder& set_using_argument_list(T v) & {
    node_->set_using_argument_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExecuteImmediateArgument>>>::value>>
  ResolvedExecuteImmediateStmtBuilder&& set_using_argument_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_using_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExecuteImmediateArgument>>>::value>>
  ResolvedExecuteImmediateStmtBuilder& set_using_argument_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_using_argument_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExecuteImmediateStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExecuteImmediateStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExecuteImmediateStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedExecuteImmediateStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExecuteImmediateStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExecuteImmediateStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExecuteImmediateStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedExecuteImmediateStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedExecuteImmediateStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<4> field_is_set_ = {0};
  friend ResolvedExecuteImmediateStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedExecuteImmediateStmt> node);

  ResolvedExecuteImmediateStmtBuilder(std::unique_ptr<ResolvedExecuteImmediateStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedExecuteImmediateStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedExecuteImmediateStmt> node) {
  ResolvedExecuteImmediateStmtBuilder builder(absl::WrapUnique<ResolvedExecuteImmediateStmt>(
      const_cast<ResolvedExecuteImmediateStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedAssignmentStmtBuilder final {
 public:
  ResolvedAssignmentStmtBuilder() : ResolvedAssignmentStmtBuilder(absl::WrapUnique(new ResolvedAssignmentStmt)) {}

  ResolvedAssignmentStmtBuilder(const ResolvedAssignmentStmtBuilder&) = delete;
  ResolvedAssignmentStmtBuilder& operator=(const ResolvedAssignmentStmtBuilder&) = delete;
  ResolvedAssignmentStmtBuilder(ResolvedAssignmentStmtBuilder&& other)
      : ResolvedAssignmentStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAssignmentStmtBuilder& operator=(ResolvedAssignmentStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAssignmentStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAssignmentStmt::target was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAssignmentStmt::expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // Target of the assignment.  Currently, this will be either ResolvedSystemVariable, or a chain of ResolveGetField operations around it.
  const ResolvedExpr* target() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->target();
  }

  std::unique_ptr<const ResolvedExpr> release_target() {
    return node_->release_target();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssignmentStmtBuilder&& set_target(T v) && {
    node_->set_target(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssignmentStmtBuilder& set_target(T v) & {
    node_->set_target(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssignmentStmtBuilder&& set_target(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_target(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssignmentStmtBuilder& set_target(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_target(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

  // Value to assign into the target.  This will always be the same type as the target.
  const ResolvedExpr* expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr();
  }

  std::unique_ptr<const ResolvedExpr> release_expr() {
    return node_->release_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssignmentStmtBuilder&& set_expr(T v) && {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssignmentStmtBuilder& set_expr(T v) & {
    node_->set_expr(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssignmentStmtBuilder&& set_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAssignmentStmtBuilder& set_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAssignmentStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAssignmentStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAssignmentStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAssignmentStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAssignmentStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAssignmentStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAssignmentStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAssignmentStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAssignmentStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedAssignmentStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAssignmentStmt> node);

  ResolvedAssignmentStmtBuilder(std::unique_ptr<ResolvedAssignmentStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAssignmentStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAssignmentStmt> node) {
  ResolvedAssignmentStmtBuilder builder(absl::WrapUnique<ResolvedAssignmentStmt>(
      const_cast<ResolvedAssignmentStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedCreateEntityStmtBuilder final {
 public:
  ResolvedCreateEntityStmtBuilder() : ResolvedCreateEntityStmtBuilder(absl::WrapUnique(new ResolvedCreateEntityStmt)) {}

  ResolvedCreateEntityStmtBuilder(const ResolvedCreateEntityStmtBuilder&) = delete;
  ResolvedCreateEntityStmtBuilder& operator=(const ResolvedCreateEntityStmtBuilder&) = delete;
  ResolvedCreateEntityStmtBuilder(ResolvedCreateEntityStmtBuilder&& other)
      : ResolvedCreateEntityStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCreateEntityStmtBuilder& operator=(ResolvedCreateEntityStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCreateEntityStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCreateEntityStmt::entity_type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& entity_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->entity_type();
  }

  ResolvedCreateEntityStmtBuilder&& set_entity_type(const std::string& v) && {
    node_->set_entity_type(v);
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  ResolvedCreateEntityStmtBuilder& set_entity_type(const std::string& v) & {
    node_->set_entity_type(v);
    field_is_set_.set(4, true);

    return *this;
  }

  const std::string& entity_body_json() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->entity_body_json();
  }

  ResolvedCreateEntityStmtBuilder&& set_entity_body_json(const std::string& v) && {
    node_->set_entity_body_json(v);

    return std::move(*this);
  }

  ResolvedCreateEntityStmtBuilder& set_entity_body_json(const std::string& v) & {
    node_->set_entity_body_json(v);

    return *this;
  }

  const std::string& entity_body_text() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->entity_body_text();
  }

  ResolvedCreateEntityStmtBuilder&& set_entity_body_text(const std::string& v) && {
    node_->set_entity_body_text(v);

    return std::move(*this);
  }

  ResolvedCreateEntityStmtBuilder& set_entity_body_text(const std::string& v) & {
    node_->set_entity_body_text(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateEntityStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateEntityStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateEntityStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateEntityStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateEntityStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateEntityStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateEntityStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateEntityStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateEntityStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateEntityStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateEntityStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCreateEntityStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateEntityStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateEntityStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateEntityStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCreateEntityStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedCreateEntityStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateEntityStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedCreateEntityStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedCreateEntityStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  ResolvedCreateStatement::CreateScope create_scope() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_scope();
  }

  ResolvedCreateEntityStmtBuilder&& set_create_scope(ResolvedCreateStatement::CreateScope v) && {
    node_->set_create_scope(v);

    return std::move(*this);
  }

  ResolvedCreateEntityStmtBuilder& set_create_scope(ResolvedCreateStatement::CreateScope v) & {
    node_->set_create_scope(v);

    return *this;
  }

  ResolvedCreateStatement::CreateMode create_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->create_mode();
  }

  ResolvedCreateEntityStmtBuilder&& set_create_mode(ResolvedCreateStatement::CreateMode v) && {
    node_->set_create_mode(v);

    return std::move(*this);
  }

  ResolvedCreateEntityStmtBuilder& set_create_mode(ResolvedCreateStatement::CreateMode v) & {
    node_->set_create_mode(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCreateEntityStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<8> field_is_set_ = {0};
  friend ResolvedCreateEntityStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCreateEntityStmt> node);

  ResolvedCreateEntityStmtBuilder(std::unique_ptr<ResolvedCreateEntityStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCreateEntityStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCreateEntityStmt> node) {
  ResolvedCreateEntityStmtBuilder builder(absl::WrapUnique<ResolvedCreateEntityStmt>(
      const_cast<ResolvedCreateEntityStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedAlterEntityStmtBuilder final {
 public:
  ResolvedAlterEntityStmtBuilder() : ResolvedAlterEntityStmtBuilder(absl::WrapUnique(new ResolvedAlterEntityStmt)) {}

  ResolvedAlterEntityStmtBuilder(const ResolvedAlterEntityStmtBuilder&) = delete;
  ResolvedAlterEntityStmtBuilder& operator=(const ResolvedAlterEntityStmtBuilder&) = delete;
  ResolvedAlterEntityStmtBuilder(ResolvedAlterEntityStmtBuilder&& other)
      : ResolvedAlterEntityStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAlterEntityStmtBuilder& operator=(ResolvedAlterEntityStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAlterEntityStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(4)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAlterEntityStmt::entity_type was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::string& entity_type() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->entity_type();
  }

  ResolvedAlterEntityStmtBuilder&& set_entity_type(const std::string& v) && {
    node_->set_entity_type(v);
    field_is_set_.set(4, true);

    return std::move(*this);
  }

  ResolvedAlterEntityStmtBuilder& set_entity_type(const std::string& v) & {
    node_->set_entity_type(v);
    field_is_set_.set(4, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterEntityStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterEntityStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterEntityStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAlterEntityStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterEntityStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterEntityStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterEntityStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAlterEntityStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedAlterEntityStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterEntityStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedAlterEntityStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedAlterEntityStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedAlterAction>>& alter_action_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list();
  }

  int alter_action_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list_size();
  }

  const ResolvedAlterAction* alter_action_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->alter_action_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterEntityStmtBuilder&& add_alter_action_list(T v) && {
    node_->add_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterEntityStmtBuilder& add_alter_action_list(T v) & {
    node_->add_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterEntityStmtBuilder&& add_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedAlterAction>>::value>>
  ResolvedAlterEntityStmtBuilder& add_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedAlterAction>> release_alter_action_list() {
    return node_->release_alter_action_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterEntityStmtBuilder&& set_alter_action_list(T v) && {
    node_->set_alter_action_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterEntityStmtBuilder& set_alter_action_list(T v) & {
    node_->set_alter_action_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterEntityStmtBuilder&& set_alter_action_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedAlterAction>>>::value>>
  ResolvedAlterEntityStmtBuilder& set_alter_action_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_alter_action_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_if_exists() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_if_exists();
  }

  ResolvedAlterEntityStmtBuilder&& set_is_if_exists(bool v) && {
    node_->set_is_if_exists(v);

    return std::move(*this);
  }

  ResolvedAlterEntityStmtBuilder& set_is_if_exists(bool v) & {
    node_->set_is_if_exists(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAlterEntityStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<5> field_is_set_ = {0};
  friend ResolvedAlterEntityStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAlterEntityStmt> node);

  ResolvedAlterEntityStmtBuilder(std::unique_ptr<ResolvedAlterEntityStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAlterEntityStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAlterEntityStmt> node) {
  ResolvedAlterEntityStmtBuilder builder(absl::WrapUnique<ResolvedAlterEntityStmt>(
      const_cast<ResolvedAlterEntityStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(4, true);
  return builder;
}

class ResolvedPivotColumnBuilder final {
 public:
  ResolvedPivotColumnBuilder() : ResolvedPivotColumnBuilder(absl::WrapUnique(new ResolvedPivotColumn)) {}

  ResolvedPivotColumnBuilder(const ResolvedPivotColumnBuilder&) = delete;
  ResolvedPivotColumnBuilder& operator=(const ResolvedPivotColumnBuilder&) = delete;
  ResolvedPivotColumnBuilder(ResolvedPivotColumnBuilder&& other)
      : ResolvedPivotColumnBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedPivotColumnBuilder& operator=(ResolvedPivotColumnBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedPivotColumn>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(0)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedPivotColumn::column was not set on the builder");
    }
    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedPivotColumn::pivot_expr_index was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedPivotColumn::pivot_value_index was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // The output column used to represent the result of the pivot.
  const ResolvedColumn& column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column();
  }

  ResolvedPivotColumnBuilder&& set_column(const ResolvedColumn& v) && {
    node_->set_column(v);
    field_is_set_.set(0, true);

    return std::move(*this);
  }

  ResolvedPivotColumnBuilder& set_column(const ResolvedColumn& v) & {
    node_->set_column(v);
    field_is_set_.set(0, true);

    return *this;
  }

  // Specifies the index of the pivot expression
  // within the enclosing ResolvedPivotScan's <pivot_expr_list> used to
  // determine the result of the column.
  int pivot_expr_index() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pivot_expr_index();
  }

  ResolvedPivotColumnBuilder&& set_pivot_expr_index(int v) && {
    node_->set_pivot_expr_index(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedPivotColumnBuilder& set_pivot_expr_index(int v) & {
    node_->set_pivot_expr_index(v);
    field_is_set_.set(1, true);

    return *this;
  }

  // Specifies the index of the pivot value within
  // the enclosing ResolvedPivotScan's <pivot_value_list> used to
  // determine the subset of input rows the pivot expression should be
  // evaluated over.
  int pivot_value_index() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pivot_value_index();
  }

  ResolvedPivotColumnBuilder&& set_pivot_value_index(int v) && {
    node_->set_pivot_value_index(v);
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  ResolvedPivotColumnBuilder& set_pivot_value_index(int v) & {
    node_->set_pivot_value_index(v);
    field_is_set_.set(2, true);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedPivotColumn> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedPivotColumnBuilder ToBuilder(
      std::unique_ptr<const ResolvedPivotColumn> node);

  ResolvedPivotColumnBuilder(std::unique_ptr<ResolvedPivotColumn> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedPivotColumnBuilder ToBuilder(
    std::unique_ptr<const ResolvedPivotColumn> node) {
  ResolvedPivotColumnBuilder builder(absl::WrapUnique<ResolvedPivotColumn>(
      const_cast<ResolvedPivotColumn*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(0, true);
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedPivotScanBuilder final {
 public:
  ResolvedPivotScanBuilder() : ResolvedPivotScanBuilder(absl::WrapUnique(new ResolvedPivotScan)) {}

  ResolvedPivotScanBuilder(const ResolvedPivotScanBuilder&) = delete;
  ResolvedPivotScanBuilder& operator=(const ResolvedPivotScanBuilder&) = delete;
  ResolvedPivotScanBuilder(ResolvedPivotScanBuilder&& other)
      : ResolvedPivotScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedPivotScanBuilder& operator=(ResolvedPivotScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedPivotScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedPivotScan::input_scan was not set on the builder");
    }
    if (!field_is_set_.test(6)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedPivotScan::for_expr was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // Input to the PIVOT clause
  const ResolvedScan* input_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_scan();
  }

  std::unique_ptr<const ResolvedScan> release_input_scan() {
    return node_->release_input_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedPivotScanBuilder&& set_input_scan(T v) && {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedPivotScanBuilder& set_input_scan(T v) & {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedPivotScanBuilder&& set_input_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedPivotScanBuilder& set_input_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return *this;
  }

  // The columns from <input_scan> to group by.
  // The output will have one row for each distinct combination of
  // values for all grouping columns. (There will be one output row if
  // this list is empty.)
  //
  // Each element is a ResolvedComputedColumn. The expression is always
  // a ResolvedColumnRef that references a column from <input_scan>.
  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& group_by_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->group_by_list();
  }

  int group_by_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->group_by_list_size();
  }

  const ResolvedComputedColumn* group_by_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->group_by_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedPivotScanBuilder&& add_group_by_list(T v) && {
    node_->add_group_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedPivotScanBuilder& add_group_by_list(T v) & {
    node_->add_group_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedPivotScanBuilder&& add_group_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_group_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedPivotScanBuilder& add_group_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_group_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_group_by_list() {
    return node_->release_group_by_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedPivotScanBuilder&& set_group_by_list(T v) && {
    node_->set_group_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedPivotScanBuilder& set_group_by_list(T v) & {
    node_->set_group_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedPivotScanBuilder&& set_group_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_group_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedPivotScanBuilder& set_group_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_group_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Pivot expressions which aggregate over the subset of <input_scan>
  // where <for_expr> matches each value in <pivot_value_list>, plus
  // all columns in <group_by_list>.
  const std::vector<std::unique_ptr<const ResolvedExpr>>& pivot_expr_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pivot_expr_list();
  }

  int pivot_expr_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pivot_expr_list_size();
  }

  const ResolvedExpr* pivot_expr_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pivot_expr_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedPivotScanBuilder&& add_pivot_expr_list(T v) && {
    node_->add_pivot_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedPivotScanBuilder& add_pivot_expr_list(T v) & {
    node_->add_pivot_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedPivotScanBuilder&& add_pivot_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_pivot_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedPivotScanBuilder& add_pivot_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_pivot_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_pivot_expr_list() {
    return node_->release_pivot_expr_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedPivotScanBuilder&& set_pivot_expr_list(T v) && {
    node_->set_pivot_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedPivotScanBuilder& set_pivot_expr_list(T v) & {
    node_->set_pivot_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedPivotScanBuilder&& set_pivot_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_pivot_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedPivotScanBuilder& set_pivot_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_pivot_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Expression following the FOR keyword, to be evaluated over each row
  // in <input_scan>. This value is compared with each value in
  // <pivot_value_list> to determine which columns the aggregation
  // results of <pivot_expr_list> should go to.
  const ResolvedExpr* for_expr() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->for_expr();
  }

  std::unique_ptr<const ResolvedExpr> release_for_expr() {
    return node_->release_for_expr();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedPivotScanBuilder&& set_for_expr(T v) && {
    node_->set_for_expr(std::move(v));
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedPivotScanBuilder& set_for_expr(T v) & {
    node_->set_for_expr(std::move(v));
    field_is_set_.set(6, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedPivotScanBuilder&& set_for_expr(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_for_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(6, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedPivotScanBuilder& set_for_expr(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_for_expr(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(6, true);

    return *this;
  }

  // A list of pivot values within the IN list, to be compared against
  // the result of <for_expr> for each row in the input table. Each
  // pivot value generates a distinct column in the output for each
  // pivot expression, representing the result of the corresponding
  // pivot expression over the subset of input where <for_expr> matches
  // this pivot value.
  //
  // All pivot values in this list must have the same type as
  // <for_expr> and must be constant.
  const std::vector<std::unique_ptr<const ResolvedExpr>>& pivot_value_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pivot_value_list();
  }

  int pivot_value_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pivot_value_list_size();
  }

  const ResolvedExpr* pivot_value_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pivot_value_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedPivotScanBuilder&& add_pivot_value_list(T v) && {
    node_->add_pivot_value_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedPivotScanBuilder& add_pivot_value_list(T v) & {
    node_->add_pivot_value_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedPivotScanBuilder&& add_pivot_value_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_pivot_value_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedPivotScanBuilder& add_pivot_value_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_pivot_value_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_pivot_value_list() {
    return node_->release_pivot_value_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedPivotScanBuilder&& set_pivot_value_list(T v) && {
    node_->set_pivot_value_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedPivotScanBuilder& set_pivot_value_list(T v) & {
    node_->set_pivot_value_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedPivotScanBuilder&& set_pivot_value_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_pivot_value_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedPivotScanBuilder& set_pivot_value_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_pivot_value_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // List of columns created to store the output pivot columns.
  // Each is computed using one of pivot_expr_list and one of
  // pivot_value_list.
  const std::vector<std::unique_ptr<const ResolvedPivotColumn>>& pivot_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pivot_column_list();
  }

  int pivot_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pivot_column_list_size();
  }

  const ResolvedPivotColumn* pivot_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pivot_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPivotColumn>>::value>>
  ResolvedPivotScanBuilder&& add_pivot_column_list(T v) && {
    node_->add_pivot_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPivotColumn>>::value>>
  ResolvedPivotScanBuilder& add_pivot_column_list(T v) & {
    node_->add_pivot_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPivotColumn>>::value>>
  ResolvedPivotScanBuilder&& add_pivot_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_pivot_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPivotColumn>>::value>>
  ResolvedPivotScanBuilder& add_pivot_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_pivot_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedPivotColumn>> release_pivot_column_list() {
    return node_->release_pivot_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedPivotColumn>>>::value>>
  ResolvedPivotScanBuilder&& set_pivot_column_list(T v) && {
    node_->set_pivot_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedPivotColumn>>>::value>>
  ResolvedPivotScanBuilder& set_pivot_column_list(T v) & {
    node_->set_pivot_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedPivotColumn>>>::value>>
  ResolvedPivotScanBuilder&& set_pivot_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_pivot_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedPivotColumn>>>::value>>
  ResolvedPivotScanBuilder& set_pivot_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_pivot_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedPivotScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedPivotScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedPivotScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedPivotScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedPivotScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedPivotScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedPivotScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedPivotScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedPivotScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedPivotScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedPivotScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedPivotScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedPivotScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedPivotScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedPivotScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<9> field_is_set_ = {0};
  friend ResolvedPivotScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedPivotScan> node);

  ResolvedPivotScanBuilder(std::unique_ptr<ResolvedPivotScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedPivotScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedPivotScan> node) {
  ResolvedPivotScanBuilder builder(absl::WrapUnique<ResolvedPivotScan>(
      const_cast<ResolvedPivotScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  builder.field_is_set_.set(6, true);
  return builder;
}

class ResolvedReturningClauseBuilder final {
 public:
  ResolvedReturningClauseBuilder() : ResolvedReturningClauseBuilder(absl::WrapUnique(new ResolvedReturningClause)) {}

  ResolvedReturningClauseBuilder(const ResolvedReturningClauseBuilder&) = delete;
  ResolvedReturningClauseBuilder& operator=(const ResolvedReturningClauseBuilder&) = delete;
  ResolvedReturningClauseBuilder(ResolvedReturningClauseBuilder&& other)
      : ResolvedReturningClauseBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedReturningClauseBuilder& operator=(ResolvedReturningClauseBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedReturningClause>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedReturningClause::action_column was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // Specifies the columns in the returned output row with column
  // names. It can reference columns from the target table scan
  // <table_scan> from INSERT/DELETE/UPDATE statements. Also this list
  // can have columns computed in the <expr_list> or an <action_column>
  // as the last column.
  const std::vector<std::unique_ptr<const ResolvedOutputColumn>>& output_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list();
  }

  int output_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list_size();
  }

  const ResolvedOutputColumn* output_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedReturningClauseBuilder&& add_output_column_list(T v) && {
    node_->add_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedReturningClauseBuilder& add_output_column_list(T v) & {
    node_->add_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedReturningClauseBuilder&& add_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedReturningClauseBuilder& add_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOutputColumn>> release_output_column_list() {
    return node_->release_output_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedReturningClauseBuilder&& set_output_column_list(T v) && {
    node_->set_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedReturningClauseBuilder& set_output_column_list(T v) & {
    node_->set_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedReturningClauseBuilder&& set_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedReturningClauseBuilder& set_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Represents the WITH ACTION column in <output_column_list> as a
  // string type column. There are four valid values for this action
  // column: "INSERT", "REPLACE", "UPDATE", and "DELETE".
  const ResolvedColumnHolder* action_column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->action_column();
  }

  std::unique_ptr<const ResolvedColumnHolder> release_action_column() {
    return node_->release_action_column();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedReturningClauseBuilder&& set_action_column(T v) && {
    node_->set_action_column(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedReturningClauseBuilder& set_action_column(T v) & {
    node_->set_action_column(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedReturningClauseBuilder&& set_action_column(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_action_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnHolder>>::value>>
  ResolvedReturningClauseBuilder& set_action_column(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_action_column(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

  // Represents the computed expressions so they can be referenced in
  // <output_column_list>. Worth noting, it can't see <action_column>
  // and can only access columns from the DML statement target table.
  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& expr_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr_list();
  }

  int expr_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr_list_size();
  }

  const ResolvedComputedColumn* expr_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->expr_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedReturningClauseBuilder&& add_expr_list(T v) && {
    node_->add_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedReturningClauseBuilder& add_expr_list(T v) & {
    node_->add_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedReturningClauseBuilder&& add_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedReturningClauseBuilder& add_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_expr_list() {
    return node_->release_expr_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedReturningClauseBuilder&& set_expr_list(T v) && {
    node_->set_expr_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedReturningClauseBuilder& set_expr_list(T v) & {
    node_->set_expr_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedReturningClauseBuilder&& set_expr_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedReturningClauseBuilder& set_expr_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_expr_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedReturningClause> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedReturningClauseBuilder ToBuilder(
      std::unique_ptr<const ResolvedReturningClause> node);

  ResolvedReturningClauseBuilder(std::unique_ptr<ResolvedReturningClause> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedReturningClauseBuilder ToBuilder(
    std::unique_ptr<const ResolvedReturningClause> node) {
  ResolvedReturningClauseBuilder builder(absl::WrapUnique<ResolvedReturningClause>(
      const_cast<ResolvedReturningClause*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

class ResolvedUnpivotArgBuilder final {
 public:
  ResolvedUnpivotArgBuilder() : ResolvedUnpivotArgBuilder(absl::WrapUnique(new ResolvedUnpivotArg)) {}

  ResolvedUnpivotArgBuilder(const ResolvedUnpivotArgBuilder&) = delete;
  ResolvedUnpivotArgBuilder& operator=(const ResolvedUnpivotArgBuilder&) = delete;
  ResolvedUnpivotArgBuilder(ResolvedUnpivotArgBuilder&& other)
      : ResolvedUnpivotArgBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedUnpivotArgBuilder& operator=(ResolvedUnpivotArgBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedUnpivotArg>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  // A list of columns referencing an output column of the <input_scan>
  // of ResolvedUnpivotScan. The size of this vector is
  // the same as <value_column_list>.
  const std::vector<std::unique_ptr<const ResolvedColumnRef>>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumnRef* column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedUnpivotArgBuilder&& add_column_list(T v) && {
    node_->add_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedUnpivotArgBuilder& add_column_list(T v) & {
    node_->add_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedUnpivotArgBuilder&& add_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnRef>>::value>>
  ResolvedUnpivotArgBuilder& add_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnRef>> release_column_list() {
    return node_->release_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedUnpivotArgBuilder&& set_column_list(T v) && {
    node_->set_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedUnpivotArgBuilder& set_column_list(T v) & {
    node_->set_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedUnpivotArgBuilder&& set_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnRef>>>::value>>
  ResolvedUnpivotArgBuilder& set_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedUnpivotArg> node_;

  absl::Status deferred_build_status_;
  friend ResolvedUnpivotArgBuilder ToBuilder(
      std::unique_ptr<const ResolvedUnpivotArg> node);

  ResolvedUnpivotArgBuilder(std::unique_ptr<ResolvedUnpivotArg> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedUnpivotArgBuilder ToBuilder(
    std::unique_ptr<const ResolvedUnpivotArg> node) {
  ResolvedUnpivotArgBuilder builder(absl::WrapUnique<ResolvedUnpivotArg>(
      const_cast<ResolvedUnpivotArg*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedUnpivotScanBuilder final {
 public:
  ResolvedUnpivotScanBuilder() : ResolvedUnpivotScanBuilder(absl::WrapUnique(new ResolvedUnpivotScan)) {}

  ResolvedUnpivotScanBuilder(const ResolvedUnpivotScanBuilder&) = delete;
  ResolvedUnpivotScanBuilder& operator=(const ResolvedUnpivotScanBuilder&) = delete;
  ResolvedUnpivotScanBuilder(ResolvedUnpivotScanBuilder&& other)
      : ResolvedUnpivotScanBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedUnpivotScanBuilder& operator=(ResolvedUnpivotScanBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedUnpivotScan>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(3)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedUnpivotScan::input_scan was not set on the builder");
    }
    if (!field_is_set_.test(5)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedUnpivotScan::label_column was not set on the builder");
    }
    if (!field_is_set_.test(9)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedUnpivotScan::include_nulls was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedScan* input_scan() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->input_scan();
  }

  std::unique_ptr<const ResolvedScan> release_input_scan() {
    return node_->release_input_scan();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedUnpivotScanBuilder&& set_input_scan(T v) && {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedUnpivotScanBuilder& set_input_scan(T v) & {
    node_->set_input_scan(std::move(v));
    field_is_set_.set(3, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedUnpivotScanBuilder&& set_input_scan(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedUnpivotScanBuilder& set_input_scan(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_input_scan(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(3, true);

    return *this;
  }

  // This is a list of one or more new columns added by UNPIVOT.
  // These new column(s) store the value of input columns that are in
  // the UNPIVOT IN clause.
  const std::vector<ResolvedColumn>& value_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->value_column_list();
  }

  int value_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->value_column_list_size();
  }

  const ResolvedColumn& value_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->value_column_list(i);
  }

  ResolvedUnpivotScanBuilder&& add_value_column_list(ResolvedColumn v) && {
    node_->add_value_column_list(v);

    return std::move(*this);
  }

  ResolvedUnpivotScanBuilder& add_value_column_list(ResolvedColumn v) & {
    node_->add_value_column_list(v);

    return *this;
  }

  ResolvedUnpivotScanBuilder&& set_value_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_value_column_list(v);

    return std::move(*this);
  }

  ResolvedUnpivotScanBuilder& set_value_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_value_column_list(v);

    return *this;
  }

  // This is a new column added in the output for storing labels for
  // input columns groups that are present in the IN clause. Its
  // values are taken from <label_list>.
  const ResolvedColumn& label_column() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->label_column();
  }

  ResolvedUnpivotScanBuilder&& set_label_column(const ResolvedColumn& v) && {
    node_->set_label_column(v);
    field_is_set_.set(5, true);

    return std::move(*this);
  }

  ResolvedUnpivotScanBuilder& set_label_column(const ResolvedColumn& v) & {
    node_->set_label_column(v);
    field_is_set_.set(5, true);

    return *this;
  }

  // String or integer literal for each column group in
  // <unpivot_arg_list>.
  const std::vector<std::unique_ptr<const ResolvedLiteral>>& label_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->label_list();
  }

  int label_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->label_list_size();
  }

  const ResolvedLiteral* label_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->label_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedLiteral>>::value>>
  ResolvedUnpivotScanBuilder&& add_label_list(T v) && {
    node_->add_label_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedLiteral>>::value>>
  ResolvedUnpivotScanBuilder& add_label_list(T v) & {
    node_->add_label_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedLiteral>>::value>>
  ResolvedUnpivotScanBuilder&& add_label_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_label_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedLiteral>>::value>>
  ResolvedUnpivotScanBuilder& add_label_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_label_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedLiteral>> release_label_list() {
    return node_->release_label_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedLiteral>>>::value>>
  ResolvedUnpivotScanBuilder&& set_label_list(T v) && {
    node_->set_label_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedLiteral>>>::value>>
  ResolvedUnpivotScanBuilder& set_label_list(T v) & {
    node_->set_label_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedLiteral>>>::value>>
  ResolvedUnpivotScanBuilder&& set_label_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_label_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedLiteral>>>::value>>
  ResolvedUnpivotScanBuilder& set_label_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_label_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // The list of groups of columns in the UNPIVOT IN list. Each group
  // contains references to the output columns of <input_scan> of the
  // ResolvedUnpivotScan. The values of these columns are stored in the
  // new <value_column_list> and the column group labels/names
  // in the <label_column>.
  const std::vector<std::unique_ptr<const ResolvedUnpivotArg>>& unpivot_arg_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->unpivot_arg_list();
  }

  int unpivot_arg_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->unpivot_arg_list_size();
  }

  const ResolvedUnpivotArg* unpivot_arg_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->unpivot_arg_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUnpivotArg>>::value>>
  ResolvedUnpivotScanBuilder&& add_unpivot_arg_list(T v) && {
    node_->add_unpivot_arg_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedUnpivotArg>>::value>>
  ResolvedUnpivotScanBuilder& add_unpivot_arg_list(T v) & {
    node_->add_unpivot_arg_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUnpivotArg>>::value>>
  ResolvedUnpivotScanBuilder&& add_unpivot_arg_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_unpivot_arg_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedUnpivotArg>>::value>>
  ResolvedUnpivotScanBuilder& add_unpivot_arg_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_unpivot_arg_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedUnpivotArg>> release_unpivot_arg_list() {
    return node_->release_unpivot_arg_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedUnpivotArg>>>::value>>
  ResolvedUnpivotScanBuilder&& set_unpivot_arg_list(T v) && {
    node_->set_unpivot_arg_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedUnpivotArg>>>::value>>
  ResolvedUnpivotScanBuilder& set_unpivot_arg_list(T v) & {
    node_->set_unpivot_arg_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedUnpivotArg>>>::value>>
  ResolvedUnpivotScanBuilder&& set_unpivot_arg_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_unpivot_arg_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedUnpivotArg>>>::value>>
  ResolvedUnpivotScanBuilder& set_unpivot_arg_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_unpivot_arg_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // The columns from <input_scan> that are not unpivoted in UNPIVOT
  // IN clause. Columns in <projected_input_column_list> and
  // <unpivot_arg_list> are mutually exclusive and their union is the
  // complete set of columns in the unpivot input-source.
  //
  // The expression of each ResolvedComputedColumn is a
  // ResolvedColumnRef that references a column from <input_scan>.
  const std::vector<std::unique_ptr<const ResolvedComputedColumn>>& projected_input_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->projected_input_column_list();
  }

  int projected_input_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->projected_input_column_list_size();
  }

  const ResolvedComputedColumn* projected_input_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->projected_input_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedUnpivotScanBuilder&& add_projected_input_column_list(T v) && {
    node_->add_projected_input_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedUnpivotScanBuilder& add_projected_input_column_list(T v) & {
    node_->add_projected_input_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedUnpivotScanBuilder&& add_projected_input_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_projected_input_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedComputedColumn>>::value>>
  ResolvedUnpivotScanBuilder& add_projected_input_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_projected_input_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedComputedColumn>> release_projected_input_column_list() {
    return node_->release_projected_input_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedUnpivotScanBuilder&& set_projected_input_column_list(T v) && {
    node_->set_projected_input_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedUnpivotScanBuilder& set_projected_input_column_list(T v) & {
    node_->set_projected_input_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedUnpivotScanBuilder&& set_projected_input_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_projected_input_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedComputedColumn>>>::value>>
  ResolvedUnpivotScanBuilder& set_projected_input_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_projected_input_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  // Whether we need to include the rows from output where ALL columns
  // from <value_column_list> are null.
  bool include_nulls() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->include_nulls();
  }

  ResolvedUnpivotScanBuilder&& set_include_nulls(bool v) && {
    node_->set_include_nulls(v);
    field_is_set_.set(9, true);

    return std::move(*this);
  }

  ResolvedUnpivotScanBuilder& set_include_nulls(bool v) & {
    node_->set_include_nulls(v);
    field_is_set_.set(9, true);

    return *this;
  }

  const std::vector<ResolvedColumn>& column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list();
  }

  int column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list_size();
  }

  const ResolvedColumn& column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_list(i);
  }

  ResolvedUnpivotScanBuilder&& add_column_list(ResolvedColumn v) && {
    node_->add_column_list(v);

    return std::move(*this);
  }

  ResolvedUnpivotScanBuilder& add_column_list(ResolvedColumn v) & {
    node_->add_column_list(v);

    return *this;
  }

  ResolvedUnpivotScanBuilder&& set_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_column_list(v);

    return std::move(*this);
  }

  ResolvedUnpivotScanBuilder& set_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_column_list(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedUnpivotScanBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedUnpivotScanBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedUnpivotScanBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedUnpivotScanBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedUnpivotScanBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedUnpivotScanBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedUnpivotScanBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedUnpivotScanBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  bool is_ordered() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->is_ordered();
  }

  ResolvedUnpivotScanBuilder&& set_is_ordered(bool v) && {
    node_->set_is_ordered(v);

    return std::move(*this);
  }

  ResolvedUnpivotScanBuilder& set_is_ordered(bool v) & {
    node_->set_is_ordered(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedUnpivotScan> node_;

  absl::Status deferred_build_status_;
  std::bitset<10> field_is_set_ = {0};
  friend ResolvedUnpivotScanBuilder ToBuilder(
      std::unique_ptr<const ResolvedUnpivotScan> node);

  ResolvedUnpivotScanBuilder(std::unique_ptr<ResolvedUnpivotScan> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedUnpivotScanBuilder ToBuilder(
    std::unique_ptr<const ResolvedUnpivotScan> node) {
  ResolvedUnpivotScanBuilder builder(absl::WrapUnique<ResolvedUnpivotScan>(
      const_cast<ResolvedUnpivotScan*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(3, true);
  builder.field_is_set_.set(5, true);
  builder.field_is_set_.set(9, true);
  return builder;
}

class ResolvedCloneDataStmtBuilder final {
 public:
  ResolvedCloneDataStmtBuilder() : ResolvedCloneDataStmtBuilder(absl::WrapUnique(new ResolvedCloneDataStmt)) {}

  ResolvedCloneDataStmtBuilder(const ResolvedCloneDataStmtBuilder&) = delete;
  ResolvedCloneDataStmtBuilder& operator=(const ResolvedCloneDataStmtBuilder&) = delete;
  ResolvedCloneDataStmtBuilder(ResolvedCloneDataStmtBuilder&& other)
      : ResolvedCloneDataStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedCloneDataStmtBuilder& operator=(ResolvedCloneDataStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedCloneDataStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCloneDataStmt::target_table was not set on the builder");
    }
    if (!field_is_set_.test(2)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedCloneDataStmt::clone_from was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const ResolvedTableScan* target_table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->target_table();
  }

  std::unique_ptr<const ResolvedTableScan> release_target_table() {
    return node_->release_target_table();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedCloneDataStmtBuilder&& set_target_table(T v) && {
    node_->set_target_table(std::move(v));
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedCloneDataStmtBuilder& set_target_table(T v) & {
    node_->set_target_table(std::move(v));
    field_is_set_.set(1, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedCloneDataStmtBuilder&& set_target_table(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_target_table(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableScan>>::value>>
  ResolvedCloneDataStmtBuilder& set_target_table(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_target_table(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(1, true);

    return *this;
  }

  const ResolvedScan* clone_from() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->clone_from();
  }

  std::unique_ptr<const ResolvedScan> release_clone_from() {
    return node_->release_clone_from();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCloneDataStmtBuilder&& set_clone_from(T v) && {
    node_->set_clone_from(std::move(v));
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCloneDataStmtBuilder& set_clone_from(T v) & {
    node_->set_clone_from(std::move(v));
    field_is_set_.set(2, true);

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCloneDataStmtBuilder&& set_clone_from(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_clone_from(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedScan>>::value>>
  ResolvedCloneDataStmtBuilder& set_clone_from(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_clone_from(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }
    field_is_set_.set(2, true);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCloneDataStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCloneDataStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCloneDataStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedCloneDataStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCloneDataStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCloneDataStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCloneDataStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedCloneDataStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedCloneDataStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<3> field_is_set_ = {0};
  friend ResolvedCloneDataStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedCloneDataStmt> node);

  ResolvedCloneDataStmtBuilder(std::unique_ptr<ResolvedCloneDataStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedCloneDataStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedCloneDataStmt> node) {
  ResolvedCloneDataStmtBuilder builder(absl::WrapUnique<ResolvedCloneDataStmt>(
      const_cast<ResolvedCloneDataStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  builder.field_is_set_.set(2, true);
  return builder;
}

class ResolvedTableAndColumnInfoBuilder final {
 public:
  ResolvedTableAndColumnInfoBuilder() : ResolvedTableAndColumnInfoBuilder(absl::WrapUnique(new ResolvedTableAndColumnInfo)) {}

  ResolvedTableAndColumnInfoBuilder(const ResolvedTableAndColumnInfoBuilder&) = delete;
  ResolvedTableAndColumnInfoBuilder& operator=(const ResolvedTableAndColumnInfoBuilder&) = delete;
  ResolvedTableAndColumnInfoBuilder(ResolvedTableAndColumnInfoBuilder&& other)
      : ResolvedTableAndColumnInfoBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedTableAndColumnInfoBuilder& operator=(ResolvedTableAndColumnInfoBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedTableAndColumnInfo>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const Table* table() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table();
  }

  ResolvedTableAndColumnInfoBuilder&& set_table(const Table* v) && {
    node_->set_table(v);

    return std::move(*this);
  }

  ResolvedTableAndColumnInfoBuilder& set_table(const Table* v) & {
    node_->set_table(v);

    return *this;
  }

  const std::vector<int>& column_index_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_index_list();
  }

  int column_index_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_index_list_size();
  }

  int column_index_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_index_list(i);
  }

  ResolvedTableAndColumnInfoBuilder&& add_column_index_list(int v) && {
    node_->add_column_index_list(v);

    return std::move(*this);
  }

  ResolvedTableAndColumnInfoBuilder& add_column_index_list(int v) & {
    node_->add_column_index_list(v);

    return *this;
  }

  ResolvedTableAndColumnInfoBuilder&& set_column_index_list(const std::vector<int>& v) && {
    node_->set_column_index_list(v);

    return std::move(*this);
  }

  ResolvedTableAndColumnInfoBuilder& set_column_index_list(const std::vector<int>& v) & {
    node_->set_column_index_list(v);

    return *this;
  }

 private:
  std::unique_ptr<ResolvedTableAndColumnInfo> node_;

  absl::Status deferred_build_status_;
  friend ResolvedTableAndColumnInfoBuilder ToBuilder(
      std::unique_ptr<const ResolvedTableAndColumnInfo> node);

  ResolvedTableAndColumnInfoBuilder(std::unique_ptr<ResolvedTableAndColumnInfo> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedTableAndColumnInfoBuilder ToBuilder(
    std::unique_ptr<const ResolvedTableAndColumnInfo> node) {
  ResolvedTableAndColumnInfoBuilder builder(absl::WrapUnique<ResolvedTableAndColumnInfo>(
      const_cast<ResolvedTableAndColumnInfo*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedAnalyzeStmtBuilder final {
 public:
  ResolvedAnalyzeStmtBuilder() : ResolvedAnalyzeStmtBuilder(absl::WrapUnique(new ResolvedAnalyzeStmt)) {}

  ResolvedAnalyzeStmtBuilder(const ResolvedAnalyzeStmtBuilder&) = delete;
  ResolvedAnalyzeStmtBuilder& operator=(const ResolvedAnalyzeStmtBuilder&) = delete;
  ResolvedAnalyzeStmtBuilder(ResolvedAnalyzeStmtBuilder&& other)
      : ResolvedAnalyzeStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
  }

  ResolvedAnalyzeStmtBuilder& operator=(ResolvedAnalyzeStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAnalyzeStmt>> Build() && {
    node_->accessed_ = 0;

    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyzeStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyzeStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyzeStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyzeStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyzeStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyzeStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyzeStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyzeStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedTableAndColumnInfo>>& table_and_column_index_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_and_column_index_list();
  }

  int table_and_column_index_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_and_column_index_list_size();
  }

  const ResolvedTableAndColumnInfo* table_and_column_index_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->table_and_column_index_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableAndColumnInfo>>::value>>
  ResolvedAnalyzeStmtBuilder&& add_table_and_column_index_list(T v) && {
    node_->add_table_and_column_index_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedTableAndColumnInfo>>::value>>
  ResolvedAnalyzeStmtBuilder& add_table_and_column_index_list(T v) & {
    node_->add_table_and_column_index_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableAndColumnInfo>>::value>>
  ResolvedAnalyzeStmtBuilder&& add_table_and_column_index_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_table_and_column_index_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedTableAndColumnInfo>>::value>>
  ResolvedAnalyzeStmtBuilder& add_table_and_column_index_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_table_and_column_index_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedTableAndColumnInfo>> release_table_and_column_index_list() {
    return node_->release_table_and_column_index_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedTableAndColumnInfo>>>::value>>
  ResolvedAnalyzeStmtBuilder&& set_table_and_column_index_list(T v) && {
    node_->set_table_and_column_index_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedTableAndColumnInfo>>>::value>>
  ResolvedAnalyzeStmtBuilder& set_table_and_column_index_list(T v) & {
    node_->set_table_and_column_index_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedTableAndColumnInfo>>>::value>>
  ResolvedAnalyzeStmtBuilder&& set_table_and_column_index_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_and_column_index_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedTableAndColumnInfo>>>::value>>
  ResolvedAnalyzeStmtBuilder& set_table_and_column_index_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_table_and_column_index_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyzeStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyzeStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyzeStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAnalyzeStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyzeStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyzeStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyzeStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAnalyzeStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAnalyzeStmt> node_;

  absl::Status deferred_build_status_;
  friend ResolvedAnalyzeStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAnalyzeStmt> node);

  ResolvedAnalyzeStmtBuilder(std::unique_ptr<ResolvedAnalyzeStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAnalyzeStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAnalyzeStmt> node) {
  ResolvedAnalyzeStmtBuilder builder(absl::WrapUnique<ResolvedAnalyzeStmt>(
      const_cast<ResolvedAnalyzeStmt*>(node.release())));
  // All required nodes are evidently already set
  return builder;
}

class ResolvedAuxLoadDataStmtBuilder final {
 public:
    typedef ResolvedAuxLoadDataStmtEnums::InsertionMode InsertionMode;
  static const InsertionMode NONE = ResolvedAuxLoadDataStmtEnums::NONE;
  static const InsertionMode APPEND = ResolvedAuxLoadDataStmtEnums::APPEND;
  static const InsertionMode OVERWRITE = ResolvedAuxLoadDataStmtEnums::OVERWRITE;

  ResolvedAuxLoadDataStmtBuilder() : ResolvedAuxLoadDataStmtBuilder(absl::WrapUnique(new ResolvedAuxLoadDataStmt)) {}

  ResolvedAuxLoadDataStmtBuilder(const ResolvedAuxLoadDataStmtBuilder&) = delete;
  ResolvedAuxLoadDataStmtBuilder& operator=(const ResolvedAuxLoadDataStmtBuilder&) = delete;
  ResolvedAuxLoadDataStmtBuilder(ResolvedAuxLoadDataStmtBuilder&& other)
      : ResolvedAuxLoadDataStmtBuilder(std::move(other.node_)) {
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
  }

  ResolvedAuxLoadDataStmtBuilder& operator=(ResolvedAuxLoadDataStmtBuilder&& other) {
    node_ = std::move(other.node_);
    deferred_build_status_ = std::move(other.deferred_build_status_);
    field_is_set_ = std::move(other.field_is_set_);
    return *this;
  };

  // Build() releases the current inner node, so it is callable only on an
  // r-value, where the builder is expected to be going away. Resets the
  // `accessed_` bits.
  absl::StatusOr<std::unique_ptr<const ResolvedAuxLoadDataStmt>> Build() && {
    node_->accessed_ = 0;

    if (!field_is_set_.test(1)) {
      zetasql::internal::UpdateStatus(
          &deferred_build_status_,
          ::zetasql_base::InternalErrorBuilder(ZETASQL_LOC).LogError()
            << "ResolvedAuxLoadDataStmt::insertion_mode was not set on the builder");
    }
    if (deferred_build_status_.ok()) {
      return std::move(node_);
    }

    return deferred_build_status_;
  }

  // Getters and chained setters
  ResolvedAuxLoadDataStmt::InsertionMode insertion_mode() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->insertion_mode();
  }

  ResolvedAuxLoadDataStmtBuilder&& set_insertion_mode(ResolvedAuxLoadDataStmt::InsertionMode v) && {
    node_->set_insertion_mode(v);
    field_is_set_.set(1, true);

    return std::move(*this);
  }

  ResolvedAuxLoadDataStmtBuilder& set_insertion_mode(ResolvedAuxLoadDataStmt::InsertionMode v) & {
    node_->set_insertion_mode(v);
    field_is_set_.set(1, true);

    return *this;
  }

  const std::vector<std::string>& name_path() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path();
  }

  int name_path_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path_size();
  }

  const std::string& name_path(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->name_path(i);
  }

  ResolvedAuxLoadDataStmtBuilder&& add_name_path(std::string v) && {
    node_->add_name_path(v);

    return std::move(*this);
  }

  ResolvedAuxLoadDataStmtBuilder& add_name_path(std::string v) & {
    node_->add_name_path(v);

    return *this;
  }

  ResolvedAuxLoadDataStmtBuilder&& set_name_path(const std::vector<std::string>& v) && {
    node_->set_name_path(v);

    return std::move(*this);
  }

  ResolvedAuxLoadDataStmtBuilder& set_name_path(const std::vector<std::string>& v) & {
    node_->set_name_path(v);

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOutputColumn>>& output_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list();
  }

  int output_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list_size();
  }

  const ResolvedOutputColumn* output_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->output_column_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_output_column_list(T v) && {
    node_->add_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_output_column_list(T v) & {
    node_->add_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOutputColumn>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOutputColumn>> release_output_column_list() {
    return node_->release_output_column_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_output_column_list(T v) && {
    node_->set_output_column_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_output_column_list(T v) & {
    node_->set_output_column_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_output_column_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOutputColumn>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_output_column_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_output_column_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedColumnDefinition>>& column_definition_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list();
  }

  int column_definition_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list_size();
  }

  const ResolvedColumnDefinition* column_definition_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->column_definition_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_column_definition_list(T v) && {
    node_->add_column_definition_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_column_definition_list(T v) & {
    node_->add_column_definition_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_column_definition_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedColumnDefinition>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_column_definition_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedColumnDefinition>> release_column_definition_list() {
    return node_->release_column_definition_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_column_definition_list(T v) && {
    node_->set_column_definition_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_column_definition_list(T v) & {
    node_->set_column_definition_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_column_definition_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedColumnDefinition>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_column_definition_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_column_definition_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<ResolvedColumn>& pseudo_column_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pseudo_column_list();
  }

  int pseudo_column_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pseudo_column_list_size();
  }

  const ResolvedColumn& pseudo_column_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->pseudo_column_list(i);
  }

  ResolvedAuxLoadDataStmtBuilder&& add_pseudo_column_list(ResolvedColumn v) && {
    node_->add_pseudo_column_list(v);

    return std::move(*this);
  }

  ResolvedAuxLoadDataStmtBuilder& add_pseudo_column_list(ResolvedColumn v) & {
    node_->add_pseudo_column_list(v);

    return *this;
  }

  ResolvedAuxLoadDataStmtBuilder&& set_pseudo_column_list(const std::vector<ResolvedColumn>& v) && {
    node_->set_pseudo_column_list(v);

    return std::move(*this);
  }

  ResolvedAuxLoadDataStmtBuilder& set_pseudo_column_list(const std::vector<ResolvedColumn>& v) & {
    node_->set_pseudo_column_list(v);

    return *this;
  }

  const ResolvedPrimaryKey* primary_key() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->primary_key();
  }

  std::unique_ptr<const ResolvedPrimaryKey> release_primary_key() {
    return node_->release_primary_key();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_primary_key(T v) && {
    node_->set_primary_key(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_primary_key(T v) & {
    node_->set_primary_key(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_primary_key(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_primary_key(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedPrimaryKey>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_primary_key(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_primary_key(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedForeignKey>>& foreign_key_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->foreign_key_list();
  }

  int foreign_key_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->foreign_key_list_size();
  }

  const ResolvedForeignKey* foreign_key_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->foreign_key_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_foreign_key_list(T v) && {
    node_->add_foreign_key_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_foreign_key_list(T v) & {
    node_->add_foreign_key_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_foreign_key_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedForeignKey>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_foreign_key_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedForeignKey>> release_foreign_key_list() {
    return node_->release_foreign_key_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_foreign_key_list(T v) && {
    node_->set_foreign_key_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_foreign_key_list(T v) & {
    node_->set_foreign_key_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_foreign_key_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedForeignKey>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_foreign_key_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_foreign_key_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedCheckConstraint>>& check_constraint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->check_constraint_list();
  }

  int check_constraint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->check_constraint_list_size();
  }

  const ResolvedCheckConstraint* check_constraint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->check_constraint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_check_constraint_list(T v) && {
    node_->add_check_constraint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_check_constraint_list(T v) & {
    node_->add_check_constraint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_check_constraint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedCheckConstraint>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_check_constraint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedCheckConstraint>> release_check_constraint_list() {
    return node_->release_check_constraint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_check_constraint_list(T v) && {
    node_->set_check_constraint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_check_constraint_list(T v) & {
    node_->set_check_constraint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_check_constraint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedCheckConstraint>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_check_constraint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_check_constraint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& partition_by_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list();
  }

  int partition_by_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list_size();
  }

  const ResolvedExpr* partition_by_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->partition_by_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_partition_by_list(T v) && {
    node_->add_partition_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_partition_by_list(T v) & {
    node_->add_partition_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_partition_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_partition_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_partition_by_list() {
    return node_->release_partition_by_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_partition_by_list(T v) && {
    node_->set_partition_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_partition_by_list(T v) & {
    node_->set_partition_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_partition_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_partition_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_partition_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedExpr>>& cluster_by_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->cluster_by_list();
  }

  int cluster_by_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->cluster_by_list_size();
  }

  const ResolvedExpr* cluster_by_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->cluster_by_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_cluster_by_list(T v) && {
    node_->add_cluster_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_cluster_by_list(T v) & {
    node_->add_cluster_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_cluster_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedExpr>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_cluster_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedExpr>> release_cluster_by_list() {
    return node_->release_cluster_by_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_cluster_by_list(T v) && {
    node_->set_cluster_by_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_cluster_by_list(T v) & {
    node_->set_cluster_by_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_cluster_by_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedExpr>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_cluster_by_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_cluster_by_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list();
  }

  int option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list_size();
  }

  const ResolvedOption* option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_option_list(T v) && {
    node_->add_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_option_list(T v) & {
    node_->add_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_option_list() {
    return node_->release_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_option_list(T v) && {
    node_->set_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_option_list(T v) & {
    node_->set_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedWithPartitionColumns* with_partition_columns() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->with_partition_columns();
  }

  std::unique_ptr<const ResolvedWithPartitionColumns> release_with_partition_columns() {
    return node_->release_with_partition_columns();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWithPartitionColumns>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_with_partition_columns(T v) && {
    node_->set_with_partition_columns(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedWithPartitionColumns>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_with_partition_columns(T v) & {
    node_->set_with_partition_columns(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWithPartitionColumns>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_with_partition_columns(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_partition_columns(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedWithPartitionColumns>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_with_partition_columns(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_with_partition_columns(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const ResolvedConnection* connection() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->connection();
  }

  std::unique_ptr<const ResolvedConnection> release_connection() {
    return node_->release_connection();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_connection(T v) && {
    node_->set_connection(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_connection(T v) & {
    node_->set_connection(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_connection(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedConnection>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_connection(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_connection(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& from_files_option_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->from_files_option_list();
  }

  int from_files_option_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->from_files_option_list_size();
  }

  const ResolvedOption* from_files_option_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->from_files_option_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_from_files_option_list(T v) && {
    node_->add_from_files_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_from_files_option_list(T v) & {
    node_->add_from_files_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_from_files_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_from_files_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_from_files_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_from_files_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_from_files_option_list() {
    return node_->release_from_files_option_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_from_files_option_list(T v) && {
    node_->set_from_files_option_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_from_files_option_list(T v) & {
    node_->set_from_files_option_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_from_files_option_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_from_files_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_from_files_option_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_from_files_option_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  const std::vector<std::unique_ptr<const ResolvedOption>>& hint_list() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list();
  }

  int hint_list_size() const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list_size();
  }

  const ResolvedOption* hint_list(int i) const {
    ZETASQL_DCHECK(node_ != nullptr);
    return node_->hint_list(i);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_hint_list(T v) && {
    node_->add_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_hint_list(T v) & {
    node_->add_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& add_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::unique_ptr<const ResolvedOption>>::value>>
  ResolvedAuxLoadDataStmtBuilder& add_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      add_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

  std::vector<std::unique_ptr<const ResolvedOption>> release_hint_list() {
    return node_->release_hint_list();
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_hint_list(T v) && {
    node_->set_hint_list(std::move(v));

    return std::move(*this);
  }

  template<typename T, typename = typename std::enable_if_t<std::is_convertible<T, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_hint_list(T v) & {
    node_->set_hint_list(std::move(v));

    return *this;
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAuxLoadDataStmtBuilder&& set_hint_list(TBuilder&& b) && {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return std::move(*this);
  }

  template<typename TBuilder, typename = typename std::enable_if_t<!std::is_convertible<TBuilder, std::vector<std::unique_ptr<const ResolvedOption>>>::value>>
  ResolvedAuxLoadDataStmtBuilder& set_hint_list(TBuilder&& b) & {
    auto status_or_node = std::move(b).Build();
    if (status_or_node.ok()) {
      set_hint_list(std::move(*status_or_node));
    } else {
      zetasql::internal::UpdateStatus(&deferred_build_status_,
                                        status_or_node.status());
    }

    return *this;
  }

 private:
  std::unique_ptr<ResolvedAuxLoadDataStmt> node_;

  absl::Status deferred_build_status_;
  std::bitset<15> field_is_set_ = {0};
  friend ResolvedAuxLoadDataStmtBuilder ToBuilder(
      std::unique_ptr<const ResolvedAuxLoadDataStmt> node);

  ResolvedAuxLoadDataStmtBuilder(std::unique_ptr<ResolvedAuxLoadDataStmt> node)
      : node_(std::move(node)) {
    ZETASQL_DCHECK(node_ != nullptr);
  }
};

inline ResolvedAuxLoadDataStmtBuilder ToBuilder(
    std::unique_ptr<const ResolvedAuxLoadDataStmt> node) {
  ResolvedAuxLoadDataStmtBuilder builder(absl::WrapUnique<ResolvedAuxLoadDataStmt>(
      const_cast<ResolvedAuxLoadDataStmt*>(node.release())));
  // All required nodes are evidently already set
  builder.field_is_set_.set(1, true);
  return builder;
}

}  // namespace zetasql

#endif  // ZETASQL_RESOLVED_AST_RESOLVED_AST_BUILDER_H_