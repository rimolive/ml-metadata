// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zetasql/resolved_ast/serialization.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_zetasql_2fresolved_5fast_2fserialization_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_zetasql_2fresolved_5fast_2fserialization_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "zetasql/public/annotation.pb.h"
#include "zetasql/public/parse_location_range.pb.h"
#include "zetasql/public/type.pb.h"
#include "zetasql/public/value.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_zetasql_2fresolved_5fast_2fserialization_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_zetasql_2fresolved_5fast_2fserialization_2eproto;
namespace zetasql {
class ConnectionRefProto;
struct ConnectionRefProtoDefaultTypeInternal;
extern ConnectionRefProtoDefaultTypeInternal _ConnectionRefProto_default_instance_;
class ConstantRefProto;
struct ConstantRefProtoDefaultTypeInternal;
extern ConstantRefProtoDefaultTypeInternal _ConstantRefProto_default_instance_;
class FieldDescriptorRefProto;
struct FieldDescriptorRefProtoDefaultTypeInternal;
extern FieldDescriptorRefProtoDefaultTypeInternal _FieldDescriptorRefProto_default_instance_;
class FunctionRefProto;
struct FunctionRefProtoDefaultTypeInternal;
extern FunctionRefProtoDefaultTypeInternal _FunctionRefProto_default_instance_;
class ModelRefProto;
struct ModelRefProtoDefaultTypeInternal;
extern ModelRefProtoDefaultTypeInternal _ModelRefProto_default_instance_;
class OneofDescriptorRefProto;
struct OneofDescriptorRefProtoDefaultTypeInternal;
extern OneofDescriptorRefProtoDefaultTypeInternal _OneofDescriptorRefProto_default_instance_;
class ProcedureRefProto;
struct ProcedureRefProtoDefaultTypeInternal;
extern ProcedureRefProtoDefaultTypeInternal _ProcedureRefProto_default_instance_;
class ResolvedCollationProto;
struct ResolvedCollationProtoDefaultTypeInternal;
extern ResolvedCollationProtoDefaultTypeInternal _ResolvedCollationProto_default_instance_;
class ResolvedColumnProto;
struct ResolvedColumnProtoDefaultTypeInternal;
extern ResolvedColumnProtoDefaultTypeInternal _ResolvedColumnProto_default_instance_;
class ResolvedNodeProto;
struct ResolvedNodeProtoDefaultTypeInternal;
extern ResolvedNodeProtoDefaultTypeInternal _ResolvedNodeProto_default_instance_;
class TableRefProto;
struct TableRefProtoDefaultTypeInternal;
extern TableRefProtoDefaultTypeInternal _TableRefProto_default_instance_;
class TableValuedFunctionRefProto;
struct TableValuedFunctionRefProtoDefaultTypeInternal;
extern TableValuedFunctionRefProtoDefaultTypeInternal _TableValuedFunctionRefProto_default_instance_;
class ValueWithTypeProto;
struct ValueWithTypeProtoDefaultTypeInternal;
extern ValueWithTypeProtoDefaultTypeInternal _ValueWithTypeProto_default_instance_;
}  // namespace zetasql
PROTOBUF_NAMESPACE_OPEN
template<> ::zetasql::ConnectionRefProto* Arena::CreateMaybeMessage<::zetasql::ConnectionRefProto>(Arena*);
template<> ::zetasql::ConstantRefProto* Arena::CreateMaybeMessage<::zetasql::ConstantRefProto>(Arena*);
template<> ::zetasql::FieldDescriptorRefProto* Arena::CreateMaybeMessage<::zetasql::FieldDescriptorRefProto>(Arena*);
template<> ::zetasql::FunctionRefProto* Arena::CreateMaybeMessage<::zetasql::FunctionRefProto>(Arena*);
template<> ::zetasql::ModelRefProto* Arena::CreateMaybeMessage<::zetasql::ModelRefProto>(Arena*);
template<> ::zetasql::OneofDescriptorRefProto* Arena::CreateMaybeMessage<::zetasql::OneofDescriptorRefProto>(Arena*);
template<> ::zetasql::ProcedureRefProto* Arena::CreateMaybeMessage<::zetasql::ProcedureRefProto>(Arena*);
template<> ::zetasql::ResolvedCollationProto* Arena::CreateMaybeMessage<::zetasql::ResolvedCollationProto>(Arena*);
template<> ::zetasql::ResolvedColumnProto* Arena::CreateMaybeMessage<::zetasql::ResolvedColumnProto>(Arena*);
template<> ::zetasql::ResolvedNodeProto* Arena::CreateMaybeMessage<::zetasql::ResolvedNodeProto>(Arena*);
template<> ::zetasql::TableRefProto* Arena::CreateMaybeMessage<::zetasql::TableRefProto>(Arena*);
template<> ::zetasql::TableValuedFunctionRefProto* Arena::CreateMaybeMessage<::zetasql::TableValuedFunctionRefProto>(Arena*);
template<> ::zetasql::ValueWithTypeProto* Arena::CreateMaybeMessage<::zetasql::ValueWithTypeProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zetasql {

// ===================================================================

class ResolvedColumnProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedColumnProto) */ {
 public:
  inline ResolvedColumnProto() : ResolvedColumnProto(nullptr) {}
  ~ResolvedColumnProto() override;
  explicit PROTOBUF_CONSTEXPR ResolvedColumnProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedColumnProto(const ResolvedColumnProto& from);
  ResolvedColumnProto(ResolvedColumnProto&& from) noexcept
    : ResolvedColumnProto() {
    *this = ::std::move(from);
  }

  inline ResolvedColumnProto& operator=(const ResolvedColumnProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedColumnProto& operator=(ResolvedColumnProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedColumnProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedColumnProto* internal_default_instance() {
    return reinterpret_cast<const ResolvedColumnProto*>(
               &_ResolvedColumnProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ResolvedColumnProto& a, ResolvedColumnProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedColumnProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedColumnProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedColumnProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedColumnProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResolvedColumnProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResolvedColumnProto& from) {
    ResolvedColumnProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedColumnProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedColumnProto";
  }
  protected:
  explicit ResolvedColumnProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 2,
    kNameFieldNumber = 3,
    kTypeFieldNumber = 4,
    kAnnotationMapFieldNumber = 5,
    kColumnIdFieldNumber = 1,
  };
  // optional string table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .zetasql.TypeProto type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::zetasql::TypeProto& type() const;
  PROTOBUF_NODISCARD ::zetasql::TypeProto* release_type();
  ::zetasql::TypeProto* mutable_type();
  void set_allocated_type(::zetasql::TypeProto* type);
  private:
  const ::zetasql::TypeProto& _internal_type() const;
  ::zetasql::TypeProto* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::zetasql::TypeProto* type);
  ::zetasql::TypeProto* unsafe_arena_release_type();

  // optional .zetasql.AnnotationMapProto annotation_map = 5;
  bool has_annotation_map() const;
  private:
  bool _internal_has_annotation_map() const;
  public:
  void clear_annotation_map();
  const ::zetasql::AnnotationMapProto& annotation_map() const;
  PROTOBUF_NODISCARD ::zetasql::AnnotationMapProto* release_annotation_map();
  ::zetasql::AnnotationMapProto* mutable_annotation_map();
  void set_allocated_annotation_map(::zetasql::AnnotationMapProto* annotation_map);
  private:
  const ::zetasql::AnnotationMapProto& _internal_annotation_map() const;
  ::zetasql::AnnotationMapProto* _internal_mutable_annotation_map();
  public:
  void unsafe_arena_set_allocated_annotation_map(
      ::zetasql::AnnotationMapProto* annotation_map);
  ::zetasql::AnnotationMapProto* unsafe_arena_release_annotation_map();

  // optional int64 column_id = 1;
  bool has_column_id() const;
  private:
  bool _internal_has_column_id() const;
  public:
  void clear_column_id();
  int64_t column_id() const;
  void set_column_id(int64_t value);
  private:
  int64_t _internal_column_id() const;
  void _internal_set_column_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedColumnProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::zetasql::TypeProto* type_;
    ::zetasql::AnnotationMapProto* annotation_map_;
    int64_t column_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto;
};
// -------------------------------------------------------------------

class ValueWithTypeProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zetasql.ValueWithTypeProto) */ {
 public:
  inline ValueWithTypeProto() : ValueWithTypeProto(nullptr) {}
  ~ValueWithTypeProto() override;
  explicit PROTOBUF_CONSTEXPR ValueWithTypeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueWithTypeProto(const ValueWithTypeProto& from);
  ValueWithTypeProto(ValueWithTypeProto&& from) noexcept
    : ValueWithTypeProto() {
    *this = ::std::move(from);
  }

  inline ValueWithTypeProto& operator=(const ValueWithTypeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueWithTypeProto& operator=(ValueWithTypeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValueWithTypeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValueWithTypeProto* internal_default_instance() {
    return reinterpret_cast<const ValueWithTypeProto*>(
               &_ValueWithTypeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ValueWithTypeProto& a, ValueWithTypeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueWithTypeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueWithTypeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueWithTypeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueWithTypeProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValueWithTypeProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValueWithTypeProto& from) {
    ValueWithTypeProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValueWithTypeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ValueWithTypeProto";
  }
  protected:
  explicit ValueWithTypeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional .zetasql.TypeProto type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::zetasql::TypeProto& type() const;
  PROTOBUF_NODISCARD ::zetasql::TypeProto* release_type();
  ::zetasql::TypeProto* mutable_type();
  void set_allocated_type(::zetasql::TypeProto* type);
  private:
  const ::zetasql::TypeProto& _internal_type() const;
  ::zetasql::TypeProto* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::zetasql::TypeProto* type);
  ::zetasql::TypeProto* unsafe_arena_release_type();

  // optional .zetasql.ValueProto value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::zetasql::ValueProto& value() const;
  PROTOBUF_NODISCARD ::zetasql::ValueProto* release_value();
  ::zetasql::ValueProto* mutable_value();
  void set_allocated_value(::zetasql::ValueProto* value);
  private:
  const ::zetasql::ValueProto& _internal_value() const;
  ::zetasql::ValueProto* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::zetasql::ValueProto* value);
  ::zetasql::ValueProto* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:zetasql.ValueWithTypeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::zetasql::TypeProto* type_;
    ::zetasql::ValueProto* value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto;
};
// -------------------------------------------------------------------

class TableRefProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zetasql.TableRefProto) */ {
 public:
  inline TableRefProto() : TableRefProto(nullptr) {}
  ~TableRefProto() override;
  explicit PROTOBUF_CONSTEXPR TableRefProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableRefProto(const TableRefProto& from);
  TableRefProto(TableRefProto&& from) noexcept
    : TableRefProto() {
    *this = ::std::move(from);
  }

  inline TableRefProto& operator=(const TableRefProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableRefProto& operator=(TableRefProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableRefProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableRefProto* internal_default_instance() {
    return reinterpret_cast<const TableRefProto*>(
               &_TableRefProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TableRefProto& a, TableRefProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TableRefProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableRefProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableRefProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableRefProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableRefProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableRefProto& from) {
    TableRefProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableRefProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.TableRefProto";
  }
  protected:
  explicit TableRefProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFullNameFieldNumber = 3,
    kSerializationIdFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string full_name = 3;
  bool has_full_name() const;
  private:
  bool _internal_has_full_name() const;
  public:
  void clear_full_name();
  const std::string& full_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_name();
  PROTOBUF_NODISCARD std::string* release_full_name();
  void set_allocated_full_name(std::string* full_name);
  private:
  const std::string& _internal_full_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_name(const std::string& value);
  std::string* _internal_mutable_full_name();
  public:

  // optional int64 serialization_id = 2;
  bool has_serialization_id() const;
  private:
  bool _internal_has_serialization_id() const;
  public:
  void clear_serialization_id();
  int64_t serialization_id() const;
  void set_serialization_id(int64_t value);
  private:
  int64_t _internal_serialization_id() const;
  void _internal_set_serialization_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:zetasql.TableRefProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_name_;
    int64_t serialization_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto;
};
// -------------------------------------------------------------------

class ModelRefProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zetasql.ModelRefProto) */ {
 public:
  inline ModelRefProto() : ModelRefProto(nullptr) {}
  ~ModelRefProto() override;
  explicit PROTOBUF_CONSTEXPR ModelRefProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelRefProto(const ModelRefProto& from);
  ModelRefProto(ModelRefProto&& from) noexcept
    : ModelRefProto() {
    *this = ::std::move(from);
  }

  inline ModelRefProto& operator=(const ModelRefProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelRefProto& operator=(ModelRefProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelRefProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelRefProto* internal_default_instance() {
    return reinterpret_cast<const ModelRefProto*>(
               &_ModelRefProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ModelRefProto& a, ModelRefProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelRefProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelRefProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelRefProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelRefProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelRefProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelRefProto& from) {
    ModelRefProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelRefProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ModelRefProto";
  }
  protected:
  explicit ModelRefProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFullNameFieldNumber = 3,
    kSerializationIdFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string full_name = 3;
  bool has_full_name() const;
  private:
  bool _internal_has_full_name() const;
  public:
  void clear_full_name();
  const std::string& full_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_name();
  PROTOBUF_NODISCARD std::string* release_full_name();
  void set_allocated_full_name(std::string* full_name);
  private:
  const std::string& _internal_full_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_name(const std::string& value);
  std::string* _internal_mutable_full_name();
  public:

  // optional int64 serialization_id = 2;
  bool has_serialization_id() const;
  private:
  bool _internal_has_serialization_id() const;
  public:
  void clear_serialization_id();
  int64_t serialization_id() const;
  void set_serialization_id(int64_t value);
  private:
  int64_t _internal_serialization_id() const;
  void _internal_set_serialization_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:zetasql.ModelRefProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_name_;
    int64_t serialization_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto;
};
// -------------------------------------------------------------------

class ConnectionRefProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zetasql.ConnectionRefProto) */ {
 public:
  inline ConnectionRefProto() : ConnectionRefProto(nullptr) {}
  ~ConnectionRefProto() override;
  explicit PROTOBUF_CONSTEXPR ConnectionRefProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionRefProto(const ConnectionRefProto& from);
  ConnectionRefProto(ConnectionRefProto&& from) noexcept
    : ConnectionRefProto() {
    *this = ::std::move(from);
  }

  inline ConnectionRefProto& operator=(const ConnectionRefProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionRefProto& operator=(ConnectionRefProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionRefProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionRefProto* internal_default_instance() {
    return reinterpret_cast<const ConnectionRefProto*>(
               &_ConnectionRefProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConnectionRefProto& a, ConnectionRefProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionRefProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionRefProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionRefProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionRefProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionRefProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectionRefProto& from) {
    ConnectionRefProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionRefProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ConnectionRefProto";
  }
  protected:
  explicit ConnectionRefProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFullNameFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string full_name = 3;
  bool has_full_name() const;
  private:
  bool _internal_has_full_name() const;
  public:
  void clear_full_name();
  const std::string& full_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_name();
  PROTOBUF_NODISCARD std::string* release_full_name();
  void set_allocated_full_name(std::string* full_name);
  private:
  const std::string& _internal_full_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_name(const std::string& value);
  std::string* _internal_mutable_full_name();
  public:

  // @@protoc_insertion_point(class_scope:zetasql.ConnectionRefProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto;
};
// -------------------------------------------------------------------

class ConstantRefProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zetasql.ConstantRefProto) */ {
 public:
  inline ConstantRefProto() : ConstantRefProto(nullptr) {}
  ~ConstantRefProto() override;
  explicit PROTOBUF_CONSTEXPR ConstantRefProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConstantRefProto(const ConstantRefProto& from);
  ConstantRefProto(ConstantRefProto&& from) noexcept
    : ConstantRefProto() {
    *this = ::std::move(from);
  }

  inline ConstantRefProto& operator=(const ConstantRefProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstantRefProto& operator=(ConstantRefProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstantRefProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConstantRefProto* internal_default_instance() {
    return reinterpret_cast<const ConstantRefProto*>(
               &_ConstantRefProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ConstantRefProto& a, ConstantRefProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstantRefProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstantRefProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstantRefProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConstantRefProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConstantRefProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConstantRefProto& from) {
    ConstantRefProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstantRefProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ConstantRefProto";
  }
  protected:
  explicit ConstantRefProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:zetasql.ConstantRefProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto;
};
// -------------------------------------------------------------------

class FunctionRefProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zetasql.FunctionRefProto) */ {
 public:
  inline FunctionRefProto() : FunctionRefProto(nullptr) {}
  ~FunctionRefProto() override;
  explicit PROTOBUF_CONSTEXPR FunctionRefProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionRefProto(const FunctionRefProto& from);
  FunctionRefProto(FunctionRefProto&& from) noexcept
    : FunctionRefProto() {
    *this = ::std::move(from);
  }

  inline FunctionRefProto& operator=(const FunctionRefProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionRefProto& operator=(FunctionRefProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionRefProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionRefProto* internal_default_instance() {
    return reinterpret_cast<const FunctionRefProto*>(
               &_FunctionRefProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FunctionRefProto& a, FunctionRefProto& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionRefProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionRefProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionRefProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionRefProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunctionRefProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FunctionRefProto& from) {
    FunctionRefProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionRefProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.FunctionRefProto";
  }
  protected:
  explicit FunctionRefProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:zetasql.FunctionRefProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto;
};
// -------------------------------------------------------------------

class TableValuedFunctionRefProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zetasql.TableValuedFunctionRefProto) */ {
 public:
  inline TableValuedFunctionRefProto() : TableValuedFunctionRefProto(nullptr) {}
  ~TableValuedFunctionRefProto() override;
  explicit PROTOBUF_CONSTEXPR TableValuedFunctionRefProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableValuedFunctionRefProto(const TableValuedFunctionRefProto& from);
  TableValuedFunctionRefProto(TableValuedFunctionRefProto&& from) noexcept
    : TableValuedFunctionRefProto() {
    *this = ::std::move(from);
  }

  inline TableValuedFunctionRefProto& operator=(const TableValuedFunctionRefProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableValuedFunctionRefProto& operator=(TableValuedFunctionRefProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableValuedFunctionRefProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableValuedFunctionRefProto* internal_default_instance() {
    return reinterpret_cast<const TableValuedFunctionRefProto*>(
               &_TableValuedFunctionRefProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TableValuedFunctionRefProto& a, TableValuedFunctionRefProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TableValuedFunctionRefProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableValuedFunctionRefProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableValuedFunctionRefProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableValuedFunctionRefProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableValuedFunctionRefProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableValuedFunctionRefProto& from) {
    TableValuedFunctionRefProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableValuedFunctionRefProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.TableValuedFunctionRefProto";
  }
  protected:
  explicit TableValuedFunctionRefProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:zetasql.TableValuedFunctionRefProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto;
};
// -------------------------------------------------------------------

class ResolvedNodeProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedNodeProto) */ {
 public:
  inline ResolvedNodeProto() : ResolvedNodeProto(nullptr) {}
  ~ResolvedNodeProto() override;
  explicit PROTOBUF_CONSTEXPR ResolvedNodeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedNodeProto(const ResolvedNodeProto& from);
  ResolvedNodeProto(ResolvedNodeProto&& from) noexcept
    : ResolvedNodeProto() {
    *this = ::std::move(from);
  }

  inline ResolvedNodeProto& operator=(const ResolvedNodeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedNodeProto& operator=(ResolvedNodeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedNodeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedNodeProto* internal_default_instance() {
    return reinterpret_cast<const ResolvedNodeProto*>(
               &_ResolvedNodeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ResolvedNodeProto& a, ResolvedNodeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedNodeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedNodeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedNodeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedNodeProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResolvedNodeProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResolvedNodeProto& from) {
    ResolvedNodeProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedNodeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedNodeProto";
  }
  protected:
  explicit ResolvedNodeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParseLocationRangeFieldNumber = 1,
  };
  // optional .zetasql.ParseLocationRangeProto parse_location_range = 1;
  bool has_parse_location_range() const;
  private:
  bool _internal_has_parse_location_range() const;
  public:
  void clear_parse_location_range();
  const ::zetasql::ParseLocationRangeProto& parse_location_range() const;
  PROTOBUF_NODISCARD ::zetasql::ParseLocationRangeProto* release_parse_location_range();
  ::zetasql::ParseLocationRangeProto* mutable_parse_location_range();
  void set_allocated_parse_location_range(::zetasql::ParseLocationRangeProto* parse_location_range);
  private:
  const ::zetasql::ParseLocationRangeProto& _internal_parse_location_range() const;
  ::zetasql::ParseLocationRangeProto* _internal_mutable_parse_location_range();
  public:
  void unsafe_arena_set_allocated_parse_location_range(
      ::zetasql::ParseLocationRangeProto* parse_location_range);
  ::zetasql::ParseLocationRangeProto* unsafe_arena_release_parse_location_range();

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedNodeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::zetasql::ParseLocationRangeProto* parse_location_range_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto;
};
// -------------------------------------------------------------------

class FieldDescriptorRefProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zetasql.FieldDescriptorRefProto) */ {
 public:
  inline FieldDescriptorRefProto() : FieldDescriptorRefProto(nullptr) {}
  ~FieldDescriptorRefProto() override;
  explicit PROTOBUF_CONSTEXPR FieldDescriptorRefProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldDescriptorRefProto(const FieldDescriptorRefProto& from);
  FieldDescriptorRefProto(FieldDescriptorRefProto&& from) noexcept
    : FieldDescriptorRefProto() {
    *this = ::std::move(from);
  }

  inline FieldDescriptorRefProto& operator=(const FieldDescriptorRefProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldDescriptorRefProto& operator=(FieldDescriptorRefProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldDescriptorRefProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldDescriptorRefProto* internal_default_instance() {
    return reinterpret_cast<const FieldDescriptorRefProto*>(
               &_FieldDescriptorRefProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FieldDescriptorRefProto& a, FieldDescriptorRefProto& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldDescriptorRefProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldDescriptorRefProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldDescriptorRefProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldDescriptorRefProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldDescriptorRefProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FieldDescriptorRefProto& from) {
    FieldDescriptorRefProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldDescriptorRefProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.FieldDescriptorRefProto";
  }
  protected:
  explicit FieldDescriptorRefProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainingProtoFieldNumber = 1,
    kNumberFieldNumber = 2,
  };
  // optional .zetasql.ProtoTypeProto containing_proto = 1;
  bool has_containing_proto() const;
  private:
  bool _internal_has_containing_proto() const;
  public:
  void clear_containing_proto();
  const ::zetasql::ProtoTypeProto& containing_proto() const;
  PROTOBUF_NODISCARD ::zetasql::ProtoTypeProto* release_containing_proto();
  ::zetasql::ProtoTypeProto* mutable_containing_proto();
  void set_allocated_containing_proto(::zetasql::ProtoTypeProto* containing_proto);
  private:
  const ::zetasql::ProtoTypeProto& _internal_containing_proto() const;
  ::zetasql::ProtoTypeProto* _internal_mutable_containing_proto();
  public:
  void unsafe_arena_set_allocated_containing_proto(
      ::zetasql::ProtoTypeProto* containing_proto);
  ::zetasql::ProtoTypeProto* unsafe_arena_release_containing_proto();

  // optional int32 number = 2;
  bool has_number() const;
  private:
  bool _internal_has_number() const;
  public:
  void clear_number();
  int32_t number() const;
  void set_number(int32_t value);
  private:
  int32_t _internal_number() const;
  void _internal_set_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zetasql.FieldDescriptorRefProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::zetasql::ProtoTypeProto* containing_proto_;
    int32_t number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto;
};
// -------------------------------------------------------------------

class OneofDescriptorRefProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zetasql.OneofDescriptorRefProto) */ {
 public:
  inline OneofDescriptorRefProto() : OneofDescriptorRefProto(nullptr) {}
  ~OneofDescriptorRefProto() override;
  explicit PROTOBUF_CONSTEXPR OneofDescriptorRefProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneofDescriptorRefProto(const OneofDescriptorRefProto& from);
  OneofDescriptorRefProto(OneofDescriptorRefProto&& from) noexcept
    : OneofDescriptorRefProto() {
    *this = ::std::move(from);
  }

  inline OneofDescriptorRefProto& operator=(const OneofDescriptorRefProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneofDescriptorRefProto& operator=(OneofDescriptorRefProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneofDescriptorRefProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneofDescriptorRefProto* internal_default_instance() {
    return reinterpret_cast<const OneofDescriptorRefProto*>(
               &_OneofDescriptorRefProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(OneofDescriptorRefProto& a, OneofDescriptorRefProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OneofDescriptorRefProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneofDescriptorRefProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneofDescriptorRefProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneofDescriptorRefProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OneofDescriptorRefProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OneofDescriptorRefProto& from) {
    OneofDescriptorRefProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OneofDescriptorRefProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.OneofDescriptorRefProto";
  }
  protected:
  explicit OneofDescriptorRefProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainingProtoFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // optional .zetasql.ProtoTypeProto containing_proto = 1;
  bool has_containing_proto() const;
  private:
  bool _internal_has_containing_proto() const;
  public:
  void clear_containing_proto();
  const ::zetasql::ProtoTypeProto& containing_proto() const;
  PROTOBUF_NODISCARD ::zetasql::ProtoTypeProto* release_containing_proto();
  ::zetasql::ProtoTypeProto* mutable_containing_proto();
  void set_allocated_containing_proto(::zetasql::ProtoTypeProto* containing_proto);
  private:
  const ::zetasql::ProtoTypeProto& _internal_containing_proto() const;
  ::zetasql::ProtoTypeProto* _internal_mutable_containing_proto();
  public:
  void unsafe_arena_set_allocated_containing_proto(
      ::zetasql::ProtoTypeProto* containing_proto);
  ::zetasql::ProtoTypeProto* unsafe_arena_release_containing_proto();

  // optional int32 index = 2;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zetasql.OneofDescriptorRefProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::zetasql::ProtoTypeProto* containing_proto_;
    int32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto;
};
// -------------------------------------------------------------------

class ProcedureRefProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zetasql.ProcedureRefProto) */ {
 public:
  inline ProcedureRefProto() : ProcedureRefProto(nullptr) {}
  ~ProcedureRefProto() override;
  explicit PROTOBUF_CONSTEXPR ProcedureRefProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcedureRefProto(const ProcedureRefProto& from);
  ProcedureRefProto(ProcedureRefProto&& from) noexcept
    : ProcedureRefProto() {
    *this = ::std::move(from);
  }

  inline ProcedureRefProto& operator=(const ProcedureRefProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcedureRefProto& operator=(ProcedureRefProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcedureRefProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcedureRefProto* internal_default_instance() {
    return reinterpret_cast<const ProcedureRefProto*>(
               &_ProcedureRefProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ProcedureRefProto& a, ProcedureRefProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcedureRefProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcedureRefProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcedureRefProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcedureRefProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcedureRefProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcedureRefProto& from) {
    ProcedureRefProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureRefProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ProcedureRefProto";
  }
  protected:
  explicit ProcedureRefProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:zetasql.ProcedureRefProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto;
};
// -------------------------------------------------------------------

class ResolvedCollationProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zetasql.ResolvedCollationProto) */ {
 public:
  inline ResolvedCollationProto() : ResolvedCollationProto(nullptr) {}
  ~ResolvedCollationProto() override;
  explicit PROTOBUF_CONSTEXPR ResolvedCollationProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedCollationProto(const ResolvedCollationProto& from);
  ResolvedCollationProto(ResolvedCollationProto&& from) noexcept
    : ResolvedCollationProto() {
    *this = ::std::move(from);
  }

  inline ResolvedCollationProto& operator=(const ResolvedCollationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedCollationProto& operator=(ResolvedCollationProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedCollationProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedCollationProto* internal_default_instance() {
    return reinterpret_cast<const ResolvedCollationProto*>(
               &_ResolvedCollationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ResolvedCollationProto& a, ResolvedCollationProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedCollationProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedCollationProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedCollationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedCollationProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResolvedCollationProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResolvedCollationProto& from) {
    ResolvedCollationProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedCollationProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ResolvedCollationProto";
  }
  protected:
  explicit ResolvedCollationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildListFieldNumber = 2,
    kCollationNameFieldNumber = 1,
  };
  // repeated .zetasql.ResolvedCollationProto child_list = 2;
  int child_list_size() const;
  private:
  int _internal_child_list_size() const;
  public:
  void clear_child_list();
  ::zetasql::ResolvedCollationProto* mutable_child_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zetasql::ResolvedCollationProto >*
      mutable_child_list();
  private:
  const ::zetasql::ResolvedCollationProto& _internal_child_list(int index) const;
  ::zetasql::ResolvedCollationProto* _internal_add_child_list();
  public:
  const ::zetasql::ResolvedCollationProto& child_list(int index) const;
  ::zetasql::ResolvedCollationProto* add_child_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zetasql::ResolvedCollationProto >&
      child_list() const;

  // optional string collation_name = 1;
  bool has_collation_name() const;
  private:
  bool _internal_has_collation_name() const;
  public:
  void clear_collation_name();
  const std::string& collation_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_collation_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_collation_name();
  PROTOBUF_NODISCARD std::string* release_collation_name();
  void set_allocated_collation_name(std::string* collation_name);
  private:
  const std::string& _internal_collation_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collation_name(const std::string& value);
  std::string* _internal_mutable_collation_name();
  public:

  // @@protoc_insertion_point(class_scope:zetasql.ResolvedCollationProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zetasql::ResolvedCollationProto > child_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collation_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_zetasql_2fresolved_5fast_2fserialization_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ResolvedColumnProto

// optional int64 column_id = 1;
inline bool ResolvedColumnProto::_internal_has_column_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ResolvedColumnProto::has_column_id() const {
  return _internal_has_column_id();
}
inline void ResolvedColumnProto::clear_column_id() {
  _impl_.column_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t ResolvedColumnProto::_internal_column_id() const {
  return _impl_.column_id_;
}
inline int64_t ResolvedColumnProto::column_id() const {
  // @@protoc_insertion_point(field_get:zetasql.ResolvedColumnProto.column_id)
  return _internal_column_id();
}
inline void ResolvedColumnProto::_internal_set_column_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.column_id_ = value;
}
inline void ResolvedColumnProto::set_column_id(int64_t value) {
  _internal_set_column_id(value);
  // @@protoc_insertion_point(field_set:zetasql.ResolvedColumnProto.column_id)
}

// optional string table_name = 2;
inline bool ResolvedColumnProto::_internal_has_table_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResolvedColumnProto::has_table_name() const {
  return _internal_has_table_name();
}
inline void ResolvedColumnProto::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResolvedColumnProto::table_name() const {
  // @@protoc_insertion_point(field_get:zetasql.ResolvedColumnProto.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedColumnProto::set_table_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zetasql.ResolvedColumnProto.table_name)
}
inline std::string* ResolvedColumnProto::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:zetasql.ResolvedColumnProto.table_name)
  return _s;
}
inline const std::string& ResolvedColumnProto::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void ResolvedColumnProto::_internal_set_table_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedColumnProto::_internal_mutable_table_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedColumnProto::release_table_name() {
  // @@protoc_insertion_point(field_release:zetasql.ResolvedColumnProto.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.table_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResolvedColumnProto::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zetasql.ResolvedColumnProto.table_name)
}

// optional string name = 3;
inline bool ResolvedColumnProto::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResolvedColumnProto::has_name() const {
  return _internal_has_name();
}
inline void ResolvedColumnProto::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResolvedColumnProto::name() const {
  // @@protoc_insertion_point(field_get:zetasql.ResolvedColumnProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedColumnProto::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zetasql.ResolvedColumnProto.name)
}
inline std::string* ResolvedColumnProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zetasql.ResolvedColumnProto.name)
  return _s;
}
inline const std::string& ResolvedColumnProto::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ResolvedColumnProto::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedColumnProto::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedColumnProto::release_name() {
  // @@protoc_insertion_point(field_release:zetasql.ResolvedColumnProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResolvedColumnProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zetasql.ResolvedColumnProto.name)
}

// optional .zetasql.TypeProto type = 4;
inline bool ResolvedColumnProto::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_ != nullptr);
  return value;
}
inline bool ResolvedColumnProto::has_type() const {
  return _internal_has_type();
}
inline const ::zetasql::TypeProto& ResolvedColumnProto::_internal_type() const {
  const ::zetasql::TypeProto* p = _impl_.type_;
  return p != nullptr ? *p : reinterpret_cast<const ::zetasql::TypeProto&>(
      ::zetasql::_TypeProto_default_instance_);
}
inline const ::zetasql::TypeProto& ResolvedColumnProto::type() const {
  // @@protoc_insertion_point(field_get:zetasql.ResolvedColumnProto.type)
  return _internal_type();
}
inline void ResolvedColumnProto::unsafe_arena_set_allocated_type(
    ::zetasql::TypeProto* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.type_);
  }
  _impl_.type_ = type;
  if (type) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zetasql.ResolvedColumnProto.type)
}
inline ::zetasql::TypeProto* ResolvedColumnProto::release_type() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::zetasql::TypeProto* temp = _impl_.type_;
  _impl_.type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zetasql::TypeProto* ResolvedColumnProto::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:zetasql.ResolvedColumnProto.type)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::zetasql::TypeProto* temp = _impl_.type_;
  _impl_.type_ = nullptr;
  return temp;
}
inline ::zetasql::TypeProto* ResolvedColumnProto::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_ == nullptr) {
    auto* p = CreateMaybeMessage<::zetasql::TypeProto>(GetArenaForAllocation());
    _impl_.type_ = p;
  }
  return _impl_.type_;
}
inline ::zetasql::TypeProto* ResolvedColumnProto::mutable_type() {
  ::zetasql::TypeProto* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:zetasql.ResolvedColumnProto.type)
  return _msg;
}
inline void ResolvedColumnProto::set_allocated_type(::zetasql::TypeProto* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.type_);
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type));
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.type_ = type;
  // @@protoc_insertion_point(field_set_allocated:zetasql.ResolvedColumnProto.type)
}

// optional .zetasql.AnnotationMapProto annotation_map = 5;
inline bool ResolvedColumnProto::_internal_has_annotation_map() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.annotation_map_ != nullptr);
  return value;
}
inline bool ResolvedColumnProto::has_annotation_map() const {
  return _internal_has_annotation_map();
}
inline const ::zetasql::AnnotationMapProto& ResolvedColumnProto::_internal_annotation_map() const {
  const ::zetasql::AnnotationMapProto* p = _impl_.annotation_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::zetasql::AnnotationMapProto&>(
      ::zetasql::_AnnotationMapProto_default_instance_);
}
inline const ::zetasql::AnnotationMapProto& ResolvedColumnProto::annotation_map() const {
  // @@protoc_insertion_point(field_get:zetasql.ResolvedColumnProto.annotation_map)
  return _internal_annotation_map();
}
inline void ResolvedColumnProto::unsafe_arena_set_allocated_annotation_map(
    ::zetasql::AnnotationMapProto* annotation_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_map_);
  }
  _impl_.annotation_map_ = annotation_map;
  if (annotation_map) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zetasql.ResolvedColumnProto.annotation_map)
}
inline ::zetasql::AnnotationMapProto* ResolvedColumnProto::release_annotation_map() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::zetasql::AnnotationMapProto* temp = _impl_.annotation_map_;
  _impl_.annotation_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zetasql::AnnotationMapProto* ResolvedColumnProto::unsafe_arena_release_annotation_map() {
  // @@protoc_insertion_point(field_release:zetasql.ResolvedColumnProto.annotation_map)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::zetasql::AnnotationMapProto* temp = _impl_.annotation_map_;
  _impl_.annotation_map_ = nullptr;
  return temp;
}
inline ::zetasql::AnnotationMapProto* ResolvedColumnProto::_internal_mutable_annotation_map() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.annotation_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::zetasql::AnnotationMapProto>(GetArenaForAllocation());
    _impl_.annotation_map_ = p;
  }
  return _impl_.annotation_map_;
}
inline ::zetasql::AnnotationMapProto* ResolvedColumnProto::mutable_annotation_map() {
  ::zetasql::AnnotationMapProto* _msg = _internal_mutable_annotation_map();
  // @@protoc_insertion_point(field_mutable:zetasql.ResolvedColumnProto.annotation_map)
  return _msg;
}
inline void ResolvedColumnProto::set_allocated_annotation_map(::zetasql::AnnotationMapProto* annotation_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_map_);
  }
  if (annotation_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotation_map));
    if (message_arena != submessage_arena) {
      annotation_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation_map, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.annotation_map_ = annotation_map;
  // @@protoc_insertion_point(field_set_allocated:zetasql.ResolvedColumnProto.annotation_map)
}

// -------------------------------------------------------------------

// ValueWithTypeProto

// optional .zetasql.TypeProto type = 1;
inline bool ValueWithTypeProto::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_ != nullptr);
  return value;
}
inline bool ValueWithTypeProto::has_type() const {
  return _internal_has_type();
}
inline const ::zetasql::TypeProto& ValueWithTypeProto::_internal_type() const {
  const ::zetasql::TypeProto* p = _impl_.type_;
  return p != nullptr ? *p : reinterpret_cast<const ::zetasql::TypeProto&>(
      ::zetasql::_TypeProto_default_instance_);
}
inline const ::zetasql::TypeProto& ValueWithTypeProto::type() const {
  // @@protoc_insertion_point(field_get:zetasql.ValueWithTypeProto.type)
  return _internal_type();
}
inline void ValueWithTypeProto::unsafe_arena_set_allocated_type(
    ::zetasql::TypeProto* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.type_);
  }
  _impl_.type_ = type;
  if (type) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zetasql.ValueWithTypeProto.type)
}
inline ::zetasql::TypeProto* ValueWithTypeProto::release_type() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zetasql::TypeProto* temp = _impl_.type_;
  _impl_.type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zetasql::TypeProto* ValueWithTypeProto::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:zetasql.ValueWithTypeProto.type)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zetasql::TypeProto* temp = _impl_.type_;
  _impl_.type_ = nullptr;
  return temp;
}
inline ::zetasql::TypeProto* ValueWithTypeProto::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.type_ == nullptr) {
    auto* p = CreateMaybeMessage<::zetasql::TypeProto>(GetArenaForAllocation());
    _impl_.type_ = p;
  }
  return _impl_.type_;
}
inline ::zetasql::TypeProto* ValueWithTypeProto::mutable_type() {
  ::zetasql::TypeProto* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:zetasql.ValueWithTypeProto.type)
  return _msg;
}
inline void ValueWithTypeProto::set_allocated_type(::zetasql::TypeProto* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.type_);
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type));
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_ = type;
  // @@protoc_insertion_point(field_set_allocated:zetasql.ValueWithTypeProto.type)
}

// optional .zetasql.ValueProto value = 2;
inline bool ValueWithTypeProto::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline bool ValueWithTypeProto::has_value() const {
  return _internal_has_value();
}
inline const ::zetasql::ValueProto& ValueWithTypeProto::_internal_value() const {
  const ::zetasql::ValueProto* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::zetasql::ValueProto&>(
      ::zetasql::_ValueProto_default_instance_);
}
inline const ::zetasql::ValueProto& ValueWithTypeProto::value() const {
  // @@protoc_insertion_point(field_get:zetasql.ValueWithTypeProto.value)
  return _internal_value();
}
inline void ValueWithTypeProto::unsafe_arena_set_allocated_value(
    ::zetasql::ValueProto* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zetasql.ValueWithTypeProto.value)
}
inline ::zetasql::ValueProto* ValueWithTypeProto::release_value() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::zetasql::ValueProto* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zetasql::ValueProto* ValueWithTypeProto::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:zetasql.ValueWithTypeProto.value)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::zetasql::ValueProto* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::zetasql::ValueProto* ValueWithTypeProto::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::zetasql::ValueProto>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::zetasql::ValueProto* ValueWithTypeProto::mutable_value() {
  ::zetasql::ValueProto* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:zetasql.ValueWithTypeProto.value)
  return _msg;
}
inline void ValueWithTypeProto::set_allocated_value(::zetasql::ValueProto* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:zetasql.ValueWithTypeProto.value)
}

// -------------------------------------------------------------------

// TableRefProto

// optional string name = 1;
inline bool TableRefProto::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TableRefProto::has_name() const {
  return _internal_has_name();
}
inline void TableRefProto::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TableRefProto::name() const {
  // @@protoc_insertion_point(field_get:zetasql.TableRefProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableRefProto::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zetasql.TableRefProto.name)
}
inline std::string* TableRefProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zetasql.TableRefProto.name)
  return _s;
}
inline const std::string& TableRefProto::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TableRefProto::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableRefProto::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TableRefProto::release_name() {
  // @@protoc_insertion_point(field_release:zetasql.TableRefProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TableRefProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zetasql.TableRefProto.name)
}

// optional int64 serialization_id = 2;
inline bool TableRefProto::_internal_has_serialization_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TableRefProto::has_serialization_id() const {
  return _internal_has_serialization_id();
}
inline void TableRefProto::clear_serialization_id() {
  _impl_.serialization_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t TableRefProto::_internal_serialization_id() const {
  return _impl_.serialization_id_;
}
inline int64_t TableRefProto::serialization_id() const {
  // @@protoc_insertion_point(field_get:zetasql.TableRefProto.serialization_id)
  return _internal_serialization_id();
}
inline void TableRefProto::_internal_set_serialization_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.serialization_id_ = value;
}
inline void TableRefProto::set_serialization_id(int64_t value) {
  _internal_set_serialization_id(value);
  // @@protoc_insertion_point(field_set:zetasql.TableRefProto.serialization_id)
}

// optional string full_name = 3;
inline bool TableRefProto::_internal_has_full_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TableRefProto::has_full_name() const {
  return _internal_has_full_name();
}
inline void TableRefProto::clear_full_name() {
  _impl_.full_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TableRefProto::full_name() const {
  // @@protoc_insertion_point(field_get:zetasql.TableRefProto.full_name)
  return _internal_full_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableRefProto::set_full_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.full_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zetasql.TableRefProto.full_name)
}
inline std::string* TableRefProto::mutable_full_name() {
  std::string* _s = _internal_mutable_full_name();
  // @@protoc_insertion_point(field_mutable:zetasql.TableRefProto.full_name)
  return _s;
}
inline const std::string& TableRefProto::_internal_full_name() const {
  return _impl_.full_name_.Get();
}
inline void TableRefProto::_internal_set_full_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.full_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableRefProto::_internal_mutable_full_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.full_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TableRefProto::release_full_name() {
  // @@protoc_insertion_point(field_release:zetasql.TableRefProto.full_name)
  if (!_internal_has_full_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.full_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.full_name_.IsDefault()) {
    _impl_.full_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TableRefProto::set_allocated_full_name(std::string* full_name) {
  if (full_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.full_name_.SetAllocated(full_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.full_name_.IsDefault()) {
    _impl_.full_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zetasql.TableRefProto.full_name)
}

// -------------------------------------------------------------------

// ModelRefProto

// optional string name = 1;
inline bool ModelRefProto::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModelRefProto::has_name() const {
  return _internal_has_name();
}
inline void ModelRefProto::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModelRefProto::name() const {
  // @@protoc_insertion_point(field_get:zetasql.ModelRefProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelRefProto::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zetasql.ModelRefProto.name)
}
inline std::string* ModelRefProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zetasql.ModelRefProto.name)
  return _s;
}
inline const std::string& ModelRefProto::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelRefProto::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelRefProto::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelRefProto::release_name() {
  // @@protoc_insertion_point(field_release:zetasql.ModelRefProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModelRefProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zetasql.ModelRefProto.name)
}

// optional int64 serialization_id = 2;
inline bool ModelRefProto::_internal_has_serialization_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ModelRefProto::has_serialization_id() const {
  return _internal_has_serialization_id();
}
inline void ModelRefProto::clear_serialization_id() {
  _impl_.serialization_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t ModelRefProto::_internal_serialization_id() const {
  return _impl_.serialization_id_;
}
inline int64_t ModelRefProto::serialization_id() const {
  // @@protoc_insertion_point(field_get:zetasql.ModelRefProto.serialization_id)
  return _internal_serialization_id();
}
inline void ModelRefProto::_internal_set_serialization_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.serialization_id_ = value;
}
inline void ModelRefProto::set_serialization_id(int64_t value) {
  _internal_set_serialization_id(value);
  // @@protoc_insertion_point(field_set:zetasql.ModelRefProto.serialization_id)
}

// optional string full_name = 3;
inline bool ModelRefProto::_internal_has_full_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ModelRefProto::has_full_name() const {
  return _internal_has_full_name();
}
inline void ModelRefProto::clear_full_name() {
  _impl_.full_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ModelRefProto::full_name() const {
  // @@protoc_insertion_point(field_get:zetasql.ModelRefProto.full_name)
  return _internal_full_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelRefProto::set_full_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.full_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zetasql.ModelRefProto.full_name)
}
inline std::string* ModelRefProto::mutable_full_name() {
  std::string* _s = _internal_mutable_full_name();
  // @@protoc_insertion_point(field_mutable:zetasql.ModelRefProto.full_name)
  return _s;
}
inline const std::string& ModelRefProto::_internal_full_name() const {
  return _impl_.full_name_.Get();
}
inline void ModelRefProto::_internal_set_full_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.full_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelRefProto::_internal_mutable_full_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.full_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelRefProto::release_full_name() {
  // @@protoc_insertion_point(field_release:zetasql.ModelRefProto.full_name)
  if (!_internal_has_full_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.full_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.full_name_.IsDefault()) {
    _impl_.full_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModelRefProto::set_allocated_full_name(std::string* full_name) {
  if (full_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.full_name_.SetAllocated(full_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.full_name_.IsDefault()) {
    _impl_.full_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zetasql.ModelRefProto.full_name)
}

// -------------------------------------------------------------------

// ConnectionRefProto

// optional string name = 1;
inline bool ConnectionRefProto::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnectionRefProto::has_name() const {
  return _internal_has_name();
}
inline void ConnectionRefProto::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnectionRefProto::name() const {
  // @@protoc_insertion_point(field_get:zetasql.ConnectionRefProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionRefProto::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zetasql.ConnectionRefProto.name)
}
inline std::string* ConnectionRefProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zetasql.ConnectionRefProto.name)
  return _s;
}
inline const std::string& ConnectionRefProto::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ConnectionRefProto::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectionRefProto::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConnectionRefProto::release_name() {
  // @@protoc_insertion_point(field_release:zetasql.ConnectionRefProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectionRefProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zetasql.ConnectionRefProto.name)
}

// optional string full_name = 3;
inline bool ConnectionRefProto::_internal_has_full_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConnectionRefProto::has_full_name() const {
  return _internal_has_full_name();
}
inline void ConnectionRefProto::clear_full_name() {
  _impl_.full_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConnectionRefProto::full_name() const {
  // @@protoc_insertion_point(field_get:zetasql.ConnectionRefProto.full_name)
  return _internal_full_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionRefProto::set_full_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.full_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zetasql.ConnectionRefProto.full_name)
}
inline std::string* ConnectionRefProto::mutable_full_name() {
  std::string* _s = _internal_mutable_full_name();
  // @@protoc_insertion_point(field_mutable:zetasql.ConnectionRefProto.full_name)
  return _s;
}
inline const std::string& ConnectionRefProto::_internal_full_name() const {
  return _impl_.full_name_.Get();
}
inline void ConnectionRefProto::_internal_set_full_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.full_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectionRefProto::_internal_mutable_full_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.full_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConnectionRefProto::release_full_name() {
  // @@protoc_insertion_point(field_release:zetasql.ConnectionRefProto.full_name)
  if (!_internal_has_full_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.full_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.full_name_.IsDefault()) {
    _impl_.full_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectionRefProto::set_allocated_full_name(std::string* full_name) {
  if (full_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.full_name_.SetAllocated(full_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.full_name_.IsDefault()) {
    _impl_.full_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zetasql.ConnectionRefProto.full_name)
}

// -------------------------------------------------------------------

// ConstantRefProto

// optional string name = 1;
inline bool ConstantRefProto::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConstantRefProto::has_name() const {
  return _internal_has_name();
}
inline void ConstantRefProto::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConstantRefProto::name() const {
  // @@protoc_insertion_point(field_get:zetasql.ConstantRefProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConstantRefProto::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zetasql.ConstantRefProto.name)
}
inline std::string* ConstantRefProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zetasql.ConstantRefProto.name)
  return _s;
}
inline const std::string& ConstantRefProto::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ConstantRefProto::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConstantRefProto::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConstantRefProto::release_name() {
  // @@protoc_insertion_point(field_release:zetasql.ConstantRefProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConstantRefProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zetasql.ConstantRefProto.name)
}

// -------------------------------------------------------------------

// FunctionRefProto

// optional string name = 1;
inline bool FunctionRefProto::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FunctionRefProto::has_name() const {
  return _internal_has_name();
}
inline void FunctionRefProto::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FunctionRefProto::name() const {
  // @@protoc_insertion_point(field_get:zetasql.FunctionRefProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunctionRefProto::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zetasql.FunctionRefProto.name)
}
inline std::string* FunctionRefProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zetasql.FunctionRefProto.name)
  return _s;
}
inline const std::string& FunctionRefProto::_internal_name() const {
  return _impl_.name_.Get();
}
inline void FunctionRefProto::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* FunctionRefProto::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* FunctionRefProto::release_name() {
  // @@protoc_insertion_point(field_release:zetasql.FunctionRefProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunctionRefProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zetasql.FunctionRefProto.name)
}

// -------------------------------------------------------------------

// TableValuedFunctionRefProto

// optional string name = 1;
inline bool TableValuedFunctionRefProto::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TableValuedFunctionRefProto::has_name() const {
  return _internal_has_name();
}
inline void TableValuedFunctionRefProto::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TableValuedFunctionRefProto::name() const {
  // @@protoc_insertion_point(field_get:zetasql.TableValuedFunctionRefProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableValuedFunctionRefProto::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zetasql.TableValuedFunctionRefProto.name)
}
inline std::string* TableValuedFunctionRefProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zetasql.TableValuedFunctionRefProto.name)
  return _s;
}
inline const std::string& TableValuedFunctionRefProto::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TableValuedFunctionRefProto::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableValuedFunctionRefProto::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TableValuedFunctionRefProto::release_name() {
  // @@protoc_insertion_point(field_release:zetasql.TableValuedFunctionRefProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TableValuedFunctionRefProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zetasql.TableValuedFunctionRefProto.name)
}

// -------------------------------------------------------------------

// ResolvedNodeProto

// optional .zetasql.ParseLocationRangeProto parse_location_range = 1;
inline bool ResolvedNodeProto::_internal_has_parse_location_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parse_location_range_ != nullptr);
  return value;
}
inline bool ResolvedNodeProto::has_parse_location_range() const {
  return _internal_has_parse_location_range();
}
inline const ::zetasql::ParseLocationRangeProto& ResolvedNodeProto::_internal_parse_location_range() const {
  const ::zetasql::ParseLocationRangeProto* p = _impl_.parse_location_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::zetasql::ParseLocationRangeProto&>(
      ::zetasql::_ParseLocationRangeProto_default_instance_);
}
inline const ::zetasql::ParseLocationRangeProto& ResolvedNodeProto::parse_location_range() const {
  // @@protoc_insertion_point(field_get:zetasql.ResolvedNodeProto.parse_location_range)
  return _internal_parse_location_range();
}
inline void ResolvedNodeProto::unsafe_arena_set_allocated_parse_location_range(
    ::zetasql::ParseLocationRangeProto* parse_location_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parse_location_range_);
  }
  _impl_.parse_location_range_ = parse_location_range;
  if (parse_location_range) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zetasql.ResolvedNodeProto.parse_location_range)
}
inline ::zetasql::ParseLocationRangeProto* ResolvedNodeProto::release_parse_location_range() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zetasql::ParseLocationRangeProto* temp = _impl_.parse_location_range_;
  _impl_.parse_location_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zetasql::ParseLocationRangeProto* ResolvedNodeProto::unsafe_arena_release_parse_location_range() {
  // @@protoc_insertion_point(field_release:zetasql.ResolvedNodeProto.parse_location_range)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zetasql::ParseLocationRangeProto* temp = _impl_.parse_location_range_;
  _impl_.parse_location_range_ = nullptr;
  return temp;
}
inline ::zetasql::ParseLocationRangeProto* ResolvedNodeProto::_internal_mutable_parse_location_range() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.parse_location_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::zetasql::ParseLocationRangeProto>(GetArenaForAllocation());
    _impl_.parse_location_range_ = p;
  }
  return _impl_.parse_location_range_;
}
inline ::zetasql::ParseLocationRangeProto* ResolvedNodeProto::mutable_parse_location_range() {
  ::zetasql::ParseLocationRangeProto* _msg = _internal_mutable_parse_location_range();
  // @@protoc_insertion_point(field_mutable:zetasql.ResolvedNodeProto.parse_location_range)
  return _msg;
}
inline void ResolvedNodeProto::set_allocated_parse_location_range(::zetasql::ParseLocationRangeProto* parse_location_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parse_location_range_);
  }
  if (parse_location_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parse_location_range));
    if (message_arena != submessage_arena) {
      parse_location_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parse_location_range, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parse_location_range_ = parse_location_range;
  // @@protoc_insertion_point(field_set_allocated:zetasql.ResolvedNodeProto.parse_location_range)
}

// -------------------------------------------------------------------

// FieldDescriptorRefProto

// optional .zetasql.ProtoTypeProto containing_proto = 1;
inline bool FieldDescriptorRefProto::_internal_has_containing_proto() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.containing_proto_ != nullptr);
  return value;
}
inline bool FieldDescriptorRefProto::has_containing_proto() const {
  return _internal_has_containing_proto();
}
inline const ::zetasql::ProtoTypeProto& FieldDescriptorRefProto::_internal_containing_proto() const {
  const ::zetasql::ProtoTypeProto* p = _impl_.containing_proto_;
  return p != nullptr ? *p : reinterpret_cast<const ::zetasql::ProtoTypeProto&>(
      ::zetasql::_ProtoTypeProto_default_instance_);
}
inline const ::zetasql::ProtoTypeProto& FieldDescriptorRefProto::containing_proto() const {
  // @@protoc_insertion_point(field_get:zetasql.FieldDescriptorRefProto.containing_proto)
  return _internal_containing_proto();
}
inline void FieldDescriptorRefProto::unsafe_arena_set_allocated_containing_proto(
    ::zetasql::ProtoTypeProto* containing_proto) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.containing_proto_);
  }
  _impl_.containing_proto_ = containing_proto;
  if (containing_proto) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zetasql.FieldDescriptorRefProto.containing_proto)
}
inline ::zetasql::ProtoTypeProto* FieldDescriptorRefProto::release_containing_proto() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zetasql::ProtoTypeProto* temp = _impl_.containing_proto_;
  _impl_.containing_proto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zetasql::ProtoTypeProto* FieldDescriptorRefProto::unsafe_arena_release_containing_proto() {
  // @@protoc_insertion_point(field_release:zetasql.FieldDescriptorRefProto.containing_proto)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zetasql::ProtoTypeProto* temp = _impl_.containing_proto_;
  _impl_.containing_proto_ = nullptr;
  return temp;
}
inline ::zetasql::ProtoTypeProto* FieldDescriptorRefProto::_internal_mutable_containing_proto() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.containing_proto_ == nullptr) {
    auto* p = CreateMaybeMessage<::zetasql::ProtoTypeProto>(GetArenaForAllocation());
    _impl_.containing_proto_ = p;
  }
  return _impl_.containing_proto_;
}
inline ::zetasql::ProtoTypeProto* FieldDescriptorRefProto::mutable_containing_proto() {
  ::zetasql::ProtoTypeProto* _msg = _internal_mutable_containing_proto();
  // @@protoc_insertion_point(field_mutable:zetasql.FieldDescriptorRefProto.containing_proto)
  return _msg;
}
inline void FieldDescriptorRefProto::set_allocated_containing_proto(::zetasql::ProtoTypeProto* containing_proto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.containing_proto_);
  }
  if (containing_proto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(containing_proto));
    if (message_arena != submessage_arena) {
      containing_proto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, containing_proto, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.containing_proto_ = containing_proto;
  // @@protoc_insertion_point(field_set_allocated:zetasql.FieldDescriptorRefProto.containing_proto)
}

// optional int32 number = 2;
inline bool FieldDescriptorRefProto::_internal_has_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FieldDescriptorRefProto::has_number() const {
  return _internal_has_number();
}
inline void FieldDescriptorRefProto::clear_number() {
  _impl_.number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t FieldDescriptorRefProto::_internal_number() const {
  return _impl_.number_;
}
inline int32_t FieldDescriptorRefProto::number() const {
  // @@protoc_insertion_point(field_get:zetasql.FieldDescriptorRefProto.number)
  return _internal_number();
}
inline void FieldDescriptorRefProto::_internal_set_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.number_ = value;
}
inline void FieldDescriptorRefProto::set_number(int32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:zetasql.FieldDescriptorRefProto.number)
}

// -------------------------------------------------------------------

// OneofDescriptorRefProto

// optional .zetasql.ProtoTypeProto containing_proto = 1;
inline bool OneofDescriptorRefProto::_internal_has_containing_proto() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.containing_proto_ != nullptr);
  return value;
}
inline bool OneofDescriptorRefProto::has_containing_proto() const {
  return _internal_has_containing_proto();
}
inline const ::zetasql::ProtoTypeProto& OneofDescriptorRefProto::_internal_containing_proto() const {
  const ::zetasql::ProtoTypeProto* p = _impl_.containing_proto_;
  return p != nullptr ? *p : reinterpret_cast<const ::zetasql::ProtoTypeProto&>(
      ::zetasql::_ProtoTypeProto_default_instance_);
}
inline const ::zetasql::ProtoTypeProto& OneofDescriptorRefProto::containing_proto() const {
  // @@protoc_insertion_point(field_get:zetasql.OneofDescriptorRefProto.containing_proto)
  return _internal_containing_proto();
}
inline void OneofDescriptorRefProto::unsafe_arena_set_allocated_containing_proto(
    ::zetasql::ProtoTypeProto* containing_proto) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.containing_proto_);
  }
  _impl_.containing_proto_ = containing_proto;
  if (containing_proto) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zetasql.OneofDescriptorRefProto.containing_proto)
}
inline ::zetasql::ProtoTypeProto* OneofDescriptorRefProto::release_containing_proto() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zetasql::ProtoTypeProto* temp = _impl_.containing_proto_;
  _impl_.containing_proto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zetasql::ProtoTypeProto* OneofDescriptorRefProto::unsafe_arena_release_containing_proto() {
  // @@protoc_insertion_point(field_release:zetasql.OneofDescriptorRefProto.containing_proto)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::zetasql::ProtoTypeProto* temp = _impl_.containing_proto_;
  _impl_.containing_proto_ = nullptr;
  return temp;
}
inline ::zetasql::ProtoTypeProto* OneofDescriptorRefProto::_internal_mutable_containing_proto() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.containing_proto_ == nullptr) {
    auto* p = CreateMaybeMessage<::zetasql::ProtoTypeProto>(GetArenaForAllocation());
    _impl_.containing_proto_ = p;
  }
  return _impl_.containing_proto_;
}
inline ::zetasql::ProtoTypeProto* OneofDescriptorRefProto::mutable_containing_proto() {
  ::zetasql::ProtoTypeProto* _msg = _internal_mutable_containing_proto();
  // @@protoc_insertion_point(field_mutable:zetasql.OneofDescriptorRefProto.containing_proto)
  return _msg;
}
inline void OneofDescriptorRefProto::set_allocated_containing_proto(::zetasql::ProtoTypeProto* containing_proto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.containing_proto_);
  }
  if (containing_proto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(containing_proto));
    if (message_arena != submessage_arena) {
      containing_proto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, containing_proto, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.containing_proto_ = containing_proto;
  // @@protoc_insertion_point(field_set_allocated:zetasql.OneofDescriptorRefProto.containing_proto)
}

// optional int32 index = 2;
inline bool OneofDescriptorRefProto::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OneofDescriptorRefProto::has_index() const {
  return _internal_has_index();
}
inline void OneofDescriptorRefProto::clear_index() {
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t OneofDescriptorRefProto::_internal_index() const {
  return _impl_.index_;
}
inline int32_t OneofDescriptorRefProto::index() const {
  // @@protoc_insertion_point(field_get:zetasql.OneofDescriptorRefProto.index)
  return _internal_index();
}
inline void OneofDescriptorRefProto::_internal_set_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.index_ = value;
}
inline void OneofDescriptorRefProto::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:zetasql.OneofDescriptorRefProto.index)
}

// -------------------------------------------------------------------

// ProcedureRefProto

// optional string name = 1;
inline bool ProcedureRefProto::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProcedureRefProto::has_name() const {
  return _internal_has_name();
}
inline void ProcedureRefProto::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProcedureRefProto::name() const {
  // @@protoc_insertion_point(field_get:zetasql.ProcedureRefProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcedureRefProto::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zetasql.ProcedureRefProto.name)
}
inline std::string* ProcedureRefProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zetasql.ProcedureRefProto.name)
  return _s;
}
inline const std::string& ProcedureRefProto::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ProcedureRefProto::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcedureRefProto::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcedureRefProto::release_name() {
  // @@protoc_insertion_point(field_release:zetasql.ProcedureRefProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProcedureRefProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zetasql.ProcedureRefProto.name)
}

// -------------------------------------------------------------------

// ResolvedCollationProto

// optional string collation_name = 1;
inline bool ResolvedCollationProto::_internal_has_collation_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResolvedCollationProto::has_collation_name() const {
  return _internal_has_collation_name();
}
inline void ResolvedCollationProto::clear_collation_name() {
  _impl_.collation_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResolvedCollationProto::collation_name() const {
  // @@protoc_insertion_point(field_get:zetasql.ResolvedCollationProto.collation_name)
  return _internal_collation_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedCollationProto::set_collation_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.collation_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zetasql.ResolvedCollationProto.collation_name)
}
inline std::string* ResolvedCollationProto::mutable_collation_name() {
  std::string* _s = _internal_mutable_collation_name();
  // @@protoc_insertion_point(field_mutable:zetasql.ResolvedCollationProto.collation_name)
  return _s;
}
inline const std::string& ResolvedCollationProto::_internal_collation_name() const {
  return _impl_.collation_name_.Get();
}
inline void ResolvedCollationProto::_internal_set_collation_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.collation_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedCollationProto::_internal_mutable_collation_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.collation_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedCollationProto::release_collation_name() {
  // @@protoc_insertion_point(field_release:zetasql.ResolvedCollationProto.collation_name)
  if (!_internal_has_collation_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.collation_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.collation_name_.IsDefault()) {
    _impl_.collation_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResolvedCollationProto::set_allocated_collation_name(std::string* collation_name) {
  if (collation_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.collation_name_.SetAllocated(collation_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.collation_name_.IsDefault()) {
    _impl_.collation_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zetasql.ResolvedCollationProto.collation_name)
}

// repeated .zetasql.ResolvedCollationProto child_list = 2;
inline int ResolvedCollationProto::_internal_child_list_size() const {
  return _impl_.child_list_.size();
}
inline int ResolvedCollationProto::child_list_size() const {
  return _internal_child_list_size();
}
inline void ResolvedCollationProto::clear_child_list() {
  _impl_.child_list_.Clear();
}
inline ::zetasql::ResolvedCollationProto* ResolvedCollationProto::mutable_child_list(int index) {
  // @@protoc_insertion_point(field_mutable:zetasql.ResolvedCollationProto.child_list)
  return _impl_.child_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zetasql::ResolvedCollationProto >*
ResolvedCollationProto::mutable_child_list() {
  // @@protoc_insertion_point(field_mutable_list:zetasql.ResolvedCollationProto.child_list)
  return &_impl_.child_list_;
}
inline const ::zetasql::ResolvedCollationProto& ResolvedCollationProto::_internal_child_list(int index) const {
  return _impl_.child_list_.Get(index);
}
inline const ::zetasql::ResolvedCollationProto& ResolvedCollationProto::child_list(int index) const {
  // @@protoc_insertion_point(field_get:zetasql.ResolvedCollationProto.child_list)
  return _internal_child_list(index);
}
inline ::zetasql::ResolvedCollationProto* ResolvedCollationProto::_internal_add_child_list() {
  return _impl_.child_list_.Add();
}
inline ::zetasql::ResolvedCollationProto* ResolvedCollationProto::add_child_list() {
  ::zetasql::ResolvedCollationProto* _add = _internal_add_child_list();
  // @@protoc_insertion_point(field_add:zetasql.ResolvedCollationProto.child_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zetasql::ResolvedCollationProto >&
ResolvedCollationProto::child_list() const {
  // @@protoc_insertion_point(field_list:zetasql.ResolvedCollationProto.child_list)
  return _impl_.child_list_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zetasql

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_zetasql_2fresolved_5fast_2fserialization_2eproto
