// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zetasql/parser/ast_enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_zetasql_2fparser_2fast_5fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_zetasql_2fparser_2fast_5fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_zetasql_2fparser_2fast_5fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_zetasql_2fparser_2fast_5fenums_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_zetasql_2fparser_2fast_5fenums_2eproto;
namespace zetasql {
class ASTAnySomeAllOpEnums;
struct ASTAnySomeAllOpEnumsDefaultTypeInternal;
extern ASTAnySomeAllOpEnumsDefaultTypeInternal _ASTAnySomeAllOpEnums_default_instance_;
class ASTAuxLoadDataStatementEnums;
struct ASTAuxLoadDataStatementEnumsDefaultTypeInternal;
extern ASTAuxLoadDataStatementEnumsDefaultTypeInternal _ASTAuxLoadDataStatementEnums_default_instance_;
class ASTBinaryExpressionEnums;
struct ASTBinaryExpressionEnumsDefaultTypeInternal;
extern ASTBinaryExpressionEnumsDefaultTypeInternal _ASTBinaryExpressionEnums_default_instance_;
class ASTBreakContinueStatementEnums;
struct ASTBreakContinueStatementEnumsDefaultTypeInternal;
extern ASTBreakContinueStatementEnumsDefaultTypeInternal _ASTBreakContinueStatementEnums_default_instance_;
class ASTColumnPositionEnums;
struct ASTColumnPositionEnumsDefaultTypeInternal;
extern ASTColumnPositionEnumsDefaultTypeInternal _ASTColumnPositionEnums_default_instance_;
class ASTCreateFunctionStmtBaseEnums;
struct ASTCreateFunctionStmtBaseEnumsDefaultTypeInternal;
extern ASTCreateFunctionStmtBaseEnumsDefaultTypeInternal _ASTCreateFunctionStmtBaseEnums_default_instance_;
class ASTCreateStatementEnums;
struct ASTCreateStatementEnumsDefaultTypeInternal;
extern ASTCreateStatementEnumsDefaultTypeInternal _ASTCreateStatementEnums_default_instance_;
class ASTDropStatementEnums;
struct ASTDropStatementEnumsDefaultTypeInternal;
extern ASTDropStatementEnumsDefaultTypeInternal _ASTDropStatementEnums_default_instance_;
class ASTExpressionSubqueryEnums;
struct ASTExpressionSubqueryEnumsDefaultTypeInternal;
extern ASTExpressionSubqueryEnumsDefaultTypeInternal _ASTExpressionSubqueryEnums_default_instance_;
class ASTFilterFieldsArgEnums;
struct ASTFilterFieldsArgEnumsDefaultTypeInternal;
extern ASTFilterFieldsArgEnumsDefaultTypeInternal _ASTFilterFieldsArgEnums_default_instance_;
class ASTForeignKeyActionsEnums;
struct ASTForeignKeyActionsEnumsDefaultTypeInternal;
extern ASTForeignKeyActionsEnumsDefaultTypeInternal _ASTForeignKeyActionsEnums_default_instance_;
class ASTForeignKeyReferenceEnums;
struct ASTForeignKeyReferenceEnumsDefaultTypeInternal;
extern ASTForeignKeyReferenceEnumsDefaultTypeInternal _ASTForeignKeyReferenceEnums_default_instance_;
class ASTFunctionCallEnums;
struct ASTFunctionCallEnumsDefaultTypeInternal;
extern ASTFunctionCallEnumsDefaultTypeInternal _ASTFunctionCallEnums_default_instance_;
class ASTFunctionParameterEnums;
struct ASTFunctionParameterEnumsDefaultTypeInternal;
extern ASTFunctionParameterEnumsDefaultTypeInternal _ASTFunctionParameterEnums_default_instance_;
class ASTGeneratedColumnInfoEnums;
struct ASTGeneratedColumnInfoEnumsDefaultTypeInternal;
extern ASTGeneratedColumnInfoEnumsDefaultTypeInternal _ASTGeneratedColumnInfoEnums_default_instance_;
class ASTHavingModifierEnums;
struct ASTHavingModifierEnumsDefaultTypeInternal;
extern ASTHavingModifierEnumsDefaultTypeInternal _ASTHavingModifierEnums_default_instance_;
class ASTImportStatementEnums;
struct ASTImportStatementEnumsDefaultTypeInternal;
extern ASTImportStatementEnumsDefaultTypeInternal _ASTImportStatementEnums_default_instance_;
class ASTInsertStatementEnums;
struct ASTInsertStatementEnumsDefaultTypeInternal;
extern ASTInsertStatementEnumsDefaultTypeInternal _ASTInsertStatementEnums_default_instance_;
class ASTJoinEnums;
struct ASTJoinEnumsDefaultTypeInternal;
extern ASTJoinEnumsDefaultTypeInternal _ASTJoinEnums_default_instance_;
class ASTMergeActionEnums;
struct ASTMergeActionEnumsDefaultTypeInternal;
extern ASTMergeActionEnumsDefaultTypeInternal _ASTMergeActionEnums_default_instance_;
class ASTMergeWhenClauseEnums;
struct ASTMergeWhenClauseEnumsDefaultTypeInternal;
extern ASTMergeWhenClauseEnumsDefaultTypeInternal _ASTMergeWhenClauseEnums_default_instance_;
class ASTOrderingExpressionEnums;
struct ASTOrderingExpressionEnumsDefaultTypeInternal;
extern ASTOrderingExpressionEnumsDefaultTypeInternal _ASTOrderingExpressionEnums_default_instance_;
class ASTSampleSizeEnums;
struct ASTSampleSizeEnumsDefaultTypeInternal;
extern ASTSampleSizeEnumsDefaultTypeInternal _ASTSampleSizeEnums_default_instance_;
class ASTSelectAsEnums;
struct ASTSelectAsEnumsDefaultTypeInternal;
extern ASTSelectAsEnumsDefaultTypeInternal _ASTSelectAsEnums_default_instance_;
class ASTSetOperationEnums;
struct ASTSetOperationEnumsDefaultTypeInternal;
extern ASTSetOperationEnumsDefaultTypeInternal _ASTSetOperationEnums_default_instance_;
class ASTSpannerInterleaveClauseEnums;
struct ASTSpannerInterleaveClauseEnumsDefaultTypeInternal;
extern ASTSpannerInterleaveClauseEnumsDefaultTypeInternal _ASTSpannerInterleaveClauseEnums_default_instance_;
class ASTTemplatedParameterTypeEnums;
struct ASTTemplatedParameterTypeEnumsDefaultTypeInternal;
extern ASTTemplatedParameterTypeEnumsDefaultTypeInternal _ASTTemplatedParameterTypeEnums_default_instance_;
class ASTTransactionReadWriteModeEnums;
struct ASTTransactionReadWriteModeEnumsDefaultTypeInternal;
extern ASTTransactionReadWriteModeEnumsDefaultTypeInternal _ASTTransactionReadWriteModeEnums_default_instance_;
class ASTUnaryExpressionEnums;
struct ASTUnaryExpressionEnumsDefaultTypeInternal;
extern ASTUnaryExpressionEnumsDefaultTypeInternal _ASTUnaryExpressionEnums_default_instance_;
class ASTUnpivotClauseEnums;
struct ASTUnpivotClauseEnumsDefaultTypeInternal;
extern ASTUnpivotClauseEnumsDefaultTypeInternal _ASTUnpivotClauseEnums_default_instance_;
class ASTWindowFrameEnums;
struct ASTWindowFrameEnumsDefaultTypeInternal;
extern ASTWindowFrameEnumsDefaultTypeInternal _ASTWindowFrameEnums_default_instance_;
class ASTWindowFrameExprEnums;
struct ASTWindowFrameExprEnumsDefaultTypeInternal;
extern ASTWindowFrameExprEnumsDefaultTypeInternal _ASTWindowFrameExprEnums_default_instance_;
}  // namespace zetasql
PROTOBUF_NAMESPACE_OPEN
template<> ::zetasql::ASTAnySomeAllOpEnums* Arena::CreateMaybeMessage<::zetasql::ASTAnySomeAllOpEnums>(Arena*);
template<> ::zetasql::ASTAuxLoadDataStatementEnums* Arena::CreateMaybeMessage<::zetasql::ASTAuxLoadDataStatementEnums>(Arena*);
template<> ::zetasql::ASTBinaryExpressionEnums* Arena::CreateMaybeMessage<::zetasql::ASTBinaryExpressionEnums>(Arena*);
template<> ::zetasql::ASTBreakContinueStatementEnums* Arena::CreateMaybeMessage<::zetasql::ASTBreakContinueStatementEnums>(Arena*);
template<> ::zetasql::ASTColumnPositionEnums* Arena::CreateMaybeMessage<::zetasql::ASTColumnPositionEnums>(Arena*);
template<> ::zetasql::ASTCreateFunctionStmtBaseEnums* Arena::CreateMaybeMessage<::zetasql::ASTCreateFunctionStmtBaseEnums>(Arena*);
template<> ::zetasql::ASTCreateStatementEnums* Arena::CreateMaybeMessage<::zetasql::ASTCreateStatementEnums>(Arena*);
template<> ::zetasql::ASTDropStatementEnums* Arena::CreateMaybeMessage<::zetasql::ASTDropStatementEnums>(Arena*);
template<> ::zetasql::ASTExpressionSubqueryEnums* Arena::CreateMaybeMessage<::zetasql::ASTExpressionSubqueryEnums>(Arena*);
template<> ::zetasql::ASTFilterFieldsArgEnums* Arena::CreateMaybeMessage<::zetasql::ASTFilterFieldsArgEnums>(Arena*);
template<> ::zetasql::ASTForeignKeyActionsEnums* Arena::CreateMaybeMessage<::zetasql::ASTForeignKeyActionsEnums>(Arena*);
template<> ::zetasql::ASTForeignKeyReferenceEnums* Arena::CreateMaybeMessage<::zetasql::ASTForeignKeyReferenceEnums>(Arena*);
template<> ::zetasql::ASTFunctionCallEnums* Arena::CreateMaybeMessage<::zetasql::ASTFunctionCallEnums>(Arena*);
template<> ::zetasql::ASTFunctionParameterEnums* Arena::CreateMaybeMessage<::zetasql::ASTFunctionParameterEnums>(Arena*);
template<> ::zetasql::ASTGeneratedColumnInfoEnums* Arena::CreateMaybeMessage<::zetasql::ASTGeneratedColumnInfoEnums>(Arena*);
template<> ::zetasql::ASTHavingModifierEnums* Arena::CreateMaybeMessage<::zetasql::ASTHavingModifierEnums>(Arena*);
template<> ::zetasql::ASTImportStatementEnums* Arena::CreateMaybeMessage<::zetasql::ASTImportStatementEnums>(Arena*);
template<> ::zetasql::ASTInsertStatementEnums* Arena::CreateMaybeMessage<::zetasql::ASTInsertStatementEnums>(Arena*);
template<> ::zetasql::ASTJoinEnums* Arena::CreateMaybeMessage<::zetasql::ASTJoinEnums>(Arena*);
template<> ::zetasql::ASTMergeActionEnums* Arena::CreateMaybeMessage<::zetasql::ASTMergeActionEnums>(Arena*);
template<> ::zetasql::ASTMergeWhenClauseEnums* Arena::CreateMaybeMessage<::zetasql::ASTMergeWhenClauseEnums>(Arena*);
template<> ::zetasql::ASTOrderingExpressionEnums* Arena::CreateMaybeMessage<::zetasql::ASTOrderingExpressionEnums>(Arena*);
template<> ::zetasql::ASTSampleSizeEnums* Arena::CreateMaybeMessage<::zetasql::ASTSampleSizeEnums>(Arena*);
template<> ::zetasql::ASTSelectAsEnums* Arena::CreateMaybeMessage<::zetasql::ASTSelectAsEnums>(Arena*);
template<> ::zetasql::ASTSetOperationEnums* Arena::CreateMaybeMessage<::zetasql::ASTSetOperationEnums>(Arena*);
template<> ::zetasql::ASTSpannerInterleaveClauseEnums* Arena::CreateMaybeMessage<::zetasql::ASTSpannerInterleaveClauseEnums>(Arena*);
template<> ::zetasql::ASTTemplatedParameterTypeEnums* Arena::CreateMaybeMessage<::zetasql::ASTTemplatedParameterTypeEnums>(Arena*);
template<> ::zetasql::ASTTransactionReadWriteModeEnums* Arena::CreateMaybeMessage<::zetasql::ASTTransactionReadWriteModeEnums>(Arena*);
template<> ::zetasql::ASTUnaryExpressionEnums* Arena::CreateMaybeMessage<::zetasql::ASTUnaryExpressionEnums>(Arena*);
template<> ::zetasql::ASTUnpivotClauseEnums* Arena::CreateMaybeMessage<::zetasql::ASTUnpivotClauseEnums>(Arena*);
template<> ::zetasql::ASTWindowFrameEnums* Arena::CreateMaybeMessage<::zetasql::ASTWindowFrameEnums>(Arena*);
template<> ::zetasql::ASTWindowFrameExprEnums* Arena::CreateMaybeMessage<::zetasql::ASTWindowFrameExprEnums>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zetasql {

enum ASTBinaryExpressionEnums_Op : int {
  ASTBinaryExpressionEnums_Op_NOT_SET = 0,
  ASTBinaryExpressionEnums_Op_LIKE = 1,
  ASTBinaryExpressionEnums_Op_IS = 2,
  ASTBinaryExpressionEnums_Op_EQ = 3,
  ASTBinaryExpressionEnums_Op_NE = 4,
  ASTBinaryExpressionEnums_Op_NE2 = 5,
  ASTBinaryExpressionEnums_Op_GT = 6,
  ASTBinaryExpressionEnums_Op_LT = 7,
  ASTBinaryExpressionEnums_Op_GE = 8,
  ASTBinaryExpressionEnums_Op_LE = 9,
  ASTBinaryExpressionEnums_Op_BITWISE_OR = 10,
  ASTBinaryExpressionEnums_Op_BITWISE_XOR = 11,
  ASTBinaryExpressionEnums_Op_BITWISE_AND = 12,
  ASTBinaryExpressionEnums_Op_PLUS = 13,
  ASTBinaryExpressionEnums_Op_MINUS = 14,
  ASTBinaryExpressionEnums_Op_MULTIPLY = 15,
  ASTBinaryExpressionEnums_Op_DIVIDE = 16,
  ASTBinaryExpressionEnums_Op_CONCAT_OP = 17,
  ASTBinaryExpressionEnums_Op_DISTINCT = 18
};
bool ASTBinaryExpressionEnums_Op_IsValid(int value);
constexpr ASTBinaryExpressionEnums_Op ASTBinaryExpressionEnums_Op_Op_MIN = ASTBinaryExpressionEnums_Op_NOT_SET;
constexpr ASTBinaryExpressionEnums_Op ASTBinaryExpressionEnums_Op_Op_MAX = ASTBinaryExpressionEnums_Op_DISTINCT;
constexpr int ASTBinaryExpressionEnums_Op_Op_ARRAYSIZE = ASTBinaryExpressionEnums_Op_Op_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTBinaryExpressionEnums_Op_descriptor();
template<typename T>
inline const std::string& ASTBinaryExpressionEnums_Op_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTBinaryExpressionEnums_Op>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTBinaryExpressionEnums_Op_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTBinaryExpressionEnums_Op_descriptor(), enum_t_value);
}
inline bool ASTBinaryExpressionEnums_Op_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTBinaryExpressionEnums_Op* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTBinaryExpressionEnums_Op>(
    ASTBinaryExpressionEnums_Op_descriptor(), name, value);
}
enum ASTOrderingExpressionEnums_OrderingSpec : int {
  ASTOrderingExpressionEnums_OrderingSpec_NOT_SET = 0,
  ASTOrderingExpressionEnums_OrderingSpec_ASC = 1,
  ASTOrderingExpressionEnums_OrderingSpec_DESC = 2,
  ASTOrderingExpressionEnums_OrderingSpec_UNSPECIFIED = 3
};
bool ASTOrderingExpressionEnums_OrderingSpec_IsValid(int value);
constexpr ASTOrderingExpressionEnums_OrderingSpec ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MIN = ASTOrderingExpressionEnums_OrderingSpec_NOT_SET;
constexpr ASTOrderingExpressionEnums_OrderingSpec ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MAX = ASTOrderingExpressionEnums_OrderingSpec_UNSPECIFIED;
constexpr int ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_ARRAYSIZE = ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTOrderingExpressionEnums_OrderingSpec_descriptor();
template<typename T>
inline const std::string& ASTOrderingExpressionEnums_OrderingSpec_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTOrderingExpressionEnums_OrderingSpec>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTOrderingExpressionEnums_OrderingSpec_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTOrderingExpressionEnums_OrderingSpec_descriptor(), enum_t_value);
}
inline bool ASTOrderingExpressionEnums_OrderingSpec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTOrderingExpressionEnums_OrderingSpec* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTOrderingExpressionEnums_OrderingSpec>(
    ASTOrderingExpressionEnums_OrderingSpec_descriptor(), name, value);
}
enum ASTJoinEnums_JoinType : int {
  ASTJoinEnums_JoinType_DEFAULT_JOIN_TYPE = 0,
  ASTJoinEnums_JoinType_COMMA = 1,
  ASTJoinEnums_JoinType_CROSS = 2,
  ASTJoinEnums_JoinType_FULL = 3,
  ASTJoinEnums_JoinType_INNER = 4,
  ASTJoinEnums_JoinType_LEFT = 5,
  ASTJoinEnums_JoinType_RIGHT = 6
};
bool ASTJoinEnums_JoinType_IsValid(int value);
constexpr ASTJoinEnums_JoinType ASTJoinEnums_JoinType_JoinType_MIN = ASTJoinEnums_JoinType_DEFAULT_JOIN_TYPE;
constexpr ASTJoinEnums_JoinType ASTJoinEnums_JoinType_JoinType_MAX = ASTJoinEnums_JoinType_RIGHT;
constexpr int ASTJoinEnums_JoinType_JoinType_ARRAYSIZE = ASTJoinEnums_JoinType_JoinType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTJoinEnums_JoinType_descriptor();
template<typename T>
inline const std::string& ASTJoinEnums_JoinType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTJoinEnums_JoinType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTJoinEnums_JoinType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTJoinEnums_JoinType_descriptor(), enum_t_value);
}
inline bool ASTJoinEnums_JoinType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTJoinEnums_JoinType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTJoinEnums_JoinType>(
    ASTJoinEnums_JoinType_descriptor(), name, value);
}
enum ASTJoinEnums_JoinHint : int {
  ASTJoinEnums_JoinHint_NO_JOIN_HINT = 0,
  ASTJoinEnums_JoinHint_HASH = 1,
  ASTJoinEnums_JoinHint_LOOKUP = 2
};
bool ASTJoinEnums_JoinHint_IsValid(int value);
constexpr ASTJoinEnums_JoinHint ASTJoinEnums_JoinHint_JoinHint_MIN = ASTJoinEnums_JoinHint_NO_JOIN_HINT;
constexpr ASTJoinEnums_JoinHint ASTJoinEnums_JoinHint_JoinHint_MAX = ASTJoinEnums_JoinHint_LOOKUP;
constexpr int ASTJoinEnums_JoinHint_JoinHint_ARRAYSIZE = ASTJoinEnums_JoinHint_JoinHint_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTJoinEnums_JoinHint_descriptor();
template<typename T>
inline const std::string& ASTJoinEnums_JoinHint_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTJoinEnums_JoinHint>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTJoinEnums_JoinHint_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTJoinEnums_JoinHint_descriptor(), enum_t_value);
}
inline bool ASTJoinEnums_JoinHint_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTJoinEnums_JoinHint* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTJoinEnums_JoinHint>(
    ASTJoinEnums_JoinHint_descriptor(), name, value);
}
enum ASTSelectAsEnums_AsMode : int {
  ASTSelectAsEnums_AsMode_NOT_SET = 0,
  ASTSelectAsEnums_AsMode_STRUCT = 1,
  ASTSelectAsEnums_AsMode_VALUE = 2,
  ASTSelectAsEnums_AsMode_TYPE_NAME = 3
};
bool ASTSelectAsEnums_AsMode_IsValid(int value);
constexpr ASTSelectAsEnums_AsMode ASTSelectAsEnums_AsMode_AsMode_MIN = ASTSelectAsEnums_AsMode_NOT_SET;
constexpr ASTSelectAsEnums_AsMode ASTSelectAsEnums_AsMode_AsMode_MAX = ASTSelectAsEnums_AsMode_TYPE_NAME;
constexpr int ASTSelectAsEnums_AsMode_AsMode_ARRAYSIZE = ASTSelectAsEnums_AsMode_AsMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTSelectAsEnums_AsMode_descriptor();
template<typename T>
inline const std::string& ASTSelectAsEnums_AsMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTSelectAsEnums_AsMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTSelectAsEnums_AsMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTSelectAsEnums_AsMode_descriptor(), enum_t_value);
}
inline bool ASTSelectAsEnums_AsMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTSelectAsEnums_AsMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTSelectAsEnums_AsMode>(
    ASTSelectAsEnums_AsMode_descriptor(), name, value);
}
enum ASTFunctionCallEnums_NullHandlingModifier : int {
  ASTFunctionCallEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING = 0,
  ASTFunctionCallEnums_NullHandlingModifier_IGNORE_NULLS = 1,
  ASTFunctionCallEnums_NullHandlingModifier_RESPECT_NULLS = 2
};
bool ASTFunctionCallEnums_NullHandlingModifier_IsValid(int value);
constexpr ASTFunctionCallEnums_NullHandlingModifier ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MIN = ASTFunctionCallEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING;
constexpr ASTFunctionCallEnums_NullHandlingModifier ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MAX = ASTFunctionCallEnums_NullHandlingModifier_RESPECT_NULLS;
constexpr int ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_ARRAYSIZE = ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTFunctionCallEnums_NullHandlingModifier_descriptor();
template<typename T>
inline const std::string& ASTFunctionCallEnums_NullHandlingModifier_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTFunctionCallEnums_NullHandlingModifier>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTFunctionCallEnums_NullHandlingModifier_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTFunctionCallEnums_NullHandlingModifier_descriptor(), enum_t_value);
}
inline bool ASTFunctionCallEnums_NullHandlingModifier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTFunctionCallEnums_NullHandlingModifier* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTFunctionCallEnums_NullHandlingModifier>(
    ASTFunctionCallEnums_NullHandlingModifier_descriptor(), name, value);
}
enum ASTExpressionSubqueryEnums_Modifier : int {
  ASTExpressionSubqueryEnums_Modifier_NONE = 0,
  ASTExpressionSubqueryEnums_Modifier_ARRAY = 1,
  ASTExpressionSubqueryEnums_Modifier_EXISTS = 2
};
bool ASTExpressionSubqueryEnums_Modifier_IsValid(int value);
constexpr ASTExpressionSubqueryEnums_Modifier ASTExpressionSubqueryEnums_Modifier_Modifier_MIN = ASTExpressionSubqueryEnums_Modifier_NONE;
constexpr ASTExpressionSubqueryEnums_Modifier ASTExpressionSubqueryEnums_Modifier_Modifier_MAX = ASTExpressionSubqueryEnums_Modifier_EXISTS;
constexpr int ASTExpressionSubqueryEnums_Modifier_Modifier_ARRAYSIZE = ASTExpressionSubqueryEnums_Modifier_Modifier_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTExpressionSubqueryEnums_Modifier_descriptor();
template<typename T>
inline const std::string& ASTExpressionSubqueryEnums_Modifier_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTExpressionSubqueryEnums_Modifier>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTExpressionSubqueryEnums_Modifier_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTExpressionSubqueryEnums_Modifier_descriptor(), enum_t_value);
}
inline bool ASTExpressionSubqueryEnums_Modifier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTExpressionSubqueryEnums_Modifier* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTExpressionSubqueryEnums_Modifier>(
    ASTExpressionSubqueryEnums_Modifier_descriptor(), name, value);
}
enum ASTHavingModifierEnums_ModifierKind : int {
  ASTHavingModifierEnums_ModifierKind_NOT_SET = 0,
  ASTHavingModifierEnums_ModifierKind_MIN = 1,
  ASTHavingModifierEnums_ModifierKind_MAX = 2
};
bool ASTHavingModifierEnums_ModifierKind_IsValid(int value);
constexpr ASTHavingModifierEnums_ModifierKind ASTHavingModifierEnums_ModifierKind_ModifierKind_MIN = ASTHavingModifierEnums_ModifierKind_NOT_SET;
constexpr ASTHavingModifierEnums_ModifierKind ASTHavingModifierEnums_ModifierKind_ModifierKind_MAX = ASTHavingModifierEnums_ModifierKind_MAX;
constexpr int ASTHavingModifierEnums_ModifierKind_ModifierKind_ARRAYSIZE = ASTHavingModifierEnums_ModifierKind_ModifierKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTHavingModifierEnums_ModifierKind_descriptor();
template<typename T>
inline const std::string& ASTHavingModifierEnums_ModifierKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTHavingModifierEnums_ModifierKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTHavingModifierEnums_ModifierKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTHavingModifierEnums_ModifierKind_descriptor(), enum_t_value);
}
inline bool ASTHavingModifierEnums_ModifierKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTHavingModifierEnums_ModifierKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTHavingModifierEnums_ModifierKind>(
    ASTHavingModifierEnums_ModifierKind_descriptor(), name, value);
}
enum ASTSetOperationEnums_OperationType : int {
  ASTSetOperationEnums_OperationType_NOT_SET = 0,
  ASTSetOperationEnums_OperationType_UNION = 1,
  ASTSetOperationEnums_OperationType_EXCEPT = 2,
  ASTSetOperationEnums_OperationType_INTERSECT = 4
};
bool ASTSetOperationEnums_OperationType_IsValid(int value);
constexpr ASTSetOperationEnums_OperationType ASTSetOperationEnums_OperationType_OperationType_MIN = ASTSetOperationEnums_OperationType_NOT_SET;
constexpr ASTSetOperationEnums_OperationType ASTSetOperationEnums_OperationType_OperationType_MAX = ASTSetOperationEnums_OperationType_INTERSECT;
constexpr int ASTSetOperationEnums_OperationType_OperationType_ARRAYSIZE = ASTSetOperationEnums_OperationType_OperationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTSetOperationEnums_OperationType_descriptor();
template<typename T>
inline const std::string& ASTSetOperationEnums_OperationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTSetOperationEnums_OperationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTSetOperationEnums_OperationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTSetOperationEnums_OperationType_descriptor(), enum_t_value);
}
inline bool ASTSetOperationEnums_OperationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTSetOperationEnums_OperationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTSetOperationEnums_OperationType>(
    ASTSetOperationEnums_OperationType_descriptor(), name, value);
}
enum ASTUnaryExpressionEnums_Op : int {
  ASTUnaryExpressionEnums_Op_NOT_SET = 0,
  ASTUnaryExpressionEnums_Op_NOT = 1,
  ASTUnaryExpressionEnums_Op_BITWISE_NOT = 2,
  ASTUnaryExpressionEnums_Op_MINUS = 3,
  ASTUnaryExpressionEnums_Op_PLUS = 4,
  ASTUnaryExpressionEnums_Op_IS_UNKNOWN = 5,
  ASTUnaryExpressionEnums_Op_IS_NOT_UNKNOWN = 6
};
bool ASTUnaryExpressionEnums_Op_IsValid(int value);
constexpr ASTUnaryExpressionEnums_Op ASTUnaryExpressionEnums_Op_Op_MIN = ASTUnaryExpressionEnums_Op_NOT_SET;
constexpr ASTUnaryExpressionEnums_Op ASTUnaryExpressionEnums_Op_Op_MAX = ASTUnaryExpressionEnums_Op_IS_NOT_UNKNOWN;
constexpr int ASTUnaryExpressionEnums_Op_Op_ARRAYSIZE = ASTUnaryExpressionEnums_Op_Op_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTUnaryExpressionEnums_Op_descriptor();
template<typename T>
inline const std::string& ASTUnaryExpressionEnums_Op_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTUnaryExpressionEnums_Op>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTUnaryExpressionEnums_Op_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTUnaryExpressionEnums_Op_descriptor(), enum_t_value);
}
inline bool ASTUnaryExpressionEnums_Op_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTUnaryExpressionEnums_Op* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTUnaryExpressionEnums_Op>(
    ASTUnaryExpressionEnums_Op_descriptor(), name, value);
}
enum ASTWindowFrameEnums_FrameUnit : int {
  ASTWindowFrameEnums_FrameUnit_ROWS = 1,
  ASTWindowFrameEnums_FrameUnit_RANGE = 2
};
bool ASTWindowFrameEnums_FrameUnit_IsValid(int value);
constexpr ASTWindowFrameEnums_FrameUnit ASTWindowFrameEnums_FrameUnit_FrameUnit_MIN = ASTWindowFrameEnums_FrameUnit_ROWS;
constexpr ASTWindowFrameEnums_FrameUnit ASTWindowFrameEnums_FrameUnit_FrameUnit_MAX = ASTWindowFrameEnums_FrameUnit_RANGE;
constexpr int ASTWindowFrameEnums_FrameUnit_FrameUnit_ARRAYSIZE = ASTWindowFrameEnums_FrameUnit_FrameUnit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTWindowFrameEnums_FrameUnit_descriptor();
template<typename T>
inline const std::string& ASTWindowFrameEnums_FrameUnit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTWindowFrameEnums_FrameUnit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTWindowFrameEnums_FrameUnit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTWindowFrameEnums_FrameUnit_descriptor(), enum_t_value);
}
inline bool ASTWindowFrameEnums_FrameUnit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTWindowFrameEnums_FrameUnit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTWindowFrameEnums_FrameUnit>(
    ASTWindowFrameEnums_FrameUnit_descriptor(), name, value);
}
enum ASTWindowFrameExprEnums_BoundaryType : int {
  ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING = 1,
  ASTWindowFrameExprEnums_BoundaryType_OFFSET_PRECEDING = 2,
  ASTWindowFrameExprEnums_BoundaryType_CURRENT_ROW = 3,
  ASTWindowFrameExprEnums_BoundaryType_OFFSET_FOLLOWING = 4,
  ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING = 5
};
bool ASTWindowFrameExprEnums_BoundaryType_IsValid(int value);
constexpr ASTWindowFrameExprEnums_BoundaryType ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MIN = ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING;
constexpr ASTWindowFrameExprEnums_BoundaryType ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MAX = ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING;
constexpr int ASTWindowFrameExprEnums_BoundaryType_BoundaryType_ARRAYSIZE = ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTWindowFrameExprEnums_BoundaryType_descriptor();
template<typename T>
inline const std::string& ASTWindowFrameExprEnums_BoundaryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTWindowFrameExprEnums_BoundaryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTWindowFrameExprEnums_BoundaryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTWindowFrameExprEnums_BoundaryType_descriptor(), enum_t_value);
}
inline bool ASTWindowFrameExprEnums_BoundaryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTWindowFrameExprEnums_BoundaryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTWindowFrameExprEnums_BoundaryType>(
    ASTWindowFrameExprEnums_BoundaryType_descriptor(), name, value);
}
enum ASTAnySomeAllOpEnums_Op : int {
  ASTAnySomeAllOpEnums_Op_kUninitialized = 1,
  ASTAnySomeAllOpEnums_Op_kAny = 2,
  ASTAnySomeAllOpEnums_Op_kSome = 3,
  ASTAnySomeAllOpEnums_Op_kAll = 4
};
bool ASTAnySomeAllOpEnums_Op_IsValid(int value);
constexpr ASTAnySomeAllOpEnums_Op ASTAnySomeAllOpEnums_Op_Op_MIN = ASTAnySomeAllOpEnums_Op_kUninitialized;
constexpr ASTAnySomeAllOpEnums_Op ASTAnySomeAllOpEnums_Op_Op_MAX = ASTAnySomeAllOpEnums_Op_kAll;
constexpr int ASTAnySomeAllOpEnums_Op_Op_ARRAYSIZE = ASTAnySomeAllOpEnums_Op_Op_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTAnySomeAllOpEnums_Op_descriptor();
template<typename T>
inline const std::string& ASTAnySomeAllOpEnums_Op_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTAnySomeAllOpEnums_Op>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTAnySomeAllOpEnums_Op_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTAnySomeAllOpEnums_Op_descriptor(), enum_t_value);
}
inline bool ASTAnySomeAllOpEnums_Op_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTAnySomeAllOpEnums_Op* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTAnySomeAllOpEnums_Op>(
    ASTAnySomeAllOpEnums_Op_descriptor(), name, value);
}
enum ASTTransactionReadWriteModeEnums_Mode : int {
  ASTTransactionReadWriteModeEnums_Mode_INVALID = 0,
  ASTTransactionReadWriteModeEnums_Mode_READ_ONLY = 1,
  ASTTransactionReadWriteModeEnums_Mode_READ_WRITE = 2
};
bool ASTTransactionReadWriteModeEnums_Mode_IsValid(int value);
constexpr ASTTransactionReadWriteModeEnums_Mode ASTTransactionReadWriteModeEnums_Mode_Mode_MIN = ASTTransactionReadWriteModeEnums_Mode_INVALID;
constexpr ASTTransactionReadWriteModeEnums_Mode ASTTransactionReadWriteModeEnums_Mode_Mode_MAX = ASTTransactionReadWriteModeEnums_Mode_READ_WRITE;
constexpr int ASTTransactionReadWriteModeEnums_Mode_Mode_ARRAYSIZE = ASTTransactionReadWriteModeEnums_Mode_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTTransactionReadWriteModeEnums_Mode_descriptor();
template<typename T>
inline const std::string& ASTTransactionReadWriteModeEnums_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTTransactionReadWriteModeEnums_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTTransactionReadWriteModeEnums_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTTransactionReadWriteModeEnums_Mode_descriptor(), enum_t_value);
}
inline bool ASTTransactionReadWriteModeEnums_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTTransactionReadWriteModeEnums_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTTransactionReadWriteModeEnums_Mode>(
    ASTTransactionReadWriteModeEnums_Mode_descriptor(), name, value);
}
enum ASTImportStatementEnums_ImportKind : int {
  ASTImportStatementEnums_ImportKind_MODULE = 1,
  ASTImportStatementEnums_ImportKind_PROTO = 2
};
bool ASTImportStatementEnums_ImportKind_IsValid(int value);
constexpr ASTImportStatementEnums_ImportKind ASTImportStatementEnums_ImportKind_ImportKind_MIN = ASTImportStatementEnums_ImportKind_MODULE;
constexpr ASTImportStatementEnums_ImportKind ASTImportStatementEnums_ImportKind_ImportKind_MAX = ASTImportStatementEnums_ImportKind_PROTO;
constexpr int ASTImportStatementEnums_ImportKind_ImportKind_ARRAYSIZE = ASTImportStatementEnums_ImportKind_ImportKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTImportStatementEnums_ImportKind_descriptor();
template<typename T>
inline const std::string& ASTImportStatementEnums_ImportKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTImportStatementEnums_ImportKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTImportStatementEnums_ImportKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTImportStatementEnums_ImportKind_descriptor(), enum_t_value);
}
inline bool ASTImportStatementEnums_ImportKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTImportStatementEnums_ImportKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTImportStatementEnums_ImportKind>(
    ASTImportStatementEnums_ImportKind_descriptor(), name, value);
}
enum ASTUnpivotClauseEnums_NullFilter : int {
  ASTUnpivotClauseEnums_NullFilter_kUnspecified = 1,
  ASTUnpivotClauseEnums_NullFilter_kInclude = 2,
  ASTUnpivotClauseEnums_NullFilter_kExclude = 3
};
bool ASTUnpivotClauseEnums_NullFilter_IsValid(int value);
constexpr ASTUnpivotClauseEnums_NullFilter ASTUnpivotClauseEnums_NullFilter_NullFilter_MIN = ASTUnpivotClauseEnums_NullFilter_kUnspecified;
constexpr ASTUnpivotClauseEnums_NullFilter ASTUnpivotClauseEnums_NullFilter_NullFilter_MAX = ASTUnpivotClauseEnums_NullFilter_kExclude;
constexpr int ASTUnpivotClauseEnums_NullFilter_NullFilter_ARRAYSIZE = ASTUnpivotClauseEnums_NullFilter_NullFilter_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTUnpivotClauseEnums_NullFilter_descriptor();
template<typename T>
inline const std::string& ASTUnpivotClauseEnums_NullFilter_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTUnpivotClauseEnums_NullFilter>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTUnpivotClauseEnums_NullFilter_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTUnpivotClauseEnums_NullFilter_descriptor(), enum_t_value);
}
inline bool ASTUnpivotClauseEnums_NullFilter_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTUnpivotClauseEnums_NullFilter* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTUnpivotClauseEnums_NullFilter>(
    ASTUnpivotClauseEnums_NullFilter_descriptor(), name, value);
}
enum ASTCreateStatementEnums_Scope : int {
  ASTCreateStatementEnums_Scope_DEFAULT_SCOPE = 0,
  ASTCreateStatementEnums_Scope_PRIVATE = 1,
  ASTCreateStatementEnums_Scope_PUBLIC = 2,
  ASTCreateStatementEnums_Scope_TEMPORARY = 3
};
bool ASTCreateStatementEnums_Scope_IsValid(int value);
constexpr ASTCreateStatementEnums_Scope ASTCreateStatementEnums_Scope_Scope_MIN = ASTCreateStatementEnums_Scope_DEFAULT_SCOPE;
constexpr ASTCreateStatementEnums_Scope ASTCreateStatementEnums_Scope_Scope_MAX = ASTCreateStatementEnums_Scope_TEMPORARY;
constexpr int ASTCreateStatementEnums_Scope_Scope_ARRAYSIZE = ASTCreateStatementEnums_Scope_Scope_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTCreateStatementEnums_Scope_descriptor();
template<typename T>
inline const std::string& ASTCreateStatementEnums_Scope_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTCreateStatementEnums_Scope>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTCreateStatementEnums_Scope_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTCreateStatementEnums_Scope_descriptor(), enum_t_value);
}
inline bool ASTCreateStatementEnums_Scope_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTCreateStatementEnums_Scope* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTCreateStatementEnums_Scope>(
    ASTCreateStatementEnums_Scope_descriptor(), name, value);
}
enum ASTCreateStatementEnums_SqlSecurity : int {
  ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED = 0,
  ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_DEFINER = 1,
  ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER = 2
};
bool ASTCreateStatementEnums_SqlSecurity_IsValid(int value);
constexpr ASTCreateStatementEnums_SqlSecurity ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MIN = ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED;
constexpr ASTCreateStatementEnums_SqlSecurity ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MAX = ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER;
constexpr int ASTCreateStatementEnums_SqlSecurity_SqlSecurity_ARRAYSIZE = ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTCreateStatementEnums_SqlSecurity_descriptor();
template<typename T>
inline const std::string& ASTCreateStatementEnums_SqlSecurity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTCreateStatementEnums_SqlSecurity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTCreateStatementEnums_SqlSecurity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTCreateStatementEnums_SqlSecurity_descriptor(), enum_t_value);
}
inline bool ASTCreateStatementEnums_SqlSecurity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTCreateStatementEnums_SqlSecurity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTCreateStatementEnums_SqlSecurity>(
    ASTCreateStatementEnums_SqlSecurity_descriptor(), name, value);
}
enum ASTFunctionParameterEnums_ProcedureParameterMode : int {
  ASTFunctionParameterEnums_ProcedureParameterMode_NOT_SET = 0,
  ASTFunctionParameterEnums_ProcedureParameterMode_IN = 1,
  ASTFunctionParameterEnums_ProcedureParameterMode_OUT = 2,
  ASTFunctionParameterEnums_ProcedureParameterMode_INOUT = 3
};
bool ASTFunctionParameterEnums_ProcedureParameterMode_IsValid(int value);
constexpr ASTFunctionParameterEnums_ProcedureParameterMode ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MIN = ASTFunctionParameterEnums_ProcedureParameterMode_NOT_SET;
constexpr ASTFunctionParameterEnums_ProcedureParameterMode ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MAX = ASTFunctionParameterEnums_ProcedureParameterMode_INOUT;
constexpr int ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_ARRAYSIZE = ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTFunctionParameterEnums_ProcedureParameterMode_descriptor();
template<typename T>
inline const std::string& ASTFunctionParameterEnums_ProcedureParameterMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTFunctionParameterEnums_ProcedureParameterMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTFunctionParameterEnums_ProcedureParameterMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTFunctionParameterEnums_ProcedureParameterMode_descriptor(), enum_t_value);
}
inline bool ASTFunctionParameterEnums_ProcedureParameterMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTFunctionParameterEnums_ProcedureParameterMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTFunctionParameterEnums_ProcedureParameterMode>(
    ASTFunctionParameterEnums_ProcedureParameterMode_descriptor(), name, value);
}
enum ASTTemplatedParameterTypeEnums_TemplatedTypeKind : int {
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_UNINITIALIZED = 1,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TYPE = 2,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_PROTO = 3,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_ENUM = 4,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_STRUCT = 5,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_ARRAY = 6,
  ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TABLE = 7
};
bool ASTTemplatedParameterTypeEnums_TemplatedTypeKind_IsValid(int value);
constexpr ASTTemplatedParameterTypeEnums_TemplatedTypeKind ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MIN = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_UNINITIALIZED;
constexpr ASTTemplatedParameterTypeEnums_TemplatedTypeKind ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MAX = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TABLE;
constexpr int ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_ARRAYSIZE = ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor();
template<typename T>
inline const std::string& ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTTemplatedParameterTypeEnums_TemplatedTypeKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor(), enum_t_value);
}
inline bool ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTTemplatedParameterTypeEnums_TemplatedTypeKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTTemplatedParameterTypeEnums_TemplatedTypeKind>(
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor(), name, value);
}
enum ASTGeneratedColumnInfoEnums_StoredMode : int {
  ASTGeneratedColumnInfoEnums_StoredMode_NON_STORED = 0,
  ASTGeneratedColumnInfoEnums_StoredMode_STORED = 1,
  ASTGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE = 2
};
bool ASTGeneratedColumnInfoEnums_StoredMode_IsValid(int value);
constexpr ASTGeneratedColumnInfoEnums_StoredMode ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MIN = ASTGeneratedColumnInfoEnums_StoredMode_NON_STORED;
constexpr ASTGeneratedColumnInfoEnums_StoredMode ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX = ASTGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE;
constexpr int ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_ARRAYSIZE = ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTGeneratedColumnInfoEnums_StoredMode_descriptor();
template<typename T>
inline const std::string& ASTGeneratedColumnInfoEnums_StoredMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTGeneratedColumnInfoEnums_StoredMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTGeneratedColumnInfoEnums_StoredMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTGeneratedColumnInfoEnums_StoredMode_descriptor(), enum_t_value);
}
inline bool ASTGeneratedColumnInfoEnums_StoredMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTGeneratedColumnInfoEnums_StoredMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTGeneratedColumnInfoEnums_StoredMode>(
    ASTGeneratedColumnInfoEnums_StoredMode_descriptor(), name, value);
}
enum ASTColumnPositionEnums_RelativePositionType : int {
  ASTColumnPositionEnums_RelativePositionType_PRECEDING = 1,
  ASTColumnPositionEnums_RelativePositionType_FOLLOWING = 2
};
bool ASTColumnPositionEnums_RelativePositionType_IsValid(int value);
constexpr ASTColumnPositionEnums_RelativePositionType ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MIN = ASTColumnPositionEnums_RelativePositionType_PRECEDING;
constexpr ASTColumnPositionEnums_RelativePositionType ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MAX = ASTColumnPositionEnums_RelativePositionType_FOLLOWING;
constexpr int ASTColumnPositionEnums_RelativePositionType_RelativePositionType_ARRAYSIZE = ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTColumnPositionEnums_RelativePositionType_descriptor();
template<typename T>
inline const std::string& ASTColumnPositionEnums_RelativePositionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTColumnPositionEnums_RelativePositionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTColumnPositionEnums_RelativePositionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTColumnPositionEnums_RelativePositionType_descriptor(), enum_t_value);
}
inline bool ASTColumnPositionEnums_RelativePositionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTColumnPositionEnums_RelativePositionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTColumnPositionEnums_RelativePositionType>(
    ASTColumnPositionEnums_RelativePositionType_descriptor(), name, value);
}
enum ASTInsertStatementEnums_InsertMode : int {
  ASTInsertStatementEnums_InsertMode_DEFAULT_MODE = 0,
  ASTInsertStatementEnums_InsertMode_REPLACE = 1,
  ASTInsertStatementEnums_InsertMode_UPDATE = 2,
  ASTInsertStatementEnums_InsertMode_IGNORE = 3
};
bool ASTInsertStatementEnums_InsertMode_IsValid(int value);
constexpr ASTInsertStatementEnums_InsertMode ASTInsertStatementEnums_InsertMode_InsertMode_MIN = ASTInsertStatementEnums_InsertMode_DEFAULT_MODE;
constexpr ASTInsertStatementEnums_InsertMode ASTInsertStatementEnums_InsertMode_InsertMode_MAX = ASTInsertStatementEnums_InsertMode_IGNORE;
constexpr int ASTInsertStatementEnums_InsertMode_InsertMode_ARRAYSIZE = ASTInsertStatementEnums_InsertMode_InsertMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTInsertStatementEnums_InsertMode_descriptor();
template<typename T>
inline const std::string& ASTInsertStatementEnums_InsertMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTInsertStatementEnums_InsertMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTInsertStatementEnums_InsertMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTInsertStatementEnums_InsertMode_descriptor(), enum_t_value);
}
inline bool ASTInsertStatementEnums_InsertMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTInsertStatementEnums_InsertMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTInsertStatementEnums_InsertMode>(
    ASTInsertStatementEnums_InsertMode_descriptor(), name, value);
}
enum ASTInsertStatementEnums_ParseProgress : int {
  ASTInsertStatementEnums_ParseProgress_kInitial = 1,
  ASTInsertStatementEnums_ParseProgress_kSeenOrIgnoreReplaceUpdate = 2,
  ASTInsertStatementEnums_ParseProgress_kSeenTargetPath = 3,
  ASTInsertStatementEnums_ParseProgress_kSeenColumnList = 4,
  ASTInsertStatementEnums_ParseProgress_kSeenValuesList = 5
};
bool ASTInsertStatementEnums_ParseProgress_IsValid(int value);
constexpr ASTInsertStatementEnums_ParseProgress ASTInsertStatementEnums_ParseProgress_ParseProgress_MIN = ASTInsertStatementEnums_ParseProgress_kInitial;
constexpr ASTInsertStatementEnums_ParseProgress ASTInsertStatementEnums_ParseProgress_ParseProgress_MAX = ASTInsertStatementEnums_ParseProgress_kSeenValuesList;
constexpr int ASTInsertStatementEnums_ParseProgress_ParseProgress_ARRAYSIZE = ASTInsertStatementEnums_ParseProgress_ParseProgress_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTInsertStatementEnums_ParseProgress_descriptor();
template<typename T>
inline const std::string& ASTInsertStatementEnums_ParseProgress_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTInsertStatementEnums_ParseProgress>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTInsertStatementEnums_ParseProgress_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTInsertStatementEnums_ParseProgress_descriptor(), enum_t_value);
}
inline bool ASTInsertStatementEnums_ParseProgress_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTInsertStatementEnums_ParseProgress* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTInsertStatementEnums_ParseProgress>(
    ASTInsertStatementEnums_ParseProgress_descriptor(), name, value);
}
enum ASTMergeActionEnums_ActionType : int {
  ASTMergeActionEnums_ActionType_NOT_SET = 0,
  ASTMergeActionEnums_ActionType_INSERT = 1,
  ASTMergeActionEnums_ActionType_UPDATE = 2,
  ASTMergeActionEnums_ActionType_DELETE = 3
};
bool ASTMergeActionEnums_ActionType_IsValid(int value);
constexpr ASTMergeActionEnums_ActionType ASTMergeActionEnums_ActionType_ActionType_MIN = ASTMergeActionEnums_ActionType_NOT_SET;
constexpr ASTMergeActionEnums_ActionType ASTMergeActionEnums_ActionType_ActionType_MAX = ASTMergeActionEnums_ActionType_DELETE;
constexpr int ASTMergeActionEnums_ActionType_ActionType_ARRAYSIZE = ASTMergeActionEnums_ActionType_ActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTMergeActionEnums_ActionType_descriptor();
template<typename T>
inline const std::string& ASTMergeActionEnums_ActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTMergeActionEnums_ActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTMergeActionEnums_ActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTMergeActionEnums_ActionType_descriptor(), enum_t_value);
}
inline bool ASTMergeActionEnums_ActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTMergeActionEnums_ActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTMergeActionEnums_ActionType>(
    ASTMergeActionEnums_ActionType_descriptor(), name, value);
}
enum ASTMergeWhenClauseEnums_MatchType : int {
  ASTMergeWhenClauseEnums_MatchType_NOT_SET = 0,
  ASTMergeWhenClauseEnums_MatchType_MATCHED = 1,
  ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_SOURCE = 2,
  ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_TARGET = 3
};
bool ASTMergeWhenClauseEnums_MatchType_IsValid(int value);
constexpr ASTMergeWhenClauseEnums_MatchType ASTMergeWhenClauseEnums_MatchType_MatchType_MIN = ASTMergeWhenClauseEnums_MatchType_NOT_SET;
constexpr ASTMergeWhenClauseEnums_MatchType ASTMergeWhenClauseEnums_MatchType_MatchType_MAX = ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_TARGET;
constexpr int ASTMergeWhenClauseEnums_MatchType_MatchType_ARRAYSIZE = ASTMergeWhenClauseEnums_MatchType_MatchType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTMergeWhenClauseEnums_MatchType_descriptor();
template<typename T>
inline const std::string& ASTMergeWhenClauseEnums_MatchType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTMergeWhenClauseEnums_MatchType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTMergeWhenClauseEnums_MatchType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTMergeWhenClauseEnums_MatchType_descriptor(), enum_t_value);
}
inline bool ASTMergeWhenClauseEnums_MatchType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTMergeWhenClauseEnums_MatchType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTMergeWhenClauseEnums_MatchType>(
    ASTMergeWhenClauseEnums_MatchType_descriptor(), name, value);
}
enum ASTFilterFieldsArgEnums_FilterType : int {
  ASTFilterFieldsArgEnums_FilterType_NOT_SET = 0,
  ASTFilterFieldsArgEnums_FilterType_INCLUDE = 1,
  ASTFilterFieldsArgEnums_FilterType_EXCLUDE = 2
};
bool ASTFilterFieldsArgEnums_FilterType_IsValid(int value);
constexpr ASTFilterFieldsArgEnums_FilterType ASTFilterFieldsArgEnums_FilterType_FilterType_MIN = ASTFilterFieldsArgEnums_FilterType_NOT_SET;
constexpr ASTFilterFieldsArgEnums_FilterType ASTFilterFieldsArgEnums_FilterType_FilterType_MAX = ASTFilterFieldsArgEnums_FilterType_EXCLUDE;
constexpr int ASTFilterFieldsArgEnums_FilterType_FilterType_ARRAYSIZE = ASTFilterFieldsArgEnums_FilterType_FilterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTFilterFieldsArgEnums_FilterType_descriptor();
template<typename T>
inline const std::string& ASTFilterFieldsArgEnums_FilterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTFilterFieldsArgEnums_FilterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTFilterFieldsArgEnums_FilterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTFilterFieldsArgEnums_FilterType_descriptor(), enum_t_value);
}
inline bool ASTFilterFieldsArgEnums_FilterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTFilterFieldsArgEnums_FilterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTFilterFieldsArgEnums_FilterType>(
    ASTFilterFieldsArgEnums_FilterType_descriptor(), name, value);
}
enum ASTSampleSizeEnums_Unit : int {
  ASTSampleSizeEnums_Unit_NOT_SET = 0,
  ASTSampleSizeEnums_Unit_ROWS = 1,
  ASTSampleSizeEnums_Unit_PERCENT = 2
};
bool ASTSampleSizeEnums_Unit_IsValid(int value);
constexpr ASTSampleSizeEnums_Unit ASTSampleSizeEnums_Unit_Unit_MIN = ASTSampleSizeEnums_Unit_NOT_SET;
constexpr ASTSampleSizeEnums_Unit ASTSampleSizeEnums_Unit_Unit_MAX = ASTSampleSizeEnums_Unit_PERCENT;
constexpr int ASTSampleSizeEnums_Unit_Unit_ARRAYSIZE = ASTSampleSizeEnums_Unit_Unit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTSampleSizeEnums_Unit_descriptor();
template<typename T>
inline const std::string& ASTSampleSizeEnums_Unit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTSampleSizeEnums_Unit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTSampleSizeEnums_Unit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTSampleSizeEnums_Unit_descriptor(), enum_t_value);
}
inline bool ASTSampleSizeEnums_Unit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTSampleSizeEnums_Unit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTSampleSizeEnums_Unit>(
    ASTSampleSizeEnums_Unit_descriptor(), name, value);
}
enum ASTForeignKeyActionsEnums_Action : int {
  ASTForeignKeyActionsEnums_Action_NO_ACTION = 0,
  ASTForeignKeyActionsEnums_Action_RESTRICT = 1,
  ASTForeignKeyActionsEnums_Action_CASCADE = 2,
  ASTForeignKeyActionsEnums_Action_SET_NULL = 3
};
bool ASTForeignKeyActionsEnums_Action_IsValid(int value);
constexpr ASTForeignKeyActionsEnums_Action ASTForeignKeyActionsEnums_Action_Action_MIN = ASTForeignKeyActionsEnums_Action_NO_ACTION;
constexpr ASTForeignKeyActionsEnums_Action ASTForeignKeyActionsEnums_Action_Action_MAX = ASTForeignKeyActionsEnums_Action_SET_NULL;
constexpr int ASTForeignKeyActionsEnums_Action_Action_ARRAYSIZE = ASTForeignKeyActionsEnums_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTForeignKeyActionsEnums_Action_descriptor();
template<typename T>
inline const std::string& ASTForeignKeyActionsEnums_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTForeignKeyActionsEnums_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTForeignKeyActionsEnums_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTForeignKeyActionsEnums_Action_descriptor(), enum_t_value);
}
inline bool ASTForeignKeyActionsEnums_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTForeignKeyActionsEnums_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTForeignKeyActionsEnums_Action>(
    ASTForeignKeyActionsEnums_Action_descriptor(), name, value);
}
enum ASTForeignKeyReferenceEnums_Match : int {
  ASTForeignKeyReferenceEnums_Match_SIMPLE = 1,
  ASTForeignKeyReferenceEnums_Match_FULL = 2,
  ASTForeignKeyReferenceEnums_Match_NOT_DISTINCT = 3
};
bool ASTForeignKeyReferenceEnums_Match_IsValid(int value);
constexpr ASTForeignKeyReferenceEnums_Match ASTForeignKeyReferenceEnums_Match_Match_MIN = ASTForeignKeyReferenceEnums_Match_SIMPLE;
constexpr ASTForeignKeyReferenceEnums_Match ASTForeignKeyReferenceEnums_Match_Match_MAX = ASTForeignKeyReferenceEnums_Match_NOT_DISTINCT;
constexpr int ASTForeignKeyReferenceEnums_Match_Match_ARRAYSIZE = ASTForeignKeyReferenceEnums_Match_Match_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTForeignKeyReferenceEnums_Match_descriptor();
template<typename T>
inline const std::string& ASTForeignKeyReferenceEnums_Match_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTForeignKeyReferenceEnums_Match>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTForeignKeyReferenceEnums_Match_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTForeignKeyReferenceEnums_Match_descriptor(), enum_t_value);
}
inline bool ASTForeignKeyReferenceEnums_Match_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTForeignKeyReferenceEnums_Match* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTForeignKeyReferenceEnums_Match>(
    ASTForeignKeyReferenceEnums_Match_descriptor(), name, value);
}
enum ASTBreakContinueStatementEnums_BreakContinueKeyword : int {
  ASTBreakContinueStatementEnums_BreakContinueKeyword_BREAK = 1,
  ASTBreakContinueStatementEnums_BreakContinueKeyword_LEAVE = 2,
  ASTBreakContinueStatementEnums_BreakContinueKeyword_CONTINUE = 3,
  ASTBreakContinueStatementEnums_BreakContinueKeyword_ITERATE = 4
};
bool ASTBreakContinueStatementEnums_BreakContinueKeyword_IsValid(int value);
constexpr ASTBreakContinueStatementEnums_BreakContinueKeyword ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MIN = ASTBreakContinueStatementEnums_BreakContinueKeyword_BREAK;
constexpr ASTBreakContinueStatementEnums_BreakContinueKeyword ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MAX = ASTBreakContinueStatementEnums_BreakContinueKeyword_ITERATE;
constexpr int ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_ARRAYSIZE = ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor();
template<typename T>
inline const std::string& ASTBreakContinueStatementEnums_BreakContinueKeyword_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTBreakContinueStatementEnums_BreakContinueKeyword>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTBreakContinueStatementEnums_BreakContinueKeyword_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor(), enum_t_value);
}
inline bool ASTBreakContinueStatementEnums_BreakContinueKeyword_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTBreakContinueStatementEnums_BreakContinueKeyword* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTBreakContinueStatementEnums_BreakContinueKeyword>(
    ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor(), name, value);
}
enum ASTDropStatementEnums_DropMode : int {
  ASTDropStatementEnums_DropMode_DROP_MODE_UNSPECIFIED = 0,
  ASTDropStatementEnums_DropMode_RESTRICT = 1,
  ASTDropStatementEnums_DropMode_CASCADE = 2
};
bool ASTDropStatementEnums_DropMode_IsValid(int value);
constexpr ASTDropStatementEnums_DropMode ASTDropStatementEnums_DropMode_DropMode_MIN = ASTDropStatementEnums_DropMode_DROP_MODE_UNSPECIFIED;
constexpr ASTDropStatementEnums_DropMode ASTDropStatementEnums_DropMode_DropMode_MAX = ASTDropStatementEnums_DropMode_CASCADE;
constexpr int ASTDropStatementEnums_DropMode_DropMode_ARRAYSIZE = ASTDropStatementEnums_DropMode_DropMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTDropStatementEnums_DropMode_descriptor();
template<typename T>
inline const std::string& ASTDropStatementEnums_DropMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTDropStatementEnums_DropMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTDropStatementEnums_DropMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTDropStatementEnums_DropMode_descriptor(), enum_t_value);
}
inline bool ASTDropStatementEnums_DropMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTDropStatementEnums_DropMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTDropStatementEnums_DropMode>(
    ASTDropStatementEnums_DropMode_descriptor(), name, value);
}
enum ASTCreateFunctionStmtBaseEnums_DeterminismLevel : int {
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED = 0,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISTIC = 1,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_NOT_DETERMINISTIC = 2,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_IMMUTABLE = 3,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_STABLE = 4,
  ASTCreateFunctionStmtBaseEnums_DeterminismLevel_VOLATILE = 5
};
bool ASTCreateFunctionStmtBaseEnums_DeterminismLevel_IsValid(int value);
constexpr ASTCreateFunctionStmtBaseEnums_DeterminismLevel ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MIN = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED;
constexpr ASTCreateFunctionStmtBaseEnums_DeterminismLevel ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MAX = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_VOLATILE;
constexpr int ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_ARRAYSIZE = ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor();
template<typename T>
inline const std::string& ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTCreateFunctionStmtBaseEnums_DeterminismLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor(), enum_t_value);
}
inline bool ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTCreateFunctionStmtBaseEnums_DeterminismLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTCreateFunctionStmtBaseEnums_DeterminismLevel>(
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor(), name, value);
}
enum ASTAuxLoadDataStatementEnums_InsertionMode : int {
  ASTAuxLoadDataStatementEnums_InsertionMode_NOT_SET = 0,
  ASTAuxLoadDataStatementEnums_InsertionMode_APPEND = 1,
  ASTAuxLoadDataStatementEnums_InsertionMode_OVERWRITE = 2
};
bool ASTAuxLoadDataStatementEnums_InsertionMode_IsValid(int value);
constexpr ASTAuxLoadDataStatementEnums_InsertionMode ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MIN = ASTAuxLoadDataStatementEnums_InsertionMode_NOT_SET;
constexpr ASTAuxLoadDataStatementEnums_InsertionMode ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MAX = ASTAuxLoadDataStatementEnums_InsertionMode_OVERWRITE;
constexpr int ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_ARRAYSIZE = ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTAuxLoadDataStatementEnums_InsertionMode_descriptor();
template<typename T>
inline const std::string& ASTAuxLoadDataStatementEnums_InsertionMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTAuxLoadDataStatementEnums_InsertionMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTAuxLoadDataStatementEnums_InsertionMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTAuxLoadDataStatementEnums_InsertionMode_descriptor(), enum_t_value);
}
inline bool ASTAuxLoadDataStatementEnums_InsertionMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTAuxLoadDataStatementEnums_InsertionMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTAuxLoadDataStatementEnums_InsertionMode>(
    ASTAuxLoadDataStatementEnums_InsertionMode_descriptor(), name, value);
}
enum ASTSpannerInterleaveClauseEnums_Type : int {
  ASTSpannerInterleaveClauseEnums_Type_NOT_SET = 0,
  ASTSpannerInterleaveClauseEnums_Type_IN = 1,
  ASTSpannerInterleaveClauseEnums_Type_IN_PARENT = 2
};
bool ASTSpannerInterleaveClauseEnums_Type_IsValid(int value);
constexpr ASTSpannerInterleaveClauseEnums_Type ASTSpannerInterleaveClauseEnums_Type_Type_MIN = ASTSpannerInterleaveClauseEnums_Type_NOT_SET;
constexpr ASTSpannerInterleaveClauseEnums_Type ASTSpannerInterleaveClauseEnums_Type_Type_MAX = ASTSpannerInterleaveClauseEnums_Type_IN_PARENT;
constexpr int ASTSpannerInterleaveClauseEnums_Type_Type_ARRAYSIZE = ASTSpannerInterleaveClauseEnums_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ASTSpannerInterleaveClauseEnums_Type_descriptor();
template<typename T>
inline const std::string& ASTSpannerInterleaveClauseEnums_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ASTSpannerInterleaveClauseEnums_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ASTSpannerInterleaveClauseEnums_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ASTSpannerInterleaveClauseEnums_Type_descriptor(), enum_t_value);
}
inline bool ASTSpannerInterleaveClauseEnums_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ASTSpannerInterleaveClauseEnums_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ASTSpannerInterleaveClauseEnums_Type>(
    ASTSpannerInterleaveClauseEnums_Type_descriptor(), name, value);
}
enum SchemaObjectKind : int {
  __SchemaObjectKind__switch_must_have_a_default__ = -1,
  kInvalidSchemaObjectKind = 1,
  kAggregateFunction = 2,
  kConstant = 3,
  kDatabase = 4,
  kExternalTable = 5,
  kFunction = 6,
  kIndex = 7,
  kMaterializedView = 8,
  kModel = 9,
  kProcedure = 10,
  kSchema = 11,
  kTable = 12,
  kTableFunction = 13,
  kView = 14,
  kSnapshotTable = 15
};
bool SchemaObjectKind_IsValid(int value);
constexpr SchemaObjectKind SchemaObjectKind_MIN = __SchemaObjectKind__switch_must_have_a_default__;
constexpr SchemaObjectKind SchemaObjectKind_MAX = kSnapshotTable;
constexpr int SchemaObjectKind_ARRAYSIZE = SchemaObjectKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SchemaObjectKind_descriptor();
template<typename T>
inline const std::string& SchemaObjectKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SchemaObjectKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SchemaObjectKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SchemaObjectKind_descriptor(), enum_t_value);
}
inline bool SchemaObjectKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SchemaObjectKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SchemaObjectKind>(
    SchemaObjectKind_descriptor(), name, value);
}
// ===================================================================

class ASTBinaryExpressionEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTBinaryExpressionEnums) */ {
 public:
  inline ASTBinaryExpressionEnums() : ASTBinaryExpressionEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTBinaryExpressionEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTBinaryExpressionEnums(const ASTBinaryExpressionEnums& from);
  ASTBinaryExpressionEnums(ASTBinaryExpressionEnums&& from) noexcept
    : ASTBinaryExpressionEnums() {
    *this = ::std::move(from);
  }

  inline ASTBinaryExpressionEnums& operator=(const ASTBinaryExpressionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTBinaryExpressionEnums& operator=(ASTBinaryExpressionEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTBinaryExpressionEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTBinaryExpressionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTBinaryExpressionEnums*>(
               &_ASTBinaryExpressionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ASTBinaryExpressionEnums& a, ASTBinaryExpressionEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTBinaryExpressionEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTBinaryExpressionEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTBinaryExpressionEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTBinaryExpressionEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTBinaryExpressionEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTBinaryExpressionEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTBinaryExpressionEnums";
  }
  protected:
  explicit ASTBinaryExpressionEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTBinaryExpressionEnums_Op Op;
  static constexpr Op NOT_SET =
    ASTBinaryExpressionEnums_Op_NOT_SET;
  static constexpr Op LIKE =
    ASTBinaryExpressionEnums_Op_LIKE;
  static constexpr Op IS =
    ASTBinaryExpressionEnums_Op_IS;
  static constexpr Op EQ =
    ASTBinaryExpressionEnums_Op_EQ;
  static constexpr Op NE =
    ASTBinaryExpressionEnums_Op_NE;
  static constexpr Op NE2 =
    ASTBinaryExpressionEnums_Op_NE2;
  static constexpr Op GT =
    ASTBinaryExpressionEnums_Op_GT;
  static constexpr Op LT =
    ASTBinaryExpressionEnums_Op_LT;
  static constexpr Op GE =
    ASTBinaryExpressionEnums_Op_GE;
  static constexpr Op LE =
    ASTBinaryExpressionEnums_Op_LE;
  static constexpr Op BITWISE_OR =
    ASTBinaryExpressionEnums_Op_BITWISE_OR;
  static constexpr Op BITWISE_XOR =
    ASTBinaryExpressionEnums_Op_BITWISE_XOR;
  static constexpr Op BITWISE_AND =
    ASTBinaryExpressionEnums_Op_BITWISE_AND;
  static constexpr Op PLUS =
    ASTBinaryExpressionEnums_Op_PLUS;
  static constexpr Op MINUS =
    ASTBinaryExpressionEnums_Op_MINUS;
  static constexpr Op MULTIPLY =
    ASTBinaryExpressionEnums_Op_MULTIPLY;
  static constexpr Op DIVIDE =
    ASTBinaryExpressionEnums_Op_DIVIDE;
  static constexpr Op CONCAT_OP =
    ASTBinaryExpressionEnums_Op_CONCAT_OP;
  static constexpr Op DISTINCT =
    ASTBinaryExpressionEnums_Op_DISTINCT;
  static inline bool Op_IsValid(int value) {
    return ASTBinaryExpressionEnums_Op_IsValid(value);
  }
  static constexpr Op Op_MIN =
    ASTBinaryExpressionEnums_Op_Op_MIN;
  static constexpr Op Op_MAX =
    ASTBinaryExpressionEnums_Op_Op_MAX;
  static constexpr int Op_ARRAYSIZE =
    ASTBinaryExpressionEnums_Op_Op_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Op_descriptor() {
    return ASTBinaryExpressionEnums_Op_descriptor();
  }
  template<typename T>
  static inline const std::string& Op_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Op>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Op_Name.");
    return ASTBinaryExpressionEnums_Op_Name(enum_t_value);
  }
  static inline bool Op_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Op* value) {
    return ASTBinaryExpressionEnums_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTBinaryExpressionEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTOrderingExpressionEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTOrderingExpressionEnums) */ {
 public:
  inline ASTOrderingExpressionEnums() : ASTOrderingExpressionEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTOrderingExpressionEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTOrderingExpressionEnums(const ASTOrderingExpressionEnums& from);
  ASTOrderingExpressionEnums(ASTOrderingExpressionEnums&& from) noexcept
    : ASTOrderingExpressionEnums() {
    *this = ::std::move(from);
  }

  inline ASTOrderingExpressionEnums& operator=(const ASTOrderingExpressionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTOrderingExpressionEnums& operator=(ASTOrderingExpressionEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTOrderingExpressionEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTOrderingExpressionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTOrderingExpressionEnums*>(
               &_ASTOrderingExpressionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ASTOrderingExpressionEnums& a, ASTOrderingExpressionEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTOrderingExpressionEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTOrderingExpressionEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTOrderingExpressionEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTOrderingExpressionEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTOrderingExpressionEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTOrderingExpressionEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTOrderingExpressionEnums";
  }
  protected:
  explicit ASTOrderingExpressionEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTOrderingExpressionEnums_OrderingSpec OrderingSpec;
  static constexpr OrderingSpec NOT_SET =
    ASTOrderingExpressionEnums_OrderingSpec_NOT_SET;
  static constexpr OrderingSpec ASC =
    ASTOrderingExpressionEnums_OrderingSpec_ASC;
  static constexpr OrderingSpec DESC =
    ASTOrderingExpressionEnums_OrderingSpec_DESC;
  static constexpr OrderingSpec UNSPECIFIED =
    ASTOrderingExpressionEnums_OrderingSpec_UNSPECIFIED;
  static inline bool OrderingSpec_IsValid(int value) {
    return ASTOrderingExpressionEnums_OrderingSpec_IsValid(value);
  }
  static constexpr OrderingSpec OrderingSpec_MIN =
    ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MIN;
  static constexpr OrderingSpec OrderingSpec_MAX =
    ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_MAX;
  static constexpr int OrderingSpec_ARRAYSIZE =
    ASTOrderingExpressionEnums_OrderingSpec_OrderingSpec_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OrderingSpec_descriptor() {
    return ASTOrderingExpressionEnums_OrderingSpec_descriptor();
  }
  template<typename T>
  static inline const std::string& OrderingSpec_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OrderingSpec>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OrderingSpec_Name.");
    return ASTOrderingExpressionEnums_OrderingSpec_Name(enum_t_value);
  }
  static inline bool OrderingSpec_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OrderingSpec* value) {
    return ASTOrderingExpressionEnums_OrderingSpec_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTOrderingExpressionEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTJoinEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTJoinEnums) */ {
 public:
  inline ASTJoinEnums() : ASTJoinEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTJoinEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTJoinEnums(const ASTJoinEnums& from);
  ASTJoinEnums(ASTJoinEnums&& from) noexcept
    : ASTJoinEnums() {
    *this = ::std::move(from);
  }

  inline ASTJoinEnums& operator=(const ASTJoinEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTJoinEnums& operator=(ASTJoinEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTJoinEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTJoinEnums* internal_default_instance() {
    return reinterpret_cast<const ASTJoinEnums*>(
               &_ASTJoinEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ASTJoinEnums& a, ASTJoinEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTJoinEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTJoinEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTJoinEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTJoinEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTJoinEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTJoinEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTJoinEnums";
  }
  protected:
  explicit ASTJoinEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTJoinEnums_JoinType JoinType;
  static constexpr JoinType DEFAULT_JOIN_TYPE =
    ASTJoinEnums_JoinType_DEFAULT_JOIN_TYPE;
  static constexpr JoinType COMMA =
    ASTJoinEnums_JoinType_COMMA;
  static constexpr JoinType CROSS =
    ASTJoinEnums_JoinType_CROSS;
  static constexpr JoinType FULL =
    ASTJoinEnums_JoinType_FULL;
  static constexpr JoinType INNER =
    ASTJoinEnums_JoinType_INNER;
  static constexpr JoinType LEFT =
    ASTJoinEnums_JoinType_LEFT;
  static constexpr JoinType RIGHT =
    ASTJoinEnums_JoinType_RIGHT;
  static inline bool JoinType_IsValid(int value) {
    return ASTJoinEnums_JoinType_IsValid(value);
  }
  static constexpr JoinType JoinType_MIN =
    ASTJoinEnums_JoinType_JoinType_MIN;
  static constexpr JoinType JoinType_MAX =
    ASTJoinEnums_JoinType_JoinType_MAX;
  static constexpr int JoinType_ARRAYSIZE =
    ASTJoinEnums_JoinType_JoinType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  JoinType_descriptor() {
    return ASTJoinEnums_JoinType_descriptor();
  }
  template<typename T>
  static inline const std::string& JoinType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, JoinType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function JoinType_Name.");
    return ASTJoinEnums_JoinType_Name(enum_t_value);
  }
  static inline bool JoinType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      JoinType* value) {
    return ASTJoinEnums_JoinType_Parse(name, value);
  }

  typedef ASTJoinEnums_JoinHint JoinHint;
  static constexpr JoinHint NO_JOIN_HINT =
    ASTJoinEnums_JoinHint_NO_JOIN_HINT;
  static constexpr JoinHint HASH =
    ASTJoinEnums_JoinHint_HASH;
  static constexpr JoinHint LOOKUP =
    ASTJoinEnums_JoinHint_LOOKUP;
  static inline bool JoinHint_IsValid(int value) {
    return ASTJoinEnums_JoinHint_IsValid(value);
  }
  static constexpr JoinHint JoinHint_MIN =
    ASTJoinEnums_JoinHint_JoinHint_MIN;
  static constexpr JoinHint JoinHint_MAX =
    ASTJoinEnums_JoinHint_JoinHint_MAX;
  static constexpr int JoinHint_ARRAYSIZE =
    ASTJoinEnums_JoinHint_JoinHint_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  JoinHint_descriptor() {
    return ASTJoinEnums_JoinHint_descriptor();
  }
  template<typename T>
  static inline const std::string& JoinHint_Name(T enum_t_value) {
    static_assert(::std::is_same<T, JoinHint>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function JoinHint_Name.");
    return ASTJoinEnums_JoinHint_Name(enum_t_value);
  }
  static inline bool JoinHint_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      JoinHint* value) {
    return ASTJoinEnums_JoinHint_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTJoinEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTSelectAsEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTSelectAsEnums) */ {
 public:
  inline ASTSelectAsEnums() : ASTSelectAsEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTSelectAsEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTSelectAsEnums(const ASTSelectAsEnums& from);
  ASTSelectAsEnums(ASTSelectAsEnums&& from) noexcept
    : ASTSelectAsEnums() {
    *this = ::std::move(from);
  }

  inline ASTSelectAsEnums& operator=(const ASTSelectAsEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTSelectAsEnums& operator=(ASTSelectAsEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTSelectAsEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTSelectAsEnums* internal_default_instance() {
    return reinterpret_cast<const ASTSelectAsEnums*>(
               &_ASTSelectAsEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ASTSelectAsEnums& a, ASTSelectAsEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTSelectAsEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTSelectAsEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTSelectAsEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTSelectAsEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTSelectAsEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTSelectAsEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTSelectAsEnums";
  }
  protected:
  explicit ASTSelectAsEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTSelectAsEnums_AsMode AsMode;
  static constexpr AsMode NOT_SET =
    ASTSelectAsEnums_AsMode_NOT_SET;
  static constexpr AsMode STRUCT =
    ASTSelectAsEnums_AsMode_STRUCT;
  static constexpr AsMode VALUE =
    ASTSelectAsEnums_AsMode_VALUE;
  static constexpr AsMode TYPE_NAME =
    ASTSelectAsEnums_AsMode_TYPE_NAME;
  static inline bool AsMode_IsValid(int value) {
    return ASTSelectAsEnums_AsMode_IsValid(value);
  }
  static constexpr AsMode AsMode_MIN =
    ASTSelectAsEnums_AsMode_AsMode_MIN;
  static constexpr AsMode AsMode_MAX =
    ASTSelectAsEnums_AsMode_AsMode_MAX;
  static constexpr int AsMode_ARRAYSIZE =
    ASTSelectAsEnums_AsMode_AsMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AsMode_descriptor() {
    return ASTSelectAsEnums_AsMode_descriptor();
  }
  template<typename T>
  static inline const std::string& AsMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AsMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AsMode_Name.");
    return ASTSelectAsEnums_AsMode_Name(enum_t_value);
  }
  static inline bool AsMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AsMode* value) {
    return ASTSelectAsEnums_AsMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTSelectAsEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTFunctionCallEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTFunctionCallEnums) */ {
 public:
  inline ASTFunctionCallEnums() : ASTFunctionCallEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTFunctionCallEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTFunctionCallEnums(const ASTFunctionCallEnums& from);
  ASTFunctionCallEnums(ASTFunctionCallEnums&& from) noexcept
    : ASTFunctionCallEnums() {
    *this = ::std::move(from);
  }

  inline ASTFunctionCallEnums& operator=(const ASTFunctionCallEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTFunctionCallEnums& operator=(ASTFunctionCallEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTFunctionCallEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTFunctionCallEnums* internal_default_instance() {
    return reinterpret_cast<const ASTFunctionCallEnums*>(
               &_ASTFunctionCallEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ASTFunctionCallEnums& a, ASTFunctionCallEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTFunctionCallEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTFunctionCallEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTFunctionCallEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTFunctionCallEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTFunctionCallEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTFunctionCallEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTFunctionCallEnums";
  }
  protected:
  explicit ASTFunctionCallEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTFunctionCallEnums_NullHandlingModifier NullHandlingModifier;
  static constexpr NullHandlingModifier DEFAULT_NULL_HANDLING =
    ASTFunctionCallEnums_NullHandlingModifier_DEFAULT_NULL_HANDLING;
  static constexpr NullHandlingModifier IGNORE_NULLS =
    ASTFunctionCallEnums_NullHandlingModifier_IGNORE_NULLS;
  static constexpr NullHandlingModifier RESPECT_NULLS =
    ASTFunctionCallEnums_NullHandlingModifier_RESPECT_NULLS;
  static inline bool NullHandlingModifier_IsValid(int value) {
    return ASTFunctionCallEnums_NullHandlingModifier_IsValid(value);
  }
  static constexpr NullHandlingModifier NullHandlingModifier_MIN =
    ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MIN;
  static constexpr NullHandlingModifier NullHandlingModifier_MAX =
    ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_MAX;
  static constexpr int NullHandlingModifier_ARRAYSIZE =
    ASTFunctionCallEnums_NullHandlingModifier_NullHandlingModifier_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NullHandlingModifier_descriptor() {
    return ASTFunctionCallEnums_NullHandlingModifier_descriptor();
  }
  template<typename T>
  static inline const std::string& NullHandlingModifier_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NullHandlingModifier>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NullHandlingModifier_Name.");
    return ASTFunctionCallEnums_NullHandlingModifier_Name(enum_t_value);
  }
  static inline bool NullHandlingModifier_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NullHandlingModifier* value) {
    return ASTFunctionCallEnums_NullHandlingModifier_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTFunctionCallEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTExpressionSubqueryEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTExpressionSubqueryEnums) */ {
 public:
  inline ASTExpressionSubqueryEnums() : ASTExpressionSubqueryEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTExpressionSubqueryEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTExpressionSubqueryEnums(const ASTExpressionSubqueryEnums& from);
  ASTExpressionSubqueryEnums(ASTExpressionSubqueryEnums&& from) noexcept
    : ASTExpressionSubqueryEnums() {
    *this = ::std::move(from);
  }

  inline ASTExpressionSubqueryEnums& operator=(const ASTExpressionSubqueryEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTExpressionSubqueryEnums& operator=(ASTExpressionSubqueryEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTExpressionSubqueryEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTExpressionSubqueryEnums* internal_default_instance() {
    return reinterpret_cast<const ASTExpressionSubqueryEnums*>(
               &_ASTExpressionSubqueryEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ASTExpressionSubqueryEnums& a, ASTExpressionSubqueryEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTExpressionSubqueryEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTExpressionSubqueryEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTExpressionSubqueryEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTExpressionSubqueryEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTExpressionSubqueryEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTExpressionSubqueryEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTExpressionSubqueryEnums";
  }
  protected:
  explicit ASTExpressionSubqueryEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTExpressionSubqueryEnums_Modifier Modifier;
  static constexpr Modifier NONE =
    ASTExpressionSubqueryEnums_Modifier_NONE;
  static constexpr Modifier ARRAY =
    ASTExpressionSubqueryEnums_Modifier_ARRAY;
  static constexpr Modifier EXISTS =
    ASTExpressionSubqueryEnums_Modifier_EXISTS;
  static inline bool Modifier_IsValid(int value) {
    return ASTExpressionSubqueryEnums_Modifier_IsValid(value);
  }
  static constexpr Modifier Modifier_MIN =
    ASTExpressionSubqueryEnums_Modifier_Modifier_MIN;
  static constexpr Modifier Modifier_MAX =
    ASTExpressionSubqueryEnums_Modifier_Modifier_MAX;
  static constexpr int Modifier_ARRAYSIZE =
    ASTExpressionSubqueryEnums_Modifier_Modifier_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Modifier_descriptor() {
    return ASTExpressionSubqueryEnums_Modifier_descriptor();
  }
  template<typename T>
  static inline const std::string& Modifier_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Modifier>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Modifier_Name.");
    return ASTExpressionSubqueryEnums_Modifier_Name(enum_t_value);
  }
  static inline bool Modifier_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Modifier* value) {
    return ASTExpressionSubqueryEnums_Modifier_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTExpressionSubqueryEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTHavingModifierEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTHavingModifierEnums) */ {
 public:
  inline ASTHavingModifierEnums() : ASTHavingModifierEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTHavingModifierEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTHavingModifierEnums(const ASTHavingModifierEnums& from);
  ASTHavingModifierEnums(ASTHavingModifierEnums&& from) noexcept
    : ASTHavingModifierEnums() {
    *this = ::std::move(from);
  }

  inline ASTHavingModifierEnums& operator=(const ASTHavingModifierEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTHavingModifierEnums& operator=(ASTHavingModifierEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTHavingModifierEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTHavingModifierEnums* internal_default_instance() {
    return reinterpret_cast<const ASTHavingModifierEnums*>(
               &_ASTHavingModifierEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ASTHavingModifierEnums& a, ASTHavingModifierEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTHavingModifierEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTHavingModifierEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTHavingModifierEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTHavingModifierEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTHavingModifierEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTHavingModifierEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTHavingModifierEnums";
  }
  protected:
  explicit ASTHavingModifierEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTHavingModifierEnums_ModifierKind ModifierKind;
  static constexpr ModifierKind NOT_SET =
    ASTHavingModifierEnums_ModifierKind_NOT_SET;
  static constexpr ModifierKind MIN =
    ASTHavingModifierEnums_ModifierKind_MIN;
  static constexpr ModifierKind MAX =
    ASTHavingModifierEnums_ModifierKind_MAX;
  static inline bool ModifierKind_IsValid(int value) {
    return ASTHavingModifierEnums_ModifierKind_IsValid(value);
  }
  static constexpr ModifierKind ModifierKind_MIN =
    ASTHavingModifierEnums_ModifierKind_ModifierKind_MIN;
  static constexpr ModifierKind ModifierKind_MAX =
    ASTHavingModifierEnums_ModifierKind_ModifierKind_MAX;
  static constexpr int ModifierKind_ARRAYSIZE =
    ASTHavingModifierEnums_ModifierKind_ModifierKind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ModifierKind_descriptor() {
    return ASTHavingModifierEnums_ModifierKind_descriptor();
  }
  template<typename T>
  static inline const std::string& ModifierKind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ModifierKind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ModifierKind_Name.");
    return ASTHavingModifierEnums_ModifierKind_Name(enum_t_value);
  }
  static inline bool ModifierKind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ModifierKind* value) {
    return ASTHavingModifierEnums_ModifierKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTHavingModifierEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTSetOperationEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTSetOperationEnums) */ {
 public:
  inline ASTSetOperationEnums() : ASTSetOperationEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTSetOperationEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTSetOperationEnums(const ASTSetOperationEnums& from);
  ASTSetOperationEnums(ASTSetOperationEnums&& from) noexcept
    : ASTSetOperationEnums() {
    *this = ::std::move(from);
  }

  inline ASTSetOperationEnums& operator=(const ASTSetOperationEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTSetOperationEnums& operator=(ASTSetOperationEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTSetOperationEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTSetOperationEnums* internal_default_instance() {
    return reinterpret_cast<const ASTSetOperationEnums*>(
               &_ASTSetOperationEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ASTSetOperationEnums& a, ASTSetOperationEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTSetOperationEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTSetOperationEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTSetOperationEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTSetOperationEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTSetOperationEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTSetOperationEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTSetOperationEnums";
  }
  protected:
  explicit ASTSetOperationEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTSetOperationEnums_OperationType OperationType;
  static constexpr OperationType NOT_SET =
    ASTSetOperationEnums_OperationType_NOT_SET;
  static constexpr OperationType UNION =
    ASTSetOperationEnums_OperationType_UNION;
  static constexpr OperationType EXCEPT =
    ASTSetOperationEnums_OperationType_EXCEPT;
  static constexpr OperationType INTERSECT =
    ASTSetOperationEnums_OperationType_INTERSECT;
  static inline bool OperationType_IsValid(int value) {
    return ASTSetOperationEnums_OperationType_IsValid(value);
  }
  static constexpr OperationType OperationType_MIN =
    ASTSetOperationEnums_OperationType_OperationType_MIN;
  static constexpr OperationType OperationType_MAX =
    ASTSetOperationEnums_OperationType_OperationType_MAX;
  static constexpr int OperationType_ARRAYSIZE =
    ASTSetOperationEnums_OperationType_OperationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OperationType_descriptor() {
    return ASTSetOperationEnums_OperationType_descriptor();
  }
  template<typename T>
  static inline const std::string& OperationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OperationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OperationType_Name.");
    return ASTSetOperationEnums_OperationType_Name(enum_t_value);
  }
  static inline bool OperationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OperationType* value) {
    return ASTSetOperationEnums_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTSetOperationEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTUnaryExpressionEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTUnaryExpressionEnums) */ {
 public:
  inline ASTUnaryExpressionEnums() : ASTUnaryExpressionEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTUnaryExpressionEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTUnaryExpressionEnums(const ASTUnaryExpressionEnums& from);
  ASTUnaryExpressionEnums(ASTUnaryExpressionEnums&& from) noexcept
    : ASTUnaryExpressionEnums() {
    *this = ::std::move(from);
  }

  inline ASTUnaryExpressionEnums& operator=(const ASTUnaryExpressionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTUnaryExpressionEnums& operator=(ASTUnaryExpressionEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTUnaryExpressionEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTUnaryExpressionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTUnaryExpressionEnums*>(
               &_ASTUnaryExpressionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ASTUnaryExpressionEnums& a, ASTUnaryExpressionEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTUnaryExpressionEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTUnaryExpressionEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTUnaryExpressionEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTUnaryExpressionEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTUnaryExpressionEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTUnaryExpressionEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTUnaryExpressionEnums";
  }
  protected:
  explicit ASTUnaryExpressionEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTUnaryExpressionEnums_Op Op;
  static constexpr Op NOT_SET =
    ASTUnaryExpressionEnums_Op_NOT_SET;
  static constexpr Op NOT =
    ASTUnaryExpressionEnums_Op_NOT;
  static constexpr Op BITWISE_NOT =
    ASTUnaryExpressionEnums_Op_BITWISE_NOT;
  static constexpr Op MINUS =
    ASTUnaryExpressionEnums_Op_MINUS;
  static constexpr Op PLUS =
    ASTUnaryExpressionEnums_Op_PLUS;
  static constexpr Op IS_UNKNOWN =
    ASTUnaryExpressionEnums_Op_IS_UNKNOWN;
  static constexpr Op IS_NOT_UNKNOWN =
    ASTUnaryExpressionEnums_Op_IS_NOT_UNKNOWN;
  static inline bool Op_IsValid(int value) {
    return ASTUnaryExpressionEnums_Op_IsValid(value);
  }
  static constexpr Op Op_MIN =
    ASTUnaryExpressionEnums_Op_Op_MIN;
  static constexpr Op Op_MAX =
    ASTUnaryExpressionEnums_Op_Op_MAX;
  static constexpr int Op_ARRAYSIZE =
    ASTUnaryExpressionEnums_Op_Op_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Op_descriptor() {
    return ASTUnaryExpressionEnums_Op_descriptor();
  }
  template<typename T>
  static inline const std::string& Op_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Op>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Op_Name.");
    return ASTUnaryExpressionEnums_Op_Name(enum_t_value);
  }
  static inline bool Op_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Op* value) {
    return ASTUnaryExpressionEnums_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTUnaryExpressionEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTWindowFrameEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTWindowFrameEnums) */ {
 public:
  inline ASTWindowFrameEnums() : ASTWindowFrameEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTWindowFrameEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTWindowFrameEnums(const ASTWindowFrameEnums& from);
  ASTWindowFrameEnums(ASTWindowFrameEnums&& from) noexcept
    : ASTWindowFrameEnums() {
    *this = ::std::move(from);
  }

  inline ASTWindowFrameEnums& operator=(const ASTWindowFrameEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTWindowFrameEnums& operator=(ASTWindowFrameEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTWindowFrameEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTWindowFrameEnums* internal_default_instance() {
    return reinterpret_cast<const ASTWindowFrameEnums*>(
               &_ASTWindowFrameEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ASTWindowFrameEnums& a, ASTWindowFrameEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTWindowFrameEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTWindowFrameEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTWindowFrameEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTWindowFrameEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTWindowFrameEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTWindowFrameEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTWindowFrameEnums";
  }
  protected:
  explicit ASTWindowFrameEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTWindowFrameEnums_FrameUnit FrameUnit;
  static constexpr FrameUnit ROWS =
    ASTWindowFrameEnums_FrameUnit_ROWS;
  static constexpr FrameUnit RANGE =
    ASTWindowFrameEnums_FrameUnit_RANGE;
  static inline bool FrameUnit_IsValid(int value) {
    return ASTWindowFrameEnums_FrameUnit_IsValid(value);
  }
  static constexpr FrameUnit FrameUnit_MIN =
    ASTWindowFrameEnums_FrameUnit_FrameUnit_MIN;
  static constexpr FrameUnit FrameUnit_MAX =
    ASTWindowFrameEnums_FrameUnit_FrameUnit_MAX;
  static constexpr int FrameUnit_ARRAYSIZE =
    ASTWindowFrameEnums_FrameUnit_FrameUnit_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FrameUnit_descriptor() {
    return ASTWindowFrameEnums_FrameUnit_descriptor();
  }
  template<typename T>
  static inline const std::string& FrameUnit_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FrameUnit>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FrameUnit_Name.");
    return ASTWindowFrameEnums_FrameUnit_Name(enum_t_value);
  }
  static inline bool FrameUnit_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FrameUnit* value) {
    return ASTWindowFrameEnums_FrameUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTWindowFrameEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTWindowFrameExprEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTWindowFrameExprEnums) */ {
 public:
  inline ASTWindowFrameExprEnums() : ASTWindowFrameExprEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTWindowFrameExprEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTWindowFrameExprEnums(const ASTWindowFrameExprEnums& from);
  ASTWindowFrameExprEnums(ASTWindowFrameExprEnums&& from) noexcept
    : ASTWindowFrameExprEnums() {
    *this = ::std::move(from);
  }

  inline ASTWindowFrameExprEnums& operator=(const ASTWindowFrameExprEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTWindowFrameExprEnums& operator=(ASTWindowFrameExprEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTWindowFrameExprEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTWindowFrameExprEnums* internal_default_instance() {
    return reinterpret_cast<const ASTWindowFrameExprEnums*>(
               &_ASTWindowFrameExprEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ASTWindowFrameExprEnums& a, ASTWindowFrameExprEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTWindowFrameExprEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTWindowFrameExprEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTWindowFrameExprEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTWindowFrameExprEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTWindowFrameExprEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTWindowFrameExprEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTWindowFrameExprEnums";
  }
  protected:
  explicit ASTWindowFrameExprEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTWindowFrameExprEnums_BoundaryType BoundaryType;
  static constexpr BoundaryType UNBOUNDED_PRECEDING =
    ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_PRECEDING;
  static constexpr BoundaryType OFFSET_PRECEDING =
    ASTWindowFrameExprEnums_BoundaryType_OFFSET_PRECEDING;
  static constexpr BoundaryType CURRENT_ROW =
    ASTWindowFrameExprEnums_BoundaryType_CURRENT_ROW;
  static constexpr BoundaryType OFFSET_FOLLOWING =
    ASTWindowFrameExprEnums_BoundaryType_OFFSET_FOLLOWING;
  static constexpr BoundaryType UNBOUNDED_FOLLOWING =
    ASTWindowFrameExprEnums_BoundaryType_UNBOUNDED_FOLLOWING;
  static inline bool BoundaryType_IsValid(int value) {
    return ASTWindowFrameExprEnums_BoundaryType_IsValid(value);
  }
  static constexpr BoundaryType BoundaryType_MIN =
    ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MIN;
  static constexpr BoundaryType BoundaryType_MAX =
    ASTWindowFrameExprEnums_BoundaryType_BoundaryType_MAX;
  static constexpr int BoundaryType_ARRAYSIZE =
    ASTWindowFrameExprEnums_BoundaryType_BoundaryType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BoundaryType_descriptor() {
    return ASTWindowFrameExprEnums_BoundaryType_descriptor();
  }
  template<typename T>
  static inline const std::string& BoundaryType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BoundaryType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BoundaryType_Name.");
    return ASTWindowFrameExprEnums_BoundaryType_Name(enum_t_value);
  }
  static inline bool BoundaryType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BoundaryType* value) {
    return ASTWindowFrameExprEnums_BoundaryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTWindowFrameExprEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTAnySomeAllOpEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTAnySomeAllOpEnums) */ {
 public:
  inline ASTAnySomeAllOpEnums() : ASTAnySomeAllOpEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTAnySomeAllOpEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTAnySomeAllOpEnums(const ASTAnySomeAllOpEnums& from);
  ASTAnySomeAllOpEnums(ASTAnySomeAllOpEnums&& from) noexcept
    : ASTAnySomeAllOpEnums() {
    *this = ::std::move(from);
  }

  inline ASTAnySomeAllOpEnums& operator=(const ASTAnySomeAllOpEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTAnySomeAllOpEnums& operator=(ASTAnySomeAllOpEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTAnySomeAllOpEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTAnySomeAllOpEnums* internal_default_instance() {
    return reinterpret_cast<const ASTAnySomeAllOpEnums*>(
               &_ASTAnySomeAllOpEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ASTAnySomeAllOpEnums& a, ASTAnySomeAllOpEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTAnySomeAllOpEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTAnySomeAllOpEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTAnySomeAllOpEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTAnySomeAllOpEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTAnySomeAllOpEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTAnySomeAllOpEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTAnySomeAllOpEnums";
  }
  protected:
  explicit ASTAnySomeAllOpEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTAnySomeAllOpEnums_Op Op;
  static constexpr Op kUninitialized =
    ASTAnySomeAllOpEnums_Op_kUninitialized;
  static constexpr Op kAny =
    ASTAnySomeAllOpEnums_Op_kAny;
  static constexpr Op kSome =
    ASTAnySomeAllOpEnums_Op_kSome;
  static constexpr Op kAll =
    ASTAnySomeAllOpEnums_Op_kAll;
  static inline bool Op_IsValid(int value) {
    return ASTAnySomeAllOpEnums_Op_IsValid(value);
  }
  static constexpr Op Op_MIN =
    ASTAnySomeAllOpEnums_Op_Op_MIN;
  static constexpr Op Op_MAX =
    ASTAnySomeAllOpEnums_Op_Op_MAX;
  static constexpr int Op_ARRAYSIZE =
    ASTAnySomeAllOpEnums_Op_Op_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Op_descriptor() {
    return ASTAnySomeAllOpEnums_Op_descriptor();
  }
  template<typename T>
  static inline const std::string& Op_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Op>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Op_Name.");
    return ASTAnySomeAllOpEnums_Op_Name(enum_t_value);
  }
  static inline bool Op_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Op* value) {
    return ASTAnySomeAllOpEnums_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTAnySomeAllOpEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTTransactionReadWriteModeEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTTransactionReadWriteModeEnums) */ {
 public:
  inline ASTTransactionReadWriteModeEnums() : ASTTransactionReadWriteModeEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTTransactionReadWriteModeEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTTransactionReadWriteModeEnums(const ASTTransactionReadWriteModeEnums& from);
  ASTTransactionReadWriteModeEnums(ASTTransactionReadWriteModeEnums&& from) noexcept
    : ASTTransactionReadWriteModeEnums() {
    *this = ::std::move(from);
  }

  inline ASTTransactionReadWriteModeEnums& operator=(const ASTTransactionReadWriteModeEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTTransactionReadWriteModeEnums& operator=(ASTTransactionReadWriteModeEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTTransactionReadWriteModeEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTTransactionReadWriteModeEnums* internal_default_instance() {
    return reinterpret_cast<const ASTTransactionReadWriteModeEnums*>(
               &_ASTTransactionReadWriteModeEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ASTTransactionReadWriteModeEnums& a, ASTTransactionReadWriteModeEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTTransactionReadWriteModeEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTTransactionReadWriteModeEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTTransactionReadWriteModeEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTTransactionReadWriteModeEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTTransactionReadWriteModeEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTTransactionReadWriteModeEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTTransactionReadWriteModeEnums";
  }
  protected:
  explicit ASTTransactionReadWriteModeEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTTransactionReadWriteModeEnums_Mode Mode;
  static constexpr Mode INVALID =
    ASTTransactionReadWriteModeEnums_Mode_INVALID;
  static constexpr Mode READ_ONLY =
    ASTTransactionReadWriteModeEnums_Mode_READ_ONLY;
  static constexpr Mode READ_WRITE =
    ASTTransactionReadWriteModeEnums_Mode_READ_WRITE;
  static inline bool Mode_IsValid(int value) {
    return ASTTransactionReadWriteModeEnums_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    ASTTransactionReadWriteModeEnums_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    ASTTransactionReadWriteModeEnums_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    ASTTransactionReadWriteModeEnums_Mode_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Mode_descriptor() {
    return ASTTransactionReadWriteModeEnums_Mode_descriptor();
  }
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return ASTTransactionReadWriteModeEnums_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Mode* value) {
    return ASTTransactionReadWriteModeEnums_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTTransactionReadWriteModeEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTImportStatementEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTImportStatementEnums) */ {
 public:
  inline ASTImportStatementEnums() : ASTImportStatementEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTImportStatementEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTImportStatementEnums(const ASTImportStatementEnums& from);
  ASTImportStatementEnums(ASTImportStatementEnums&& from) noexcept
    : ASTImportStatementEnums() {
    *this = ::std::move(from);
  }

  inline ASTImportStatementEnums& operator=(const ASTImportStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTImportStatementEnums& operator=(ASTImportStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTImportStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTImportStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTImportStatementEnums*>(
               &_ASTImportStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ASTImportStatementEnums& a, ASTImportStatementEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTImportStatementEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTImportStatementEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTImportStatementEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTImportStatementEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTImportStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTImportStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTImportStatementEnums";
  }
  protected:
  explicit ASTImportStatementEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTImportStatementEnums_ImportKind ImportKind;
  static constexpr ImportKind MODULE =
    ASTImportStatementEnums_ImportKind_MODULE;
  static constexpr ImportKind PROTO =
    ASTImportStatementEnums_ImportKind_PROTO;
  static inline bool ImportKind_IsValid(int value) {
    return ASTImportStatementEnums_ImportKind_IsValid(value);
  }
  static constexpr ImportKind ImportKind_MIN =
    ASTImportStatementEnums_ImportKind_ImportKind_MIN;
  static constexpr ImportKind ImportKind_MAX =
    ASTImportStatementEnums_ImportKind_ImportKind_MAX;
  static constexpr int ImportKind_ARRAYSIZE =
    ASTImportStatementEnums_ImportKind_ImportKind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ImportKind_descriptor() {
    return ASTImportStatementEnums_ImportKind_descriptor();
  }
  template<typename T>
  static inline const std::string& ImportKind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ImportKind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ImportKind_Name.");
    return ASTImportStatementEnums_ImportKind_Name(enum_t_value);
  }
  static inline bool ImportKind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ImportKind* value) {
    return ASTImportStatementEnums_ImportKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTImportStatementEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTUnpivotClauseEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTUnpivotClauseEnums) */ {
 public:
  inline ASTUnpivotClauseEnums() : ASTUnpivotClauseEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTUnpivotClauseEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTUnpivotClauseEnums(const ASTUnpivotClauseEnums& from);
  ASTUnpivotClauseEnums(ASTUnpivotClauseEnums&& from) noexcept
    : ASTUnpivotClauseEnums() {
    *this = ::std::move(from);
  }

  inline ASTUnpivotClauseEnums& operator=(const ASTUnpivotClauseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTUnpivotClauseEnums& operator=(ASTUnpivotClauseEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTUnpivotClauseEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTUnpivotClauseEnums* internal_default_instance() {
    return reinterpret_cast<const ASTUnpivotClauseEnums*>(
               &_ASTUnpivotClauseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ASTUnpivotClauseEnums& a, ASTUnpivotClauseEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTUnpivotClauseEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTUnpivotClauseEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTUnpivotClauseEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTUnpivotClauseEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTUnpivotClauseEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTUnpivotClauseEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTUnpivotClauseEnums";
  }
  protected:
  explicit ASTUnpivotClauseEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTUnpivotClauseEnums_NullFilter NullFilter;
  static constexpr NullFilter kUnspecified =
    ASTUnpivotClauseEnums_NullFilter_kUnspecified;
  static constexpr NullFilter kInclude =
    ASTUnpivotClauseEnums_NullFilter_kInclude;
  static constexpr NullFilter kExclude =
    ASTUnpivotClauseEnums_NullFilter_kExclude;
  static inline bool NullFilter_IsValid(int value) {
    return ASTUnpivotClauseEnums_NullFilter_IsValid(value);
  }
  static constexpr NullFilter NullFilter_MIN =
    ASTUnpivotClauseEnums_NullFilter_NullFilter_MIN;
  static constexpr NullFilter NullFilter_MAX =
    ASTUnpivotClauseEnums_NullFilter_NullFilter_MAX;
  static constexpr int NullFilter_ARRAYSIZE =
    ASTUnpivotClauseEnums_NullFilter_NullFilter_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NullFilter_descriptor() {
    return ASTUnpivotClauseEnums_NullFilter_descriptor();
  }
  template<typename T>
  static inline const std::string& NullFilter_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NullFilter>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NullFilter_Name.");
    return ASTUnpivotClauseEnums_NullFilter_Name(enum_t_value);
  }
  static inline bool NullFilter_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NullFilter* value) {
    return ASTUnpivotClauseEnums_NullFilter_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTUnpivotClauseEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTCreateStatementEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTCreateStatementEnums) */ {
 public:
  inline ASTCreateStatementEnums() : ASTCreateStatementEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTCreateStatementEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTCreateStatementEnums(const ASTCreateStatementEnums& from);
  ASTCreateStatementEnums(ASTCreateStatementEnums&& from) noexcept
    : ASTCreateStatementEnums() {
    *this = ::std::move(from);
  }

  inline ASTCreateStatementEnums& operator=(const ASTCreateStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTCreateStatementEnums& operator=(ASTCreateStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTCreateStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTCreateStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTCreateStatementEnums*>(
               &_ASTCreateStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ASTCreateStatementEnums& a, ASTCreateStatementEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTCreateStatementEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTCreateStatementEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTCreateStatementEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTCreateStatementEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTCreateStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTCreateStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTCreateStatementEnums";
  }
  protected:
  explicit ASTCreateStatementEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTCreateStatementEnums_Scope Scope;
  static constexpr Scope DEFAULT_SCOPE =
    ASTCreateStatementEnums_Scope_DEFAULT_SCOPE;
  static constexpr Scope PRIVATE =
    ASTCreateStatementEnums_Scope_PRIVATE;
  static constexpr Scope PUBLIC =
    ASTCreateStatementEnums_Scope_PUBLIC;
  static constexpr Scope TEMPORARY =
    ASTCreateStatementEnums_Scope_TEMPORARY;
  static inline bool Scope_IsValid(int value) {
    return ASTCreateStatementEnums_Scope_IsValid(value);
  }
  static constexpr Scope Scope_MIN =
    ASTCreateStatementEnums_Scope_Scope_MIN;
  static constexpr Scope Scope_MAX =
    ASTCreateStatementEnums_Scope_Scope_MAX;
  static constexpr int Scope_ARRAYSIZE =
    ASTCreateStatementEnums_Scope_Scope_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Scope_descriptor() {
    return ASTCreateStatementEnums_Scope_descriptor();
  }
  template<typename T>
  static inline const std::string& Scope_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Scope>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Scope_Name.");
    return ASTCreateStatementEnums_Scope_Name(enum_t_value);
  }
  static inline bool Scope_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Scope* value) {
    return ASTCreateStatementEnums_Scope_Parse(name, value);
  }

  typedef ASTCreateStatementEnums_SqlSecurity SqlSecurity;
  static constexpr SqlSecurity SQL_SECURITY_UNSPECIFIED =
    ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_UNSPECIFIED;
  static constexpr SqlSecurity SQL_SECURITY_DEFINER =
    ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_DEFINER;
  static constexpr SqlSecurity SQL_SECURITY_INVOKER =
    ASTCreateStatementEnums_SqlSecurity_SQL_SECURITY_INVOKER;
  static inline bool SqlSecurity_IsValid(int value) {
    return ASTCreateStatementEnums_SqlSecurity_IsValid(value);
  }
  static constexpr SqlSecurity SqlSecurity_MIN =
    ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MIN;
  static constexpr SqlSecurity SqlSecurity_MAX =
    ASTCreateStatementEnums_SqlSecurity_SqlSecurity_MAX;
  static constexpr int SqlSecurity_ARRAYSIZE =
    ASTCreateStatementEnums_SqlSecurity_SqlSecurity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SqlSecurity_descriptor() {
    return ASTCreateStatementEnums_SqlSecurity_descriptor();
  }
  template<typename T>
  static inline const std::string& SqlSecurity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SqlSecurity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SqlSecurity_Name.");
    return ASTCreateStatementEnums_SqlSecurity_Name(enum_t_value);
  }
  static inline bool SqlSecurity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SqlSecurity* value) {
    return ASTCreateStatementEnums_SqlSecurity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTCreateStatementEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTFunctionParameterEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTFunctionParameterEnums) */ {
 public:
  inline ASTFunctionParameterEnums() : ASTFunctionParameterEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTFunctionParameterEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTFunctionParameterEnums(const ASTFunctionParameterEnums& from);
  ASTFunctionParameterEnums(ASTFunctionParameterEnums&& from) noexcept
    : ASTFunctionParameterEnums() {
    *this = ::std::move(from);
  }

  inline ASTFunctionParameterEnums& operator=(const ASTFunctionParameterEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTFunctionParameterEnums& operator=(ASTFunctionParameterEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTFunctionParameterEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTFunctionParameterEnums* internal_default_instance() {
    return reinterpret_cast<const ASTFunctionParameterEnums*>(
               &_ASTFunctionParameterEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ASTFunctionParameterEnums& a, ASTFunctionParameterEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTFunctionParameterEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTFunctionParameterEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTFunctionParameterEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTFunctionParameterEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTFunctionParameterEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTFunctionParameterEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTFunctionParameterEnums";
  }
  protected:
  explicit ASTFunctionParameterEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTFunctionParameterEnums_ProcedureParameterMode ProcedureParameterMode;
  static constexpr ProcedureParameterMode NOT_SET =
    ASTFunctionParameterEnums_ProcedureParameterMode_NOT_SET;
  static constexpr ProcedureParameterMode IN =
    ASTFunctionParameterEnums_ProcedureParameterMode_IN;
  static constexpr ProcedureParameterMode OUT =
    ASTFunctionParameterEnums_ProcedureParameterMode_OUT;
  static constexpr ProcedureParameterMode INOUT =
    ASTFunctionParameterEnums_ProcedureParameterMode_INOUT;
  static inline bool ProcedureParameterMode_IsValid(int value) {
    return ASTFunctionParameterEnums_ProcedureParameterMode_IsValid(value);
  }
  static constexpr ProcedureParameterMode ProcedureParameterMode_MIN =
    ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MIN;
  static constexpr ProcedureParameterMode ProcedureParameterMode_MAX =
    ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_MAX;
  static constexpr int ProcedureParameterMode_ARRAYSIZE =
    ASTFunctionParameterEnums_ProcedureParameterMode_ProcedureParameterMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ProcedureParameterMode_descriptor() {
    return ASTFunctionParameterEnums_ProcedureParameterMode_descriptor();
  }
  template<typename T>
  static inline const std::string& ProcedureParameterMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ProcedureParameterMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ProcedureParameterMode_Name.");
    return ASTFunctionParameterEnums_ProcedureParameterMode_Name(enum_t_value);
  }
  static inline bool ProcedureParameterMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ProcedureParameterMode* value) {
    return ASTFunctionParameterEnums_ProcedureParameterMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTFunctionParameterEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTTemplatedParameterTypeEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTTemplatedParameterTypeEnums) */ {
 public:
  inline ASTTemplatedParameterTypeEnums() : ASTTemplatedParameterTypeEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTTemplatedParameterTypeEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTTemplatedParameterTypeEnums(const ASTTemplatedParameterTypeEnums& from);
  ASTTemplatedParameterTypeEnums(ASTTemplatedParameterTypeEnums&& from) noexcept
    : ASTTemplatedParameterTypeEnums() {
    *this = ::std::move(from);
  }

  inline ASTTemplatedParameterTypeEnums& operator=(const ASTTemplatedParameterTypeEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTTemplatedParameterTypeEnums& operator=(ASTTemplatedParameterTypeEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTTemplatedParameterTypeEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTTemplatedParameterTypeEnums* internal_default_instance() {
    return reinterpret_cast<const ASTTemplatedParameterTypeEnums*>(
               &_ASTTemplatedParameterTypeEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ASTTemplatedParameterTypeEnums& a, ASTTemplatedParameterTypeEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTTemplatedParameterTypeEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTTemplatedParameterTypeEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTTemplatedParameterTypeEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTTemplatedParameterTypeEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTTemplatedParameterTypeEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTTemplatedParameterTypeEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTTemplatedParameterTypeEnums";
  }
  protected:
  explicit ASTTemplatedParameterTypeEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTTemplatedParameterTypeEnums_TemplatedTypeKind TemplatedTypeKind;
  static constexpr TemplatedTypeKind UNINITIALIZED =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_UNINITIALIZED;
  static constexpr TemplatedTypeKind ANY_TYPE =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TYPE;
  static constexpr TemplatedTypeKind ANY_PROTO =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_PROTO;
  static constexpr TemplatedTypeKind ANY_ENUM =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_ENUM;
  static constexpr TemplatedTypeKind ANY_STRUCT =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_STRUCT;
  static constexpr TemplatedTypeKind ANY_ARRAY =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_ARRAY;
  static constexpr TemplatedTypeKind ANY_TABLE =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_ANY_TABLE;
  static inline bool TemplatedTypeKind_IsValid(int value) {
    return ASTTemplatedParameterTypeEnums_TemplatedTypeKind_IsValid(value);
  }
  static constexpr TemplatedTypeKind TemplatedTypeKind_MIN =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MIN;
  static constexpr TemplatedTypeKind TemplatedTypeKind_MAX =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_MAX;
  static constexpr int TemplatedTypeKind_ARRAYSIZE =
    ASTTemplatedParameterTypeEnums_TemplatedTypeKind_TemplatedTypeKind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TemplatedTypeKind_descriptor() {
    return ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor();
  }
  template<typename T>
  static inline const std::string& TemplatedTypeKind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TemplatedTypeKind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TemplatedTypeKind_Name.");
    return ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Name(enum_t_value);
  }
  static inline bool TemplatedTypeKind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TemplatedTypeKind* value) {
    return ASTTemplatedParameterTypeEnums_TemplatedTypeKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTTemplatedParameterTypeEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTGeneratedColumnInfoEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTGeneratedColumnInfoEnums) */ {
 public:
  inline ASTGeneratedColumnInfoEnums() : ASTGeneratedColumnInfoEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTGeneratedColumnInfoEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTGeneratedColumnInfoEnums(const ASTGeneratedColumnInfoEnums& from);
  ASTGeneratedColumnInfoEnums(ASTGeneratedColumnInfoEnums&& from) noexcept
    : ASTGeneratedColumnInfoEnums() {
    *this = ::std::move(from);
  }

  inline ASTGeneratedColumnInfoEnums& operator=(const ASTGeneratedColumnInfoEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTGeneratedColumnInfoEnums& operator=(ASTGeneratedColumnInfoEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTGeneratedColumnInfoEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTGeneratedColumnInfoEnums* internal_default_instance() {
    return reinterpret_cast<const ASTGeneratedColumnInfoEnums*>(
               &_ASTGeneratedColumnInfoEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ASTGeneratedColumnInfoEnums& a, ASTGeneratedColumnInfoEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTGeneratedColumnInfoEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTGeneratedColumnInfoEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTGeneratedColumnInfoEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTGeneratedColumnInfoEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTGeneratedColumnInfoEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTGeneratedColumnInfoEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTGeneratedColumnInfoEnums";
  }
  protected:
  explicit ASTGeneratedColumnInfoEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTGeneratedColumnInfoEnums_StoredMode StoredMode;
  static constexpr StoredMode NON_STORED =
    ASTGeneratedColumnInfoEnums_StoredMode_NON_STORED;
  static constexpr StoredMode STORED =
    ASTGeneratedColumnInfoEnums_StoredMode_STORED;
  static constexpr StoredMode STORED_VOLATILE =
    ASTGeneratedColumnInfoEnums_StoredMode_STORED_VOLATILE;
  static inline bool StoredMode_IsValid(int value) {
    return ASTGeneratedColumnInfoEnums_StoredMode_IsValid(value);
  }
  static constexpr StoredMode StoredMode_MIN =
    ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MIN;
  static constexpr StoredMode StoredMode_MAX =
    ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_MAX;
  static constexpr int StoredMode_ARRAYSIZE =
    ASTGeneratedColumnInfoEnums_StoredMode_StoredMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StoredMode_descriptor() {
    return ASTGeneratedColumnInfoEnums_StoredMode_descriptor();
  }
  template<typename T>
  static inline const std::string& StoredMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StoredMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StoredMode_Name.");
    return ASTGeneratedColumnInfoEnums_StoredMode_Name(enum_t_value);
  }
  static inline bool StoredMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StoredMode* value) {
    return ASTGeneratedColumnInfoEnums_StoredMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTGeneratedColumnInfoEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTColumnPositionEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTColumnPositionEnums) */ {
 public:
  inline ASTColumnPositionEnums() : ASTColumnPositionEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTColumnPositionEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTColumnPositionEnums(const ASTColumnPositionEnums& from);
  ASTColumnPositionEnums(ASTColumnPositionEnums&& from) noexcept
    : ASTColumnPositionEnums() {
    *this = ::std::move(from);
  }

  inline ASTColumnPositionEnums& operator=(const ASTColumnPositionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTColumnPositionEnums& operator=(ASTColumnPositionEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTColumnPositionEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTColumnPositionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTColumnPositionEnums*>(
               &_ASTColumnPositionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ASTColumnPositionEnums& a, ASTColumnPositionEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTColumnPositionEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTColumnPositionEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTColumnPositionEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTColumnPositionEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTColumnPositionEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTColumnPositionEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTColumnPositionEnums";
  }
  protected:
  explicit ASTColumnPositionEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTColumnPositionEnums_RelativePositionType RelativePositionType;
  static constexpr RelativePositionType PRECEDING =
    ASTColumnPositionEnums_RelativePositionType_PRECEDING;
  static constexpr RelativePositionType FOLLOWING =
    ASTColumnPositionEnums_RelativePositionType_FOLLOWING;
  static inline bool RelativePositionType_IsValid(int value) {
    return ASTColumnPositionEnums_RelativePositionType_IsValid(value);
  }
  static constexpr RelativePositionType RelativePositionType_MIN =
    ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MIN;
  static constexpr RelativePositionType RelativePositionType_MAX =
    ASTColumnPositionEnums_RelativePositionType_RelativePositionType_MAX;
  static constexpr int RelativePositionType_ARRAYSIZE =
    ASTColumnPositionEnums_RelativePositionType_RelativePositionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RelativePositionType_descriptor() {
    return ASTColumnPositionEnums_RelativePositionType_descriptor();
  }
  template<typename T>
  static inline const std::string& RelativePositionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RelativePositionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RelativePositionType_Name.");
    return ASTColumnPositionEnums_RelativePositionType_Name(enum_t_value);
  }
  static inline bool RelativePositionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RelativePositionType* value) {
    return ASTColumnPositionEnums_RelativePositionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTColumnPositionEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTInsertStatementEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTInsertStatementEnums) */ {
 public:
  inline ASTInsertStatementEnums() : ASTInsertStatementEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTInsertStatementEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTInsertStatementEnums(const ASTInsertStatementEnums& from);
  ASTInsertStatementEnums(ASTInsertStatementEnums&& from) noexcept
    : ASTInsertStatementEnums() {
    *this = ::std::move(from);
  }

  inline ASTInsertStatementEnums& operator=(const ASTInsertStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTInsertStatementEnums& operator=(ASTInsertStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTInsertStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTInsertStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTInsertStatementEnums*>(
               &_ASTInsertStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ASTInsertStatementEnums& a, ASTInsertStatementEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTInsertStatementEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTInsertStatementEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTInsertStatementEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTInsertStatementEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTInsertStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTInsertStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTInsertStatementEnums";
  }
  protected:
  explicit ASTInsertStatementEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTInsertStatementEnums_InsertMode InsertMode;
  static constexpr InsertMode DEFAULT_MODE =
    ASTInsertStatementEnums_InsertMode_DEFAULT_MODE;
  static constexpr InsertMode REPLACE =
    ASTInsertStatementEnums_InsertMode_REPLACE;
  static constexpr InsertMode UPDATE =
    ASTInsertStatementEnums_InsertMode_UPDATE;
  static constexpr InsertMode IGNORE =
    ASTInsertStatementEnums_InsertMode_IGNORE;
  static inline bool InsertMode_IsValid(int value) {
    return ASTInsertStatementEnums_InsertMode_IsValid(value);
  }
  static constexpr InsertMode InsertMode_MIN =
    ASTInsertStatementEnums_InsertMode_InsertMode_MIN;
  static constexpr InsertMode InsertMode_MAX =
    ASTInsertStatementEnums_InsertMode_InsertMode_MAX;
  static constexpr int InsertMode_ARRAYSIZE =
    ASTInsertStatementEnums_InsertMode_InsertMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InsertMode_descriptor() {
    return ASTInsertStatementEnums_InsertMode_descriptor();
  }
  template<typename T>
  static inline const std::string& InsertMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InsertMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InsertMode_Name.");
    return ASTInsertStatementEnums_InsertMode_Name(enum_t_value);
  }
  static inline bool InsertMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InsertMode* value) {
    return ASTInsertStatementEnums_InsertMode_Parse(name, value);
  }

  typedef ASTInsertStatementEnums_ParseProgress ParseProgress;
  static constexpr ParseProgress kInitial =
    ASTInsertStatementEnums_ParseProgress_kInitial;
  static constexpr ParseProgress kSeenOrIgnoreReplaceUpdate =
    ASTInsertStatementEnums_ParseProgress_kSeenOrIgnoreReplaceUpdate;
  static constexpr ParseProgress kSeenTargetPath =
    ASTInsertStatementEnums_ParseProgress_kSeenTargetPath;
  static constexpr ParseProgress kSeenColumnList =
    ASTInsertStatementEnums_ParseProgress_kSeenColumnList;
  static constexpr ParseProgress kSeenValuesList =
    ASTInsertStatementEnums_ParseProgress_kSeenValuesList;
  static inline bool ParseProgress_IsValid(int value) {
    return ASTInsertStatementEnums_ParseProgress_IsValid(value);
  }
  static constexpr ParseProgress ParseProgress_MIN =
    ASTInsertStatementEnums_ParseProgress_ParseProgress_MIN;
  static constexpr ParseProgress ParseProgress_MAX =
    ASTInsertStatementEnums_ParseProgress_ParseProgress_MAX;
  static constexpr int ParseProgress_ARRAYSIZE =
    ASTInsertStatementEnums_ParseProgress_ParseProgress_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ParseProgress_descriptor() {
    return ASTInsertStatementEnums_ParseProgress_descriptor();
  }
  template<typename T>
  static inline const std::string& ParseProgress_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ParseProgress>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ParseProgress_Name.");
    return ASTInsertStatementEnums_ParseProgress_Name(enum_t_value);
  }
  static inline bool ParseProgress_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ParseProgress* value) {
    return ASTInsertStatementEnums_ParseProgress_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTInsertStatementEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTMergeActionEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTMergeActionEnums) */ {
 public:
  inline ASTMergeActionEnums() : ASTMergeActionEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTMergeActionEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTMergeActionEnums(const ASTMergeActionEnums& from);
  ASTMergeActionEnums(ASTMergeActionEnums&& from) noexcept
    : ASTMergeActionEnums() {
    *this = ::std::move(from);
  }

  inline ASTMergeActionEnums& operator=(const ASTMergeActionEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTMergeActionEnums& operator=(ASTMergeActionEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTMergeActionEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTMergeActionEnums* internal_default_instance() {
    return reinterpret_cast<const ASTMergeActionEnums*>(
               &_ASTMergeActionEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ASTMergeActionEnums& a, ASTMergeActionEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTMergeActionEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTMergeActionEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTMergeActionEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTMergeActionEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTMergeActionEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTMergeActionEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTMergeActionEnums";
  }
  protected:
  explicit ASTMergeActionEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTMergeActionEnums_ActionType ActionType;
  static constexpr ActionType NOT_SET =
    ASTMergeActionEnums_ActionType_NOT_SET;
  static constexpr ActionType INSERT =
    ASTMergeActionEnums_ActionType_INSERT;
  static constexpr ActionType UPDATE =
    ASTMergeActionEnums_ActionType_UPDATE;
  static constexpr ActionType DELETE =
    ASTMergeActionEnums_ActionType_DELETE;
  static inline bool ActionType_IsValid(int value) {
    return ASTMergeActionEnums_ActionType_IsValid(value);
  }
  static constexpr ActionType ActionType_MIN =
    ASTMergeActionEnums_ActionType_ActionType_MIN;
  static constexpr ActionType ActionType_MAX =
    ASTMergeActionEnums_ActionType_ActionType_MAX;
  static constexpr int ActionType_ARRAYSIZE =
    ASTMergeActionEnums_ActionType_ActionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ActionType_descriptor() {
    return ASTMergeActionEnums_ActionType_descriptor();
  }
  template<typename T>
  static inline const std::string& ActionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ActionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ActionType_Name.");
    return ASTMergeActionEnums_ActionType_Name(enum_t_value);
  }
  static inline bool ActionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ActionType* value) {
    return ASTMergeActionEnums_ActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTMergeActionEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTMergeWhenClauseEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTMergeWhenClauseEnums) */ {
 public:
  inline ASTMergeWhenClauseEnums() : ASTMergeWhenClauseEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTMergeWhenClauseEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTMergeWhenClauseEnums(const ASTMergeWhenClauseEnums& from);
  ASTMergeWhenClauseEnums(ASTMergeWhenClauseEnums&& from) noexcept
    : ASTMergeWhenClauseEnums() {
    *this = ::std::move(from);
  }

  inline ASTMergeWhenClauseEnums& operator=(const ASTMergeWhenClauseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTMergeWhenClauseEnums& operator=(ASTMergeWhenClauseEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTMergeWhenClauseEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTMergeWhenClauseEnums* internal_default_instance() {
    return reinterpret_cast<const ASTMergeWhenClauseEnums*>(
               &_ASTMergeWhenClauseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ASTMergeWhenClauseEnums& a, ASTMergeWhenClauseEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTMergeWhenClauseEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTMergeWhenClauseEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTMergeWhenClauseEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTMergeWhenClauseEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTMergeWhenClauseEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTMergeWhenClauseEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTMergeWhenClauseEnums";
  }
  protected:
  explicit ASTMergeWhenClauseEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTMergeWhenClauseEnums_MatchType MatchType;
  static constexpr MatchType NOT_SET =
    ASTMergeWhenClauseEnums_MatchType_NOT_SET;
  static constexpr MatchType MATCHED =
    ASTMergeWhenClauseEnums_MatchType_MATCHED;
  static constexpr MatchType NOT_MATCHED_BY_SOURCE =
    ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_SOURCE;
  static constexpr MatchType NOT_MATCHED_BY_TARGET =
    ASTMergeWhenClauseEnums_MatchType_NOT_MATCHED_BY_TARGET;
  static inline bool MatchType_IsValid(int value) {
    return ASTMergeWhenClauseEnums_MatchType_IsValid(value);
  }
  static constexpr MatchType MatchType_MIN =
    ASTMergeWhenClauseEnums_MatchType_MatchType_MIN;
  static constexpr MatchType MatchType_MAX =
    ASTMergeWhenClauseEnums_MatchType_MatchType_MAX;
  static constexpr int MatchType_ARRAYSIZE =
    ASTMergeWhenClauseEnums_MatchType_MatchType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MatchType_descriptor() {
    return ASTMergeWhenClauseEnums_MatchType_descriptor();
  }
  template<typename T>
  static inline const std::string& MatchType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MatchType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MatchType_Name.");
    return ASTMergeWhenClauseEnums_MatchType_Name(enum_t_value);
  }
  static inline bool MatchType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MatchType* value) {
    return ASTMergeWhenClauseEnums_MatchType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTMergeWhenClauseEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTFilterFieldsArgEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTFilterFieldsArgEnums) */ {
 public:
  inline ASTFilterFieldsArgEnums() : ASTFilterFieldsArgEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTFilterFieldsArgEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTFilterFieldsArgEnums(const ASTFilterFieldsArgEnums& from);
  ASTFilterFieldsArgEnums(ASTFilterFieldsArgEnums&& from) noexcept
    : ASTFilterFieldsArgEnums() {
    *this = ::std::move(from);
  }

  inline ASTFilterFieldsArgEnums& operator=(const ASTFilterFieldsArgEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTFilterFieldsArgEnums& operator=(ASTFilterFieldsArgEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTFilterFieldsArgEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTFilterFieldsArgEnums* internal_default_instance() {
    return reinterpret_cast<const ASTFilterFieldsArgEnums*>(
               &_ASTFilterFieldsArgEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ASTFilterFieldsArgEnums& a, ASTFilterFieldsArgEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTFilterFieldsArgEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTFilterFieldsArgEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTFilterFieldsArgEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTFilterFieldsArgEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTFilterFieldsArgEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTFilterFieldsArgEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTFilterFieldsArgEnums";
  }
  protected:
  explicit ASTFilterFieldsArgEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTFilterFieldsArgEnums_FilterType FilterType;
  static constexpr FilterType NOT_SET =
    ASTFilterFieldsArgEnums_FilterType_NOT_SET;
  static constexpr FilterType INCLUDE =
    ASTFilterFieldsArgEnums_FilterType_INCLUDE;
  static constexpr FilterType EXCLUDE =
    ASTFilterFieldsArgEnums_FilterType_EXCLUDE;
  static inline bool FilterType_IsValid(int value) {
    return ASTFilterFieldsArgEnums_FilterType_IsValid(value);
  }
  static constexpr FilterType FilterType_MIN =
    ASTFilterFieldsArgEnums_FilterType_FilterType_MIN;
  static constexpr FilterType FilterType_MAX =
    ASTFilterFieldsArgEnums_FilterType_FilterType_MAX;
  static constexpr int FilterType_ARRAYSIZE =
    ASTFilterFieldsArgEnums_FilterType_FilterType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FilterType_descriptor() {
    return ASTFilterFieldsArgEnums_FilterType_descriptor();
  }
  template<typename T>
  static inline const std::string& FilterType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FilterType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FilterType_Name.");
    return ASTFilterFieldsArgEnums_FilterType_Name(enum_t_value);
  }
  static inline bool FilterType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FilterType* value) {
    return ASTFilterFieldsArgEnums_FilterType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTFilterFieldsArgEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTSampleSizeEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTSampleSizeEnums) */ {
 public:
  inline ASTSampleSizeEnums() : ASTSampleSizeEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTSampleSizeEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTSampleSizeEnums(const ASTSampleSizeEnums& from);
  ASTSampleSizeEnums(ASTSampleSizeEnums&& from) noexcept
    : ASTSampleSizeEnums() {
    *this = ::std::move(from);
  }

  inline ASTSampleSizeEnums& operator=(const ASTSampleSizeEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTSampleSizeEnums& operator=(ASTSampleSizeEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTSampleSizeEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTSampleSizeEnums* internal_default_instance() {
    return reinterpret_cast<const ASTSampleSizeEnums*>(
               &_ASTSampleSizeEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ASTSampleSizeEnums& a, ASTSampleSizeEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTSampleSizeEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTSampleSizeEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTSampleSizeEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTSampleSizeEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTSampleSizeEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTSampleSizeEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTSampleSizeEnums";
  }
  protected:
  explicit ASTSampleSizeEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTSampleSizeEnums_Unit Unit;
  static constexpr Unit NOT_SET =
    ASTSampleSizeEnums_Unit_NOT_SET;
  static constexpr Unit ROWS =
    ASTSampleSizeEnums_Unit_ROWS;
  static constexpr Unit PERCENT =
    ASTSampleSizeEnums_Unit_PERCENT;
  static inline bool Unit_IsValid(int value) {
    return ASTSampleSizeEnums_Unit_IsValid(value);
  }
  static constexpr Unit Unit_MIN =
    ASTSampleSizeEnums_Unit_Unit_MIN;
  static constexpr Unit Unit_MAX =
    ASTSampleSizeEnums_Unit_Unit_MAX;
  static constexpr int Unit_ARRAYSIZE =
    ASTSampleSizeEnums_Unit_Unit_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Unit_descriptor() {
    return ASTSampleSizeEnums_Unit_descriptor();
  }
  template<typename T>
  static inline const std::string& Unit_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Unit>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Unit_Name.");
    return ASTSampleSizeEnums_Unit_Name(enum_t_value);
  }
  static inline bool Unit_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Unit* value) {
    return ASTSampleSizeEnums_Unit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTSampleSizeEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTForeignKeyActionsEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTForeignKeyActionsEnums) */ {
 public:
  inline ASTForeignKeyActionsEnums() : ASTForeignKeyActionsEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTForeignKeyActionsEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTForeignKeyActionsEnums(const ASTForeignKeyActionsEnums& from);
  ASTForeignKeyActionsEnums(ASTForeignKeyActionsEnums&& from) noexcept
    : ASTForeignKeyActionsEnums() {
    *this = ::std::move(from);
  }

  inline ASTForeignKeyActionsEnums& operator=(const ASTForeignKeyActionsEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTForeignKeyActionsEnums& operator=(ASTForeignKeyActionsEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTForeignKeyActionsEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTForeignKeyActionsEnums* internal_default_instance() {
    return reinterpret_cast<const ASTForeignKeyActionsEnums*>(
               &_ASTForeignKeyActionsEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ASTForeignKeyActionsEnums& a, ASTForeignKeyActionsEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTForeignKeyActionsEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTForeignKeyActionsEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTForeignKeyActionsEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTForeignKeyActionsEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTForeignKeyActionsEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTForeignKeyActionsEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTForeignKeyActionsEnums";
  }
  protected:
  explicit ASTForeignKeyActionsEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTForeignKeyActionsEnums_Action Action;
  static constexpr Action NO_ACTION =
    ASTForeignKeyActionsEnums_Action_NO_ACTION;
  static constexpr Action RESTRICT =
    ASTForeignKeyActionsEnums_Action_RESTRICT;
  static constexpr Action CASCADE =
    ASTForeignKeyActionsEnums_Action_CASCADE;
  static constexpr Action SET_NULL =
    ASTForeignKeyActionsEnums_Action_SET_NULL;
  static inline bool Action_IsValid(int value) {
    return ASTForeignKeyActionsEnums_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    ASTForeignKeyActionsEnums_Action_Action_MIN;
  static constexpr Action Action_MAX =
    ASTForeignKeyActionsEnums_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    ASTForeignKeyActionsEnums_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return ASTForeignKeyActionsEnums_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return ASTForeignKeyActionsEnums_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return ASTForeignKeyActionsEnums_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTForeignKeyActionsEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTForeignKeyReferenceEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTForeignKeyReferenceEnums) */ {
 public:
  inline ASTForeignKeyReferenceEnums() : ASTForeignKeyReferenceEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTForeignKeyReferenceEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTForeignKeyReferenceEnums(const ASTForeignKeyReferenceEnums& from);
  ASTForeignKeyReferenceEnums(ASTForeignKeyReferenceEnums&& from) noexcept
    : ASTForeignKeyReferenceEnums() {
    *this = ::std::move(from);
  }

  inline ASTForeignKeyReferenceEnums& operator=(const ASTForeignKeyReferenceEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTForeignKeyReferenceEnums& operator=(ASTForeignKeyReferenceEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTForeignKeyReferenceEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTForeignKeyReferenceEnums* internal_default_instance() {
    return reinterpret_cast<const ASTForeignKeyReferenceEnums*>(
               &_ASTForeignKeyReferenceEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ASTForeignKeyReferenceEnums& a, ASTForeignKeyReferenceEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTForeignKeyReferenceEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTForeignKeyReferenceEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTForeignKeyReferenceEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTForeignKeyReferenceEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTForeignKeyReferenceEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTForeignKeyReferenceEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTForeignKeyReferenceEnums";
  }
  protected:
  explicit ASTForeignKeyReferenceEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTForeignKeyReferenceEnums_Match Match;
  static constexpr Match SIMPLE =
    ASTForeignKeyReferenceEnums_Match_SIMPLE;
  static constexpr Match FULL =
    ASTForeignKeyReferenceEnums_Match_FULL;
  static constexpr Match NOT_DISTINCT =
    ASTForeignKeyReferenceEnums_Match_NOT_DISTINCT;
  static inline bool Match_IsValid(int value) {
    return ASTForeignKeyReferenceEnums_Match_IsValid(value);
  }
  static constexpr Match Match_MIN =
    ASTForeignKeyReferenceEnums_Match_Match_MIN;
  static constexpr Match Match_MAX =
    ASTForeignKeyReferenceEnums_Match_Match_MAX;
  static constexpr int Match_ARRAYSIZE =
    ASTForeignKeyReferenceEnums_Match_Match_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Match_descriptor() {
    return ASTForeignKeyReferenceEnums_Match_descriptor();
  }
  template<typename T>
  static inline const std::string& Match_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Match>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Match_Name.");
    return ASTForeignKeyReferenceEnums_Match_Name(enum_t_value);
  }
  static inline bool Match_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Match* value) {
    return ASTForeignKeyReferenceEnums_Match_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTForeignKeyReferenceEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTBreakContinueStatementEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTBreakContinueStatementEnums) */ {
 public:
  inline ASTBreakContinueStatementEnums() : ASTBreakContinueStatementEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTBreakContinueStatementEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTBreakContinueStatementEnums(const ASTBreakContinueStatementEnums& from);
  ASTBreakContinueStatementEnums(ASTBreakContinueStatementEnums&& from) noexcept
    : ASTBreakContinueStatementEnums() {
    *this = ::std::move(from);
  }

  inline ASTBreakContinueStatementEnums& operator=(const ASTBreakContinueStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTBreakContinueStatementEnums& operator=(ASTBreakContinueStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTBreakContinueStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTBreakContinueStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTBreakContinueStatementEnums*>(
               &_ASTBreakContinueStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ASTBreakContinueStatementEnums& a, ASTBreakContinueStatementEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTBreakContinueStatementEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTBreakContinueStatementEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTBreakContinueStatementEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTBreakContinueStatementEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTBreakContinueStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTBreakContinueStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTBreakContinueStatementEnums";
  }
  protected:
  explicit ASTBreakContinueStatementEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTBreakContinueStatementEnums_BreakContinueKeyword BreakContinueKeyword;
  static constexpr BreakContinueKeyword BREAK =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_BREAK;
  static constexpr BreakContinueKeyword LEAVE =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_LEAVE;
  static constexpr BreakContinueKeyword CONTINUE =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_CONTINUE;
  static constexpr BreakContinueKeyword ITERATE =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_ITERATE;
  static inline bool BreakContinueKeyword_IsValid(int value) {
    return ASTBreakContinueStatementEnums_BreakContinueKeyword_IsValid(value);
  }
  static constexpr BreakContinueKeyword BreakContinueKeyword_MIN =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MIN;
  static constexpr BreakContinueKeyword BreakContinueKeyword_MAX =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_MAX;
  static constexpr int BreakContinueKeyword_ARRAYSIZE =
    ASTBreakContinueStatementEnums_BreakContinueKeyword_BreakContinueKeyword_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BreakContinueKeyword_descriptor() {
    return ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor();
  }
  template<typename T>
  static inline const std::string& BreakContinueKeyword_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BreakContinueKeyword>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BreakContinueKeyword_Name.");
    return ASTBreakContinueStatementEnums_BreakContinueKeyword_Name(enum_t_value);
  }
  static inline bool BreakContinueKeyword_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BreakContinueKeyword* value) {
    return ASTBreakContinueStatementEnums_BreakContinueKeyword_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTBreakContinueStatementEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTDropStatementEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTDropStatementEnums) */ {
 public:
  inline ASTDropStatementEnums() : ASTDropStatementEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTDropStatementEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTDropStatementEnums(const ASTDropStatementEnums& from);
  ASTDropStatementEnums(ASTDropStatementEnums&& from) noexcept
    : ASTDropStatementEnums() {
    *this = ::std::move(from);
  }

  inline ASTDropStatementEnums& operator=(const ASTDropStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTDropStatementEnums& operator=(ASTDropStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTDropStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTDropStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTDropStatementEnums*>(
               &_ASTDropStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ASTDropStatementEnums& a, ASTDropStatementEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTDropStatementEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTDropStatementEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTDropStatementEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTDropStatementEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTDropStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTDropStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTDropStatementEnums";
  }
  protected:
  explicit ASTDropStatementEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTDropStatementEnums_DropMode DropMode;
  static constexpr DropMode DROP_MODE_UNSPECIFIED =
    ASTDropStatementEnums_DropMode_DROP_MODE_UNSPECIFIED;
  static constexpr DropMode RESTRICT =
    ASTDropStatementEnums_DropMode_RESTRICT;
  static constexpr DropMode CASCADE =
    ASTDropStatementEnums_DropMode_CASCADE;
  static inline bool DropMode_IsValid(int value) {
    return ASTDropStatementEnums_DropMode_IsValid(value);
  }
  static constexpr DropMode DropMode_MIN =
    ASTDropStatementEnums_DropMode_DropMode_MIN;
  static constexpr DropMode DropMode_MAX =
    ASTDropStatementEnums_DropMode_DropMode_MAX;
  static constexpr int DropMode_ARRAYSIZE =
    ASTDropStatementEnums_DropMode_DropMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DropMode_descriptor() {
    return ASTDropStatementEnums_DropMode_descriptor();
  }
  template<typename T>
  static inline const std::string& DropMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DropMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DropMode_Name.");
    return ASTDropStatementEnums_DropMode_Name(enum_t_value);
  }
  static inline bool DropMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DropMode* value) {
    return ASTDropStatementEnums_DropMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTDropStatementEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTCreateFunctionStmtBaseEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTCreateFunctionStmtBaseEnums) */ {
 public:
  inline ASTCreateFunctionStmtBaseEnums() : ASTCreateFunctionStmtBaseEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTCreateFunctionStmtBaseEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTCreateFunctionStmtBaseEnums(const ASTCreateFunctionStmtBaseEnums& from);
  ASTCreateFunctionStmtBaseEnums(ASTCreateFunctionStmtBaseEnums&& from) noexcept
    : ASTCreateFunctionStmtBaseEnums() {
    *this = ::std::move(from);
  }

  inline ASTCreateFunctionStmtBaseEnums& operator=(const ASTCreateFunctionStmtBaseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTCreateFunctionStmtBaseEnums& operator=(ASTCreateFunctionStmtBaseEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTCreateFunctionStmtBaseEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTCreateFunctionStmtBaseEnums* internal_default_instance() {
    return reinterpret_cast<const ASTCreateFunctionStmtBaseEnums*>(
               &_ASTCreateFunctionStmtBaseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ASTCreateFunctionStmtBaseEnums& a, ASTCreateFunctionStmtBaseEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTCreateFunctionStmtBaseEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTCreateFunctionStmtBaseEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTCreateFunctionStmtBaseEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTCreateFunctionStmtBaseEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTCreateFunctionStmtBaseEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTCreateFunctionStmtBaseEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTCreateFunctionStmtBaseEnums";
  }
  protected:
  explicit ASTCreateFunctionStmtBaseEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTCreateFunctionStmtBaseEnums_DeterminismLevel DeterminismLevel;
  static constexpr DeterminismLevel DETERMINISM_UNSPECIFIED =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISM_UNSPECIFIED;
  static constexpr DeterminismLevel DETERMINISTIC =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DETERMINISTIC;
  static constexpr DeterminismLevel NOT_DETERMINISTIC =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_NOT_DETERMINISTIC;
  static constexpr DeterminismLevel IMMUTABLE =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_IMMUTABLE;
  static constexpr DeterminismLevel STABLE =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_STABLE;
  static constexpr DeterminismLevel VOLATILE =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_VOLATILE;
  static inline bool DeterminismLevel_IsValid(int value) {
    return ASTCreateFunctionStmtBaseEnums_DeterminismLevel_IsValid(value);
  }
  static constexpr DeterminismLevel DeterminismLevel_MIN =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MIN;
  static constexpr DeterminismLevel DeterminismLevel_MAX =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_MAX;
  static constexpr int DeterminismLevel_ARRAYSIZE =
    ASTCreateFunctionStmtBaseEnums_DeterminismLevel_DeterminismLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DeterminismLevel_descriptor() {
    return ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& DeterminismLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DeterminismLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DeterminismLevel_Name.");
    return ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Name(enum_t_value);
  }
  static inline bool DeterminismLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DeterminismLevel* value) {
    return ASTCreateFunctionStmtBaseEnums_DeterminismLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTCreateFunctionStmtBaseEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTAuxLoadDataStatementEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTAuxLoadDataStatementEnums) */ {
 public:
  inline ASTAuxLoadDataStatementEnums() : ASTAuxLoadDataStatementEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTAuxLoadDataStatementEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTAuxLoadDataStatementEnums(const ASTAuxLoadDataStatementEnums& from);
  ASTAuxLoadDataStatementEnums(ASTAuxLoadDataStatementEnums&& from) noexcept
    : ASTAuxLoadDataStatementEnums() {
    *this = ::std::move(from);
  }

  inline ASTAuxLoadDataStatementEnums& operator=(const ASTAuxLoadDataStatementEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTAuxLoadDataStatementEnums& operator=(ASTAuxLoadDataStatementEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTAuxLoadDataStatementEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTAuxLoadDataStatementEnums* internal_default_instance() {
    return reinterpret_cast<const ASTAuxLoadDataStatementEnums*>(
               &_ASTAuxLoadDataStatementEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ASTAuxLoadDataStatementEnums& a, ASTAuxLoadDataStatementEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTAuxLoadDataStatementEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTAuxLoadDataStatementEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTAuxLoadDataStatementEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTAuxLoadDataStatementEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTAuxLoadDataStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTAuxLoadDataStatementEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTAuxLoadDataStatementEnums";
  }
  protected:
  explicit ASTAuxLoadDataStatementEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTAuxLoadDataStatementEnums_InsertionMode InsertionMode;
  static constexpr InsertionMode NOT_SET =
    ASTAuxLoadDataStatementEnums_InsertionMode_NOT_SET;
  static constexpr InsertionMode APPEND =
    ASTAuxLoadDataStatementEnums_InsertionMode_APPEND;
  static constexpr InsertionMode OVERWRITE =
    ASTAuxLoadDataStatementEnums_InsertionMode_OVERWRITE;
  static inline bool InsertionMode_IsValid(int value) {
    return ASTAuxLoadDataStatementEnums_InsertionMode_IsValid(value);
  }
  static constexpr InsertionMode InsertionMode_MIN =
    ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MIN;
  static constexpr InsertionMode InsertionMode_MAX =
    ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_MAX;
  static constexpr int InsertionMode_ARRAYSIZE =
    ASTAuxLoadDataStatementEnums_InsertionMode_InsertionMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InsertionMode_descriptor() {
    return ASTAuxLoadDataStatementEnums_InsertionMode_descriptor();
  }
  template<typename T>
  static inline const std::string& InsertionMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InsertionMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InsertionMode_Name.");
    return ASTAuxLoadDataStatementEnums_InsertionMode_Name(enum_t_value);
  }
  static inline bool InsertionMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InsertionMode* value) {
    return ASTAuxLoadDataStatementEnums_InsertionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTAuxLoadDataStatementEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// -------------------------------------------------------------------

class ASTSpannerInterleaveClauseEnums final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zetasql.ASTSpannerInterleaveClauseEnums) */ {
 public:
  inline ASTSpannerInterleaveClauseEnums() : ASTSpannerInterleaveClauseEnums(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ASTSpannerInterleaveClauseEnums(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASTSpannerInterleaveClauseEnums(const ASTSpannerInterleaveClauseEnums& from);
  ASTSpannerInterleaveClauseEnums(ASTSpannerInterleaveClauseEnums&& from) noexcept
    : ASTSpannerInterleaveClauseEnums() {
    *this = ::std::move(from);
  }

  inline ASTSpannerInterleaveClauseEnums& operator=(const ASTSpannerInterleaveClauseEnums& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASTSpannerInterleaveClauseEnums& operator=(ASTSpannerInterleaveClauseEnums&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASTSpannerInterleaveClauseEnums& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASTSpannerInterleaveClauseEnums* internal_default_instance() {
    return reinterpret_cast<const ASTSpannerInterleaveClauseEnums*>(
               &_ASTSpannerInterleaveClauseEnums_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ASTSpannerInterleaveClauseEnums& a, ASTSpannerInterleaveClauseEnums& b) {
    a.Swap(&b);
  }
  inline void Swap(ASTSpannerInterleaveClauseEnums* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASTSpannerInterleaveClauseEnums* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASTSpannerInterleaveClauseEnums* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASTSpannerInterleaveClauseEnums>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ASTSpannerInterleaveClauseEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ASTSpannerInterleaveClauseEnums& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zetasql.ASTSpannerInterleaveClauseEnums";
  }
  protected:
  explicit ASTSpannerInterleaveClauseEnums(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ASTSpannerInterleaveClauseEnums_Type Type;
  static constexpr Type NOT_SET =
    ASTSpannerInterleaveClauseEnums_Type_NOT_SET;
  static constexpr Type IN =
    ASTSpannerInterleaveClauseEnums_Type_IN;
  static constexpr Type IN_PARENT =
    ASTSpannerInterleaveClauseEnums_Type_IN_PARENT;
  static inline bool Type_IsValid(int value) {
    return ASTSpannerInterleaveClauseEnums_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ASTSpannerInterleaveClauseEnums_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ASTSpannerInterleaveClauseEnums_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ASTSpannerInterleaveClauseEnums_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ASTSpannerInterleaveClauseEnums_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ASTSpannerInterleaveClauseEnums_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ASTSpannerInterleaveClauseEnums_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zetasql.ASTSpannerInterleaveClauseEnums)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_zetasql_2fparser_2fast_5fenums_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ASTBinaryExpressionEnums

// -------------------------------------------------------------------

// ASTOrderingExpressionEnums

// -------------------------------------------------------------------

// ASTJoinEnums

// -------------------------------------------------------------------

// ASTSelectAsEnums

// -------------------------------------------------------------------

// ASTFunctionCallEnums

// -------------------------------------------------------------------

// ASTExpressionSubqueryEnums

// -------------------------------------------------------------------

// ASTHavingModifierEnums

// -------------------------------------------------------------------

// ASTSetOperationEnums

// -------------------------------------------------------------------

// ASTUnaryExpressionEnums

// -------------------------------------------------------------------

// ASTWindowFrameEnums

// -------------------------------------------------------------------

// ASTWindowFrameExprEnums

// -------------------------------------------------------------------

// ASTAnySomeAllOpEnums

// -------------------------------------------------------------------

// ASTTransactionReadWriteModeEnums

// -------------------------------------------------------------------

// ASTImportStatementEnums

// -------------------------------------------------------------------

// ASTUnpivotClauseEnums

// -------------------------------------------------------------------

// ASTCreateStatementEnums

// -------------------------------------------------------------------

// ASTFunctionParameterEnums

// -------------------------------------------------------------------

// ASTTemplatedParameterTypeEnums

// -------------------------------------------------------------------

// ASTGeneratedColumnInfoEnums

// -------------------------------------------------------------------

// ASTColumnPositionEnums

// -------------------------------------------------------------------

// ASTInsertStatementEnums

// -------------------------------------------------------------------

// ASTMergeActionEnums

// -------------------------------------------------------------------

// ASTMergeWhenClauseEnums

// -------------------------------------------------------------------

// ASTFilterFieldsArgEnums

// -------------------------------------------------------------------

// ASTSampleSizeEnums

// -------------------------------------------------------------------

// ASTForeignKeyActionsEnums

// -------------------------------------------------------------------

// ASTForeignKeyReferenceEnums

// -------------------------------------------------------------------

// ASTBreakContinueStatementEnums

// -------------------------------------------------------------------

// ASTDropStatementEnums

// -------------------------------------------------------------------

// ASTCreateFunctionStmtBaseEnums

// -------------------------------------------------------------------

// ASTAuxLoadDataStatementEnums

// -------------------------------------------------------------------

// ASTSpannerInterleaveClauseEnums

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zetasql

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zetasql::ASTBinaryExpressionEnums_Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTBinaryExpressionEnums_Op>() {
  return ::zetasql::ASTBinaryExpressionEnums_Op_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTOrderingExpressionEnums_OrderingSpec> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTOrderingExpressionEnums_OrderingSpec>() {
  return ::zetasql::ASTOrderingExpressionEnums_OrderingSpec_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTJoinEnums_JoinType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTJoinEnums_JoinType>() {
  return ::zetasql::ASTJoinEnums_JoinType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTJoinEnums_JoinHint> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTJoinEnums_JoinHint>() {
  return ::zetasql::ASTJoinEnums_JoinHint_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTSelectAsEnums_AsMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTSelectAsEnums_AsMode>() {
  return ::zetasql::ASTSelectAsEnums_AsMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTFunctionCallEnums_NullHandlingModifier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTFunctionCallEnums_NullHandlingModifier>() {
  return ::zetasql::ASTFunctionCallEnums_NullHandlingModifier_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTExpressionSubqueryEnums_Modifier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTExpressionSubqueryEnums_Modifier>() {
  return ::zetasql::ASTExpressionSubqueryEnums_Modifier_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTHavingModifierEnums_ModifierKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTHavingModifierEnums_ModifierKind>() {
  return ::zetasql::ASTHavingModifierEnums_ModifierKind_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTSetOperationEnums_OperationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTSetOperationEnums_OperationType>() {
  return ::zetasql::ASTSetOperationEnums_OperationType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTUnaryExpressionEnums_Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTUnaryExpressionEnums_Op>() {
  return ::zetasql::ASTUnaryExpressionEnums_Op_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTWindowFrameEnums_FrameUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTWindowFrameEnums_FrameUnit>() {
  return ::zetasql::ASTWindowFrameEnums_FrameUnit_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTWindowFrameExprEnums_BoundaryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTWindowFrameExprEnums_BoundaryType>() {
  return ::zetasql::ASTWindowFrameExprEnums_BoundaryType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTAnySomeAllOpEnums_Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTAnySomeAllOpEnums_Op>() {
  return ::zetasql::ASTAnySomeAllOpEnums_Op_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTTransactionReadWriteModeEnums_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTTransactionReadWriteModeEnums_Mode>() {
  return ::zetasql::ASTTransactionReadWriteModeEnums_Mode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTImportStatementEnums_ImportKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTImportStatementEnums_ImportKind>() {
  return ::zetasql::ASTImportStatementEnums_ImportKind_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTUnpivotClauseEnums_NullFilter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTUnpivotClauseEnums_NullFilter>() {
  return ::zetasql::ASTUnpivotClauseEnums_NullFilter_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTCreateStatementEnums_Scope> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTCreateStatementEnums_Scope>() {
  return ::zetasql::ASTCreateStatementEnums_Scope_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTCreateStatementEnums_SqlSecurity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTCreateStatementEnums_SqlSecurity>() {
  return ::zetasql::ASTCreateStatementEnums_SqlSecurity_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTFunctionParameterEnums_ProcedureParameterMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTFunctionParameterEnums_ProcedureParameterMode>() {
  return ::zetasql::ASTFunctionParameterEnums_ProcedureParameterMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTTemplatedParameterTypeEnums_TemplatedTypeKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTTemplatedParameterTypeEnums_TemplatedTypeKind>() {
  return ::zetasql::ASTTemplatedParameterTypeEnums_TemplatedTypeKind_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTGeneratedColumnInfoEnums_StoredMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTGeneratedColumnInfoEnums_StoredMode>() {
  return ::zetasql::ASTGeneratedColumnInfoEnums_StoredMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTColumnPositionEnums_RelativePositionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTColumnPositionEnums_RelativePositionType>() {
  return ::zetasql::ASTColumnPositionEnums_RelativePositionType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTInsertStatementEnums_InsertMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTInsertStatementEnums_InsertMode>() {
  return ::zetasql::ASTInsertStatementEnums_InsertMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTInsertStatementEnums_ParseProgress> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTInsertStatementEnums_ParseProgress>() {
  return ::zetasql::ASTInsertStatementEnums_ParseProgress_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTMergeActionEnums_ActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTMergeActionEnums_ActionType>() {
  return ::zetasql::ASTMergeActionEnums_ActionType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTMergeWhenClauseEnums_MatchType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTMergeWhenClauseEnums_MatchType>() {
  return ::zetasql::ASTMergeWhenClauseEnums_MatchType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTFilterFieldsArgEnums_FilterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTFilterFieldsArgEnums_FilterType>() {
  return ::zetasql::ASTFilterFieldsArgEnums_FilterType_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTSampleSizeEnums_Unit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTSampleSizeEnums_Unit>() {
  return ::zetasql::ASTSampleSizeEnums_Unit_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTForeignKeyActionsEnums_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTForeignKeyActionsEnums_Action>() {
  return ::zetasql::ASTForeignKeyActionsEnums_Action_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTForeignKeyReferenceEnums_Match> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTForeignKeyReferenceEnums_Match>() {
  return ::zetasql::ASTForeignKeyReferenceEnums_Match_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTBreakContinueStatementEnums_BreakContinueKeyword> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTBreakContinueStatementEnums_BreakContinueKeyword>() {
  return ::zetasql::ASTBreakContinueStatementEnums_BreakContinueKeyword_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTDropStatementEnums_DropMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTDropStatementEnums_DropMode>() {
  return ::zetasql::ASTDropStatementEnums_DropMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTCreateFunctionStmtBaseEnums_DeterminismLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTCreateFunctionStmtBaseEnums_DeterminismLevel>() {
  return ::zetasql::ASTCreateFunctionStmtBaseEnums_DeterminismLevel_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTAuxLoadDataStatementEnums_InsertionMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTAuxLoadDataStatementEnums_InsertionMode>() {
  return ::zetasql::ASTAuxLoadDataStatementEnums_InsertionMode_descriptor();
}
template <> struct is_proto_enum< ::zetasql::ASTSpannerInterleaveClauseEnums_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::ASTSpannerInterleaveClauseEnums_Type>() {
  return ::zetasql::ASTSpannerInterleaveClauseEnums_Type_descriptor();
}
template <> struct is_proto_enum< ::zetasql::SchemaObjectKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zetasql::SchemaObjectKind>() {
  return ::zetasql::SchemaObjectKind_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_zetasql_2fparser_2fast_5fenums_2eproto
