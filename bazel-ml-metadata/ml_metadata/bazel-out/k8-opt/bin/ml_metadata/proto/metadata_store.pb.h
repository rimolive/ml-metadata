// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ml_metadata/proto/metadata_store.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/descriptor.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
namespace ml_metadata {
class AnyArtifactStructType;
struct AnyArtifactStructTypeDefaultTypeInternal;
extern AnyArtifactStructTypeDefaultTypeInternal _AnyArtifactStructType_default_instance_;
class Artifact;
struct ArtifactDefaultTypeInternal;
extern ArtifactDefaultTypeInternal _Artifact_default_instance_;
class ArtifactStructType;
struct ArtifactStructTypeDefaultTypeInternal;
extern ArtifactStructTypeDefaultTypeInternal _ArtifactStructType_default_instance_;
class ArtifactType;
struct ArtifactTypeDefaultTypeInternal;
extern ArtifactTypeDefaultTypeInternal _ArtifactType_default_instance_;
class ArtifactType_PropertiesEntry_DoNotUse;
struct ArtifactType_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern ArtifactType_PropertiesEntry_DoNotUseDefaultTypeInternal _ArtifactType_PropertiesEntry_DoNotUse_default_instance_;
class Artifact_CustomPropertiesEntry_DoNotUse;
struct Artifact_CustomPropertiesEntry_DoNotUseDefaultTypeInternal;
extern Artifact_CustomPropertiesEntry_DoNotUseDefaultTypeInternal _Artifact_CustomPropertiesEntry_DoNotUse_default_instance_;
class Artifact_PropertiesEntry_DoNotUse;
struct Artifact_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern Artifact_PropertiesEntry_DoNotUseDefaultTypeInternal _Artifact_PropertiesEntry_DoNotUse_default_instance_;
class Association;
struct AssociationDefaultTypeInternal;
extern AssociationDefaultTypeInternal _Association_default_instance_;
class Attribution;
struct AttributionDefaultTypeInternal;
extern AttributionDefaultTypeInternal _Attribution_default_instance_;
class ConnectionConfig;
struct ConnectionConfigDefaultTypeInternal;
extern ConnectionConfigDefaultTypeInternal _ConnectionConfig_default_instance_;
class Context;
struct ContextDefaultTypeInternal;
extern ContextDefaultTypeInternal _Context_default_instance_;
class ContextType;
struct ContextTypeDefaultTypeInternal;
extern ContextTypeDefaultTypeInternal _ContextType_default_instance_;
class ContextType_PropertiesEntry_DoNotUse;
struct ContextType_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern ContextType_PropertiesEntry_DoNotUseDefaultTypeInternal _ContextType_PropertiesEntry_DoNotUse_default_instance_;
class Context_CustomPropertiesEntry_DoNotUse;
struct Context_CustomPropertiesEntry_DoNotUseDefaultTypeInternal;
extern Context_CustomPropertiesEntry_DoNotUseDefaultTypeInternal _Context_CustomPropertiesEntry_DoNotUse_default_instance_;
class Context_PropertiesEntry_DoNotUse;
struct Context_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern Context_PropertiesEntry_DoNotUseDefaultTypeInternal _Context_PropertiesEntry_DoNotUse_default_instance_;
class DictArtifactStructType;
struct DictArtifactStructTypeDefaultTypeInternal;
extern DictArtifactStructTypeDefaultTypeInternal _DictArtifactStructType_default_instance_;
class DictArtifactStructType_PropertiesEntry_DoNotUse;
struct DictArtifactStructType_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern DictArtifactStructType_PropertiesEntry_DoNotUseDefaultTypeInternal _DictArtifactStructType_PropertiesEntry_DoNotUse_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Event_Path;
struct Event_PathDefaultTypeInternal;
extern Event_PathDefaultTypeInternal _Event_Path_default_instance_;
class Event_Path_Step;
struct Event_Path_StepDefaultTypeInternal;
extern Event_Path_StepDefaultTypeInternal _Event_Path_Step_default_instance_;
class Execution;
struct ExecutionDefaultTypeInternal;
extern ExecutionDefaultTypeInternal _Execution_default_instance_;
class ExecutionType;
struct ExecutionTypeDefaultTypeInternal;
extern ExecutionTypeDefaultTypeInternal _ExecutionType_default_instance_;
class ExecutionType_PropertiesEntry_DoNotUse;
struct ExecutionType_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern ExecutionType_PropertiesEntry_DoNotUseDefaultTypeInternal _ExecutionType_PropertiesEntry_DoNotUse_default_instance_;
class Execution_CustomPropertiesEntry_DoNotUse;
struct Execution_CustomPropertiesEntry_DoNotUseDefaultTypeInternal;
extern Execution_CustomPropertiesEntry_DoNotUseDefaultTypeInternal _Execution_CustomPropertiesEntry_DoNotUse_default_instance_;
class Execution_PropertiesEntry_DoNotUse;
struct Execution_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern Execution_PropertiesEntry_DoNotUseDefaultTypeInternal _Execution_PropertiesEntry_DoNotUse_default_instance_;
class FakeDatabaseConfig;
struct FakeDatabaseConfigDefaultTypeInternal;
extern FakeDatabaseConfigDefaultTypeInternal _FakeDatabaseConfig_default_instance_;
class GrpcChannelArguments;
struct GrpcChannelArgumentsDefaultTypeInternal;
extern GrpcChannelArgumentsDefaultTypeInternal _GrpcChannelArguments_default_instance_;
class IntersectionArtifactStructType;
struct IntersectionArtifactStructTypeDefaultTypeInternal;
extern IntersectionArtifactStructTypeDefaultTypeInternal _IntersectionArtifactStructType_default_instance_;
class LineageGraph;
struct LineageGraphDefaultTypeInternal;
extern LineageGraphDefaultTypeInternal _LineageGraph_default_instance_;
class LineageGraphQueryOptions;
struct LineageGraphQueryOptionsDefaultTypeInternal;
extern LineageGraphQueryOptionsDefaultTypeInternal _LineageGraphQueryOptions_default_instance_;
class LineageGraphQueryOptions_BoundaryConstraint;
struct LineageGraphQueryOptions_BoundaryConstraintDefaultTypeInternal;
extern LineageGraphQueryOptions_BoundaryConstraintDefaultTypeInternal _LineageGraphQueryOptions_BoundaryConstraint_default_instance_;
class LineageSubgraphQueryOptions;
struct LineageSubgraphQueryOptionsDefaultTypeInternal;
extern LineageSubgraphQueryOptionsDefaultTypeInternal _LineageSubgraphQueryOptions_default_instance_;
class LineageSubgraphQueryOptions_EndingNodes;
struct LineageSubgraphQueryOptions_EndingNodesDefaultTypeInternal;
extern LineageSubgraphQueryOptions_EndingNodesDefaultTypeInternal _LineageSubgraphQueryOptions_EndingNodes_default_instance_;
class LineageSubgraphQueryOptions_StartingNodes;
struct LineageSubgraphQueryOptions_StartingNodesDefaultTypeInternal;
extern LineageSubgraphQueryOptions_StartingNodesDefaultTypeInternal _LineageSubgraphQueryOptions_StartingNodes_default_instance_;
class ListArtifactStructType;
struct ListArtifactStructTypeDefaultTypeInternal;
extern ListArtifactStructTypeDefaultTypeInternal _ListArtifactStructType_default_instance_;
class ListOperationNextPageToken;
struct ListOperationNextPageTokenDefaultTypeInternal;
extern ListOperationNextPageTokenDefaultTypeInternal _ListOperationNextPageToken_default_instance_;
class ListOperationOptions;
struct ListOperationOptionsDefaultTypeInternal;
extern ListOperationOptionsDefaultTypeInternal _ListOperationOptions_default_instance_;
class ListOperationOptions_OrderByField;
struct ListOperationOptions_OrderByFieldDefaultTypeInternal;
extern ListOperationOptions_OrderByFieldDefaultTypeInternal _ListOperationOptions_OrderByField_default_instance_;
class MetadataStoreClientConfig;
struct MetadataStoreClientConfigDefaultTypeInternal;
extern MetadataStoreClientConfigDefaultTypeInternal _MetadataStoreClientConfig_default_instance_;
class MetadataStoreClientConfig_SSLConfig;
struct MetadataStoreClientConfig_SSLConfigDefaultTypeInternal;
extern MetadataStoreClientConfig_SSLConfigDefaultTypeInternal _MetadataStoreClientConfig_SSLConfig_default_instance_;
class MetadataStoreServerConfig;
struct MetadataStoreServerConfigDefaultTypeInternal;
extern MetadataStoreServerConfigDefaultTypeInternal _MetadataStoreServerConfig_default_instance_;
class MetadataStoreServerConfig_SSLConfig;
struct MetadataStoreServerConfig_SSLConfigDefaultTypeInternal;
extern MetadataStoreServerConfig_SSLConfigDefaultTypeInternal _MetadataStoreServerConfig_SSLConfig_default_instance_;
class MigrationOptions;
struct MigrationOptionsDefaultTypeInternal;
extern MigrationOptionsDefaultTypeInternal _MigrationOptions_default_instance_;
class MySQLDatabaseConfig;
struct MySQLDatabaseConfigDefaultTypeInternal;
extern MySQLDatabaseConfigDefaultTypeInternal _MySQLDatabaseConfig_default_instance_;
class MySQLDatabaseConfig_SSLOptions;
struct MySQLDatabaseConfig_SSLOptionsDefaultTypeInternal;
extern MySQLDatabaseConfig_SSLOptionsDefaultTypeInternal _MySQLDatabaseConfig_SSLOptions_default_instance_;
class NoneArtifactStructType;
struct NoneArtifactStructTypeDefaultTypeInternal;
extern NoneArtifactStructTypeDefaultTypeInternal _NoneArtifactStructType_default_instance_;
class ParentContext;
struct ParentContextDefaultTypeInternal;
extern ParentContextDefaultTypeInternal _ParentContext_default_instance_;
class PostgreSQLDatabaseConfig;
struct PostgreSQLDatabaseConfigDefaultTypeInternal;
extern PostgreSQLDatabaseConfigDefaultTypeInternal _PostgreSQLDatabaseConfig_default_instance_;
class PostgreSQLDatabaseConfig_SSLOptions;
struct PostgreSQLDatabaseConfig_SSLOptionsDefaultTypeInternal;
extern PostgreSQLDatabaseConfig_SSLOptionsDefaultTypeInternal _PostgreSQLDatabaseConfig_SSLOptions_default_instance_;
class RetryOptions;
struct RetryOptionsDefaultTypeInternal;
extern RetryOptionsDefaultTypeInternal _RetryOptions_default_instance_;
class SqliteMetadataSourceConfig;
struct SqliteMetadataSourceConfigDefaultTypeInternal;
extern SqliteMetadataSourceConfigDefaultTypeInternal _SqliteMetadataSourceConfig_default_instance_;
class SystemTypeExtension;
struct SystemTypeExtensionDefaultTypeInternal;
extern SystemTypeExtensionDefaultTypeInternal _SystemTypeExtension_default_instance_;
class TransactionOptions;
struct TransactionOptionsDefaultTypeInternal;
extern TransactionOptionsDefaultTypeInternal _TransactionOptions_default_instance_;
class TupleArtifactStructType;
struct TupleArtifactStructTypeDefaultTypeInternal;
extern TupleArtifactStructTypeDefaultTypeInternal _TupleArtifactStructType_default_instance_;
class UnionArtifactStructType;
struct UnionArtifactStructTypeDefaultTypeInternal;
extern UnionArtifactStructTypeDefaultTypeInternal _UnionArtifactStructType_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
}  // namespace ml_metadata
PROTOBUF_NAMESPACE_OPEN
template<> ::ml_metadata::AnyArtifactStructType* Arena::CreateMaybeMessage<::ml_metadata::AnyArtifactStructType>(Arena*);
template<> ::ml_metadata::Artifact* Arena::CreateMaybeMessage<::ml_metadata::Artifact>(Arena*);
template<> ::ml_metadata::ArtifactStructType* Arena::CreateMaybeMessage<::ml_metadata::ArtifactStructType>(Arena*);
template<> ::ml_metadata::ArtifactType* Arena::CreateMaybeMessage<::ml_metadata::ArtifactType>(Arena*);
template<> ::ml_metadata::ArtifactType_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::ml_metadata::ArtifactType_PropertiesEntry_DoNotUse>(Arena*);
template<> ::ml_metadata::Artifact_CustomPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::ml_metadata::Artifact_CustomPropertiesEntry_DoNotUse>(Arena*);
template<> ::ml_metadata::Artifact_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::ml_metadata::Artifact_PropertiesEntry_DoNotUse>(Arena*);
template<> ::ml_metadata::Association* Arena::CreateMaybeMessage<::ml_metadata::Association>(Arena*);
template<> ::ml_metadata::Attribution* Arena::CreateMaybeMessage<::ml_metadata::Attribution>(Arena*);
template<> ::ml_metadata::ConnectionConfig* Arena::CreateMaybeMessage<::ml_metadata::ConnectionConfig>(Arena*);
template<> ::ml_metadata::Context* Arena::CreateMaybeMessage<::ml_metadata::Context>(Arena*);
template<> ::ml_metadata::ContextType* Arena::CreateMaybeMessage<::ml_metadata::ContextType>(Arena*);
template<> ::ml_metadata::ContextType_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::ml_metadata::ContextType_PropertiesEntry_DoNotUse>(Arena*);
template<> ::ml_metadata::Context_CustomPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::ml_metadata::Context_CustomPropertiesEntry_DoNotUse>(Arena*);
template<> ::ml_metadata::Context_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::ml_metadata::Context_PropertiesEntry_DoNotUse>(Arena*);
template<> ::ml_metadata::DictArtifactStructType* Arena::CreateMaybeMessage<::ml_metadata::DictArtifactStructType>(Arena*);
template<> ::ml_metadata::DictArtifactStructType_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::ml_metadata::DictArtifactStructType_PropertiesEntry_DoNotUse>(Arena*);
template<> ::ml_metadata::Event* Arena::CreateMaybeMessage<::ml_metadata::Event>(Arena*);
template<> ::ml_metadata::Event_Path* Arena::CreateMaybeMessage<::ml_metadata::Event_Path>(Arena*);
template<> ::ml_metadata::Event_Path_Step* Arena::CreateMaybeMessage<::ml_metadata::Event_Path_Step>(Arena*);
template<> ::ml_metadata::Execution* Arena::CreateMaybeMessage<::ml_metadata::Execution>(Arena*);
template<> ::ml_metadata::ExecutionType* Arena::CreateMaybeMessage<::ml_metadata::ExecutionType>(Arena*);
template<> ::ml_metadata::ExecutionType_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::ml_metadata::ExecutionType_PropertiesEntry_DoNotUse>(Arena*);
template<> ::ml_metadata::Execution_CustomPropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::ml_metadata::Execution_CustomPropertiesEntry_DoNotUse>(Arena*);
template<> ::ml_metadata::Execution_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::ml_metadata::Execution_PropertiesEntry_DoNotUse>(Arena*);
template<> ::ml_metadata::FakeDatabaseConfig* Arena::CreateMaybeMessage<::ml_metadata::FakeDatabaseConfig>(Arena*);
template<> ::ml_metadata::GrpcChannelArguments* Arena::CreateMaybeMessage<::ml_metadata::GrpcChannelArguments>(Arena*);
template<> ::ml_metadata::IntersectionArtifactStructType* Arena::CreateMaybeMessage<::ml_metadata::IntersectionArtifactStructType>(Arena*);
template<> ::ml_metadata::LineageGraph* Arena::CreateMaybeMessage<::ml_metadata::LineageGraph>(Arena*);
template<> ::ml_metadata::LineageGraphQueryOptions* Arena::CreateMaybeMessage<::ml_metadata::LineageGraphQueryOptions>(Arena*);
template<> ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* Arena::CreateMaybeMessage<::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint>(Arena*);
template<> ::ml_metadata::LineageSubgraphQueryOptions* Arena::CreateMaybeMessage<::ml_metadata::LineageSubgraphQueryOptions>(Arena*);
template<> ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* Arena::CreateMaybeMessage<::ml_metadata::LineageSubgraphQueryOptions_EndingNodes>(Arena*);
template<> ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* Arena::CreateMaybeMessage<::ml_metadata::LineageSubgraphQueryOptions_StartingNodes>(Arena*);
template<> ::ml_metadata::ListArtifactStructType* Arena::CreateMaybeMessage<::ml_metadata::ListArtifactStructType>(Arena*);
template<> ::ml_metadata::ListOperationNextPageToken* Arena::CreateMaybeMessage<::ml_metadata::ListOperationNextPageToken>(Arena*);
template<> ::ml_metadata::ListOperationOptions* Arena::CreateMaybeMessage<::ml_metadata::ListOperationOptions>(Arena*);
template<> ::ml_metadata::ListOperationOptions_OrderByField* Arena::CreateMaybeMessage<::ml_metadata::ListOperationOptions_OrderByField>(Arena*);
template<> ::ml_metadata::MetadataStoreClientConfig* Arena::CreateMaybeMessage<::ml_metadata::MetadataStoreClientConfig>(Arena*);
template<> ::ml_metadata::MetadataStoreClientConfig_SSLConfig* Arena::CreateMaybeMessage<::ml_metadata::MetadataStoreClientConfig_SSLConfig>(Arena*);
template<> ::ml_metadata::MetadataStoreServerConfig* Arena::CreateMaybeMessage<::ml_metadata::MetadataStoreServerConfig>(Arena*);
template<> ::ml_metadata::MetadataStoreServerConfig_SSLConfig* Arena::CreateMaybeMessage<::ml_metadata::MetadataStoreServerConfig_SSLConfig>(Arena*);
template<> ::ml_metadata::MigrationOptions* Arena::CreateMaybeMessage<::ml_metadata::MigrationOptions>(Arena*);
template<> ::ml_metadata::MySQLDatabaseConfig* Arena::CreateMaybeMessage<::ml_metadata::MySQLDatabaseConfig>(Arena*);
template<> ::ml_metadata::MySQLDatabaseConfig_SSLOptions* Arena::CreateMaybeMessage<::ml_metadata::MySQLDatabaseConfig_SSLOptions>(Arena*);
template<> ::ml_metadata::NoneArtifactStructType* Arena::CreateMaybeMessage<::ml_metadata::NoneArtifactStructType>(Arena*);
template<> ::ml_metadata::ParentContext* Arena::CreateMaybeMessage<::ml_metadata::ParentContext>(Arena*);
template<> ::ml_metadata::PostgreSQLDatabaseConfig* Arena::CreateMaybeMessage<::ml_metadata::PostgreSQLDatabaseConfig>(Arena*);
template<> ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* Arena::CreateMaybeMessage<::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions>(Arena*);
template<> ::ml_metadata::RetryOptions* Arena::CreateMaybeMessage<::ml_metadata::RetryOptions>(Arena*);
template<> ::ml_metadata::SqliteMetadataSourceConfig* Arena::CreateMaybeMessage<::ml_metadata::SqliteMetadataSourceConfig>(Arena*);
template<> ::ml_metadata::SystemTypeExtension* Arena::CreateMaybeMessage<::ml_metadata::SystemTypeExtension>(Arena*);
template<> ::ml_metadata::TransactionOptions* Arena::CreateMaybeMessage<::ml_metadata::TransactionOptions>(Arena*);
template<> ::ml_metadata::TupleArtifactStructType* Arena::CreateMaybeMessage<::ml_metadata::TupleArtifactStructType>(Arena*);
template<> ::ml_metadata::UnionArtifactStructType* Arena::CreateMaybeMessage<::ml_metadata::UnionArtifactStructType>(Arena*);
template<> ::ml_metadata::Value* Arena::CreateMaybeMessage<::ml_metadata::Value>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ml_metadata {

enum Artifact_State : int {
  Artifact_State_UNKNOWN = 0,
  Artifact_State_PENDING = 1,
  Artifact_State_LIVE = 2,
  Artifact_State_MARKED_FOR_DELETION = 3,
  Artifact_State_DELETED = 4,
  Artifact_State_ABANDONED = 5,
  Artifact_State_REFERENCE = 6
};
bool Artifact_State_IsValid(int value);
constexpr Artifact_State Artifact_State_State_MIN = Artifact_State_UNKNOWN;
constexpr Artifact_State Artifact_State_State_MAX = Artifact_State_REFERENCE;
constexpr int Artifact_State_State_ARRAYSIZE = Artifact_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Artifact_State_descriptor();
template<typename T>
inline const std::string& Artifact_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Artifact_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Artifact_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Artifact_State_descriptor(), enum_t_value);
}
inline bool Artifact_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Artifact_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Artifact_State>(
    Artifact_State_descriptor(), name, value);
}
enum ArtifactType_SystemDefinedBaseType : int {
  ArtifactType_SystemDefinedBaseType_UNSET = 0,
  ArtifactType_SystemDefinedBaseType_DATASET = 1,
  ArtifactType_SystemDefinedBaseType_MODEL = 2,
  ArtifactType_SystemDefinedBaseType_METRICS = 3,
  ArtifactType_SystemDefinedBaseType_STATISTICS = 4
};
bool ArtifactType_SystemDefinedBaseType_IsValid(int value);
constexpr ArtifactType_SystemDefinedBaseType ArtifactType_SystemDefinedBaseType_SystemDefinedBaseType_MIN = ArtifactType_SystemDefinedBaseType_UNSET;
constexpr ArtifactType_SystemDefinedBaseType ArtifactType_SystemDefinedBaseType_SystemDefinedBaseType_MAX = ArtifactType_SystemDefinedBaseType_STATISTICS;
constexpr int ArtifactType_SystemDefinedBaseType_SystemDefinedBaseType_ARRAYSIZE = ArtifactType_SystemDefinedBaseType_SystemDefinedBaseType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArtifactType_SystemDefinedBaseType_descriptor();
template<typename T>
inline const std::string& ArtifactType_SystemDefinedBaseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArtifactType_SystemDefinedBaseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArtifactType_SystemDefinedBaseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArtifactType_SystemDefinedBaseType_descriptor(), enum_t_value);
}
inline bool ArtifactType_SystemDefinedBaseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArtifactType_SystemDefinedBaseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArtifactType_SystemDefinedBaseType>(
    ArtifactType_SystemDefinedBaseType_descriptor(), name, value);
}
enum Event_Type : int {
  Event_Type_UNKNOWN = 0,
  Event_Type_DECLARED_OUTPUT = 1,
  Event_Type_DECLARED_INPUT = 2,
  Event_Type_INPUT = 3,
  Event_Type_OUTPUT = 4,
  Event_Type_INTERNAL_INPUT = 5,
  Event_Type_INTERNAL_OUTPUT = 6,
  Event_Type_PENDING_OUTPUT = 7
};
bool Event_Type_IsValid(int value);
constexpr Event_Type Event_Type_Type_MIN = Event_Type_UNKNOWN;
constexpr Event_Type Event_Type_Type_MAX = Event_Type_PENDING_OUTPUT;
constexpr int Event_Type_Type_ARRAYSIZE = Event_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Event_Type_descriptor();
template<typename T>
inline const std::string& Event_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Event_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Event_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Event_Type_descriptor(), enum_t_value);
}
inline bool Event_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Event_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Event_Type>(
    Event_Type_descriptor(), name, value);
}
enum Execution_State : int {
  Execution_State_UNKNOWN = 0,
  Execution_State_NEW = 1,
  Execution_State_RUNNING = 2,
  Execution_State_COMPLETE = 3,
  Execution_State_FAILED = 4,
  Execution_State_CACHED = 5,
  Execution_State_CANCELED = 6
};
bool Execution_State_IsValid(int value);
constexpr Execution_State Execution_State_State_MIN = Execution_State_UNKNOWN;
constexpr Execution_State Execution_State_State_MAX = Execution_State_CANCELED;
constexpr int Execution_State_State_ARRAYSIZE = Execution_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Execution_State_descriptor();
template<typename T>
inline const std::string& Execution_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Execution_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Execution_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Execution_State_descriptor(), enum_t_value);
}
inline bool Execution_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Execution_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Execution_State>(
    Execution_State_descriptor(), name, value);
}
enum ExecutionType_SystemDefinedBaseType : int {
  ExecutionType_SystemDefinedBaseType_UNSET = 0,
  ExecutionType_SystemDefinedBaseType_TRAIN = 1,
  ExecutionType_SystemDefinedBaseType_TRANSFORM = 2,
  ExecutionType_SystemDefinedBaseType_PROCESS = 3,
  ExecutionType_SystemDefinedBaseType_EVALUATE = 4,
  ExecutionType_SystemDefinedBaseType_DEPLOY = 5
};
bool ExecutionType_SystemDefinedBaseType_IsValid(int value);
constexpr ExecutionType_SystemDefinedBaseType ExecutionType_SystemDefinedBaseType_SystemDefinedBaseType_MIN = ExecutionType_SystemDefinedBaseType_UNSET;
constexpr ExecutionType_SystemDefinedBaseType ExecutionType_SystemDefinedBaseType_SystemDefinedBaseType_MAX = ExecutionType_SystemDefinedBaseType_DEPLOY;
constexpr int ExecutionType_SystemDefinedBaseType_SystemDefinedBaseType_ARRAYSIZE = ExecutionType_SystemDefinedBaseType_SystemDefinedBaseType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExecutionType_SystemDefinedBaseType_descriptor();
template<typename T>
inline const std::string& ExecutionType_SystemDefinedBaseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExecutionType_SystemDefinedBaseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExecutionType_SystemDefinedBaseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExecutionType_SystemDefinedBaseType_descriptor(), enum_t_value);
}
inline bool ExecutionType_SystemDefinedBaseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExecutionType_SystemDefinedBaseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExecutionType_SystemDefinedBaseType>(
    ExecutionType_SystemDefinedBaseType_descriptor(), name, value);
}
enum ContextType_SystemDefinedBaseType : int {
  ContextType_SystemDefinedBaseType_UNSET = 0
};
bool ContextType_SystemDefinedBaseType_IsValid(int value);
constexpr ContextType_SystemDefinedBaseType ContextType_SystemDefinedBaseType_SystemDefinedBaseType_MIN = ContextType_SystemDefinedBaseType_UNSET;
constexpr ContextType_SystemDefinedBaseType ContextType_SystemDefinedBaseType_SystemDefinedBaseType_MAX = ContextType_SystemDefinedBaseType_UNSET;
constexpr int ContextType_SystemDefinedBaseType_SystemDefinedBaseType_ARRAYSIZE = ContextType_SystemDefinedBaseType_SystemDefinedBaseType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContextType_SystemDefinedBaseType_descriptor();
template<typename T>
inline const std::string& ContextType_SystemDefinedBaseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContextType_SystemDefinedBaseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContextType_SystemDefinedBaseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContextType_SystemDefinedBaseType_descriptor(), enum_t_value);
}
inline bool ContextType_SystemDefinedBaseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContextType_SystemDefinedBaseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContextType_SystemDefinedBaseType>(
    ContextType_SystemDefinedBaseType_descriptor(), name, value);
}
enum SqliteMetadataSourceConfig_ConnectionMode : int {
  SqliteMetadataSourceConfig_ConnectionMode_UNKNOWN = 0,
  SqliteMetadataSourceConfig_ConnectionMode_READONLY = 1,
  SqliteMetadataSourceConfig_ConnectionMode_READWRITE = 2,
  SqliteMetadataSourceConfig_ConnectionMode_READWRITE_OPENCREATE = 3
};
bool SqliteMetadataSourceConfig_ConnectionMode_IsValid(int value);
constexpr SqliteMetadataSourceConfig_ConnectionMode SqliteMetadataSourceConfig_ConnectionMode_ConnectionMode_MIN = SqliteMetadataSourceConfig_ConnectionMode_UNKNOWN;
constexpr SqliteMetadataSourceConfig_ConnectionMode SqliteMetadataSourceConfig_ConnectionMode_ConnectionMode_MAX = SqliteMetadataSourceConfig_ConnectionMode_READWRITE_OPENCREATE;
constexpr int SqliteMetadataSourceConfig_ConnectionMode_ConnectionMode_ARRAYSIZE = SqliteMetadataSourceConfig_ConnectionMode_ConnectionMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SqliteMetadataSourceConfig_ConnectionMode_descriptor();
template<typename T>
inline const std::string& SqliteMetadataSourceConfig_ConnectionMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SqliteMetadataSourceConfig_ConnectionMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SqliteMetadataSourceConfig_ConnectionMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SqliteMetadataSourceConfig_ConnectionMode_descriptor(), enum_t_value);
}
inline bool SqliteMetadataSourceConfig_ConnectionMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SqliteMetadataSourceConfig_ConnectionMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SqliteMetadataSourceConfig_ConnectionMode>(
    SqliteMetadataSourceConfig_ConnectionMode_descriptor(), name, value);
}
enum ListOperationOptions_OrderByField_Field : int {
  ListOperationOptions_OrderByField_Field_FIELD_UNSPECIFIED = 0,
  ListOperationOptions_OrderByField_Field_CREATE_TIME = 1,
  ListOperationOptions_OrderByField_Field_LAST_UPDATE_TIME = 2,
  ListOperationOptions_OrderByField_Field_ID = 3
};
bool ListOperationOptions_OrderByField_Field_IsValid(int value);
constexpr ListOperationOptions_OrderByField_Field ListOperationOptions_OrderByField_Field_Field_MIN = ListOperationOptions_OrderByField_Field_FIELD_UNSPECIFIED;
constexpr ListOperationOptions_OrderByField_Field ListOperationOptions_OrderByField_Field_Field_MAX = ListOperationOptions_OrderByField_Field_ID;
constexpr int ListOperationOptions_OrderByField_Field_Field_ARRAYSIZE = ListOperationOptions_OrderByField_Field_Field_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ListOperationOptions_OrderByField_Field_descriptor();
template<typename T>
inline const std::string& ListOperationOptions_OrderByField_Field_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ListOperationOptions_OrderByField_Field>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ListOperationOptions_OrderByField_Field_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ListOperationOptions_OrderByField_Field_descriptor(), enum_t_value);
}
inline bool ListOperationOptions_OrderByField_Field_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ListOperationOptions_OrderByField_Field* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ListOperationOptions_OrderByField_Field>(
    ListOperationOptions_OrderByField_Field_descriptor(), name, value);
}
enum LineageSubgraphQueryOptions_Direction : int {
  LineageSubgraphQueryOptions_Direction_DIRECTION_UNSPECIFIED = 0,
  LineageSubgraphQueryOptions_Direction_UPSTREAM = 1,
  LineageSubgraphQueryOptions_Direction_DOWNSTREAM = 2,
  LineageSubgraphQueryOptions_Direction_BIDIRECTIONAL = 3
};
bool LineageSubgraphQueryOptions_Direction_IsValid(int value);
constexpr LineageSubgraphQueryOptions_Direction LineageSubgraphQueryOptions_Direction_Direction_MIN = LineageSubgraphQueryOptions_Direction_DIRECTION_UNSPECIFIED;
constexpr LineageSubgraphQueryOptions_Direction LineageSubgraphQueryOptions_Direction_Direction_MAX = LineageSubgraphQueryOptions_Direction_BIDIRECTIONAL;
constexpr int LineageSubgraphQueryOptions_Direction_Direction_ARRAYSIZE = LineageSubgraphQueryOptions_Direction_Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LineageSubgraphQueryOptions_Direction_descriptor();
template<typename T>
inline const std::string& LineageSubgraphQueryOptions_Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LineageSubgraphQueryOptions_Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LineageSubgraphQueryOptions_Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LineageSubgraphQueryOptions_Direction_descriptor(), enum_t_value);
}
inline bool LineageSubgraphQueryOptions_Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LineageSubgraphQueryOptions_Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LineageSubgraphQueryOptions_Direction>(
    LineageSubgraphQueryOptions_Direction_descriptor(), name, value);
}
enum PropertyType : int {
  UNKNOWN = 0,
  INT = 1,
  DOUBLE = 2,
  STRING = 3,
  STRUCT = 4,
  PROTO = 5,
  BOOLEAN = 6
};
bool PropertyType_IsValid(int value);
constexpr PropertyType PropertyType_MIN = UNKNOWN;
constexpr PropertyType PropertyType_MAX = BOOLEAN;
constexpr int PropertyType_ARRAYSIZE = PropertyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PropertyType_descriptor();
template<typename T>
inline const std::string& PropertyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PropertyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PropertyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PropertyType_descriptor(), enum_t_value);
}
inline bool PropertyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PropertyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PropertyType>(
    PropertyType_descriptor(), name, value);
}
// ===================================================================

class SystemTypeExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.SystemTypeExtension) */ {
 public:
  inline SystemTypeExtension() : SystemTypeExtension(nullptr) {}
  ~SystemTypeExtension() override;
  explicit PROTOBUF_CONSTEXPR SystemTypeExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemTypeExtension(const SystemTypeExtension& from);
  SystemTypeExtension(SystemTypeExtension&& from) noexcept
    : SystemTypeExtension() {
    *this = ::std::move(from);
  }

  inline SystemTypeExtension& operator=(const SystemTypeExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemTypeExtension& operator=(SystemTypeExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemTypeExtension& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemTypeExtension* internal_default_instance() {
    return reinterpret_cast<const SystemTypeExtension*>(
               &_SystemTypeExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SystemTypeExtension& a, SystemTypeExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemTypeExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemTypeExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemTypeExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemTypeExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemTypeExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemTypeExtension& from) {
    SystemTypeExtension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemTypeExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.SystemTypeExtension";
  }
  protected:
  explicit SystemTypeExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeNameFieldNumber = 1,
  };
  // optional string type_name = 1;
  bool has_type_name() const;
  private:
  bool _internal_has_type_name() const;
  public:
  void clear_type_name();
  const std::string& type_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type_name();
  PROTOBUF_NODISCARD std::string* release_type_name();
  void set_allocated_type_name(std::string* type_name);
  private:
  const std::string& _internal_type_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type_name(const std::string& value);
  std::string* _internal_mutable_type_name();
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.SystemTypeExtension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  explicit PROTOBUF_CONSTEXPR Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kIntValue = 1,
    kDoubleValue = 2,
    kStringValue = 3,
    kStructValue = 4,
    kProtoValue = 5,
    kBoolValue = 6,
    VALUE_NOT_SET = 0,
  };

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Value& from) {
    Value::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntValueFieldNumber = 1,
    kDoubleValueFieldNumber = 2,
    kStringValueFieldNumber = 3,
    kStructValueFieldNumber = 4,
    kProtoValueFieldNumber = 5,
    kBoolValueFieldNumber = 6,
  };
  // int64 int_value = 1;
  bool has_int_value() const;
  private:
  bool _internal_has_int_value() const;
  public:
  void clear_int_value();
  int64_t int_value() const;
  void set_int_value(int64_t value);
  private:
  int64_t _internal_int_value() const;
  void _internal_set_int_value(int64_t value);
  public:

  // double double_value = 2;
  bool has_double_value() const;
  private:
  bool _internal_has_double_value() const;
  public:
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);
  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);
  public:

  // string string_value = 3;
  bool has_string_value() const;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const std::string& string_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // .google.protobuf.Struct struct_value = 4;
  bool has_struct_value() const;
  private:
  bool _internal_has_struct_value() const;
  public:
  void clear_struct_value();
  const ::PROTOBUF_NAMESPACE_ID::Struct& struct_value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_struct_value();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_struct_value();
  void set_allocated_struct_value(::PROTOBUF_NAMESPACE_ID::Struct* struct_value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_struct_value() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_struct_value();
  public:
  void unsafe_arena_set_allocated_struct_value(
      ::PROTOBUF_NAMESPACE_ID::Struct* struct_value);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_struct_value();

  // .google.protobuf.Any proto_value = 5;
  bool has_proto_value() const;
  private:
  bool _internal_has_proto_value() const;
  public:
  void clear_proto_value();
  const ::PROTOBUF_NAMESPACE_ID::Any& proto_value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_proto_value();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_proto_value();
  void set_allocated_proto_value(::PROTOBUF_NAMESPACE_ID::Any* proto_value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_proto_value() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_proto_value();
  public:
  void unsafe_arena_set_allocated_proto_value(
      ::PROTOBUF_NAMESPACE_ID::Any* proto_value);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_proto_value();

  // bool bool_value = 6;
  bool has_bool_value() const;
  private:
  bool _internal_has_bool_value() const;
  public:
  void clear_bool_value();
  bool bool_value() const;
  void set_bool_value(bool value);
  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:ml_metadata.Value)
 private:
  class _Internal;
  void set_has_int_value();
  void set_has_double_value();
  void set_has_string_value();
  void set_has_struct_value();
  void set_has_proto_value();
  void set_has_bool_value();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int64_t int_value_;
      double double_value_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
      ::PROTOBUF_NAMESPACE_ID::Struct* struct_value_;
      ::PROTOBUF_NAMESPACE_ID::Any* proto_value_;
      bool bool_value_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class Artifact_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Artifact_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Artifact_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Artifact_PropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Artifact_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Artifact_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Artifact_PropertiesEntry_DoNotUse& other);
  static const Artifact_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Artifact_PropertiesEntry_DoNotUse*>(&_Artifact_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ml_metadata.Artifact.PropertiesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};

// -------------------------------------------------------------------

class Artifact_CustomPropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Artifact_CustomPropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Artifact_CustomPropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Artifact_CustomPropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Artifact_CustomPropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Artifact_CustomPropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Artifact_CustomPropertiesEntry_DoNotUse& other);
  static const Artifact_CustomPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Artifact_CustomPropertiesEntry_DoNotUse*>(&_Artifact_CustomPropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ml_metadata.Artifact.CustomPropertiesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};

// -------------------------------------------------------------------

class Artifact final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.Artifact) */ {
 public:
  inline Artifact() : Artifact(nullptr) {}
  ~Artifact() override;
  explicit PROTOBUF_CONSTEXPR Artifact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Artifact(const Artifact& from);
  Artifact(Artifact&& from) noexcept
    : Artifact() {
    *this = ::std::move(from);
  }

  inline Artifact& operator=(const Artifact& from) {
    CopyFrom(from);
    return *this;
  }
  inline Artifact& operator=(Artifact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Artifact& default_instance() {
    return *internal_default_instance();
  }
  static inline const Artifact* internal_default_instance() {
    return reinterpret_cast<const Artifact*>(
               &_Artifact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Artifact& a, Artifact& b) {
    a.Swap(&b);
  }
  inline void Swap(Artifact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Artifact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Artifact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Artifact>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Artifact& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Artifact& from) {
    Artifact::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Artifact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.Artifact";
  }
  protected:
  explicit Artifact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef Artifact_State State;
  static constexpr State UNKNOWN =
    Artifact_State_UNKNOWN;
  static constexpr State PENDING =
    Artifact_State_PENDING;
  static constexpr State LIVE =
    Artifact_State_LIVE;
  static constexpr State MARKED_FOR_DELETION =
    Artifact_State_MARKED_FOR_DELETION;
  static constexpr State DELETED =
    Artifact_State_DELETED;
  static constexpr State ABANDONED =
    Artifact_State_ABANDONED;
  static constexpr State REFERENCE =
    Artifact_State_REFERENCE;
  static inline bool State_IsValid(int value) {
    return Artifact_State_IsValid(value);
  }
  static constexpr State State_MIN =
    Artifact_State_State_MIN;
  static constexpr State State_MAX =
    Artifact_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    Artifact_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return Artifact_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return Artifact_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return Artifact_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 4,
    kCustomPropertiesFieldNumber = 5,
    kUriFieldNumber = 3,
    kNameFieldNumber = 7,
    kTypeFieldNumber = 8,
    kExternalIdFieldNumber = 11,
    kSystemMetadataFieldNumber = 12,
    kIdFieldNumber = 1,
    kTypeIdFieldNumber = 2,
    kCreateTimeSinceEpochFieldNumber = 9,
    kLastUpdateTimeSinceEpochFieldNumber = 10,
    kStateFieldNumber = 6,
  };
  // map<string, .ml_metadata.Value> properties = 4;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
      mutable_properties();

  // map<string, .ml_metadata.Value> custom_properties = 5;
  int custom_properties_size() const;
  private:
  int _internal_custom_properties_size() const;
  public:
  void clear_custom_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
      _internal_custom_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
      _internal_mutable_custom_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
      custom_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
      mutable_custom_properties();

  // optional string uri = 3;
  bool has_uri() const;
  private:
  bool _internal_has_uri() const;
  public:
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // optional string name = 7;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string type = 8;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string external_id = 11;
  bool has_external_id() const;
  private:
  bool _internal_has_external_id() const;
  public:
  void clear_external_id();
  const std::string& external_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_id();
  PROTOBUF_NODISCARD std::string* release_external_id();
  void set_allocated_external_id(std::string* external_id);
  private:
  const std::string& _internal_external_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_id(const std::string& value);
  std::string* _internal_mutable_external_id();
  public:

  // optional .google.protobuf.Any system_metadata = 12;
  bool has_system_metadata() const;
  private:
  bool _internal_has_system_metadata() const;
  public:
  void clear_system_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Any& system_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_system_metadata();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_system_metadata();
  void set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_system_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_system_metadata();
  public:
  void unsafe_arena_set_allocated_system_metadata(
      ::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_system_metadata();

  // optional int64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // optional int64 type_id = 2;
  bool has_type_id() const;
  private:
  bool _internal_has_type_id() const;
  public:
  void clear_type_id();
  int64_t type_id() const;
  void set_type_id(int64_t value);
  private:
  int64_t _internal_type_id() const;
  void _internal_set_type_id(int64_t value);
  public:

  // optional int64 create_time_since_epoch = 9;
  bool has_create_time_since_epoch() const;
  private:
  bool _internal_has_create_time_since_epoch() const;
  public:
  void clear_create_time_since_epoch();
  int64_t create_time_since_epoch() const;
  void set_create_time_since_epoch(int64_t value);
  private:
  int64_t _internal_create_time_since_epoch() const;
  void _internal_set_create_time_since_epoch(int64_t value);
  public:

  // optional int64 last_update_time_since_epoch = 10;
  bool has_last_update_time_since_epoch() const;
  private:
  bool _internal_has_last_update_time_since_epoch() const;
  public:
  void clear_last_update_time_since_epoch();
  int64_t last_update_time_since_epoch() const;
  void set_last_update_time_since_epoch(int64_t value);
  private:
  int64_t _internal_last_update_time_since_epoch() const;
  void _internal_set_last_update_time_since_epoch(int64_t value);
  public:

  // optional .ml_metadata.Artifact.State state = 6;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::ml_metadata::Artifact_State state() const;
  void set_state(::ml_metadata::Artifact_State value);
  private:
  ::ml_metadata::Artifact_State _internal_state() const;
  void _internal_set_state(::ml_metadata::Artifact_State value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.Artifact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Artifact_PropertiesEntry_DoNotUse,
        std::string, ::ml_metadata::Value,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Artifact_CustomPropertiesEntry_DoNotUse,
        std::string, ::ml_metadata::Value,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> custom_properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_id_;
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata_;
    int64_t id_;
    int64_t type_id_;
    int64_t create_time_since_epoch_;
    int64_t last_update_time_since_epoch_;
    int state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ArtifactType_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ArtifactType_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::PropertyType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ArtifactType_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::PropertyType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> SuperType;
  ArtifactType_PropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ArtifactType_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ArtifactType_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ArtifactType_PropertiesEntry_DoNotUse& other);
  static const ArtifactType_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ArtifactType_PropertiesEntry_DoNotUse*>(&_ArtifactType_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ml_metadata.ArtifactType.PropertiesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};

// -------------------------------------------------------------------

class ArtifactType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ArtifactType) */ {
 public:
  inline ArtifactType() : ArtifactType(nullptr) {}
  ~ArtifactType() override;
  explicit PROTOBUF_CONSTEXPR ArtifactType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactType(const ArtifactType& from);
  ArtifactType(ArtifactType&& from) noexcept
    : ArtifactType() {
    *this = ::std::move(from);
  }

  inline ArtifactType& operator=(const ArtifactType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactType& operator=(ArtifactType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactType* internal_default_instance() {
    return reinterpret_cast<const ArtifactType*>(
               &_ArtifactType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ArtifactType& a, ArtifactType& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArtifactType& from) {
    ArtifactType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ArtifactType";
  }
  protected:
  explicit ArtifactType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef ArtifactType_SystemDefinedBaseType SystemDefinedBaseType;
  static constexpr SystemDefinedBaseType UNSET =
    ArtifactType_SystemDefinedBaseType_UNSET;
  static constexpr SystemDefinedBaseType DATASET =
    ArtifactType_SystemDefinedBaseType_DATASET;
  static constexpr SystemDefinedBaseType MODEL =
    ArtifactType_SystemDefinedBaseType_MODEL;
  static constexpr SystemDefinedBaseType METRICS =
    ArtifactType_SystemDefinedBaseType_METRICS;
  static constexpr SystemDefinedBaseType STATISTICS =
    ArtifactType_SystemDefinedBaseType_STATISTICS;
  static inline bool SystemDefinedBaseType_IsValid(int value) {
    return ArtifactType_SystemDefinedBaseType_IsValid(value);
  }
  static constexpr SystemDefinedBaseType SystemDefinedBaseType_MIN =
    ArtifactType_SystemDefinedBaseType_SystemDefinedBaseType_MIN;
  static constexpr SystemDefinedBaseType SystemDefinedBaseType_MAX =
    ArtifactType_SystemDefinedBaseType_SystemDefinedBaseType_MAX;
  static constexpr int SystemDefinedBaseType_ARRAYSIZE =
    ArtifactType_SystemDefinedBaseType_SystemDefinedBaseType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SystemDefinedBaseType_descriptor() {
    return ArtifactType_SystemDefinedBaseType_descriptor();
  }
  template<typename T>
  static inline const std::string& SystemDefinedBaseType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SystemDefinedBaseType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SystemDefinedBaseType_Name.");
    return ArtifactType_SystemDefinedBaseType_Name(enum_t_value);
  }
  static inline bool SystemDefinedBaseType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SystemDefinedBaseType* value) {
    return ArtifactType_SystemDefinedBaseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 3,
    kNameFieldNumber = 2,
    kVersionFieldNumber = 4,
    kDescriptionFieldNumber = 5,
    kExternalIdFieldNumber = 7,
    kIdFieldNumber = 1,
    kBaseTypeFieldNumber = 6,
  };
  // map<string, .ml_metadata.PropertyType> properties = 3;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >*
      mutable_properties();

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string version = 4;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string description = 5;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string external_id = 7;
  bool has_external_id() const;
  private:
  bool _internal_has_external_id() const;
  public:
  void clear_external_id();
  const std::string& external_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_id();
  PROTOBUF_NODISCARD std::string* release_external_id();
  void set_allocated_external_id(std::string* external_id);
  private:
  const std::string& _internal_external_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_id(const std::string& value);
  std::string* _internal_mutable_external_id();
  public:

  // optional int64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // optional .ml_metadata.ArtifactType.SystemDefinedBaseType base_type = 6;
  bool has_base_type() const;
  private:
  bool _internal_has_base_type() const;
  public:
  void clear_base_type();
  ::ml_metadata::ArtifactType_SystemDefinedBaseType base_type() const;
  void set_base_type(::ml_metadata::ArtifactType_SystemDefinedBaseType value);
  private:
  ::ml_metadata::ArtifactType_SystemDefinedBaseType _internal_base_type() const;
  void _internal_set_base_type(::ml_metadata::ArtifactType_SystemDefinedBaseType value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.ArtifactType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ArtifactType_PropertiesEntry_DoNotUse,
        std::string, ::ml_metadata::PropertyType,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_id_;
    int64_t id_;
    int base_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class Event_Path_Step final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.Event.Path.Step) */ {
 public:
  inline Event_Path_Step() : Event_Path_Step(nullptr) {}
  ~Event_Path_Step() override;
  explicit PROTOBUF_CONSTEXPR Event_Path_Step(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event_Path_Step(const Event_Path_Step& from);
  Event_Path_Step(Event_Path_Step&& from) noexcept
    : Event_Path_Step() {
    *this = ::std::move(from);
  }

  inline Event_Path_Step& operator=(const Event_Path_Step& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event_Path_Step& operator=(Event_Path_Step&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event_Path_Step& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kIndex = 1,
    kKey = 2,
    VALUE_NOT_SET = 0,
  };

  static inline const Event_Path_Step* internal_default_instance() {
    return reinterpret_cast<const Event_Path_Step*>(
               &_Event_Path_Step_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Event_Path_Step& a, Event_Path_Step& b) {
    a.Swap(&b);
  }
  inline void Swap(Event_Path_Step* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event_Path_Step* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event_Path_Step* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event_Path_Step>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event_Path_Step& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Event_Path_Step& from) {
    Event_Path_Step::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event_Path_Step* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.Event.Path.Step";
  }
  protected:
  explicit Event_Path_Step(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // int64 index = 1;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int64_t index() const;
  void set_index(int64_t value);
  private:
  int64_t _internal_index() const;
  void _internal_set_index(int64_t value);
  public:

  // string key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:ml_metadata.Event.Path.Step)
 private:
  class _Internal;
  void set_has_index();
  void set_has_key();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int64_t index_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class Event_Path final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.Event.Path) */ {
 public:
  inline Event_Path() : Event_Path(nullptr) {}
  ~Event_Path() override;
  explicit PROTOBUF_CONSTEXPR Event_Path(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event_Path(const Event_Path& from);
  Event_Path(Event_Path&& from) noexcept
    : Event_Path() {
    *this = ::std::move(from);
  }

  inline Event_Path& operator=(const Event_Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event_Path& operator=(Event_Path&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event_Path& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event_Path* internal_default_instance() {
    return reinterpret_cast<const Event_Path*>(
               &_Event_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Event_Path& a, Event_Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Event_Path* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event_Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event_Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event_Path>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event_Path& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Event_Path& from) {
    Event_Path::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event_Path* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.Event.Path";
  }
  protected:
  explicit Event_Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Event_Path_Step Step;

  // accessors -------------------------------------------------------

  enum : int {
    kStepsFieldNumber = 1,
  };
  // repeated .ml_metadata.Event.Path.Step steps = 1;
  int steps_size() const;
  private:
  int _internal_steps_size() const;
  public:
  void clear_steps();
  ::ml_metadata::Event_Path_Step* mutable_steps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Event_Path_Step >*
      mutable_steps();
  private:
  const ::ml_metadata::Event_Path_Step& _internal_steps(int index) const;
  ::ml_metadata::Event_Path_Step* _internal_add_steps();
  public:
  const ::ml_metadata::Event_Path_Step& steps(int index) const;
  ::ml_metadata::Event_Path_Step* add_steps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Event_Path_Step >&
      steps() const;

  // @@protoc_insertion_point(class_scope:ml_metadata.Event.Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Event_Path_Step > steps_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit PROTOBUF_CONSTEXPR Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Event& from) {
    Event::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Event_Path Path;

  typedef Event_Type Type;
  static constexpr Type UNKNOWN =
    Event_Type_UNKNOWN;
  static constexpr Type DECLARED_OUTPUT =
    Event_Type_DECLARED_OUTPUT;
  static constexpr Type DECLARED_INPUT =
    Event_Type_DECLARED_INPUT;
  static constexpr Type INPUT =
    Event_Type_INPUT;
  static constexpr Type OUTPUT =
    Event_Type_OUTPUT;
  static constexpr Type INTERNAL_INPUT =
    Event_Type_INTERNAL_INPUT;
  static constexpr Type INTERNAL_OUTPUT =
    Event_Type_INTERNAL_OUTPUT;
  static constexpr Type PENDING_OUTPUT =
    Event_Type_PENDING_OUTPUT;
  static inline bool Type_IsValid(int value) {
    return Event_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Event_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Event_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Event_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Event_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Event_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Event_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 3,
    kSystemMetadataFieldNumber = 6,
    kArtifactIdFieldNumber = 1,
    kExecutionIdFieldNumber = 2,
    kMillisecondsSinceEpochFieldNumber = 5,
    kTypeFieldNumber = 4,
  };
  // optional .ml_metadata.Event.Path path = 3;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::ml_metadata::Event_Path& path() const;
  PROTOBUF_NODISCARD ::ml_metadata::Event_Path* release_path();
  ::ml_metadata::Event_Path* mutable_path();
  void set_allocated_path(::ml_metadata::Event_Path* path);
  private:
  const ::ml_metadata::Event_Path& _internal_path() const;
  ::ml_metadata::Event_Path* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::ml_metadata::Event_Path* path);
  ::ml_metadata::Event_Path* unsafe_arena_release_path();

  // optional .google.protobuf.Any system_metadata = 6;
  bool has_system_metadata() const;
  private:
  bool _internal_has_system_metadata() const;
  public:
  void clear_system_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Any& system_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_system_metadata();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_system_metadata();
  void set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_system_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_system_metadata();
  public:
  void unsafe_arena_set_allocated_system_metadata(
      ::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_system_metadata();

  // optional int64 artifact_id = 1;
  bool has_artifact_id() const;
  private:
  bool _internal_has_artifact_id() const;
  public:
  void clear_artifact_id();
  int64_t artifact_id() const;
  void set_artifact_id(int64_t value);
  private:
  int64_t _internal_artifact_id() const;
  void _internal_set_artifact_id(int64_t value);
  public:

  // optional int64 execution_id = 2;
  bool has_execution_id() const;
  private:
  bool _internal_has_execution_id() const;
  public:
  void clear_execution_id();
  int64_t execution_id() const;
  void set_execution_id(int64_t value);
  private:
  int64_t _internal_execution_id() const;
  void _internal_set_execution_id(int64_t value);
  public:

  // optional int64 milliseconds_since_epoch = 5;
  bool has_milliseconds_since_epoch() const;
  private:
  bool _internal_has_milliseconds_since_epoch() const;
  public:
  void clear_milliseconds_since_epoch();
  int64_t milliseconds_since_epoch() const;
  void set_milliseconds_since_epoch(int64_t value);
  private:
  int64_t _internal_milliseconds_since_epoch() const;
  void _internal_set_milliseconds_since_epoch(int64_t value);
  public:

  // optional .ml_metadata.Event.Type type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::ml_metadata::Event_Type type() const;
  void set_type(::ml_metadata::Event_Type value);
  private:
  ::ml_metadata::Event_Type _internal_type() const;
  void _internal_set_type(::ml_metadata::Event_Type value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ml_metadata::Event_Path* path_;
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata_;
    int64_t artifact_id_;
    int64_t execution_id_;
    int64_t milliseconds_since_epoch_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class Execution_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Execution_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Execution_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Execution_PropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Execution_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Execution_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Execution_PropertiesEntry_DoNotUse& other);
  static const Execution_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Execution_PropertiesEntry_DoNotUse*>(&_Execution_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ml_metadata.Execution.PropertiesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};

// -------------------------------------------------------------------

class Execution_CustomPropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Execution_CustomPropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Execution_CustomPropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Execution_CustomPropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Execution_CustomPropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Execution_CustomPropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Execution_CustomPropertiesEntry_DoNotUse& other);
  static const Execution_CustomPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Execution_CustomPropertiesEntry_DoNotUse*>(&_Execution_CustomPropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ml_metadata.Execution.CustomPropertiesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};

// -------------------------------------------------------------------

class Execution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.Execution) */ {
 public:
  inline Execution() : Execution(nullptr) {}
  ~Execution() override;
  explicit PROTOBUF_CONSTEXPR Execution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Execution(const Execution& from);
  Execution(Execution&& from) noexcept
    : Execution() {
    *this = ::std::move(from);
  }

  inline Execution& operator=(const Execution& from) {
    CopyFrom(from);
    return *this;
  }
  inline Execution& operator=(Execution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Execution& default_instance() {
    return *internal_default_instance();
  }
  static inline const Execution* internal_default_instance() {
    return reinterpret_cast<const Execution*>(
               &_Execution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Execution& a, Execution& b) {
    a.Swap(&b);
  }
  inline void Swap(Execution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Execution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Execution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Execution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Execution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Execution& from) {
    Execution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Execution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.Execution";
  }
  protected:
  explicit Execution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef Execution_State State;
  static constexpr State UNKNOWN =
    Execution_State_UNKNOWN;
  static constexpr State NEW =
    Execution_State_NEW;
  static constexpr State RUNNING =
    Execution_State_RUNNING;
  static constexpr State COMPLETE =
    Execution_State_COMPLETE;
  static constexpr State FAILED =
    Execution_State_FAILED;
  static constexpr State CACHED =
    Execution_State_CACHED;
  static constexpr State CANCELED =
    Execution_State_CANCELED;
  static inline bool State_IsValid(int value) {
    return Execution_State_IsValid(value);
  }
  static constexpr State State_MIN =
    Execution_State_State_MIN;
  static constexpr State State_MAX =
    Execution_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    Execution_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return Execution_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return Execution_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return Execution_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 4,
    kCustomPropertiesFieldNumber = 5,
    kNameFieldNumber = 6,
    kTypeFieldNumber = 7,
    kExternalIdFieldNumber = 10,
    kSystemMetadataFieldNumber = 11,
    kIdFieldNumber = 1,
    kTypeIdFieldNumber = 2,
    kCreateTimeSinceEpochFieldNumber = 8,
    kLastUpdateTimeSinceEpochFieldNumber = 9,
    kLastKnownStateFieldNumber = 3,
  };
  // map<string, .ml_metadata.Value> properties = 4;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
      mutable_properties();

  // map<string, .ml_metadata.Value> custom_properties = 5;
  int custom_properties_size() const;
  private:
  int _internal_custom_properties_size() const;
  public:
  void clear_custom_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
      _internal_custom_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
      _internal_mutable_custom_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
      custom_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
      mutable_custom_properties();

  // optional string name = 6;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string type = 7;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string external_id = 10;
  bool has_external_id() const;
  private:
  bool _internal_has_external_id() const;
  public:
  void clear_external_id();
  const std::string& external_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_id();
  PROTOBUF_NODISCARD std::string* release_external_id();
  void set_allocated_external_id(std::string* external_id);
  private:
  const std::string& _internal_external_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_id(const std::string& value);
  std::string* _internal_mutable_external_id();
  public:

  // optional .google.protobuf.Any system_metadata = 11;
  bool has_system_metadata() const;
  private:
  bool _internal_has_system_metadata() const;
  public:
  void clear_system_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Any& system_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_system_metadata();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_system_metadata();
  void set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_system_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_system_metadata();
  public:
  void unsafe_arena_set_allocated_system_metadata(
      ::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_system_metadata();

  // optional int64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // optional int64 type_id = 2;
  bool has_type_id() const;
  private:
  bool _internal_has_type_id() const;
  public:
  void clear_type_id();
  int64_t type_id() const;
  void set_type_id(int64_t value);
  private:
  int64_t _internal_type_id() const;
  void _internal_set_type_id(int64_t value);
  public:

  // optional int64 create_time_since_epoch = 8;
  bool has_create_time_since_epoch() const;
  private:
  bool _internal_has_create_time_since_epoch() const;
  public:
  void clear_create_time_since_epoch();
  int64_t create_time_since_epoch() const;
  void set_create_time_since_epoch(int64_t value);
  private:
  int64_t _internal_create_time_since_epoch() const;
  void _internal_set_create_time_since_epoch(int64_t value);
  public:

  // optional int64 last_update_time_since_epoch = 9;
  bool has_last_update_time_since_epoch() const;
  private:
  bool _internal_has_last_update_time_since_epoch() const;
  public:
  void clear_last_update_time_since_epoch();
  int64_t last_update_time_since_epoch() const;
  void set_last_update_time_since_epoch(int64_t value);
  private:
  int64_t _internal_last_update_time_since_epoch() const;
  void _internal_set_last_update_time_since_epoch(int64_t value);
  public:

  // optional .ml_metadata.Execution.State last_known_state = 3;
  bool has_last_known_state() const;
  private:
  bool _internal_has_last_known_state() const;
  public:
  void clear_last_known_state();
  ::ml_metadata::Execution_State last_known_state() const;
  void set_last_known_state(::ml_metadata::Execution_State value);
  private:
  ::ml_metadata::Execution_State _internal_last_known_state() const;
  void _internal_set_last_known_state(::ml_metadata::Execution_State value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.Execution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Execution_PropertiesEntry_DoNotUse,
        std::string, ::ml_metadata::Value,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Execution_CustomPropertiesEntry_DoNotUse,
        std::string, ::ml_metadata::Value,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> custom_properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_id_;
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata_;
    int64_t id_;
    int64_t type_id_;
    int64_t create_time_since_epoch_;
    int64_t last_update_time_since_epoch_;
    int last_known_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ExecutionType_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ExecutionType_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::PropertyType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ExecutionType_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::PropertyType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> SuperType;
  ExecutionType_PropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ExecutionType_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ExecutionType_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ExecutionType_PropertiesEntry_DoNotUse& other);
  static const ExecutionType_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ExecutionType_PropertiesEntry_DoNotUse*>(&_ExecutionType_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ml_metadata.ExecutionType.PropertiesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};

// -------------------------------------------------------------------

class ExecutionType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ExecutionType) */ {
 public:
  inline ExecutionType() : ExecutionType(nullptr) {}
  ~ExecutionType() override;
  explicit PROTOBUF_CONSTEXPR ExecutionType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionType(const ExecutionType& from);
  ExecutionType(ExecutionType&& from) noexcept
    : ExecutionType() {
    *this = ::std::move(from);
  }

  inline ExecutionType& operator=(const ExecutionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionType& operator=(ExecutionType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionType* internal_default_instance() {
    return reinterpret_cast<const ExecutionType*>(
               &_ExecutionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ExecutionType& a, ExecutionType& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecutionType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecutionType& from) {
    ExecutionType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ExecutionType";
  }
  protected:
  explicit ExecutionType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef ExecutionType_SystemDefinedBaseType SystemDefinedBaseType;
  static constexpr SystemDefinedBaseType UNSET =
    ExecutionType_SystemDefinedBaseType_UNSET;
  static constexpr SystemDefinedBaseType TRAIN =
    ExecutionType_SystemDefinedBaseType_TRAIN;
  static constexpr SystemDefinedBaseType TRANSFORM =
    ExecutionType_SystemDefinedBaseType_TRANSFORM;
  static constexpr SystemDefinedBaseType PROCESS =
    ExecutionType_SystemDefinedBaseType_PROCESS;
  static constexpr SystemDefinedBaseType EVALUATE =
    ExecutionType_SystemDefinedBaseType_EVALUATE;
  static constexpr SystemDefinedBaseType DEPLOY =
    ExecutionType_SystemDefinedBaseType_DEPLOY;
  static inline bool SystemDefinedBaseType_IsValid(int value) {
    return ExecutionType_SystemDefinedBaseType_IsValid(value);
  }
  static constexpr SystemDefinedBaseType SystemDefinedBaseType_MIN =
    ExecutionType_SystemDefinedBaseType_SystemDefinedBaseType_MIN;
  static constexpr SystemDefinedBaseType SystemDefinedBaseType_MAX =
    ExecutionType_SystemDefinedBaseType_SystemDefinedBaseType_MAX;
  static constexpr int SystemDefinedBaseType_ARRAYSIZE =
    ExecutionType_SystemDefinedBaseType_SystemDefinedBaseType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SystemDefinedBaseType_descriptor() {
    return ExecutionType_SystemDefinedBaseType_descriptor();
  }
  template<typename T>
  static inline const std::string& SystemDefinedBaseType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SystemDefinedBaseType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SystemDefinedBaseType_Name.");
    return ExecutionType_SystemDefinedBaseType_Name(enum_t_value);
  }
  static inline bool SystemDefinedBaseType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SystemDefinedBaseType* value) {
    return ExecutionType_SystemDefinedBaseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 3,
    kNameFieldNumber = 2,
    kVersionFieldNumber = 6,
    kDescriptionFieldNumber = 7,
    kExternalIdFieldNumber = 9,
    kInputTypeFieldNumber = 4,
    kOutputTypeFieldNumber = 5,
    kIdFieldNumber = 1,
    kBaseTypeFieldNumber = 8,
  };
  // map<string, .ml_metadata.PropertyType> properties = 3;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >*
      mutable_properties();

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string version = 6;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string description = 7;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string external_id = 9;
  bool has_external_id() const;
  private:
  bool _internal_has_external_id() const;
  public:
  void clear_external_id();
  const std::string& external_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_id();
  PROTOBUF_NODISCARD std::string* release_external_id();
  void set_allocated_external_id(std::string* external_id);
  private:
  const std::string& _internal_external_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_id(const std::string& value);
  std::string* _internal_mutable_external_id();
  public:

  // optional .ml_metadata.ArtifactStructType input_type = 4;
  bool has_input_type() const;
  private:
  bool _internal_has_input_type() const;
  public:
  void clear_input_type();
  const ::ml_metadata::ArtifactStructType& input_type() const;
  PROTOBUF_NODISCARD ::ml_metadata::ArtifactStructType* release_input_type();
  ::ml_metadata::ArtifactStructType* mutable_input_type();
  void set_allocated_input_type(::ml_metadata::ArtifactStructType* input_type);
  private:
  const ::ml_metadata::ArtifactStructType& _internal_input_type() const;
  ::ml_metadata::ArtifactStructType* _internal_mutable_input_type();
  public:
  void unsafe_arena_set_allocated_input_type(
      ::ml_metadata::ArtifactStructType* input_type);
  ::ml_metadata::ArtifactStructType* unsafe_arena_release_input_type();

  // optional .ml_metadata.ArtifactStructType output_type = 5;
  bool has_output_type() const;
  private:
  bool _internal_has_output_type() const;
  public:
  void clear_output_type();
  const ::ml_metadata::ArtifactStructType& output_type() const;
  PROTOBUF_NODISCARD ::ml_metadata::ArtifactStructType* release_output_type();
  ::ml_metadata::ArtifactStructType* mutable_output_type();
  void set_allocated_output_type(::ml_metadata::ArtifactStructType* output_type);
  private:
  const ::ml_metadata::ArtifactStructType& _internal_output_type() const;
  ::ml_metadata::ArtifactStructType* _internal_mutable_output_type();
  public:
  void unsafe_arena_set_allocated_output_type(
      ::ml_metadata::ArtifactStructType* output_type);
  ::ml_metadata::ArtifactStructType* unsafe_arena_release_output_type();

  // optional int64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // optional .ml_metadata.ExecutionType.SystemDefinedBaseType base_type = 8;
  bool has_base_type() const;
  private:
  bool _internal_has_base_type() const;
  public:
  void clear_base_type();
  ::ml_metadata::ExecutionType_SystemDefinedBaseType base_type() const;
  void set_base_type(::ml_metadata::ExecutionType_SystemDefinedBaseType value);
  private:
  ::ml_metadata::ExecutionType_SystemDefinedBaseType _internal_base_type() const;
  void _internal_set_base_type(::ml_metadata::ExecutionType_SystemDefinedBaseType value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.ExecutionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ExecutionType_PropertiesEntry_DoNotUse,
        std::string, ::ml_metadata::PropertyType,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_id_;
    ::ml_metadata::ArtifactStructType* input_type_;
    ::ml_metadata::ArtifactStructType* output_type_;
    int64_t id_;
    int base_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ContextType_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ContextType_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::PropertyType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ContextType_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::PropertyType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> SuperType;
  ContextType_PropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ContextType_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ContextType_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ContextType_PropertiesEntry_DoNotUse& other);
  static const ContextType_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ContextType_PropertiesEntry_DoNotUse*>(&_ContextType_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ml_metadata.ContextType.PropertiesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};

// -------------------------------------------------------------------

class ContextType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ContextType) */ {
 public:
  inline ContextType() : ContextType(nullptr) {}
  ~ContextType() override;
  explicit PROTOBUF_CONSTEXPR ContextType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContextType(const ContextType& from);
  ContextType(ContextType&& from) noexcept
    : ContextType() {
    *this = ::std::move(from);
  }

  inline ContextType& operator=(const ContextType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextType& operator=(ContextType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContextType* internal_default_instance() {
    return reinterpret_cast<const ContextType*>(
               &_ContextType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ContextType& a, ContextType& b) {
    a.Swap(&b);
  }
  inline void Swap(ContextType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContextType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContextType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContextType& from) {
    ContextType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ContextType";
  }
  protected:
  explicit ContextType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef ContextType_SystemDefinedBaseType SystemDefinedBaseType;
  static constexpr SystemDefinedBaseType UNSET =
    ContextType_SystemDefinedBaseType_UNSET;
  static inline bool SystemDefinedBaseType_IsValid(int value) {
    return ContextType_SystemDefinedBaseType_IsValid(value);
  }
  static constexpr SystemDefinedBaseType SystemDefinedBaseType_MIN =
    ContextType_SystemDefinedBaseType_SystemDefinedBaseType_MIN;
  static constexpr SystemDefinedBaseType SystemDefinedBaseType_MAX =
    ContextType_SystemDefinedBaseType_SystemDefinedBaseType_MAX;
  static constexpr int SystemDefinedBaseType_ARRAYSIZE =
    ContextType_SystemDefinedBaseType_SystemDefinedBaseType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SystemDefinedBaseType_descriptor() {
    return ContextType_SystemDefinedBaseType_descriptor();
  }
  template<typename T>
  static inline const std::string& SystemDefinedBaseType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SystemDefinedBaseType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SystemDefinedBaseType_Name.");
    return ContextType_SystemDefinedBaseType_Name(enum_t_value);
  }
  static inline bool SystemDefinedBaseType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SystemDefinedBaseType* value) {
    return ContextType_SystemDefinedBaseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 3,
    kNameFieldNumber = 2,
    kVersionFieldNumber = 4,
    kDescriptionFieldNumber = 5,
    kExternalIdFieldNumber = 7,
    kIdFieldNumber = 1,
    kBaseTypeFieldNumber = 6,
  };
  // map<string, .ml_metadata.PropertyType> properties = 3;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >*
      mutable_properties();

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string version = 4;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string description = 5;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string external_id = 7;
  bool has_external_id() const;
  private:
  bool _internal_has_external_id() const;
  public:
  void clear_external_id();
  const std::string& external_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_id();
  PROTOBUF_NODISCARD std::string* release_external_id();
  void set_allocated_external_id(std::string* external_id);
  private:
  const std::string& _internal_external_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_id(const std::string& value);
  std::string* _internal_mutable_external_id();
  public:

  // optional int64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // optional .ml_metadata.ContextType.SystemDefinedBaseType base_type = 6;
  bool has_base_type() const;
  private:
  bool _internal_has_base_type() const;
  public:
  void clear_base_type();
  ::ml_metadata::ContextType_SystemDefinedBaseType base_type() const;
  void set_base_type(::ml_metadata::ContextType_SystemDefinedBaseType value);
  private:
  ::ml_metadata::ContextType_SystemDefinedBaseType _internal_base_type() const;
  void _internal_set_base_type(::ml_metadata::ContextType_SystemDefinedBaseType value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.ContextType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ContextType_PropertiesEntry_DoNotUse,
        std::string, ::ml_metadata::PropertyType,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_id_;
    int64_t id_;
    int base_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class Context_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Context_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Context_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Context_PropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Context_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Context_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Context_PropertiesEntry_DoNotUse& other);
  static const Context_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Context_PropertiesEntry_DoNotUse*>(&_Context_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ml_metadata.Context.PropertiesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};

// -------------------------------------------------------------------

class Context_CustomPropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Context_CustomPropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Context_CustomPropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Context_CustomPropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Context_CustomPropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Context_CustomPropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Context_CustomPropertiesEntry_DoNotUse& other);
  static const Context_CustomPropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Context_CustomPropertiesEntry_DoNotUse*>(&_Context_CustomPropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ml_metadata.Context.CustomPropertiesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};

// -------------------------------------------------------------------

class Context final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.Context) */ {
 public:
  inline Context() : Context(nullptr) {}
  ~Context() override;
  explicit PROTOBUF_CONSTEXPR Context(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Context(const Context& from);
  Context(Context&& from) noexcept
    : Context() {
    *this = ::std::move(from);
  }

  inline Context& operator=(const Context& from) {
    CopyFrom(from);
    return *this;
  }
  inline Context& operator=(Context&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Context& default_instance() {
    return *internal_default_instance();
  }
  static inline const Context* internal_default_instance() {
    return reinterpret_cast<const Context*>(
               &_Context_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Context& a, Context& b) {
    a.Swap(&b);
  }
  inline void Swap(Context* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Context* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Context* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Context>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Context& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Context& from) {
    Context::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Context* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.Context";
  }
  protected:
  explicit Context(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 4,
    kCustomPropertiesFieldNumber = 5,
    kNameFieldNumber = 3,
    kTypeFieldNumber = 6,
    kExternalIdFieldNumber = 9,
    kSystemMetadataFieldNumber = 10,
    kIdFieldNumber = 1,
    kTypeIdFieldNumber = 2,
    kCreateTimeSinceEpochFieldNumber = 7,
    kLastUpdateTimeSinceEpochFieldNumber = 8,
  };
  // map<string, .ml_metadata.Value> properties = 4;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
      mutable_properties();

  // map<string, .ml_metadata.Value> custom_properties = 5;
  int custom_properties_size() const;
  private:
  int _internal_custom_properties_size() const;
  public:
  void clear_custom_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
      _internal_custom_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
      _internal_mutable_custom_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
      custom_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
      mutable_custom_properties();

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string type = 6;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string external_id = 9;
  bool has_external_id() const;
  private:
  bool _internal_has_external_id() const;
  public:
  void clear_external_id();
  const std::string& external_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_id();
  PROTOBUF_NODISCARD std::string* release_external_id();
  void set_allocated_external_id(std::string* external_id);
  private:
  const std::string& _internal_external_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_id(const std::string& value);
  std::string* _internal_mutable_external_id();
  public:

  // optional .google.protobuf.Any system_metadata = 10;
  bool has_system_metadata() const;
  private:
  bool _internal_has_system_metadata() const;
  public:
  void clear_system_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Any& system_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_system_metadata();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_system_metadata();
  void set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_system_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_system_metadata();
  public:
  void unsafe_arena_set_allocated_system_metadata(
      ::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_system_metadata();

  // optional int64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // optional int64 type_id = 2;
  bool has_type_id() const;
  private:
  bool _internal_has_type_id() const;
  public:
  void clear_type_id();
  int64_t type_id() const;
  void set_type_id(int64_t value);
  private:
  int64_t _internal_type_id() const;
  void _internal_set_type_id(int64_t value);
  public:

  // optional int64 create_time_since_epoch = 7;
  bool has_create_time_since_epoch() const;
  private:
  bool _internal_has_create_time_since_epoch() const;
  public:
  void clear_create_time_since_epoch();
  int64_t create_time_since_epoch() const;
  void set_create_time_since_epoch(int64_t value);
  private:
  int64_t _internal_create_time_since_epoch() const;
  void _internal_set_create_time_since_epoch(int64_t value);
  public:

  // optional int64 last_update_time_since_epoch = 8;
  bool has_last_update_time_since_epoch() const;
  private:
  bool _internal_has_last_update_time_since_epoch() const;
  public:
  void clear_last_update_time_since_epoch();
  int64_t last_update_time_since_epoch() const;
  void set_last_update_time_since_epoch(int64_t value);
  private:
  int64_t _internal_last_update_time_since_epoch() const;
  void _internal_set_last_update_time_since_epoch(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.Context)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Context_PropertiesEntry_DoNotUse,
        std::string, ::ml_metadata::Value,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Context_CustomPropertiesEntry_DoNotUse,
        std::string, ::ml_metadata::Value,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> custom_properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_id_;
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata_;
    int64_t id_;
    int64_t type_id_;
    int64_t create_time_since_epoch_;
    int64_t last_update_time_since_epoch_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class Attribution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.Attribution) */ {
 public:
  inline Attribution() : Attribution(nullptr) {}
  ~Attribution() override;
  explicit PROTOBUF_CONSTEXPR Attribution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attribution(const Attribution& from);
  Attribution(Attribution&& from) noexcept
    : Attribution() {
    *this = ::std::move(from);
  }

  inline Attribution& operator=(const Attribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attribution& operator=(Attribution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attribution& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attribution* internal_default_instance() {
    return reinterpret_cast<const Attribution*>(
               &_Attribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Attribution& a, Attribution& b) {
    a.Swap(&b);
  }
  inline void Swap(Attribution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attribution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Attribution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Attribution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Attribution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Attribution& from) {
    Attribution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attribution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.Attribution";
  }
  protected:
  explicit Attribution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSystemMetadataFieldNumber = 3,
    kArtifactIdFieldNumber = 1,
    kContextIdFieldNumber = 2,
  };
  // optional .google.protobuf.Any system_metadata = 3;
  bool has_system_metadata() const;
  private:
  bool _internal_has_system_metadata() const;
  public:
  void clear_system_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Any& system_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_system_metadata();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_system_metadata();
  void set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_system_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_system_metadata();
  public:
  void unsafe_arena_set_allocated_system_metadata(
      ::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_system_metadata();

  // optional int64 artifact_id = 1;
  bool has_artifact_id() const;
  private:
  bool _internal_has_artifact_id() const;
  public:
  void clear_artifact_id();
  int64_t artifact_id() const;
  void set_artifact_id(int64_t value);
  private:
  int64_t _internal_artifact_id() const;
  void _internal_set_artifact_id(int64_t value);
  public:

  // optional int64 context_id = 2;
  bool has_context_id() const;
  private:
  bool _internal_has_context_id() const;
  public:
  void clear_context_id();
  int64_t context_id() const;
  void set_context_id(int64_t value);
  private:
  int64_t _internal_context_id() const;
  void _internal_set_context_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.Attribution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata_;
    int64_t artifact_id_;
    int64_t context_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class Association final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.Association) */ {
 public:
  inline Association() : Association(nullptr) {}
  ~Association() override;
  explicit PROTOBUF_CONSTEXPR Association(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Association(const Association& from);
  Association(Association&& from) noexcept
    : Association() {
    *this = ::std::move(from);
  }

  inline Association& operator=(const Association& from) {
    CopyFrom(from);
    return *this;
  }
  inline Association& operator=(Association&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Association& default_instance() {
    return *internal_default_instance();
  }
  static inline const Association* internal_default_instance() {
    return reinterpret_cast<const Association*>(
               &_Association_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Association& a, Association& b) {
    a.Swap(&b);
  }
  inline void Swap(Association* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Association* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Association* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Association>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Association& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Association& from) {
    Association::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Association* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.Association";
  }
  protected:
  explicit Association(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSystemMetadataFieldNumber = 3,
    kExecutionIdFieldNumber = 1,
    kContextIdFieldNumber = 2,
  };
  // optional .google.protobuf.Any system_metadata = 3;
  bool has_system_metadata() const;
  private:
  bool _internal_has_system_metadata() const;
  public:
  void clear_system_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Any& system_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_system_metadata();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_system_metadata();
  void set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_system_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_system_metadata();
  public:
  void unsafe_arena_set_allocated_system_metadata(
      ::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_system_metadata();

  // optional int64 execution_id = 1;
  bool has_execution_id() const;
  private:
  bool _internal_has_execution_id() const;
  public:
  void clear_execution_id();
  int64_t execution_id() const;
  void set_execution_id(int64_t value);
  private:
  int64_t _internal_execution_id() const;
  void _internal_set_execution_id(int64_t value);
  public:

  // optional int64 context_id = 2;
  bool has_context_id() const;
  private:
  bool _internal_has_context_id() const;
  public:
  void clear_context_id();
  int64_t context_id() const;
  void set_context_id(int64_t value);
  private:
  int64_t _internal_context_id() const;
  void _internal_set_context_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.Association)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata_;
    int64_t execution_id_;
    int64_t context_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ParentContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ParentContext) */ {
 public:
  inline ParentContext() : ParentContext(nullptr) {}
  ~ParentContext() override;
  explicit PROTOBUF_CONSTEXPR ParentContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParentContext(const ParentContext& from);
  ParentContext(ParentContext&& from) noexcept
    : ParentContext() {
    *this = ::std::move(from);
  }

  inline ParentContext& operator=(const ParentContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParentContext& operator=(ParentContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParentContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParentContext* internal_default_instance() {
    return reinterpret_cast<const ParentContext*>(
               &_ParentContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ParentContext& a, ParentContext& b) {
    a.Swap(&b);
  }
  inline void Swap(ParentContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParentContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParentContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParentContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParentContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParentContext& from) {
    ParentContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParentContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ParentContext";
  }
  protected:
  explicit ParentContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSystemMetadataFieldNumber = 3,
    kChildIdFieldNumber = 1,
    kParentIdFieldNumber = 2,
  };
  // optional .google.protobuf.Any system_metadata = 3;
  bool has_system_metadata() const;
  private:
  bool _internal_has_system_metadata() const;
  public:
  void clear_system_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Any& system_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_system_metadata();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_system_metadata();
  void set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_system_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_system_metadata();
  public:
  void unsafe_arena_set_allocated_system_metadata(
      ::PROTOBUF_NAMESPACE_ID::Any* system_metadata);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_system_metadata();

  // optional int64 child_id = 1;
  bool has_child_id() const;
  private:
  bool _internal_has_child_id() const;
  public:
  void clear_child_id();
  int64_t child_id() const;
  void set_child_id(int64_t value);
  private:
  int64_t _internal_child_id() const;
  void _internal_set_child_id(int64_t value);
  public:

  // optional int64 parent_id = 2;
  bool has_parent_id() const;
  private:
  bool _internal_has_parent_id() const;
  public:
  void clear_parent_id();
  int64_t parent_id() const;
  void set_parent_id(int64_t value);
  private:
  int64_t _internal_parent_id() const;
  void _internal_set_parent_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.ParentContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata_;
    int64_t child_id_;
    int64_t parent_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class LineageGraph final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.LineageGraph) */ {
 public:
  inline LineageGraph() : LineageGraph(nullptr) {}
  ~LineageGraph() override;
  explicit PROTOBUF_CONSTEXPR LineageGraph(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LineageGraph(const LineageGraph& from);
  LineageGraph(LineageGraph&& from) noexcept
    : LineageGraph() {
    *this = ::std::move(from);
  }

  inline LineageGraph& operator=(const LineageGraph& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineageGraph& operator=(LineageGraph&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LineageGraph& default_instance() {
    return *internal_default_instance();
  }
  static inline const LineageGraph* internal_default_instance() {
    return reinterpret_cast<const LineageGraph*>(
               &_LineageGraph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(LineageGraph& a, LineageGraph& b) {
    a.Swap(&b);
  }
  inline void Swap(LineageGraph* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineageGraph* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineageGraph* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LineageGraph>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LineageGraph& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LineageGraph& from) {
    LineageGraph::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineageGraph* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.LineageGraph";
  }
  protected:
  explicit LineageGraph(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactTypesFieldNumber = 1,
    kExecutionTypesFieldNumber = 2,
    kContextTypesFieldNumber = 3,
    kArtifactsFieldNumber = 4,
    kExecutionsFieldNumber = 5,
    kContextsFieldNumber = 6,
    kEventsFieldNumber = 7,
    kAttributionsFieldNumber = 8,
    kAssociationsFieldNumber = 9,
    kParentContextsFieldNumber = 10,
  };
  // repeated .ml_metadata.ArtifactType artifact_types = 1;
  int artifact_types_size() const;
  private:
  int _internal_artifact_types_size() const;
  public:
  void clear_artifact_types();
  ::ml_metadata::ArtifactType* mutable_artifact_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactType >*
      mutable_artifact_types();
  private:
  const ::ml_metadata::ArtifactType& _internal_artifact_types(int index) const;
  ::ml_metadata::ArtifactType* _internal_add_artifact_types();
  public:
  const ::ml_metadata::ArtifactType& artifact_types(int index) const;
  ::ml_metadata::ArtifactType* add_artifact_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactType >&
      artifact_types() const;

  // repeated .ml_metadata.ExecutionType execution_types = 2;
  int execution_types_size() const;
  private:
  int _internal_execution_types_size() const;
  public:
  void clear_execution_types();
  ::ml_metadata::ExecutionType* mutable_execution_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ExecutionType >*
      mutable_execution_types();
  private:
  const ::ml_metadata::ExecutionType& _internal_execution_types(int index) const;
  ::ml_metadata::ExecutionType* _internal_add_execution_types();
  public:
  const ::ml_metadata::ExecutionType& execution_types(int index) const;
  ::ml_metadata::ExecutionType* add_execution_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ExecutionType >&
      execution_types() const;

  // repeated .ml_metadata.ContextType context_types = 3;
  int context_types_size() const;
  private:
  int _internal_context_types_size() const;
  public:
  void clear_context_types();
  ::ml_metadata::ContextType* mutable_context_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ContextType >*
      mutable_context_types();
  private:
  const ::ml_metadata::ContextType& _internal_context_types(int index) const;
  ::ml_metadata::ContextType* _internal_add_context_types();
  public:
  const ::ml_metadata::ContextType& context_types(int index) const;
  ::ml_metadata::ContextType* add_context_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ContextType >&
      context_types() const;

  // repeated .ml_metadata.Artifact artifacts = 4;
  int artifacts_size() const;
  private:
  int _internal_artifacts_size() const;
  public:
  void clear_artifacts();
  ::ml_metadata::Artifact* mutable_artifacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Artifact >*
      mutable_artifacts();
  private:
  const ::ml_metadata::Artifact& _internal_artifacts(int index) const;
  ::ml_metadata::Artifact* _internal_add_artifacts();
  public:
  const ::ml_metadata::Artifact& artifacts(int index) const;
  ::ml_metadata::Artifact* add_artifacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Artifact >&
      artifacts() const;

  // repeated .ml_metadata.Execution executions = 5;
  int executions_size() const;
  private:
  int _internal_executions_size() const;
  public:
  void clear_executions();
  ::ml_metadata::Execution* mutable_executions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Execution >*
      mutable_executions();
  private:
  const ::ml_metadata::Execution& _internal_executions(int index) const;
  ::ml_metadata::Execution* _internal_add_executions();
  public:
  const ::ml_metadata::Execution& executions(int index) const;
  ::ml_metadata::Execution* add_executions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Execution >&
      executions() const;

  // repeated .ml_metadata.Context contexts = 6;
  int contexts_size() const;
  private:
  int _internal_contexts_size() const;
  public:
  void clear_contexts();
  ::ml_metadata::Context* mutable_contexts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Context >*
      mutable_contexts();
  private:
  const ::ml_metadata::Context& _internal_contexts(int index) const;
  ::ml_metadata::Context* _internal_add_contexts();
  public:
  const ::ml_metadata::Context& contexts(int index) const;
  ::ml_metadata::Context* add_contexts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Context >&
      contexts() const;

  // repeated .ml_metadata.Event events = 7;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::ml_metadata::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Event >*
      mutable_events();
  private:
  const ::ml_metadata::Event& _internal_events(int index) const;
  ::ml_metadata::Event* _internal_add_events();
  public:
  const ::ml_metadata::Event& events(int index) const;
  ::ml_metadata::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Event >&
      events() const;

  // repeated .ml_metadata.Attribution attributions = 8;
  int attributions_size() const;
  private:
  int _internal_attributions_size() const;
  public:
  void clear_attributions();
  ::ml_metadata::Attribution* mutable_attributions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Attribution >*
      mutable_attributions();
  private:
  const ::ml_metadata::Attribution& _internal_attributions(int index) const;
  ::ml_metadata::Attribution* _internal_add_attributions();
  public:
  const ::ml_metadata::Attribution& attributions(int index) const;
  ::ml_metadata::Attribution* add_attributions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Attribution >&
      attributions() const;

  // repeated .ml_metadata.Association associations = 9;
  int associations_size() const;
  private:
  int _internal_associations_size() const;
  public:
  void clear_associations();
  ::ml_metadata::Association* mutable_associations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Association >*
      mutable_associations();
  private:
  const ::ml_metadata::Association& _internal_associations(int index) const;
  ::ml_metadata::Association* _internal_add_associations();
  public:
  const ::ml_metadata::Association& associations(int index) const;
  ::ml_metadata::Association* add_associations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Association >&
      associations() const;

  // repeated .ml_metadata.ParentContext parent_contexts = 10;
  int parent_contexts_size() const;
  private:
  int _internal_parent_contexts_size() const;
  public:
  void clear_parent_contexts();
  ::ml_metadata::ParentContext* mutable_parent_contexts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ParentContext >*
      mutable_parent_contexts();
  private:
  const ::ml_metadata::ParentContext& _internal_parent_contexts(int index) const;
  ::ml_metadata::ParentContext* _internal_add_parent_contexts();
  public:
  const ::ml_metadata::ParentContext& parent_contexts(int index) const;
  ::ml_metadata::ParentContext* add_parent_contexts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ParentContext >&
      parent_contexts() const;

  // @@protoc_insertion_point(class_scope:ml_metadata.LineageGraph)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactType > artifact_types_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ExecutionType > execution_types_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ContextType > context_types_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Artifact > artifacts_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Execution > executions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Context > contexts_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Event > events_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Attribution > attributions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Association > associations_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ParentContext > parent_contexts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ArtifactStructType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ArtifactStructType) */ {
 public:
  inline ArtifactStructType() : ArtifactStructType(nullptr) {}
  ~ArtifactStructType() override;
  explicit PROTOBUF_CONSTEXPR ArtifactStructType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactStructType(const ArtifactStructType& from);
  ArtifactStructType(ArtifactStructType&& from) noexcept
    : ArtifactStructType() {
    *this = ::std::move(from);
  }

  inline ArtifactStructType& operator=(const ArtifactStructType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactStructType& operator=(ArtifactStructType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactStructType& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kSimple = 1,
    kUnionType = 2,
    kIntersection = 3,
    kList = 4,
    kNone = 5,
    kAny = 6,
    kTuple = 7,
    kDict = 8,
    KIND_NOT_SET = 0,
  };

  static inline const ArtifactStructType* internal_default_instance() {
    return reinterpret_cast<const ArtifactStructType*>(
               &_ArtifactStructType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ArtifactStructType& a, ArtifactStructType& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactStructType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactStructType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactStructType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactStructType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactStructType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArtifactStructType& from) {
    ArtifactStructType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactStructType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ArtifactStructType";
  }
  protected:
  explicit ArtifactStructType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimpleFieldNumber = 1,
    kUnionTypeFieldNumber = 2,
    kIntersectionFieldNumber = 3,
    kListFieldNumber = 4,
    kNoneFieldNumber = 5,
    kAnyFieldNumber = 6,
    kTupleFieldNumber = 7,
    kDictFieldNumber = 8,
  };
  // .ml_metadata.ArtifactType simple = 1;
  bool has_simple() const;
  private:
  bool _internal_has_simple() const;
  public:
  void clear_simple();
  const ::ml_metadata::ArtifactType& simple() const;
  PROTOBUF_NODISCARD ::ml_metadata::ArtifactType* release_simple();
  ::ml_metadata::ArtifactType* mutable_simple();
  void set_allocated_simple(::ml_metadata::ArtifactType* simple);
  private:
  const ::ml_metadata::ArtifactType& _internal_simple() const;
  ::ml_metadata::ArtifactType* _internal_mutable_simple();
  public:
  void unsafe_arena_set_allocated_simple(
      ::ml_metadata::ArtifactType* simple);
  ::ml_metadata::ArtifactType* unsafe_arena_release_simple();

  // .ml_metadata.UnionArtifactStructType union_type = 2;
  bool has_union_type() const;
  private:
  bool _internal_has_union_type() const;
  public:
  void clear_union_type();
  const ::ml_metadata::UnionArtifactStructType& union_type() const;
  PROTOBUF_NODISCARD ::ml_metadata::UnionArtifactStructType* release_union_type();
  ::ml_metadata::UnionArtifactStructType* mutable_union_type();
  void set_allocated_union_type(::ml_metadata::UnionArtifactStructType* union_type);
  private:
  const ::ml_metadata::UnionArtifactStructType& _internal_union_type() const;
  ::ml_metadata::UnionArtifactStructType* _internal_mutable_union_type();
  public:
  void unsafe_arena_set_allocated_union_type(
      ::ml_metadata::UnionArtifactStructType* union_type);
  ::ml_metadata::UnionArtifactStructType* unsafe_arena_release_union_type();

  // .ml_metadata.IntersectionArtifactStructType intersection = 3;
  bool has_intersection() const;
  private:
  bool _internal_has_intersection() const;
  public:
  void clear_intersection();
  const ::ml_metadata::IntersectionArtifactStructType& intersection() const;
  PROTOBUF_NODISCARD ::ml_metadata::IntersectionArtifactStructType* release_intersection();
  ::ml_metadata::IntersectionArtifactStructType* mutable_intersection();
  void set_allocated_intersection(::ml_metadata::IntersectionArtifactStructType* intersection);
  private:
  const ::ml_metadata::IntersectionArtifactStructType& _internal_intersection() const;
  ::ml_metadata::IntersectionArtifactStructType* _internal_mutable_intersection();
  public:
  void unsafe_arena_set_allocated_intersection(
      ::ml_metadata::IntersectionArtifactStructType* intersection);
  ::ml_metadata::IntersectionArtifactStructType* unsafe_arena_release_intersection();

  // .ml_metadata.ListArtifactStructType list = 4;
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::ml_metadata::ListArtifactStructType& list() const;
  PROTOBUF_NODISCARD ::ml_metadata::ListArtifactStructType* release_list();
  ::ml_metadata::ListArtifactStructType* mutable_list();
  void set_allocated_list(::ml_metadata::ListArtifactStructType* list);
  private:
  const ::ml_metadata::ListArtifactStructType& _internal_list() const;
  ::ml_metadata::ListArtifactStructType* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::ml_metadata::ListArtifactStructType* list);
  ::ml_metadata::ListArtifactStructType* unsafe_arena_release_list();

  // .ml_metadata.NoneArtifactStructType none = 5;
  bool has_none() const;
  private:
  bool _internal_has_none() const;
  public:
  void clear_none();
  const ::ml_metadata::NoneArtifactStructType& none() const;
  PROTOBUF_NODISCARD ::ml_metadata::NoneArtifactStructType* release_none();
  ::ml_metadata::NoneArtifactStructType* mutable_none();
  void set_allocated_none(::ml_metadata::NoneArtifactStructType* none);
  private:
  const ::ml_metadata::NoneArtifactStructType& _internal_none() const;
  ::ml_metadata::NoneArtifactStructType* _internal_mutable_none();
  public:
  void unsafe_arena_set_allocated_none(
      ::ml_metadata::NoneArtifactStructType* none);
  ::ml_metadata::NoneArtifactStructType* unsafe_arena_release_none();

  // .ml_metadata.AnyArtifactStructType any = 6;
  bool has_any() const;
  private:
  bool _internal_has_any() const;
  public:
  void clear_any();
  const ::ml_metadata::AnyArtifactStructType& any() const;
  PROTOBUF_NODISCARD ::ml_metadata::AnyArtifactStructType* release_any();
  ::ml_metadata::AnyArtifactStructType* mutable_any();
  void set_allocated_any(::ml_metadata::AnyArtifactStructType* any);
  private:
  const ::ml_metadata::AnyArtifactStructType& _internal_any() const;
  ::ml_metadata::AnyArtifactStructType* _internal_mutable_any();
  public:
  void unsafe_arena_set_allocated_any(
      ::ml_metadata::AnyArtifactStructType* any);
  ::ml_metadata::AnyArtifactStructType* unsafe_arena_release_any();

  // .ml_metadata.TupleArtifactStructType tuple = 7;
  bool has_tuple() const;
  private:
  bool _internal_has_tuple() const;
  public:
  void clear_tuple();
  const ::ml_metadata::TupleArtifactStructType& tuple() const;
  PROTOBUF_NODISCARD ::ml_metadata::TupleArtifactStructType* release_tuple();
  ::ml_metadata::TupleArtifactStructType* mutable_tuple();
  void set_allocated_tuple(::ml_metadata::TupleArtifactStructType* tuple);
  private:
  const ::ml_metadata::TupleArtifactStructType& _internal_tuple() const;
  ::ml_metadata::TupleArtifactStructType* _internal_mutable_tuple();
  public:
  void unsafe_arena_set_allocated_tuple(
      ::ml_metadata::TupleArtifactStructType* tuple);
  ::ml_metadata::TupleArtifactStructType* unsafe_arena_release_tuple();

  // .ml_metadata.DictArtifactStructType dict = 8;
  bool has_dict() const;
  private:
  bool _internal_has_dict() const;
  public:
  void clear_dict();
  const ::ml_metadata::DictArtifactStructType& dict() const;
  PROTOBUF_NODISCARD ::ml_metadata::DictArtifactStructType* release_dict();
  ::ml_metadata::DictArtifactStructType* mutable_dict();
  void set_allocated_dict(::ml_metadata::DictArtifactStructType* dict);
  private:
  const ::ml_metadata::DictArtifactStructType& _internal_dict() const;
  ::ml_metadata::DictArtifactStructType* _internal_mutable_dict();
  public:
  void unsafe_arena_set_allocated_dict(
      ::ml_metadata::DictArtifactStructType* dict);
  ::ml_metadata::DictArtifactStructType* unsafe_arena_release_dict();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:ml_metadata.ArtifactStructType)
 private:
  class _Internal;
  void set_has_simple();
  void set_has_union_type();
  void set_has_intersection();
  void set_has_list();
  void set_has_none();
  void set_has_any();
  void set_has_tuple();
  void set_has_dict();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ml_metadata::ArtifactType* simple_;
      ::ml_metadata::UnionArtifactStructType* union_type_;
      ::ml_metadata::IntersectionArtifactStructType* intersection_;
      ::ml_metadata::ListArtifactStructType* list_;
      ::ml_metadata::NoneArtifactStructType* none_;
      ::ml_metadata::AnyArtifactStructType* any_;
      ::ml_metadata::TupleArtifactStructType* tuple_;
      ::ml_metadata::DictArtifactStructType* dict_;
    } kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class UnionArtifactStructType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.UnionArtifactStructType) */ {
 public:
  inline UnionArtifactStructType() : UnionArtifactStructType(nullptr) {}
  ~UnionArtifactStructType() override;
  explicit PROTOBUF_CONSTEXPR UnionArtifactStructType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnionArtifactStructType(const UnionArtifactStructType& from);
  UnionArtifactStructType(UnionArtifactStructType&& from) noexcept
    : UnionArtifactStructType() {
    *this = ::std::move(from);
  }

  inline UnionArtifactStructType& operator=(const UnionArtifactStructType& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnionArtifactStructType& operator=(UnionArtifactStructType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnionArtifactStructType& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnionArtifactStructType* internal_default_instance() {
    return reinterpret_cast<const UnionArtifactStructType*>(
               &_UnionArtifactStructType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(UnionArtifactStructType& a, UnionArtifactStructType& b) {
    a.Swap(&b);
  }
  inline void Swap(UnionArtifactStructType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnionArtifactStructType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnionArtifactStructType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnionArtifactStructType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnionArtifactStructType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnionArtifactStructType& from) {
    UnionArtifactStructType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnionArtifactStructType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.UnionArtifactStructType";
  }
  protected:
  explicit UnionArtifactStructType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidatesFieldNumber = 1,
  };
  // repeated .ml_metadata.ArtifactStructType candidates = 1;
  int candidates_size() const;
  private:
  int _internal_candidates_size() const;
  public:
  void clear_candidates();
  ::ml_metadata::ArtifactStructType* mutable_candidates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType >*
      mutable_candidates();
  private:
  const ::ml_metadata::ArtifactStructType& _internal_candidates(int index) const;
  ::ml_metadata::ArtifactStructType* _internal_add_candidates();
  public:
  const ::ml_metadata::ArtifactStructType& candidates(int index) const;
  ::ml_metadata::ArtifactStructType* add_candidates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType >&
      candidates() const;

  // @@protoc_insertion_point(class_scope:ml_metadata.UnionArtifactStructType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType > candidates_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class IntersectionArtifactStructType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.IntersectionArtifactStructType) */ {
 public:
  inline IntersectionArtifactStructType() : IntersectionArtifactStructType(nullptr) {}
  ~IntersectionArtifactStructType() override;
  explicit PROTOBUF_CONSTEXPR IntersectionArtifactStructType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntersectionArtifactStructType(const IntersectionArtifactStructType& from);
  IntersectionArtifactStructType(IntersectionArtifactStructType&& from) noexcept
    : IntersectionArtifactStructType() {
    *this = ::std::move(from);
  }

  inline IntersectionArtifactStructType& operator=(const IntersectionArtifactStructType& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntersectionArtifactStructType& operator=(IntersectionArtifactStructType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntersectionArtifactStructType& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntersectionArtifactStructType* internal_default_instance() {
    return reinterpret_cast<const IntersectionArtifactStructType*>(
               &_IntersectionArtifactStructType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(IntersectionArtifactStructType& a, IntersectionArtifactStructType& b) {
    a.Swap(&b);
  }
  inline void Swap(IntersectionArtifactStructType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntersectionArtifactStructType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntersectionArtifactStructType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntersectionArtifactStructType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntersectionArtifactStructType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntersectionArtifactStructType& from) {
    IntersectionArtifactStructType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntersectionArtifactStructType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.IntersectionArtifactStructType";
  }
  protected:
  explicit IntersectionArtifactStructType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstraintsFieldNumber = 1,
  };
  // repeated .ml_metadata.ArtifactStructType constraints = 1;
  int constraints_size() const;
  private:
  int _internal_constraints_size() const;
  public:
  void clear_constraints();
  ::ml_metadata::ArtifactStructType* mutable_constraints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType >*
      mutable_constraints();
  private:
  const ::ml_metadata::ArtifactStructType& _internal_constraints(int index) const;
  ::ml_metadata::ArtifactStructType* _internal_add_constraints();
  public:
  const ::ml_metadata::ArtifactStructType& constraints(int index) const;
  ::ml_metadata::ArtifactStructType* add_constraints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType >&
      constraints() const;

  // @@protoc_insertion_point(class_scope:ml_metadata.IntersectionArtifactStructType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType > constraints_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListArtifactStructType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ListArtifactStructType) */ {
 public:
  inline ListArtifactStructType() : ListArtifactStructType(nullptr) {}
  ~ListArtifactStructType() override;
  explicit PROTOBUF_CONSTEXPR ListArtifactStructType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListArtifactStructType(const ListArtifactStructType& from);
  ListArtifactStructType(ListArtifactStructType&& from) noexcept
    : ListArtifactStructType() {
    *this = ::std::move(from);
  }

  inline ListArtifactStructType& operator=(const ListArtifactStructType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListArtifactStructType& operator=(ListArtifactStructType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListArtifactStructType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListArtifactStructType* internal_default_instance() {
    return reinterpret_cast<const ListArtifactStructType*>(
               &_ListArtifactStructType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ListArtifactStructType& a, ListArtifactStructType& b) {
    a.Swap(&b);
  }
  inline void Swap(ListArtifactStructType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListArtifactStructType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListArtifactStructType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListArtifactStructType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListArtifactStructType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListArtifactStructType& from) {
    ListArtifactStructType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListArtifactStructType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ListArtifactStructType";
  }
  protected:
  explicit ListArtifactStructType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementFieldNumber = 1,
  };
  // optional .ml_metadata.ArtifactStructType element = 1;
  bool has_element() const;
  private:
  bool _internal_has_element() const;
  public:
  void clear_element();
  const ::ml_metadata::ArtifactStructType& element() const;
  PROTOBUF_NODISCARD ::ml_metadata::ArtifactStructType* release_element();
  ::ml_metadata::ArtifactStructType* mutable_element();
  void set_allocated_element(::ml_metadata::ArtifactStructType* element);
  private:
  const ::ml_metadata::ArtifactStructType& _internal_element() const;
  ::ml_metadata::ArtifactStructType* _internal_mutable_element();
  public:
  void unsafe_arena_set_allocated_element(
      ::ml_metadata::ArtifactStructType* element);
  ::ml_metadata::ArtifactStructType* unsafe_arena_release_element();

  // @@protoc_insertion_point(class_scope:ml_metadata.ListArtifactStructType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ml_metadata::ArtifactStructType* element_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class NoneArtifactStructType final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ml_metadata.NoneArtifactStructType) */ {
 public:
  inline NoneArtifactStructType() : NoneArtifactStructType(nullptr) {}
  explicit PROTOBUF_CONSTEXPR NoneArtifactStructType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NoneArtifactStructType(const NoneArtifactStructType& from);
  NoneArtifactStructType(NoneArtifactStructType&& from) noexcept
    : NoneArtifactStructType() {
    *this = ::std::move(from);
  }

  inline NoneArtifactStructType& operator=(const NoneArtifactStructType& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoneArtifactStructType& operator=(NoneArtifactStructType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoneArtifactStructType& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoneArtifactStructType* internal_default_instance() {
    return reinterpret_cast<const NoneArtifactStructType*>(
               &_NoneArtifactStructType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(NoneArtifactStructType& a, NoneArtifactStructType& b) {
    a.Swap(&b);
  }
  inline void Swap(NoneArtifactStructType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoneArtifactStructType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoneArtifactStructType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoneArtifactStructType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NoneArtifactStructType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NoneArtifactStructType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.NoneArtifactStructType";
  }
  protected:
  explicit NoneArtifactStructType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ml_metadata.NoneArtifactStructType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class AnyArtifactStructType final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ml_metadata.AnyArtifactStructType) */ {
 public:
  inline AnyArtifactStructType() : AnyArtifactStructType(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AnyArtifactStructType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnyArtifactStructType(const AnyArtifactStructType& from);
  AnyArtifactStructType(AnyArtifactStructType&& from) noexcept
    : AnyArtifactStructType() {
    *this = ::std::move(from);
  }

  inline AnyArtifactStructType& operator=(const AnyArtifactStructType& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnyArtifactStructType& operator=(AnyArtifactStructType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnyArtifactStructType& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnyArtifactStructType* internal_default_instance() {
    return reinterpret_cast<const AnyArtifactStructType*>(
               &_AnyArtifactStructType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(AnyArtifactStructType& a, AnyArtifactStructType& b) {
    a.Swap(&b);
  }
  inline void Swap(AnyArtifactStructType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnyArtifactStructType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnyArtifactStructType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnyArtifactStructType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AnyArtifactStructType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AnyArtifactStructType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.AnyArtifactStructType";
  }
  protected:
  explicit AnyArtifactStructType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ml_metadata.AnyArtifactStructType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class TupleArtifactStructType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.TupleArtifactStructType) */ {
 public:
  inline TupleArtifactStructType() : TupleArtifactStructType(nullptr) {}
  ~TupleArtifactStructType() override;
  explicit PROTOBUF_CONSTEXPR TupleArtifactStructType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TupleArtifactStructType(const TupleArtifactStructType& from);
  TupleArtifactStructType(TupleArtifactStructType&& from) noexcept
    : TupleArtifactStructType() {
    *this = ::std::move(from);
  }

  inline TupleArtifactStructType& operator=(const TupleArtifactStructType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TupleArtifactStructType& operator=(TupleArtifactStructType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TupleArtifactStructType& default_instance() {
    return *internal_default_instance();
  }
  static inline const TupleArtifactStructType* internal_default_instance() {
    return reinterpret_cast<const TupleArtifactStructType*>(
               &_TupleArtifactStructType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TupleArtifactStructType& a, TupleArtifactStructType& b) {
    a.Swap(&b);
  }
  inline void Swap(TupleArtifactStructType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TupleArtifactStructType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TupleArtifactStructType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TupleArtifactStructType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TupleArtifactStructType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TupleArtifactStructType& from) {
    TupleArtifactStructType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TupleArtifactStructType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.TupleArtifactStructType";
  }
  protected:
  explicit TupleArtifactStructType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementsFieldNumber = 1,
  };
  // repeated .ml_metadata.ArtifactStructType elements = 1;
  int elements_size() const;
  private:
  int _internal_elements_size() const;
  public:
  void clear_elements();
  ::ml_metadata::ArtifactStructType* mutable_elements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType >*
      mutable_elements();
  private:
  const ::ml_metadata::ArtifactStructType& _internal_elements(int index) const;
  ::ml_metadata::ArtifactStructType* _internal_add_elements();
  public:
  const ::ml_metadata::ArtifactStructType& elements(int index) const;
  ::ml_metadata::ArtifactStructType* add_elements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType >&
      elements() const;

  // @@protoc_insertion_point(class_scope:ml_metadata.TupleArtifactStructType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType > elements_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class DictArtifactStructType_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DictArtifactStructType_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::ArtifactStructType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DictArtifactStructType_PropertiesEntry_DoNotUse, 
    std::string, ::ml_metadata::ArtifactStructType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  DictArtifactStructType_PropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR DictArtifactStructType_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DictArtifactStructType_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DictArtifactStructType_PropertiesEntry_DoNotUse& other);
  static const DictArtifactStructType_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DictArtifactStructType_PropertiesEntry_DoNotUse*>(&_DictArtifactStructType_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ml_metadata.DictArtifactStructType.PropertiesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};

// -------------------------------------------------------------------

class DictArtifactStructType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.DictArtifactStructType) */ {
 public:
  inline DictArtifactStructType() : DictArtifactStructType(nullptr) {}
  ~DictArtifactStructType() override;
  explicit PROTOBUF_CONSTEXPR DictArtifactStructType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DictArtifactStructType(const DictArtifactStructType& from);
  DictArtifactStructType(DictArtifactStructType&& from) noexcept
    : DictArtifactStructType() {
    *this = ::std::move(from);
  }

  inline DictArtifactStructType& operator=(const DictArtifactStructType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DictArtifactStructType& operator=(DictArtifactStructType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DictArtifactStructType& default_instance() {
    return *internal_default_instance();
  }
  static inline const DictArtifactStructType* internal_default_instance() {
    return reinterpret_cast<const DictArtifactStructType*>(
               &_DictArtifactStructType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(DictArtifactStructType& a, DictArtifactStructType& b) {
    a.Swap(&b);
  }
  inline void Swap(DictArtifactStructType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DictArtifactStructType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DictArtifactStructType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DictArtifactStructType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DictArtifactStructType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DictArtifactStructType& from) {
    DictArtifactStructType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DictArtifactStructType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.DictArtifactStructType";
  }
  protected:
  explicit DictArtifactStructType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 1,
    kExtraPropertiesTypeFieldNumber = 3,
    kNoneTypeNotRequiredFieldNumber = 2,
  };
  // map<string, .ml_metadata.ArtifactStructType> properties = 1;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::ArtifactStructType >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::ArtifactStructType >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::ArtifactStructType >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::ArtifactStructType >*
      mutable_properties();

  // optional .ml_metadata.ArtifactStructType extra_properties_type = 3;
  bool has_extra_properties_type() const;
  private:
  bool _internal_has_extra_properties_type() const;
  public:
  void clear_extra_properties_type();
  const ::ml_metadata::ArtifactStructType& extra_properties_type() const;
  PROTOBUF_NODISCARD ::ml_metadata::ArtifactStructType* release_extra_properties_type();
  ::ml_metadata::ArtifactStructType* mutable_extra_properties_type();
  void set_allocated_extra_properties_type(::ml_metadata::ArtifactStructType* extra_properties_type);
  private:
  const ::ml_metadata::ArtifactStructType& _internal_extra_properties_type() const;
  ::ml_metadata::ArtifactStructType* _internal_mutable_extra_properties_type();
  public:
  void unsafe_arena_set_allocated_extra_properties_type(
      ::ml_metadata::ArtifactStructType* extra_properties_type);
  ::ml_metadata::ArtifactStructType* unsafe_arena_release_extra_properties_type();

  // optional bool none_type_not_required = 2;
  bool has_none_type_not_required() const;
  private:
  bool _internal_has_none_type_not_required() const;
  public:
  void clear_none_type_not_required();
  bool none_type_not_required() const;
  void set_none_type_not_required(bool value);
  private:
  bool _internal_none_type_not_required() const;
  void _internal_set_none_type_not_required(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.DictArtifactStructType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        DictArtifactStructType_PropertiesEntry_DoNotUse,
        std::string, ::ml_metadata::ArtifactStructType,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> properties_;
    ::ml_metadata::ArtifactStructType* extra_properties_type_;
    bool none_type_not_required_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class FakeDatabaseConfig final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ml_metadata.FakeDatabaseConfig) */ {
 public:
  inline FakeDatabaseConfig() : FakeDatabaseConfig(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FakeDatabaseConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FakeDatabaseConfig(const FakeDatabaseConfig& from);
  FakeDatabaseConfig(FakeDatabaseConfig&& from) noexcept
    : FakeDatabaseConfig() {
    *this = ::std::move(from);
  }

  inline FakeDatabaseConfig& operator=(const FakeDatabaseConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline FakeDatabaseConfig& operator=(FakeDatabaseConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FakeDatabaseConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const FakeDatabaseConfig* internal_default_instance() {
    return reinterpret_cast<const FakeDatabaseConfig*>(
               &_FakeDatabaseConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(FakeDatabaseConfig& a, FakeDatabaseConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(FakeDatabaseConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FakeDatabaseConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FakeDatabaseConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FakeDatabaseConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FakeDatabaseConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FakeDatabaseConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.FakeDatabaseConfig";
  }
  protected:
  explicit FakeDatabaseConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ml_metadata.FakeDatabaseConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class MySQLDatabaseConfig_SSLOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.MySQLDatabaseConfig.SSLOptions) */ {
 public:
  inline MySQLDatabaseConfig_SSLOptions() : MySQLDatabaseConfig_SSLOptions(nullptr) {}
  ~MySQLDatabaseConfig_SSLOptions() override;
  explicit PROTOBUF_CONSTEXPR MySQLDatabaseConfig_SSLOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MySQLDatabaseConfig_SSLOptions(const MySQLDatabaseConfig_SSLOptions& from);
  MySQLDatabaseConfig_SSLOptions(MySQLDatabaseConfig_SSLOptions&& from) noexcept
    : MySQLDatabaseConfig_SSLOptions() {
    *this = ::std::move(from);
  }

  inline MySQLDatabaseConfig_SSLOptions& operator=(const MySQLDatabaseConfig_SSLOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline MySQLDatabaseConfig_SSLOptions& operator=(MySQLDatabaseConfig_SSLOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MySQLDatabaseConfig_SSLOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const MySQLDatabaseConfig_SSLOptions* internal_default_instance() {
    return reinterpret_cast<const MySQLDatabaseConfig_SSLOptions*>(
               &_MySQLDatabaseConfig_SSLOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(MySQLDatabaseConfig_SSLOptions& a, MySQLDatabaseConfig_SSLOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(MySQLDatabaseConfig_SSLOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MySQLDatabaseConfig_SSLOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MySQLDatabaseConfig_SSLOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MySQLDatabaseConfig_SSLOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MySQLDatabaseConfig_SSLOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MySQLDatabaseConfig_SSLOptions& from) {
    MySQLDatabaseConfig_SSLOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MySQLDatabaseConfig_SSLOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.MySQLDatabaseConfig.SSLOptions";
  }
  protected:
  explicit MySQLDatabaseConfig_SSLOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kCertFieldNumber = 2,
    kCaFieldNumber = 3,
    kCapathFieldNumber = 4,
    kCipherFieldNumber = 5,
    kVerifyServerCertFieldNumber = 6,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional string cert = 2;
  bool has_cert() const;
  private:
  bool _internal_has_cert() const;
  public:
  void clear_cert();
  const std::string& cert() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cert(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cert();
  PROTOBUF_NODISCARD std::string* release_cert();
  void set_allocated_cert(std::string* cert);
  private:
  const std::string& _internal_cert() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cert(const std::string& value);
  std::string* _internal_mutable_cert();
  public:

  // optional string ca = 3;
  bool has_ca() const;
  private:
  bool _internal_has_ca() const;
  public:
  void clear_ca();
  const std::string& ca() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ca(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ca();
  PROTOBUF_NODISCARD std::string* release_ca();
  void set_allocated_ca(std::string* ca);
  private:
  const std::string& _internal_ca() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ca(const std::string& value);
  std::string* _internal_mutable_ca();
  public:

  // optional string capath = 4;
  bool has_capath() const;
  private:
  bool _internal_has_capath() const;
  public:
  void clear_capath();
  const std::string& capath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_capath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_capath();
  PROTOBUF_NODISCARD std::string* release_capath();
  void set_allocated_capath(std::string* capath);
  private:
  const std::string& _internal_capath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_capath(const std::string& value);
  std::string* _internal_mutable_capath();
  public:

  // optional string cipher = 5;
  bool has_cipher() const;
  private:
  bool _internal_has_cipher() const;
  public:
  void clear_cipher();
  const std::string& cipher() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cipher(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cipher();
  PROTOBUF_NODISCARD std::string* release_cipher();
  void set_allocated_cipher(std::string* cipher);
  private:
  const std::string& _internal_cipher() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cipher(const std::string& value);
  std::string* _internal_mutable_cipher();
  public:

  // optional bool verify_server_cert = 6;
  bool has_verify_server_cert() const;
  private:
  bool _internal_has_verify_server_cert() const;
  public:
  void clear_verify_server_cert();
  bool verify_server_cert() const;
  void set_verify_server_cert(bool value);
  private:
  bool _internal_verify_server_cert() const;
  void _internal_set_verify_server_cert(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.MySQLDatabaseConfig.SSLOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cert_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ca_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr capath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cipher_;
    bool verify_server_cert_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class MySQLDatabaseConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.MySQLDatabaseConfig) */ {
 public:
  inline MySQLDatabaseConfig() : MySQLDatabaseConfig(nullptr) {}
  ~MySQLDatabaseConfig() override;
  explicit PROTOBUF_CONSTEXPR MySQLDatabaseConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MySQLDatabaseConfig(const MySQLDatabaseConfig& from);
  MySQLDatabaseConfig(MySQLDatabaseConfig&& from) noexcept
    : MySQLDatabaseConfig() {
    *this = ::std::move(from);
  }

  inline MySQLDatabaseConfig& operator=(const MySQLDatabaseConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MySQLDatabaseConfig& operator=(MySQLDatabaseConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MySQLDatabaseConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MySQLDatabaseConfig* internal_default_instance() {
    return reinterpret_cast<const MySQLDatabaseConfig*>(
               &_MySQLDatabaseConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(MySQLDatabaseConfig& a, MySQLDatabaseConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MySQLDatabaseConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MySQLDatabaseConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MySQLDatabaseConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MySQLDatabaseConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MySQLDatabaseConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MySQLDatabaseConfig& from) {
    MySQLDatabaseConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MySQLDatabaseConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.MySQLDatabaseConfig";
  }
  protected:
  explicit MySQLDatabaseConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MySQLDatabaseConfig_SSLOptions SSLOptions;

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
    kDatabaseFieldNumber = 3,
    kUserFieldNumber = 4,
    kPasswordFieldNumber = 5,
    kSocketFieldNumber = 6,
    kSslOptionsFieldNumber = 7,
    kPortFieldNumber = 2,
    kSkipDbCreationFieldNumber = 8,
  };
  // optional string host = 1;
  bool has_host() const;
  private:
  bool _internal_has_host() const;
  public:
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // optional string database = 3;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // optional string user = 4;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // optional string password = 5;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional string socket = 6;
  bool has_socket() const;
  private:
  bool _internal_has_socket() const;
  public:
  void clear_socket();
  const std::string& socket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_socket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_socket();
  PROTOBUF_NODISCARD std::string* release_socket();
  void set_allocated_socket(std::string* socket);
  private:
  const std::string& _internal_socket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_socket(const std::string& value);
  std::string* _internal_mutable_socket();
  public:

  // optional .ml_metadata.MySQLDatabaseConfig.SSLOptions ssl_options = 7;
  bool has_ssl_options() const;
  private:
  bool _internal_has_ssl_options() const;
  public:
  void clear_ssl_options();
  const ::ml_metadata::MySQLDatabaseConfig_SSLOptions& ssl_options() const;
  PROTOBUF_NODISCARD ::ml_metadata::MySQLDatabaseConfig_SSLOptions* release_ssl_options();
  ::ml_metadata::MySQLDatabaseConfig_SSLOptions* mutable_ssl_options();
  void set_allocated_ssl_options(::ml_metadata::MySQLDatabaseConfig_SSLOptions* ssl_options);
  private:
  const ::ml_metadata::MySQLDatabaseConfig_SSLOptions& _internal_ssl_options() const;
  ::ml_metadata::MySQLDatabaseConfig_SSLOptions* _internal_mutable_ssl_options();
  public:
  void unsafe_arena_set_allocated_ssl_options(
      ::ml_metadata::MySQLDatabaseConfig_SSLOptions* ssl_options);
  ::ml_metadata::MySQLDatabaseConfig_SSLOptions* unsafe_arena_release_ssl_options();

  // optional int64 port = 2;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  int64_t port() const;
  void set_port(int64_t value);
  private:
  int64_t _internal_port() const;
  void _internal_set_port(int64_t value);
  public:

  // optional bool skip_db_creation = 8;
  bool has_skip_db_creation() const;
  private:
  bool _internal_has_skip_db_creation() const;
  public:
  void clear_skip_db_creation();
  bool skip_db_creation() const;
  void set_skip_db_creation(bool value);
  private:
  bool _internal_skip_db_creation() const;
  void _internal_set_skip_db_creation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.MySQLDatabaseConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr socket_;
    ::ml_metadata::MySQLDatabaseConfig_SSLOptions* ssl_options_;
    int64_t port_;
    bool skip_db_creation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class SqliteMetadataSourceConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.SqliteMetadataSourceConfig) */ {
 public:
  inline SqliteMetadataSourceConfig() : SqliteMetadataSourceConfig(nullptr) {}
  ~SqliteMetadataSourceConfig() override;
  explicit PROTOBUF_CONSTEXPR SqliteMetadataSourceConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SqliteMetadataSourceConfig(const SqliteMetadataSourceConfig& from);
  SqliteMetadataSourceConfig(SqliteMetadataSourceConfig&& from) noexcept
    : SqliteMetadataSourceConfig() {
    *this = ::std::move(from);
  }

  inline SqliteMetadataSourceConfig& operator=(const SqliteMetadataSourceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SqliteMetadataSourceConfig& operator=(SqliteMetadataSourceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SqliteMetadataSourceConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SqliteMetadataSourceConfig* internal_default_instance() {
    return reinterpret_cast<const SqliteMetadataSourceConfig*>(
               &_SqliteMetadataSourceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(SqliteMetadataSourceConfig& a, SqliteMetadataSourceConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SqliteMetadataSourceConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SqliteMetadataSourceConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SqliteMetadataSourceConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SqliteMetadataSourceConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SqliteMetadataSourceConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SqliteMetadataSourceConfig& from) {
    SqliteMetadataSourceConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SqliteMetadataSourceConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.SqliteMetadataSourceConfig";
  }
  protected:
  explicit SqliteMetadataSourceConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SqliteMetadataSourceConfig_ConnectionMode ConnectionMode;
  static constexpr ConnectionMode UNKNOWN =
    SqliteMetadataSourceConfig_ConnectionMode_UNKNOWN;
  static constexpr ConnectionMode READONLY =
    SqliteMetadataSourceConfig_ConnectionMode_READONLY;
  static constexpr ConnectionMode READWRITE =
    SqliteMetadataSourceConfig_ConnectionMode_READWRITE;
  static constexpr ConnectionMode READWRITE_OPENCREATE =
    SqliteMetadataSourceConfig_ConnectionMode_READWRITE_OPENCREATE;
  static inline bool ConnectionMode_IsValid(int value) {
    return SqliteMetadataSourceConfig_ConnectionMode_IsValid(value);
  }
  static constexpr ConnectionMode ConnectionMode_MIN =
    SqliteMetadataSourceConfig_ConnectionMode_ConnectionMode_MIN;
  static constexpr ConnectionMode ConnectionMode_MAX =
    SqliteMetadataSourceConfig_ConnectionMode_ConnectionMode_MAX;
  static constexpr int ConnectionMode_ARRAYSIZE =
    SqliteMetadataSourceConfig_ConnectionMode_ConnectionMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ConnectionMode_descriptor() {
    return SqliteMetadataSourceConfig_ConnectionMode_descriptor();
  }
  template<typename T>
  static inline const std::string& ConnectionMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConnectionMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConnectionMode_Name.");
    return SqliteMetadataSourceConfig_ConnectionMode_Name(enum_t_value);
  }
  static inline bool ConnectionMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConnectionMode* value) {
    return SqliteMetadataSourceConfig_ConnectionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameUriFieldNumber = 1,
    kConnectionModeFieldNumber = 2,
  };
  // optional string filename_uri = 1;
  bool has_filename_uri() const;
  private:
  bool _internal_has_filename_uri() const;
  public:
  void clear_filename_uri();
  const std::string& filename_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename_uri();
  PROTOBUF_NODISCARD std::string* release_filename_uri();
  void set_allocated_filename_uri(std::string* filename_uri);
  private:
  const std::string& _internal_filename_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename_uri(const std::string& value);
  std::string* _internal_mutable_filename_uri();
  public:

  // optional .ml_metadata.SqliteMetadataSourceConfig.ConnectionMode connection_mode = 2;
  bool has_connection_mode() const;
  private:
  bool _internal_has_connection_mode() const;
  public:
  void clear_connection_mode();
  ::ml_metadata::SqliteMetadataSourceConfig_ConnectionMode connection_mode() const;
  void set_connection_mode(::ml_metadata::SqliteMetadataSourceConfig_ConnectionMode value);
  private:
  ::ml_metadata::SqliteMetadataSourceConfig_ConnectionMode _internal_connection_mode() const;
  void _internal_set_connection_mode(::ml_metadata::SqliteMetadataSourceConfig_ConnectionMode value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.SqliteMetadataSourceConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_uri_;
    int connection_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class PostgreSQLDatabaseConfig_SSLOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions) */ {
 public:
  inline PostgreSQLDatabaseConfig_SSLOptions() : PostgreSQLDatabaseConfig_SSLOptions(nullptr) {}
  ~PostgreSQLDatabaseConfig_SSLOptions() override;
  explicit PROTOBUF_CONSTEXPR PostgreSQLDatabaseConfig_SSLOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostgreSQLDatabaseConfig_SSLOptions(const PostgreSQLDatabaseConfig_SSLOptions& from);
  PostgreSQLDatabaseConfig_SSLOptions(PostgreSQLDatabaseConfig_SSLOptions&& from) noexcept
    : PostgreSQLDatabaseConfig_SSLOptions() {
    *this = ::std::move(from);
  }

  inline PostgreSQLDatabaseConfig_SSLOptions& operator=(const PostgreSQLDatabaseConfig_SSLOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostgreSQLDatabaseConfig_SSLOptions& operator=(PostgreSQLDatabaseConfig_SSLOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostgreSQLDatabaseConfig_SSLOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostgreSQLDatabaseConfig_SSLOptions* internal_default_instance() {
    return reinterpret_cast<const PostgreSQLDatabaseConfig_SSLOptions*>(
               &_PostgreSQLDatabaseConfig_SSLOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(PostgreSQLDatabaseConfig_SSLOptions& a, PostgreSQLDatabaseConfig_SSLOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(PostgreSQLDatabaseConfig_SSLOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostgreSQLDatabaseConfig_SSLOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostgreSQLDatabaseConfig_SSLOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostgreSQLDatabaseConfig_SSLOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostgreSQLDatabaseConfig_SSLOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostgreSQLDatabaseConfig_SSLOptions& from) {
    PostgreSQLDatabaseConfig_SSLOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostgreSQLDatabaseConfig_SSLOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.PostgreSQLDatabaseConfig.SSLOptions";
  }
  protected:
  explicit PostgreSQLDatabaseConfig_SSLOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSslmodeFieldNumber = 1,
    kSslcertFieldNumber = 2,
    kSslkeyFieldNumber = 3,
    kSslpasswordFieldNumber = 4,
    kSslrootcertFieldNumber = 5,
  };
  // optional string sslmode = 1;
  bool has_sslmode() const;
  private:
  bool _internal_has_sslmode() const;
  public:
  void clear_sslmode();
  const std::string& sslmode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sslmode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sslmode();
  PROTOBUF_NODISCARD std::string* release_sslmode();
  void set_allocated_sslmode(std::string* sslmode);
  private:
  const std::string& _internal_sslmode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sslmode(const std::string& value);
  std::string* _internal_mutable_sslmode();
  public:

  // optional string sslcert = 2;
  bool has_sslcert() const;
  private:
  bool _internal_has_sslcert() const;
  public:
  void clear_sslcert();
  const std::string& sslcert() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sslcert(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sslcert();
  PROTOBUF_NODISCARD std::string* release_sslcert();
  void set_allocated_sslcert(std::string* sslcert);
  private:
  const std::string& _internal_sslcert() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sslcert(const std::string& value);
  std::string* _internal_mutable_sslcert();
  public:

  // optional string sslkey = 3;
  bool has_sslkey() const;
  private:
  bool _internal_has_sslkey() const;
  public:
  void clear_sslkey();
  const std::string& sslkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sslkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sslkey();
  PROTOBUF_NODISCARD std::string* release_sslkey();
  void set_allocated_sslkey(std::string* sslkey);
  private:
  const std::string& _internal_sslkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sslkey(const std::string& value);
  std::string* _internal_mutable_sslkey();
  public:

  // optional string sslpassword = 4;
  bool has_sslpassword() const;
  private:
  bool _internal_has_sslpassword() const;
  public:
  void clear_sslpassword();
  const std::string& sslpassword() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sslpassword(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sslpassword();
  PROTOBUF_NODISCARD std::string* release_sslpassword();
  void set_allocated_sslpassword(std::string* sslpassword);
  private:
  const std::string& _internal_sslpassword() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sslpassword(const std::string& value);
  std::string* _internal_mutable_sslpassword();
  public:

  // optional string sslrootcert = 5;
  bool has_sslrootcert() const;
  private:
  bool _internal_has_sslrootcert() const;
  public:
  void clear_sslrootcert();
  const std::string& sslrootcert() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sslrootcert(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sslrootcert();
  PROTOBUF_NODISCARD std::string* release_sslrootcert();
  void set_allocated_sslrootcert(std::string* sslrootcert);
  private:
  const std::string& _internal_sslrootcert() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sslrootcert(const std::string& value);
  std::string* _internal_mutable_sslrootcert();
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sslmode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sslcert_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sslkey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sslpassword_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sslrootcert_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class PostgreSQLDatabaseConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.PostgreSQLDatabaseConfig) */ {
 public:
  inline PostgreSQLDatabaseConfig() : PostgreSQLDatabaseConfig(nullptr) {}
  ~PostgreSQLDatabaseConfig() override;
  explicit PROTOBUF_CONSTEXPR PostgreSQLDatabaseConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostgreSQLDatabaseConfig(const PostgreSQLDatabaseConfig& from);
  PostgreSQLDatabaseConfig(PostgreSQLDatabaseConfig&& from) noexcept
    : PostgreSQLDatabaseConfig() {
    *this = ::std::move(from);
  }

  inline PostgreSQLDatabaseConfig& operator=(const PostgreSQLDatabaseConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostgreSQLDatabaseConfig& operator=(PostgreSQLDatabaseConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostgreSQLDatabaseConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostgreSQLDatabaseConfig* internal_default_instance() {
    return reinterpret_cast<const PostgreSQLDatabaseConfig*>(
               &_PostgreSQLDatabaseConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(PostgreSQLDatabaseConfig& a, PostgreSQLDatabaseConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PostgreSQLDatabaseConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostgreSQLDatabaseConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostgreSQLDatabaseConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostgreSQLDatabaseConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostgreSQLDatabaseConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostgreSQLDatabaseConfig& from) {
    PostgreSQLDatabaseConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostgreSQLDatabaseConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.PostgreSQLDatabaseConfig";
  }
  protected:
  explicit PostgreSQLDatabaseConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PostgreSQLDatabaseConfig_SSLOptions SSLOptions;

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
    kHostaddrFieldNumber = 2,
    kPortFieldNumber = 3,
    kUserFieldNumber = 4,
    kPasswordFieldNumber = 5,
    kPassfileFieldNumber = 6,
    kDbnameFieldNumber = 7,
    kSsloptionFieldNumber = 9,
    kSkipDbCreationFieldNumber = 8,
  };
  // optional string host = 1;
  bool has_host() const;
  private:
  bool _internal_has_host() const;
  public:
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // optional string hostaddr = 2;
  bool has_hostaddr() const;
  private:
  bool _internal_has_hostaddr() const;
  public:
  void clear_hostaddr();
  const std::string& hostaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostaddr();
  PROTOBUF_NODISCARD std::string* release_hostaddr();
  void set_allocated_hostaddr(std::string* hostaddr);
  private:
  const std::string& _internal_hostaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostaddr(const std::string& value);
  std::string* _internal_mutable_hostaddr();
  public:

  // optional string port = 3;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  const std::string& port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // optional string user = 4;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // optional string password = 5;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional string passfile = 6;
  bool has_passfile() const;
  private:
  bool _internal_has_passfile() const;
  public:
  void clear_passfile();
  const std::string& passfile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passfile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passfile();
  PROTOBUF_NODISCARD std::string* release_passfile();
  void set_allocated_passfile(std::string* passfile);
  private:
  const std::string& _internal_passfile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passfile(const std::string& value);
  std::string* _internal_mutable_passfile();
  public:

  // optional string dbname = 7;
  bool has_dbname() const;
  private:
  bool _internal_has_dbname() const;
  public:
  void clear_dbname();
  const std::string& dbname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dbname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dbname();
  PROTOBUF_NODISCARD std::string* release_dbname();
  void set_allocated_dbname(std::string* dbname);
  private:
  const std::string& _internal_dbname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbname(const std::string& value);
  std::string* _internal_mutable_dbname();
  public:

  // optional .ml_metadata.PostgreSQLDatabaseConfig.SSLOptions ssloption = 9;
  bool has_ssloption() const;
  private:
  bool _internal_has_ssloption() const;
  public:
  void clear_ssloption();
  const ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions& ssloption() const;
  PROTOBUF_NODISCARD ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* release_ssloption();
  ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* mutable_ssloption();
  void set_allocated_ssloption(::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* ssloption);
  private:
  const ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions& _internal_ssloption() const;
  ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* _internal_mutable_ssloption();
  public:
  void unsafe_arena_set_allocated_ssloption(
      ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* ssloption);
  ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* unsafe_arena_release_ssloption();

  // optional bool skip_db_creation = 8;
  bool has_skip_db_creation() const;
  private:
  bool _internal_has_skip_db_creation() const;
  public:
  void clear_skip_db_creation();
  bool skip_db_creation() const;
  void set_skip_db_creation(bool value);
  private:
  bool _internal_skip_db_creation() const;
  void _internal_set_skip_db_creation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.PostgreSQLDatabaseConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostaddr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passfile_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dbname_;
    ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* ssloption_;
    bool skip_db_creation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class MigrationOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.MigrationOptions) */ {
 public:
  inline MigrationOptions() : MigrationOptions(nullptr) {}
  ~MigrationOptions() override;
  explicit PROTOBUF_CONSTEXPR MigrationOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MigrationOptions(const MigrationOptions& from);
  MigrationOptions(MigrationOptions&& from) noexcept
    : MigrationOptions() {
    *this = ::std::move(from);
  }

  inline MigrationOptions& operator=(const MigrationOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigrationOptions& operator=(MigrationOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MigrationOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const MigrationOptions* internal_default_instance() {
    return reinterpret_cast<const MigrationOptions*>(
               &_MigrationOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(MigrationOptions& a, MigrationOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(MigrationOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MigrationOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MigrationOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MigrationOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MigrationOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MigrationOptions& from) {
    MigrationOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MigrationOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.MigrationOptions";
  }
  protected:
  explicit MigrationOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableUpgradeMigrationFieldNumber = 3,
    kDowngradeToSchemaVersionFieldNumber = 2,
  };
  // optional bool enable_upgrade_migration = 3;
  bool has_enable_upgrade_migration() const;
  private:
  bool _internal_has_enable_upgrade_migration() const;
  public:
  void clear_enable_upgrade_migration();
  bool enable_upgrade_migration() const;
  void set_enable_upgrade_migration(bool value);
  private:
  bool _internal_enable_upgrade_migration() const;
  void _internal_set_enable_upgrade_migration(bool value);
  public:

  // optional int64 downgrade_to_schema_version = 2 [default = -1];
  bool has_downgrade_to_schema_version() const;
  private:
  bool _internal_has_downgrade_to_schema_version() const;
  public:
  void clear_downgrade_to_schema_version();
  int64_t downgrade_to_schema_version() const;
  void set_downgrade_to_schema_version(int64_t value);
  private:
  int64_t _internal_downgrade_to_schema_version() const;
  void _internal_set_downgrade_to_schema_version(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.MigrationOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enable_upgrade_migration_;
    int64_t downgrade_to_schema_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class RetryOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.RetryOptions) */ {
 public:
  inline RetryOptions() : RetryOptions(nullptr) {}
  ~RetryOptions() override;
  explicit PROTOBUF_CONSTEXPR RetryOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RetryOptions(const RetryOptions& from);
  RetryOptions(RetryOptions&& from) noexcept
    : RetryOptions() {
    *this = ::std::move(from);
  }

  inline RetryOptions& operator=(const RetryOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline RetryOptions& operator=(RetryOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RetryOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const RetryOptions* internal_default_instance() {
    return reinterpret_cast<const RetryOptions*>(
               &_RetryOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(RetryOptions& a, RetryOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(RetryOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RetryOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RetryOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RetryOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RetryOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RetryOptions& from) {
    RetryOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetryOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.RetryOptions";
  }
  protected:
  explicit RetryOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxNumRetriesFieldNumber = 1,
  };
  // optional int64 max_num_retries = 1;
  bool has_max_num_retries() const;
  private:
  bool _internal_has_max_num_retries() const;
  public:
  void clear_max_num_retries();
  int64_t max_num_retries() const;
  void set_max_num_retries(int64_t value);
  private:
  int64_t _internal_max_num_retries() const;
  void _internal_set_max_num_retries(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.RetryOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t max_num_retries_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ConnectionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ConnectionConfig) */ {
 public:
  inline ConnectionConfig() : ConnectionConfig(nullptr) {}
  ~ConnectionConfig() override;
  explicit PROTOBUF_CONSTEXPR ConnectionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionConfig(const ConnectionConfig& from);
  ConnectionConfig(ConnectionConfig&& from) noexcept
    : ConnectionConfig() {
    *this = ::std::move(from);
  }

  inline ConnectionConfig& operator=(const ConnectionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionConfig& operator=(ConnectionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionConfig& default_instance() {
    return *internal_default_instance();
  }
  enum ConfigCase {
    kFakeDatabase = 1,
    kMysql = 2,
    kSqlite = 3,
    kPostgresql = 5,
    CONFIG_NOT_SET = 0,
  };

  static inline const ConnectionConfig* internal_default_instance() {
    return reinterpret_cast<const ConnectionConfig*>(
               &_ConnectionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ConnectionConfig& a, ConnectionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectionConfig& from) {
    ConnectionConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ConnectionConfig";
  }
  protected:
  explicit ConnectionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetryOptionsFieldNumber = 4,
    kFakeDatabaseFieldNumber = 1,
    kMysqlFieldNumber = 2,
    kSqliteFieldNumber = 3,
    kPostgresqlFieldNumber = 5,
  };
  // optional .ml_metadata.RetryOptions retry_options = 4;
  bool has_retry_options() const;
  private:
  bool _internal_has_retry_options() const;
  public:
  void clear_retry_options();
  const ::ml_metadata::RetryOptions& retry_options() const;
  PROTOBUF_NODISCARD ::ml_metadata::RetryOptions* release_retry_options();
  ::ml_metadata::RetryOptions* mutable_retry_options();
  void set_allocated_retry_options(::ml_metadata::RetryOptions* retry_options);
  private:
  const ::ml_metadata::RetryOptions& _internal_retry_options() const;
  ::ml_metadata::RetryOptions* _internal_mutable_retry_options();
  public:
  void unsafe_arena_set_allocated_retry_options(
      ::ml_metadata::RetryOptions* retry_options);
  ::ml_metadata::RetryOptions* unsafe_arena_release_retry_options();

  // .ml_metadata.FakeDatabaseConfig fake_database = 1;
  bool has_fake_database() const;
  private:
  bool _internal_has_fake_database() const;
  public:
  void clear_fake_database();
  const ::ml_metadata::FakeDatabaseConfig& fake_database() const;
  PROTOBUF_NODISCARD ::ml_metadata::FakeDatabaseConfig* release_fake_database();
  ::ml_metadata::FakeDatabaseConfig* mutable_fake_database();
  void set_allocated_fake_database(::ml_metadata::FakeDatabaseConfig* fake_database);
  private:
  const ::ml_metadata::FakeDatabaseConfig& _internal_fake_database() const;
  ::ml_metadata::FakeDatabaseConfig* _internal_mutable_fake_database();
  public:
  void unsafe_arena_set_allocated_fake_database(
      ::ml_metadata::FakeDatabaseConfig* fake_database);
  ::ml_metadata::FakeDatabaseConfig* unsafe_arena_release_fake_database();

  // .ml_metadata.MySQLDatabaseConfig mysql = 2;
  bool has_mysql() const;
  private:
  bool _internal_has_mysql() const;
  public:
  void clear_mysql();
  const ::ml_metadata::MySQLDatabaseConfig& mysql() const;
  PROTOBUF_NODISCARD ::ml_metadata::MySQLDatabaseConfig* release_mysql();
  ::ml_metadata::MySQLDatabaseConfig* mutable_mysql();
  void set_allocated_mysql(::ml_metadata::MySQLDatabaseConfig* mysql);
  private:
  const ::ml_metadata::MySQLDatabaseConfig& _internal_mysql() const;
  ::ml_metadata::MySQLDatabaseConfig* _internal_mutable_mysql();
  public:
  void unsafe_arena_set_allocated_mysql(
      ::ml_metadata::MySQLDatabaseConfig* mysql);
  ::ml_metadata::MySQLDatabaseConfig* unsafe_arena_release_mysql();

  // .ml_metadata.SqliteMetadataSourceConfig sqlite = 3;
  bool has_sqlite() const;
  private:
  bool _internal_has_sqlite() const;
  public:
  void clear_sqlite();
  const ::ml_metadata::SqliteMetadataSourceConfig& sqlite() const;
  PROTOBUF_NODISCARD ::ml_metadata::SqliteMetadataSourceConfig* release_sqlite();
  ::ml_metadata::SqliteMetadataSourceConfig* mutable_sqlite();
  void set_allocated_sqlite(::ml_metadata::SqliteMetadataSourceConfig* sqlite);
  private:
  const ::ml_metadata::SqliteMetadataSourceConfig& _internal_sqlite() const;
  ::ml_metadata::SqliteMetadataSourceConfig* _internal_mutable_sqlite();
  public:
  void unsafe_arena_set_allocated_sqlite(
      ::ml_metadata::SqliteMetadataSourceConfig* sqlite);
  ::ml_metadata::SqliteMetadataSourceConfig* unsafe_arena_release_sqlite();

  // .ml_metadata.PostgreSQLDatabaseConfig postgresql = 5;
  bool has_postgresql() const;
  private:
  bool _internal_has_postgresql() const;
  public:
  void clear_postgresql();
  const ::ml_metadata::PostgreSQLDatabaseConfig& postgresql() const;
  PROTOBUF_NODISCARD ::ml_metadata::PostgreSQLDatabaseConfig* release_postgresql();
  ::ml_metadata::PostgreSQLDatabaseConfig* mutable_postgresql();
  void set_allocated_postgresql(::ml_metadata::PostgreSQLDatabaseConfig* postgresql);
  private:
  const ::ml_metadata::PostgreSQLDatabaseConfig& _internal_postgresql() const;
  ::ml_metadata::PostgreSQLDatabaseConfig* _internal_mutable_postgresql();
  public:
  void unsafe_arena_set_allocated_postgresql(
      ::ml_metadata::PostgreSQLDatabaseConfig* postgresql);
  ::ml_metadata::PostgreSQLDatabaseConfig* unsafe_arena_release_postgresql();

  void clear_config();
  ConfigCase config_case() const;
  // @@protoc_insertion_point(class_scope:ml_metadata.ConnectionConfig)
 private:
  class _Internal;
  void set_has_fake_database();
  void set_has_mysql();
  void set_has_sqlite();
  void set_has_postgresql();

  inline bool has_config() const;
  inline void clear_has_config();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ml_metadata::RetryOptions* retry_options_;
    union ConfigUnion {
      constexpr ConfigUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ml_metadata::FakeDatabaseConfig* fake_database_;
      ::ml_metadata::MySQLDatabaseConfig* mysql_;
      ::ml_metadata::SqliteMetadataSourceConfig* sqlite_;
      ::ml_metadata::PostgreSQLDatabaseConfig* postgresql_;
    } config_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class GrpcChannelArguments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.GrpcChannelArguments) */ {
 public:
  inline GrpcChannelArguments() : GrpcChannelArguments(nullptr) {}
  ~GrpcChannelArguments() override;
  explicit PROTOBUF_CONSTEXPR GrpcChannelArguments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrpcChannelArguments(const GrpcChannelArguments& from);
  GrpcChannelArguments(GrpcChannelArguments&& from) noexcept
    : GrpcChannelArguments() {
    *this = ::std::move(from);
  }

  inline GrpcChannelArguments& operator=(const GrpcChannelArguments& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrpcChannelArguments& operator=(GrpcChannelArguments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrpcChannelArguments& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrpcChannelArguments* internal_default_instance() {
    return reinterpret_cast<const GrpcChannelArguments*>(
               &_GrpcChannelArguments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(GrpcChannelArguments& a, GrpcChannelArguments& b) {
    a.Swap(&b);
  }
  inline void Swap(GrpcChannelArguments* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrpcChannelArguments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrpcChannelArguments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrpcChannelArguments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrpcChannelArguments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GrpcChannelArguments& from) {
    GrpcChannelArguments::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrpcChannelArguments* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.GrpcChannelArguments";
  }
  protected:
  explicit GrpcChannelArguments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxReceiveMessageLengthFieldNumber = 1,
    kHttp2MaxPingStrikesFieldNumber = 2,
  };
  // optional int64 max_receive_message_length = 1;
  bool has_max_receive_message_length() const;
  private:
  bool _internal_has_max_receive_message_length() const;
  public:
  void clear_max_receive_message_length();
  int64_t max_receive_message_length() const;
  void set_max_receive_message_length(int64_t value);
  private:
  int64_t _internal_max_receive_message_length() const;
  void _internal_set_max_receive_message_length(int64_t value);
  public:

  // optional int64 http2_max_ping_strikes = 2;
  bool has_http2_max_ping_strikes() const;
  private:
  bool _internal_has_http2_max_ping_strikes() const;
  public:
  void clear_http2_max_ping_strikes();
  int64_t http2_max_ping_strikes() const;
  void set_http2_max_ping_strikes(int64_t value);
  private:
  int64_t _internal_http2_max_ping_strikes() const;
  void _internal_set_http2_max_ping_strikes(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.GrpcChannelArguments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t max_receive_message_length_;
    int64_t http2_max_ping_strikes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class MetadataStoreClientConfig_SSLConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.MetadataStoreClientConfig.SSLConfig) */ {
 public:
  inline MetadataStoreClientConfig_SSLConfig() : MetadataStoreClientConfig_SSLConfig(nullptr) {}
  ~MetadataStoreClientConfig_SSLConfig() override;
  explicit PROTOBUF_CONSTEXPR MetadataStoreClientConfig_SSLConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetadataStoreClientConfig_SSLConfig(const MetadataStoreClientConfig_SSLConfig& from);
  MetadataStoreClientConfig_SSLConfig(MetadataStoreClientConfig_SSLConfig&& from) noexcept
    : MetadataStoreClientConfig_SSLConfig() {
    *this = ::std::move(from);
  }

  inline MetadataStoreClientConfig_SSLConfig& operator=(const MetadataStoreClientConfig_SSLConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetadataStoreClientConfig_SSLConfig& operator=(MetadataStoreClientConfig_SSLConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetadataStoreClientConfig_SSLConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetadataStoreClientConfig_SSLConfig* internal_default_instance() {
    return reinterpret_cast<const MetadataStoreClientConfig_SSLConfig*>(
               &_MetadataStoreClientConfig_SSLConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(MetadataStoreClientConfig_SSLConfig& a, MetadataStoreClientConfig_SSLConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MetadataStoreClientConfig_SSLConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetadataStoreClientConfig_SSLConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetadataStoreClientConfig_SSLConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetadataStoreClientConfig_SSLConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetadataStoreClientConfig_SSLConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetadataStoreClientConfig_SSLConfig& from) {
    MetadataStoreClientConfig_SSLConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetadataStoreClientConfig_SSLConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.MetadataStoreClientConfig.SSLConfig";
  }
  protected:
  explicit MetadataStoreClientConfig_SSLConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientKeyFieldNumber = 1,
    kServerCertFieldNumber = 2,
    kCustomCaFieldNumber = 3,
  };
  // optional string client_key = 1;
  bool has_client_key() const;
  private:
  bool _internal_has_client_key() const;
  public:
  void clear_client_key();
  const std::string& client_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_key();
  PROTOBUF_NODISCARD std::string* release_client_key();
  void set_allocated_client_key(std::string* client_key);
  private:
  const std::string& _internal_client_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_key(const std::string& value);
  std::string* _internal_mutable_client_key();
  public:

  // optional string server_cert = 2;
  bool has_server_cert() const;
  private:
  bool _internal_has_server_cert() const;
  public:
  void clear_server_cert();
  const std::string& server_cert() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_cert(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_cert();
  PROTOBUF_NODISCARD std::string* release_server_cert();
  void set_allocated_server_cert(std::string* server_cert);
  private:
  const std::string& _internal_server_cert() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_cert(const std::string& value);
  std::string* _internal_mutable_server_cert();
  public:

  // optional string custom_ca = 3;
  bool has_custom_ca() const;
  private:
  bool _internal_has_custom_ca() const;
  public:
  void clear_custom_ca();
  const std::string& custom_ca() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_custom_ca(ArgT0&& arg0, ArgT... args);
  std::string* mutable_custom_ca();
  PROTOBUF_NODISCARD std::string* release_custom_ca();
  void set_allocated_custom_ca(std::string* custom_ca);
  private:
  const std::string& _internal_custom_ca() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_ca(const std::string& value);
  std::string* _internal_mutable_custom_ca();
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.MetadataStoreClientConfig.SSLConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_cert_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_ca_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class MetadataStoreClientConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.MetadataStoreClientConfig) */ {
 public:
  inline MetadataStoreClientConfig() : MetadataStoreClientConfig(nullptr) {}
  ~MetadataStoreClientConfig() override;
  explicit PROTOBUF_CONSTEXPR MetadataStoreClientConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetadataStoreClientConfig(const MetadataStoreClientConfig& from);
  MetadataStoreClientConfig(MetadataStoreClientConfig&& from) noexcept
    : MetadataStoreClientConfig() {
    *this = ::std::move(from);
  }

  inline MetadataStoreClientConfig& operator=(const MetadataStoreClientConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetadataStoreClientConfig& operator=(MetadataStoreClientConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetadataStoreClientConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetadataStoreClientConfig* internal_default_instance() {
    return reinterpret_cast<const MetadataStoreClientConfig*>(
               &_MetadataStoreClientConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(MetadataStoreClientConfig& a, MetadataStoreClientConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MetadataStoreClientConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetadataStoreClientConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetadataStoreClientConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetadataStoreClientConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetadataStoreClientConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetadataStoreClientConfig& from) {
    MetadataStoreClientConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetadataStoreClientConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.MetadataStoreClientConfig";
  }
  protected:
  explicit MetadataStoreClientConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MetadataStoreClientConfig_SSLConfig SSLConfig;

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
    kSslConfigFieldNumber = 3,
    kChannelArgumentsFieldNumber = 4,
    kPortFieldNumber = 2,
    kClientTimeoutSecFieldNumber = 5,
  };
  // optional string host = 1;
  bool has_host() const;
  private:
  bool _internal_has_host() const;
  public:
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // optional .ml_metadata.MetadataStoreClientConfig.SSLConfig ssl_config = 3;
  bool has_ssl_config() const;
  private:
  bool _internal_has_ssl_config() const;
  public:
  void clear_ssl_config();
  const ::ml_metadata::MetadataStoreClientConfig_SSLConfig& ssl_config() const;
  PROTOBUF_NODISCARD ::ml_metadata::MetadataStoreClientConfig_SSLConfig* release_ssl_config();
  ::ml_metadata::MetadataStoreClientConfig_SSLConfig* mutable_ssl_config();
  void set_allocated_ssl_config(::ml_metadata::MetadataStoreClientConfig_SSLConfig* ssl_config);
  private:
  const ::ml_metadata::MetadataStoreClientConfig_SSLConfig& _internal_ssl_config() const;
  ::ml_metadata::MetadataStoreClientConfig_SSLConfig* _internal_mutable_ssl_config();
  public:
  void unsafe_arena_set_allocated_ssl_config(
      ::ml_metadata::MetadataStoreClientConfig_SSLConfig* ssl_config);
  ::ml_metadata::MetadataStoreClientConfig_SSLConfig* unsafe_arena_release_ssl_config();

  // optional .ml_metadata.GrpcChannelArguments channel_arguments = 4;
  bool has_channel_arguments() const;
  private:
  bool _internal_has_channel_arguments() const;
  public:
  void clear_channel_arguments();
  const ::ml_metadata::GrpcChannelArguments& channel_arguments() const;
  PROTOBUF_NODISCARD ::ml_metadata::GrpcChannelArguments* release_channel_arguments();
  ::ml_metadata::GrpcChannelArguments* mutable_channel_arguments();
  void set_allocated_channel_arguments(::ml_metadata::GrpcChannelArguments* channel_arguments);
  private:
  const ::ml_metadata::GrpcChannelArguments& _internal_channel_arguments() const;
  ::ml_metadata::GrpcChannelArguments* _internal_mutable_channel_arguments();
  public:
  void unsafe_arena_set_allocated_channel_arguments(
      ::ml_metadata::GrpcChannelArguments* channel_arguments);
  ::ml_metadata::GrpcChannelArguments* unsafe_arena_release_channel_arguments();

  // optional int64 port = 2;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  int64_t port() const;
  void set_port(int64_t value);
  private:
  int64_t _internal_port() const;
  void _internal_set_port(int64_t value);
  public:

  // optional double client_timeout_sec = 5;
  bool has_client_timeout_sec() const;
  private:
  bool _internal_has_client_timeout_sec() const;
  public:
  void clear_client_timeout_sec();
  double client_timeout_sec() const;
  void set_client_timeout_sec(double value);
  private:
  double _internal_client_timeout_sec() const;
  void _internal_set_client_timeout_sec(double value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.MetadataStoreClientConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::ml_metadata::MetadataStoreClientConfig_SSLConfig* ssl_config_;
    ::ml_metadata::GrpcChannelArguments* channel_arguments_;
    int64_t port_;
    double client_timeout_sec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class MetadataStoreServerConfig_SSLConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.MetadataStoreServerConfig.SSLConfig) */ {
 public:
  inline MetadataStoreServerConfig_SSLConfig() : MetadataStoreServerConfig_SSLConfig(nullptr) {}
  ~MetadataStoreServerConfig_SSLConfig() override;
  explicit PROTOBUF_CONSTEXPR MetadataStoreServerConfig_SSLConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetadataStoreServerConfig_SSLConfig(const MetadataStoreServerConfig_SSLConfig& from);
  MetadataStoreServerConfig_SSLConfig(MetadataStoreServerConfig_SSLConfig&& from) noexcept
    : MetadataStoreServerConfig_SSLConfig() {
    *this = ::std::move(from);
  }

  inline MetadataStoreServerConfig_SSLConfig& operator=(const MetadataStoreServerConfig_SSLConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetadataStoreServerConfig_SSLConfig& operator=(MetadataStoreServerConfig_SSLConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetadataStoreServerConfig_SSLConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetadataStoreServerConfig_SSLConfig* internal_default_instance() {
    return reinterpret_cast<const MetadataStoreServerConfig_SSLConfig*>(
               &_MetadataStoreServerConfig_SSLConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(MetadataStoreServerConfig_SSLConfig& a, MetadataStoreServerConfig_SSLConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MetadataStoreServerConfig_SSLConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetadataStoreServerConfig_SSLConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetadataStoreServerConfig_SSLConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetadataStoreServerConfig_SSLConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetadataStoreServerConfig_SSLConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetadataStoreServerConfig_SSLConfig& from) {
    MetadataStoreServerConfig_SSLConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetadataStoreServerConfig_SSLConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.MetadataStoreServerConfig.SSLConfig";
  }
  protected:
  explicit MetadataStoreServerConfig_SSLConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerKeyFieldNumber = 1,
    kServerCertFieldNumber = 2,
    kCustomCaFieldNumber = 3,
    kClientVerifyFieldNumber = 4,
  };
  // optional string server_key = 1;
  bool has_server_key() const;
  private:
  bool _internal_has_server_key() const;
  public:
  void clear_server_key();
  const std::string& server_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_key();
  PROTOBUF_NODISCARD std::string* release_server_key();
  void set_allocated_server_key(std::string* server_key);
  private:
  const std::string& _internal_server_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_key(const std::string& value);
  std::string* _internal_mutable_server_key();
  public:

  // optional string server_cert = 2;
  bool has_server_cert() const;
  private:
  bool _internal_has_server_cert() const;
  public:
  void clear_server_cert();
  const std::string& server_cert() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_cert(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_cert();
  PROTOBUF_NODISCARD std::string* release_server_cert();
  void set_allocated_server_cert(std::string* server_cert);
  private:
  const std::string& _internal_server_cert() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_cert(const std::string& value);
  std::string* _internal_mutable_server_cert();
  public:

  // optional string custom_ca = 3;
  bool has_custom_ca() const;
  private:
  bool _internal_has_custom_ca() const;
  public:
  void clear_custom_ca();
  const std::string& custom_ca() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_custom_ca(ArgT0&& arg0, ArgT... args);
  std::string* mutable_custom_ca();
  PROTOBUF_NODISCARD std::string* release_custom_ca();
  void set_allocated_custom_ca(std::string* custom_ca);
  private:
  const std::string& _internal_custom_ca() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_ca(const std::string& value);
  std::string* _internal_mutable_custom_ca();
  public:

  // optional bool client_verify = 4;
  bool has_client_verify() const;
  private:
  bool _internal_has_client_verify() const;
  public:
  void clear_client_verify();
  bool client_verify() const;
  void set_client_verify(bool value);
  private:
  bool _internal_client_verify() const;
  void _internal_set_client_verify(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.MetadataStoreServerConfig.SSLConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_cert_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_ca_;
    bool client_verify_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class MetadataStoreServerConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.MetadataStoreServerConfig) */ {
 public:
  inline MetadataStoreServerConfig() : MetadataStoreServerConfig(nullptr) {}
  ~MetadataStoreServerConfig() override;
  explicit PROTOBUF_CONSTEXPR MetadataStoreServerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetadataStoreServerConfig(const MetadataStoreServerConfig& from);
  MetadataStoreServerConfig(MetadataStoreServerConfig&& from) noexcept
    : MetadataStoreServerConfig() {
    *this = ::std::move(from);
  }

  inline MetadataStoreServerConfig& operator=(const MetadataStoreServerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetadataStoreServerConfig& operator=(MetadataStoreServerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetadataStoreServerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetadataStoreServerConfig* internal_default_instance() {
    return reinterpret_cast<const MetadataStoreServerConfig*>(
               &_MetadataStoreServerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(MetadataStoreServerConfig& a, MetadataStoreServerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MetadataStoreServerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetadataStoreServerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetadataStoreServerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetadataStoreServerConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetadataStoreServerConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetadataStoreServerConfig& from) {
    MetadataStoreServerConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetadataStoreServerConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.MetadataStoreServerConfig";
  }
  protected:
  explicit MetadataStoreServerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MetadataStoreServerConfig_SSLConfig SSLConfig;

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionConfigFieldNumber = 1,
    kSslConfigFieldNumber = 2,
    kMigrationOptionsFieldNumber = 3,
  };
  // optional .ml_metadata.ConnectionConfig connection_config = 1;
  bool has_connection_config() const;
  private:
  bool _internal_has_connection_config() const;
  public:
  void clear_connection_config();
  const ::ml_metadata::ConnectionConfig& connection_config() const;
  PROTOBUF_NODISCARD ::ml_metadata::ConnectionConfig* release_connection_config();
  ::ml_metadata::ConnectionConfig* mutable_connection_config();
  void set_allocated_connection_config(::ml_metadata::ConnectionConfig* connection_config);
  private:
  const ::ml_metadata::ConnectionConfig& _internal_connection_config() const;
  ::ml_metadata::ConnectionConfig* _internal_mutable_connection_config();
  public:
  void unsafe_arena_set_allocated_connection_config(
      ::ml_metadata::ConnectionConfig* connection_config);
  ::ml_metadata::ConnectionConfig* unsafe_arena_release_connection_config();

  // optional .ml_metadata.MetadataStoreServerConfig.SSLConfig ssl_config = 2;
  bool has_ssl_config() const;
  private:
  bool _internal_has_ssl_config() const;
  public:
  void clear_ssl_config();
  const ::ml_metadata::MetadataStoreServerConfig_SSLConfig& ssl_config() const;
  PROTOBUF_NODISCARD ::ml_metadata::MetadataStoreServerConfig_SSLConfig* release_ssl_config();
  ::ml_metadata::MetadataStoreServerConfig_SSLConfig* mutable_ssl_config();
  void set_allocated_ssl_config(::ml_metadata::MetadataStoreServerConfig_SSLConfig* ssl_config);
  private:
  const ::ml_metadata::MetadataStoreServerConfig_SSLConfig& _internal_ssl_config() const;
  ::ml_metadata::MetadataStoreServerConfig_SSLConfig* _internal_mutable_ssl_config();
  public:
  void unsafe_arena_set_allocated_ssl_config(
      ::ml_metadata::MetadataStoreServerConfig_SSLConfig* ssl_config);
  ::ml_metadata::MetadataStoreServerConfig_SSLConfig* unsafe_arena_release_ssl_config();

  // optional .ml_metadata.MigrationOptions migration_options = 3;
  bool has_migration_options() const;
  private:
  bool _internal_has_migration_options() const;
  public:
  void clear_migration_options();
  const ::ml_metadata::MigrationOptions& migration_options() const;
  PROTOBUF_NODISCARD ::ml_metadata::MigrationOptions* release_migration_options();
  ::ml_metadata::MigrationOptions* mutable_migration_options();
  void set_allocated_migration_options(::ml_metadata::MigrationOptions* migration_options);
  private:
  const ::ml_metadata::MigrationOptions& _internal_migration_options() const;
  ::ml_metadata::MigrationOptions* _internal_mutable_migration_options();
  public:
  void unsafe_arena_set_allocated_migration_options(
      ::ml_metadata::MigrationOptions* migration_options);
  ::ml_metadata::MigrationOptions* unsafe_arena_release_migration_options();

  // @@protoc_insertion_point(class_scope:ml_metadata.MetadataStoreServerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ml_metadata::ConnectionConfig* connection_config_;
    ::ml_metadata::MetadataStoreServerConfig_SSLConfig* ssl_config_;
    ::ml_metadata::MigrationOptions* migration_options_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListOperationOptions_OrderByField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ListOperationOptions.OrderByField) */ {
 public:
  inline ListOperationOptions_OrderByField() : ListOperationOptions_OrderByField(nullptr) {}
  ~ListOperationOptions_OrderByField() override;
  explicit PROTOBUF_CONSTEXPR ListOperationOptions_OrderByField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOperationOptions_OrderByField(const ListOperationOptions_OrderByField& from);
  ListOperationOptions_OrderByField(ListOperationOptions_OrderByField&& from) noexcept
    : ListOperationOptions_OrderByField() {
    *this = ::std::move(from);
  }

  inline ListOperationOptions_OrderByField& operator=(const ListOperationOptions_OrderByField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOperationOptions_OrderByField& operator=(ListOperationOptions_OrderByField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOperationOptions_OrderByField& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOperationOptions_OrderByField* internal_default_instance() {
    return reinterpret_cast<const ListOperationOptions_OrderByField*>(
               &_ListOperationOptions_OrderByField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ListOperationOptions_OrderByField& a, ListOperationOptions_OrderByField& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOperationOptions_OrderByField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOperationOptions_OrderByField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOperationOptions_OrderByField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOperationOptions_OrderByField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOperationOptions_OrderByField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListOperationOptions_OrderByField& from) {
    ListOperationOptions_OrderByField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOperationOptions_OrderByField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ListOperationOptions.OrderByField";
  }
  protected:
  explicit ListOperationOptions_OrderByField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ListOperationOptions_OrderByField_Field Field;
  static constexpr Field FIELD_UNSPECIFIED =
    ListOperationOptions_OrderByField_Field_FIELD_UNSPECIFIED;
  static constexpr Field CREATE_TIME =
    ListOperationOptions_OrderByField_Field_CREATE_TIME;
  static constexpr Field LAST_UPDATE_TIME =
    ListOperationOptions_OrderByField_Field_LAST_UPDATE_TIME;
  static constexpr Field ID =
    ListOperationOptions_OrderByField_Field_ID;
  static inline bool Field_IsValid(int value) {
    return ListOperationOptions_OrderByField_Field_IsValid(value);
  }
  static constexpr Field Field_MIN =
    ListOperationOptions_OrderByField_Field_Field_MIN;
  static constexpr Field Field_MAX =
    ListOperationOptions_OrderByField_Field_Field_MAX;
  static constexpr int Field_ARRAYSIZE =
    ListOperationOptions_OrderByField_Field_Field_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Field_descriptor() {
    return ListOperationOptions_OrderByField_Field_descriptor();
  }
  template<typename T>
  static inline const std::string& Field_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Field>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Field_Name.");
    return ListOperationOptions_OrderByField_Field_Name(enum_t_value);
  }
  static inline bool Field_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Field* value) {
    return ListOperationOptions_OrderByField_Field_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kIsAscFieldNumber = 2,
  };
  // optional .ml_metadata.ListOperationOptions.OrderByField.Field field = 1 [default = ID];
  bool has_field() const;
  private:
  bool _internal_has_field() const;
  public:
  void clear_field();
  ::ml_metadata::ListOperationOptions_OrderByField_Field field() const;
  void set_field(::ml_metadata::ListOperationOptions_OrderByField_Field value);
  private:
  ::ml_metadata::ListOperationOptions_OrderByField_Field _internal_field() const;
  void _internal_set_field(::ml_metadata::ListOperationOptions_OrderByField_Field value);
  public:

  // optional bool is_asc = 2 [default = true];
  bool has_is_asc() const;
  private:
  bool _internal_has_is_asc() const;
  public:
  void clear_is_asc();
  bool is_asc() const;
  void set_is_asc(bool value);
  private:
  bool _internal_is_asc() const;
  void _internal_set_is_asc(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.ListOperationOptions.OrderByField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int field_;
    bool is_asc_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListOperationOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ListOperationOptions) */ {
 public:
  inline ListOperationOptions() : ListOperationOptions(nullptr) {}
  ~ListOperationOptions() override;
  explicit PROTOBUF_CONSTEXPR ListOperationOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOperationOptions(const ListOperationOptions& from);
  ListOperationOptions(ListOperationOptions&& from) noexcept
    : ListOperationOptions() {
    *this = ::std::move(from);
  }

  inline ListOperationOptions& operator=(const ListOperationOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOperationOptions& operator=(ListOperationOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOperationOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOperationOptions* internal_default_instance() {
    return reinterpret_cast<const ListOperationOptions*>(
               &_ListOperationOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ListOperationOptions& a, ListOperationOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOperationOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOperationOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOperationOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOperationOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOperationOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListOperationOptions& from) {
    ListOperationOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOperationOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ListOperationOptions";
  }
  protected:
  explicit ListOperationOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ListOperationOptions_OrderByField OrderByField;

  // accessors -------------------------------------------------------

  enum : int {
    kNextPageTokenFieldNumber = 3,
    kFilterQueryFieldNumber = 4,
    kOrderByFieldFieldNumber = 2,
    kMaxResultSizeFieldNumber = 1,
  };
  // optional string next_page_token = 3;
  bool has_next_page_token() const;
  private:
  bool _internal_has_next_page_token() const;
  public:
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // optional string filter_query = 4;
  bool has_filter_query() const;
  private:
  bool _internal_has_filter_query() const;
  public:
  void clear_filter_query();
  const std::string& filter_query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter_query();
  PROTOBUF_NODISCARD std::string* release_filter_query();
  void set_allocated_filter_query(std::string* filter_query);
  private:
  const std::string& _internal_filter_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter_query(const std::string& value);
  std::string* _internal_mutable_filter_query();
  public:

  // optional .ml_metadata.ListOperationOptions.OrderByField order_by_field = 2;
  bool has_order_by_field() const;
  private:
  bool _internal_has_order_by_field() const;
  public:
  void clear_order_by_field();
  const ::ml_metadata::ListOperationOptions_OrderByField& order_by_field() const;
  PROTOBUF_NODISCARD ::ml_metadata::ListOperationOptions_OrderByField* release_order_by_field();
  ::ml_metadata::ListOperationOptions_OrderByField* mutable_order_by_field();
  void set_allocated_order_by_field(::ml_metadata::ListOperationOptions_OrderByField* order_by_field);
  private:
  const ::ml_metadata::ListOperationOptions_OrderByField& _internal_order_by_field() const;
  ::ml_metadata::ListOperationOptions_OrderByField* _internal_mutable_order_by_field();
  public:
  void unsafe_arena_set_allocated_order_by_field(
      ::ml_metadata::ListOperationOptions_OrderByField* order_by_field);
  ::ml_metadata::ListOperationOptions_OrderByField* unsafe_arena_release_order_by_field();

  // optional int32 max_result_size = 1 [default = 20];
  bool has_max_result_size() const;
  private:
  bool _internal_has_max_result_size() const;
  public:
  void clear_max_result_size();
  int32_t max_result_size() const;
  void set_max_result_size(int32_t value);
  private:
  int32_t _internal_max_result_size() const;
  void _internal_set_max_result_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.ListOperationOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_query_;
    ::ml_metadata::ListOperationOptions_OrderByField* order_by_field_;
    int32_t max_result_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListOperationNextPageToken final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ListOperationNextPageToken) */ {
 public:
  inline ListOperationNextPageToken() : ListOperationNextPageToken(nullptr) {}
  ~ListOperationNextPageToken() override;
  explicit PROTOBUF_CONSTEXPR ListOperationNextPageToken(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOperationNextPageToken(const ListOperationNextPageToken& from);
  ListOperationNextPageToken(ListOperationNextPageToken&& from) noexcept
    : ListOperationNextPageToken() {
    *this = ::std::move(from);
  }

  inline ListOperationNextPageToken& operator=(const ListOperationNextPageToken& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOperationNextPageToken& operator=(ListOperationNextPageToken&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOperationNextPageToken& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOperationNextPageToken* internal_default_instance() {
    return reinterpret_cast<const ListOperationNextPageToken*>(
               &_ListOperationNextPageToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(ListOperationNextPageToken& a, ListOperationNextPageToken& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOperationNextPageToken* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOperationNextPageToken* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOperationNextPageToken* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOperationNextPageToken>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOperationNextPageToken& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListOperationNextPageToken& from) {
    ListOperationNextPageToken::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOperationNextPageToken* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ListOperationNextPageToken";
  }
  protected:
  explicit ListOperationNextPageToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListedIdsFieldNumber = 4,
    kSetOptionsFieldNumber = 3,
    kIdOffsetFieldNumber = 1,
    kFieldOffsetFieldNumber = 2,
  };
  // repeated int64 listed_ids = 4;
  int listed_ids_size() const;
  private:
  int _internal_listed_ids_size() const;
  public:
  void clear_listed_ids();
  private:
  int64_t _internal_listed_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_listed_ids() const;
  void _internal_add_listed_ids(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_listed_ids();
  public:
  int64_t listed_ids(int index) const;
  void set_listed_ids(int index, int64_t value);
  void add_listed_ids(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      listed_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_listed_ids();

  // optional .ml_metadata.ListOperationOptions set_options = 3;
  bool has_set_options() const;
  private:
  bool _internal_has_set_options() const;
  public:
  void clear_set_options();
  const ::ml_metadata::ListOperationOptions& set_options() const;
  PROTOBUF_NODISCARD ::ml_metadata::ListOperationOptions* release_set_options();
  ::ml_metadata::ListOperationOptions* mutable_set_options();
  void set_allocated_set_options(::ml_metadata::ListOperationOptions* set_options);
  private:
  const ::ml_metadata::ListOperationOptions& _internal_set_options() const;
  ::ml_metadata::ListOperationOptions* _internal_mutable_set_options();
  public:
  void unsafe_arena_set_allocated_set_options(
      ::ml_metadata::ListOperationOptions* set_options);
  ::ml_metadata::ListOperationOptions* unsafe_arena_release_set_options();

  // optional int64 id_offset = 1;
  bool has_id_offset() const;
  private:
  bool _internal_has_id_offset() const;
  public:
  void clear_id_offset();
  int64_t id_offset() const;
  void set_id_offset(int64_t value);
  private:
  int64_t _internal_id_offset() const;
  void _internal_set_id_offset(int64_t value);
  public:

  // optional int64 field_offset = 2;
  bool has_field_offset() const;
  private:
  bool _internal_has_field_offset() const;
  public:
  void clear_field_offset();
  int64_t field_offset() const;
  void set_field_offset(int64_t value);
  private:
  int64_t _internal_field_offset() const;
  void _internal_set_field_offset(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.ListOperationNextPageToken)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > listed_ids_;
    ::ml_metadata::ListOperationOptions* set_options_;
    int64_t id_offset_;
    int64_t field_offset_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class TransactionOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.TransactionOptions) */ {
 public:
  inline TransactionOptions() : TransactionOptions(nullptr) {}
  ~TransactionOptions() override;
  explicit PROTOBUF_CONSTEXPR TransactionOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionOptions(const TransactionOptions& from);
  TransactionOptions(TransactionOptions&& from) noexcept
    : TransactionOptions() {
    *this = ::std::move(from);
  }

  inline TransactionOptions& operator=(const TransactionOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionOptions& operator=(TransactionOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionOptions* internal_default_instance() {
    return reinterpret_cast<const TransactionOptions*>(
               &_TransactionOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(TransactionOptions& a, TransactionOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionOptions& from) {
    TransactionOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.TransactionOptions";
  }
  protected:
  explicit TransactionOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
  };
  // optional string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TransactionOptions, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:ml_metadata.TransactionOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class LineageGraphQueryOptions_BoundaryConstraint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint) */ {
 public:
  inline LineageGraphQueryOptions_BoundaryConstraint() : LineageGraphQueryOptions_BoundaryConstraint(nullptr) {}
  ~LineageGraphQueryOptions_BoundaryConstraint() override;
  explicit PROTOBUF_CONSTEXPR LineageGraphQueryOptions_BoundaryConstraint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LineageGraphQueryOptions_BoundaryConstraint(const LineageGraphQueryOptions_BoundaryConstraint& from);
  LineageGraphQueryOptions_BoundaryConstraint(LineageGraphQueryOptions_BoundaryConstraint&& from) noexcept
    : LineageGraphQueryOptions_BoundaryConstraint() {
    *this = ::std::move(from);
  }

  inline LineageGraphQueryOptions_BoundaryConstraint& operator=(const LineageGraphQueryOptions_BoundaryConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineageGraphQueryOptions_BoundaryConstraint& operator=(LineageGraphQueryOptions_BoundaryConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LineageGraphQueryOptions_BoundaryConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const LineageGraphQueryOptions_BoundaryConstraint* internal_default_instance() {
    return reinterpret_cast<const LineageGraphQueryOptions_BoundaryConstraint*>(
               &_LineageGraphQueryOptions_BoundaryConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(LineageGraphQueryOptions_BoundaryConstraint& a, LineageGraphQueryOptions_BoundaryConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(LineageGraphQueryOptions_BoundaryConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineageGraphQueryOptions_BoundaryConstraint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineageGraphQueryOptions_BoundaryConstraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LineageGraphQueryOptions_BoundaryConstraint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LineageGraphQueryOptions_BoundaryConstraint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LineageGraphQueryOptions_BoundaryConstraint& from) {
    LineageGraphQueryOptions_BoundaryConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineageGraphQueryOptions_BoundaryConstraint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.LineageGraphQueryOptions.BoundaryConstraint";
  }
  protected:
  explicit LineageGraphQueryOptions_BoundaryConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoundaryArtifactsFieldNumber = 2,
    kBoundaryExecutionsFieldNumber = 3,
    kMaxNumHopsFieldNumber = 1,
  };
  // optional string boundary_artifacts = 2;
  bool has_boundary_artifacts() const;
  private:
  bool _internal_has_boundary_artifacts() const;
  public:
  void clear_boundary_artifacts();
  const std::string& boundary_artifacts() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_boundary_artifacts(ArgT0&& arg0, ArgT... args);
  std::string* mutable_boundary_artifacts();
  PROTOBUF_NODISCARD std::string* release_boundary_artifacts();
  void set_allocated_boundary_artifacts(std::string* boundary_artifacts);
  private:
  const std::string& _internal_boundary_artifacts() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_boundary_artifacts(const std::string& value);
  std::string* _internal_mutable_boundary_artifacts();
  public:

  // optional string boundary_executions = 3;
  bool has_boundary_executions() const;
  private:
  bool _internal_has_boundary_executions() const;
  public:
  void clear_boundary_executions();
  const std::string& boundary_executions() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_boundary_executions(ArgT0&& arg0, ArgT... args);
  std::string* mutable_boundary_executions();
  PROTOBUF_NODISCARD std::string* release_boundary_executions();
  void set_allocated_boundary_executions(std::string* boundary_executions);
  private:
  const std::string& _internal_boundary_executions() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_boundary_executions(const std::string& value);
  std::string* _internal_mutable_boundary_executions();
  public:

  // optional int64 max_num_hops = 1;
  bool has_max_num_hops() const;
  private:
  bool _internal_has_max_num_hops() const;
  public:
  void clear_max_num_hops();
  int64_t max_num_hops() const;
  void set_max_num_hops(int64_t value);
  private:
  int64_t _internal_max_num_hops() const;
  void _internal_set_max_num_hops(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr boundary_artifacts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr boundary_executions_;
    int64_t max_num_hops_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class LineageGraphQueryOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.LineageGraphQueryOptions) */ {
 public:
  inline LineageGraphQueryOptions() : LineageGraphQueryOptions(nullptr) {}
  ~LineageGraphQueryOptions() override;
  explicit PROTOBUF_CONSTEXPR LineageGraphQueryOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LineageGraphQueryOptions(const LineageGraphQueryOptions& from);
  LineageGraphQueryOptions(LineageGraphQueryOptions&& from) noexcept
    : LineageGraphQueryOptions() {
    *this = ::std::move(from);
  }

  inline LineageGraphQueryOptions& operator=(const LineageGraphQueryOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineageGraphQueryOptions& operator=(LineageGraphQueryOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LineageGraphQueryOptions& default_instance() {
    return *internal_default_instance();
  }
  enum QueryNodesCase {
    kArtifactsOptions = 1,
    QUERY_NODES_NOT_SET = 0,
  };

  static inline const LineageGraphQueryOptions* internal_default_instance() {
    return reinterpret_cast<const LineageGraphQueryOptions*>(
               &_LineageGraphQueryOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(LineageGraphQueryOptions& a, LineageGraphQueryOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(LineageGraphQueryOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineageGraphQueryOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineageGraphQueryOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LineageGraphQueryOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LineageGraphQueryOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LineageGraphQueryOptions& from) {
    LineageGraphQueryOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineageGraphQueryOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.LineageGraphQueryOptions";
  }
  protected:
  explicit LineageGraphQueryOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LineageGraphQueryOptions_BoundaryConstraint BoundaryConstraint;

  // accessors -------------------------------------------------------

  enum : int {
    kStopConditionsFieldNumber = 2,
    kMaxNodeSizeFieldNumber = 3,
    kArtifactsOptionsFieldNumber = 1,
  };
  // optional .ml_metadata.LineageGraphQueryOptions.BoundaryConstraint stop_conditions = 2;
  bool has_stop_conditions() const;
  private:
  bool _internal_has_stop_conditions() const;
  public:
  void clear_stop_conditions();
  const ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint& stop_conditions() const;
  PROTOBUF_NODISCARD ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* release_stop_conditions();
  ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* mutable_stop_conditions();
  void set_allocated_stop_conditions(::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* stop_conditions);
  private:
  const ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint& _internal_stop_conditions() const;
  ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* _internal_mutable_stop_conditions();
  public:
  void unsafe_arena_set_allocated_stop_conditions(
      ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* stop_conditions);
  ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* unsafe_arena_release_stop_conditions();

  // optional int64 max_node_size = 3 [default = 20];
  bool has_max_node_size() const;
  private:
  bool _internal_has_max_node_size() const;
  public:
  void clear_max_node_size();
  int64_t max_node_size() const;
  void set_max_node_size(int64_t value);
  private:
  int64_t _internal_max_node_size() const;
  void _internal_set_max_node_size(int64_t value);
  public:

  // .ml_metadata.ListOperationOptions artifacts_options = 1;
  bool has_artifacts_options() const;
  private:
  bool _internal_has_artifacts_options() const;
  public:
  void clear_artifacts_options();
  const ::ml_metadata::ListOperationOptions& artifacts_options() const;
  PROTOBUF_NODISCARD ::ml_metadata::ListOperationOptions* release_artifacts_options();
  ::ml_metadata::ListOperationOptions* mutable_artifacts_options();
  void set_allocated_artifacts_options(::ml_metadata::ListOperationOptions* artifacts_options);
  private:
  const ::ml_metadata::ListOperationOptions& _internal_artifacts_options() const;
  ::ml_metadata::ListOperationOptions* _internal_mutable_artifacts_options();
  public:
  void unsafe_arena_set_allocated_artifacts_options(
      ::ml_metadata::ListOperationOptions* artifacts_options);
  ::ml_metadata::ListOperationOptions* unsafe_arena_release_artifacts_options();

  void clear_query_nodes();
  QueryNodesCase query_nodes_case() const;
  // @@protoc_insertion_point(class_scope:ml_metadata.LineageGraphQueryOptions)
 private:
  class _Internal;
  void set_has_artifacts_options();

  inline bool has_query_nodes() const;
  inline void clear_has_query_nodes();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* stop_conditions_;
    int64_t max_node_size_;
    union QueryNodesUnion {
      constexpr QueryNodesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ml_metadata::ListOperationOptions* artifacts_options_;
    } query_nodes_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class LineageSubgraphQueryOptions_StartingNodes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.LineageSubgraphQueryOptions.StartingNodes) */ {
 public:
  inline LineageSubgraphQueryOptions_StartingNodes() : LineageSubgraphQueryOptions_StartingNodes(nullptr) {}
  ~LineageSubgraphQueryOptions_StartingNodes() override;
  explicit PROTOBUF_CONSTEXPR LineageSubgraphQueryOptions_StartingNodes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LineageSubgraphQueryOptions_StartingNodes(const LineageSubgraphQueryOptions_StartingNodes& from);
  LineageSubgraphQueryOptions_StartingNodes(LineageSubgraphQueryOptions_StartingNodes&& from) noexcept
    : LineageSubgraphQueryOptions_StartingNodes() {
    *this = ::std::move(from);
  }

  inline LineageSubgraphQueryOptions_StartingNodes& operator=(const LineageSubgraphQueryOptions_StartingNodes& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineageSubgraphQueryOptions_StartingNodes& operator=(LineageSubgraphQueryOptions_StartingNodes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LineageSubgraphQueryOptions_StartingNodes& default_instance() {
    return *internal_default_instance();
  }
  static inline const LineageSubgraphQueryOptions_StartingNodes* internal_default_instance() {
    return reinterpret_cast<const LineageSubgraphQueryOptions_StartingNodes*>(
               &_LineageSubgraphQueryOptions_StartingNodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(LineageSubgraphQueryOptions_StartingNodes& a, LineageSubgraphQueryOptions_StartingNodes& b) {
    a.Swap(&b);
  }
  inline void Swap(LineageSubgraphQueryOptions_StartingNodes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineageSubgraphQueryOptions_StartingNodes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineageSubgraphQueryOptions_StartingNodes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LineageSubgraphQueryOptions_StartingNodes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LineageSubgraphQueryOptions_StartingNodes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LineageSubgraphQueryOptions_StartingNodes& from) {
    LineageSubgraphQueryOptions_StartingNodes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineageSubgraphQueryOptions_StartingNodes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.LineageSubgraphQueryOptions.StartingNodes";
  }
  protected:
  explicit LineageSubgraphQueryOptions_StartingNodes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterQueryFieldNumber = 1,
  };
  // optional string filter_query = 1;
  bool has_filter_query() const;
  private:
  bool _internal_has_filter_query() const;
  public:
  void clear_filter_query();
  const std::string& filter_query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter_query();
  PROTOBUF_NODISCARD std::string* release_filter_query();
  void set_allocated_filter_query(std::string* filter_query);
  private:
  const std::string& _internal_filter_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter_query(const std::string& value);
  std::string* _internal_mutable_filter_query();
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.LineageSubgraphQueryOptions.StartingNodes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_query_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class LineageSubgraphQueryOptions_EndingNodes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.LineageSubgraphQueryOptions.EndingNodes) */ {
 public:
  inline LineageSubgraphQueryOptions_EndingNodes() : LineageSubgraphQueryOptions_EndingNodes(nullptr) {}
  ~LineageSubgraphQueryOptions_EndingNodes() override;
  explicit PROTOBUF_CONSTEXPR LineageSubgraphQueryOptions_EndingNodes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LineageSubgraphQueryOptions_EndingNodes(const LineageSubgraphQueryOptions_EndingNodes& from);
  LineageSubgraphQueryOptions_EndingNodes(LineageSubgraphQueryOptions_EndingNodes&& from) noexcept
    : LineageSubgraphQueryOptions_EndingNodes() {
    *this = ::std::move(from);
  }

  inline LineageSubgraphQueryOptions_EndingNodes& operator=(const LineageSubgraphQueryOptions_EndingNodes& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineageSubgraphQueryOptions_EndingNodes& operator=(LineageSubgraphQueryOptions_EndingNodes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LineageSubgraphQueryOptions_EndingNodes& default_instance() {
    return *internal_default_instance();
  }
  static inline const LineageSubgraphQueryOptions_EndingNodes* internal_default_instance() {
    return reinterpret_cast<const LineageSubgraphQueryOptions_EndingNodes*>(
               &_LineageSubgraphQueryOptions_EndingNodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(LineageSubgraphQueryOptions_EndingNodes& a, LineageSubgraphQueryOptions_EndingNodes& b) {
    a.Swap(&b);
  }
  inline void Swap(LineageSubgraphQueryOptions_EndingNodes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineageSubgraphQueryOptions_EndingNodes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineageSubgraphQueryOptions_EndingNodes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LineageSubgraphQueryOptions_EndingNodes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LineageSubgraphQueryOptions_EndingNodes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LineageSubgraphQueryOptions_EndingNodes& from) {
    LineageSubgraphQueryOptions_EndingNodes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineageSubgraphQueryOptions_EndingNodes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.LineageSubgraphQueryOptions.EndingNodes";
  }
  protected:
  explicit LineageSubgraphQueryOptions_EndingNodes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterQueryFieldNumber = 1,
    kIncludeEndingNodesFieldNumber = 2,
  };
  // optional string filter_query = 1;
  bool has_filter_query() const;
  private:
  bool _internal_has_filter_query() const;
  public:
  void clear_filter_query();
  const std::string& filter_query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter_query();
  PROTOBUF_NODISCARD std::string* release_filter_query();
  void set_allocated_filter_query(std::string* filter_query);
  private:
  const std::string& _internal_filter_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter_query(const std::string& value);
  std::string* _internal_mutable_filter_query();
  public:

  // optional bool include_ending_nodes = 2 [default = false];
  bool has_include_ending_nodes() const;
  private:
  bool _internal_has_include_ending_nodes() const;
  public:
  void clear_include_ending_nodes();
  bool include_ending_nodes() const;
  void set_include_ending_nodes(bool value);
  private:
  bool _internal_include_ending_nodes() const;
  void _internal_set_include_ending_nodes(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.LineageSubgraphQueryOptions.EndingNodes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_query_;
    bool include_ending_nodes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// -------------------------------------------------------------------

class LineageSubgraphQueryOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.LineageSubgraphQueryOptions) */ {
 public:
  inline LineageSubgraphQueryOptions() : LineageSubgraphQueryOptions(nullptr) {}
  ~LineageSubgraphQueryOptions() override;
  explicit PROTOBUF_CONSTEXPR LineageSubgraphQueryOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LineageSubgraphQueryOptions(const LineageSubgraphQueryOptions& from);
  LineageSubgraphQueryOptions(LineageSubgraphQueryOptions&& from) noexcept
    : LineageSubgraphQueryOptions() {
    *this = ::std::move(from);
  }

  inline LineageSubgraphQueryOptions& operator=(const LineageSubgraphQueryOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineageSubgraphQueryOptions& operator=(LineageSubgraphQueryOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LineageSubgraphQueryOptions& default_instance() {
    return *internal_default_instance();
  }
  enum StartingNodesCase {
    kStartingArtifacts = 1,
    kStartingExecutions = 2,
    STARTING_NODES_NOT_SET = 0,
  };

  static inline const LineageSubgraphQueryOptions* internal_default_instance() {
    return reinterpret_cast<const LineageSubgraphQueryOptions*>(
               &_LineageSubgraphQueryOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(LineageSubgraphQueryOptions& a, LineageSubgraphQueryOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(LineageSubgraphQueryOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineageSubgraphQueryOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineageSubgraphQueryOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LineageSubgraphQueryOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LineageSubgraphQueryOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LineageSubgraphQueryOptions& from) {
    LineageSubgraphQueryOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineageSubgraphQueryOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.LineageSubgraphQueryOptions";
  }
  protected:
  explicit LineageSubgraphQueryOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LineageSubgraphQueryOptions_StartingNodes StartingNodes;
  typedef LineageSubgraphQueryOptions_EndingNodes EndingNodes;

  typedef LineageSubgraphQueryOptions_Direction Direction;
  static constexpr Direction DIRECTION_UNSPECIFIED =
    LineageSubgraphQueryOptions_Direction_DIRECTION_UNSPECIFIED;
  static constexpr Direction UPSTREAM =
    LineageSubgraphQueryOptions_Direction_UPSTREAM;
  static constexpr Direction DOWNSTREAM =
    LineageSubgraphQueryOptions_Direction_DOWNSTREAM;
  static constexpr Direction BIDIRECTIONAL =
    LineageSubgraphQueryOptions_Direction_BIDIRECTIONAL;
  static inline bool Direction_IsValid(int value) {
    return LineageSubgraphQueryOptions_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN =
    LineageSubgraphQueryOptions_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX =
    LineageSubgraphQueryOptions_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE =
    LineageSubgraphQueryOptions_Direction_Direction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Direction_descriptor() {
    return LineageSubgraphQueryOptions_Direction_descriptor();
  }
  template<typename T>
  static inline const std::string& Direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Direction_Name.");
    return LineageSubgraphQueryOptions_Direction_Name(enum_t_value);
  }
  static inline bool Direction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Direction* value) {
    return LineageSubgraphQueryOptions_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEndingArtifactsFieldNumber = 5,
    kEndingExecutionsFieldNumber = 6,
    kMaxNumHopsFieldNumber = 3,
    kDirectionFieldNumber = 4,
    kStartingArtifactsFieldNumber = 1,
    kStartingExecutionsFieldNumber = 2,
  };
  // optional .ml_metadata.LineageSubgraphQueryOptions.EndingNodes ending_artifacts = 5;
  bool has_ending_artifacts() const;
  private:
  bool _internal_has_ending_artifacts() const;
  public:
  void clear_ending_artifacts();
  const ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes& ending_artifacts() const;
  PROTOBUF_NODISCARD ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* release_ending_artifacts();
  ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* mutable_ending_artifacts();
  void set_allocated_ending_artifacts(::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* ending_artifacts);
  private:
  const ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes& _internal_ending_artifacts() const;
  ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* _internal_mutable_ending_artifacts();
  public:
  void unsafe_arena_set_allocated_ending_artifacts(
      ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* ending_artifacts);
  ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* unsafe_arena_release_ending_artifacts();

  // optional .ml_metadata.LineageSubgraphQueryOptions.EndingNodes ending_executions = 6;
  bool has_ending_executions() const;
  private:
  bool _internal_has_ending_executions() const;
  public:
  void clear_ending_executions();
  const ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes& ending_executions() const;
  PROTOBUF_NODISCARD ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* release_ending_executions();
  ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* mutable_ending_executions();
  void set_allocated_ending_executions(::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* ending_executions);
  private:
  const ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes& _internal_ending_executions() const;
  ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* _internal_mutable_ending_executions();
  public:
  void unsafe_arena_set_allocated_ending_executions(
      ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* ending_executions);
  ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* unsafe_arena_release_ending_executions();

  // optional int64 max_num_hops = 3;
  bool has_max_num_hops() const;
  private:
  bool _internal_has_max_num_hops() const;
  public:
  void clear_max_num_hops();
  int64_t max_num_hops() const;
  void set_max_num_hops(int64_t value);
  private:
  int64_t _internal_max_num_hops() const;
  void _internal_set_max_num_hops(int64_t value);
  public:

  // optional .ml_metadata.LineageSubgraphQueryOptions.Direction direction = 4;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  ::ml_metadata::LineageSubgraphQueryOptions_Direction direction() const;
  void set_direction(::ml_metadata::LineageSubgraphQueryOptions_Direction value);
  private:
  ::ml_metadata::LineageSubgraphQueryOptions_Direction _internal_direction() const;
  void _internal_set_direction(::ml_metadata::LineageSubgraphQueryOptions_Direction value);
  public:

  // .ml_metadata.LineageSubgraphQueryOptions.StartingNodes starting_artifacts = 1;
  bool has_starting_artifacts() const;
  private:
  bool _internal_has_starting_artifacts() const;
  public:
  void clear_starting_artifacts();
  const ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes& starting_artifacts() const;
  PROTOBUF_NODISCARD ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* release_starting_artifacts();
  ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* mutable_starting_artifacts();
  void set_allocated_starting_artifacts(::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* starting_artifacts);
  private:
  const ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes& _internal_starting_artifacts() const;
  ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* _internal_mutable_starting_artifacts();
  public:
  void unsafe_arena_set_allocated_starting_artifacts(
      ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* starting_artifacts);
  ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* unsafe_arena_release_starting_artifacts();

  // .ml_metadata.LineageSubgraphQueryOptions.StartingNodes starting_executions = 2;
  bool has_starting_executions() const;
  private:
  bool _internal_has_starting_executions() const;
  public:
  void clear_starting_executions();
  const ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes& starting_executions() const;
  PROTOBUF_NODISCARD ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* release_starting_executions();
  ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* mutable_starting_executions();
  void set_allocated_starting_executions(::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* starting_executions);
  private:
  const ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes& _internal_starting_executions() const;
  ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* _internal_mutable_starting_executions();
  public:
  void unsafe_arena_set_allocated_starting_executions(
      ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* starting_executions);
  ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* unsafe_arena_release_starting_executions();

  void clear_starting_nodes();
  StartingNodesCase starting_nodes_case() const;
  // @@protoc_insertion_point(class_scope:ml_metadata.LineageSubgraphQueryOptions)
 private:
  class _Internal;
  void set_has_starting_artifacts();
  void set_has_starting_executions();

  inline bool has_starting_nodes() const;
  inline void clear_has_starting_nodes();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* ending_artifacts_;
    ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* ending_executions_;
    int64_t max_num_hops_;
    int direction_;
    union StartingNodesUnion {
      constexpr StartingNodesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* starting_artifacts_;
      ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* starting_executions_;
    } starting_nodes_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto;
};
// ===================================================================

static const int kSystemTypeExtensionFieldNumber = 384560917;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::EnumValueOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::ml_metadata::SystemTypeExtension >, 11, false >
  system_type_extension;

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SystemTypeExtension

// optional string type_name = 1;
inline bool SystemTypeExtension::_internal_has_type_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SystemTypeExtension::has_type_name() const {
  return _internal_has_type_name();
}
inline void SystemTypeExtension::clear_type_name() {
  _impl_.type_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SystemTypeExtension::type_name() const {
  // @@protoc_insertion_point(field_get:ml_metadata.SystemTypeExtension.type_name)
  return _internal_type_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemTypeExtension::set_type_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.type_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.SystemTypeExtension.type_name)
}
inline std::string* SystemTypeExtension::mutable_type_name() {
  std::string* _s = _internal_mutable_type_name();
  // @@protoc_insertion_point(field_mutable:ml_metadata.SystemTypeExtension.type_name)
  return _s;
}
inline const std::string& SystemTypeExtension::_internal_type_name() const {
  return _impl_.type_name_.Get();
}
inline void SystemTypeExtension::_internal_set_type_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemTypeExtension::_internal_mutable_type_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemTypeExtension::release_type_name() {
  // @@protoc_insertion_point(field_release:ml_metadata.SystemTypeExtension.type_name)
  if (!_internal_has_type_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.type_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_name_.IsDefault()) {
    _impl_.type_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SystemTypeExtension::set_allocated_type_name(std::string* type_name) {
  if (type_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_name_.SetAllocated(type_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_name_.IsDefault()) {
    _impl_.type_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.SystemTypeExtension.type_name)
}

// -------------------------------------------------------------------

// Value

// int64 int_value = 1;
inline bool Value::_internal_has_int_value() const {
  return value_case() == kIntValue;
}
inline bool Value::has_int_value() const {
  return _internal_has_int_value();
}
inline void Value::set_has_int_value() {
  _impl_._oneof_case_[0] = kIntValue;
}
inline void Value::clear_int_value() {
  if (_internal_has_int_value()) {
    _impl_.value_.int_value_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t Value::_internal_int_value() const {
  if (_internal_has_int_value()) {
    return _impl_.value_.int_value_;
  }
  return int64_t{0};
}
inline void Value::_internal_set_int_value(int64_t value) {
  if (!_internal_has_int_value()) {
    clear_value();
    set_has_int_value();
  }
  _impl_.value_.int_value_ = value;
}
inline int64_t Value::int_value() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Value.int_value)
  return _internal_int_value();
}
inline void Value::set_int_value(int64_t value) {
  _internal_set_int_value(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Value.int_value)
}

// double double_value = 2;
inline bool Value::_internal_has_double_value() const {
  return value_case() == kDoubleValue;
}
inline bool Value::has_double_value() const {
  return _internal_has_double_value();
}
inline void Value::set_has_double_value() {
  _impl_._oneof_case_[0] = kDoubleValue;
}
inline void Value::clear_double_value() {
  if (_internal_has_double_value()) {
    _impl_.value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double Value::_internal_double_value() const {
  if (_internal_has_double_value()) {
    return _impl_.value_.double_value_;
  }
  return 0;
}
inline void Value::_internal_set_double_value(double value) {
  if (!_internal_has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  _impl_.value_.double_value_ = value;
}
inline double Value::double_value() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Value.double_value)
  return _internal_double_value();
}
inline void Value::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Value.double_value)
}

// string string_value = 3;
inline bool Value::_internal_has_string_value() const {
  return value_case() == kStringValue;
}
inline bool Value::has_string_value() const {
  return _internal_has_string_value();
}
inline void Value::set_has_string_value() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void Value::clear_string_value() {
  if (_internal_has_string_value()) {
    _impl_.value_.string_value_.Destroy();
    clear_has_value();
  }
}
inline const std::string& Value::string_value() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Value.string_value)
  return _internal_string_value();
}
template <typename ArgT0, typename... ArgT>
inline void Value::set_string_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.Value.string_value)
}
inline std::string* Value::mutable_string_value() {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Value.string_value)
  return _s;
}
inline const std::string& Value::_internal_string_value() const {
  if (_internal_has_string_value()) {
    return _impl_.value_.string_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_string_value(const std::string& value) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set(value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_string_value() {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  return _impl_.value_.string_value_.Mutable(      GetArenaForAllocation());
}
inline std::string* Value::release_string_value() {
  // @@protoc_insertion_point(field_release:ml_metadata.Value.string_value)
  if (_internal_has_string_value()) {
    clear_has_value();
    return _impl_.value_.string_value_.Release();
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_string_value(std::string* string_value) {
  if (has_value()) {
    clear_value();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    _impl_.value_.string_value_.InitAllocated(string_value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Value.string_value)
}

// .google.protobuf.Struct struct_value = 4;
inline bool Value::_internal_has_struct_value() const {
  return value_case() == kStructValue;
}
inline bool Value::has_struct_value() const {
  return _internal_has_struct_value();
}
inline void Value::set_has_struct_value() {
  _impl_._oneof_case_[0] = kStructValue;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Value::release_struct_value() {
  // @@protoc_insertion_point(field_release:ml_metadata.Value.struct_value)
  if (_internal_has_struct_value()) {
    clear_has_value();
    ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.value_.struct_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.struct_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Value::_internal_struct_value() const {
  return _internal_has_struct_value()
      ? *_impl_.value_.struct_value_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Struct&>(::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Value::struct_value() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Value.struct_value)
  return _internal_struct_value();
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Value::unsafe_arena_release_struct_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.Value.struct_value)
  if (_internal_has_struct_value()) {
    clear_has_value();
    ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.value_.struct_value_;
    _impl_.value_.struct_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_struct_value(::PROTOBUF_NAMESPACE_ID::Struct* struct_value) {
  clear_value();
  if (struct_value) {
    set_has_struct_value();
    _impl_.value_.struct_value_ = struct_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Value.struct_value)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Value::_internal_mutable_struct_value() {
  if (!_internal_has_struct_value()) {
    clear_value();
    set_has_struct_value();
    _impl_.value_.struct_value_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Struct >(GetArenaForAllocation());
  }
  return _impl_.value_.struct_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Value::mutable_struct_value() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_struct_value();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Value.struct_value)
  return _msg;
}

// .google.protobuf.Any proto_value = 5;
inline bool Value::_internal_has_proto_value() const {
  return value_case() == kProtoValue;
}
inline bool Value::has_proto_value() const {
  return _internal_has_proto_value();
}
inline void Value::set_has_proto_value() {
  _impl_._oneof_case_[0] = kProtoValue;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Value::release_proto_value() {
  // @@protoc_insertion_point(field_release:ml_metadata.Value.proto_value)
  if (_internal_has_proto_value()) {
    clear_has_value();
    ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.value_.proto_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.proto_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Value::_internal_proto_value() const {
  return _internal_has_proto_value()
      ? *_impl_.value_.proto_value_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Any&>(::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Value::proto_value() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Value.proto_value)
  return _internal_proto_value();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Value::unsafe_arena_release_proto_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.Value.proto_value)
  if (_internal_has_proto_value()) {
    clear_has_value();
    ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.value_.proto_value_;
    _impl_.value_.proto_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_proto_value(::PROTOBUF_NAMESPACE_ID::Any* proto_value) {
  clear_value();
  if (proto_value) {
    set_has_proto_value();
    _impl_.value_.proto_value_ = proto_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Value.proto_value)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Value::_internal_mutable_proto_value() {
  if (!_internal_has_proto_value()) {
    clear_value();
    set_has_proto_value();
    _impl_.value_.proto_value_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Any >(GetArenaForAllocation());
  }
  return _impl_.value_.proto_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Value::mutable_proto_value() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_proto_value();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Value.proto_value)
  return _msg;
}

// bool bool_value = 6;
inline bool Value::_internal_has_bool_value() const {
  return value_case() == kBoolValue;
}
inline bool Value::has_bool_value() const {
  return _internal_has_bool_value();
}
inline void Value::set_has_bool_value() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void Value::clear_bool_value() {
  if (_internal_has_bool_value()) {
    _impl_.value_.bool_value_ = false;
    clear_has_value();
  }
}
inline bool Value::_internal_bool_value() const {
  if (_internal_has_bool_value()) {
    return _impl_.value_.bool_value_;
  }
  return false;
}
inline void Value::_internal_set_bool_value(bool value) {
  if (!_internal_has_bool_value()) {
    clear_value();
    set_has_bool_value();
  }
  _impl_.value_.bool_value_ = value;
}
inline bool Value::bool_value() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Value.bool_value)
  return _internal_bool_value();
}
inline void Value::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Value.bool_value)
}

inline bool Value::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Value::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Value::ValueCase Value::value_case() const {
  return Value::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Artifact

// optional int64 id = 1;
inline bool Artifact::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Artifact::has_id() const {
  return _internal_has_id();
}
inline void Artifact::clear_id() {
  _impl_.id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t Artifact::_internal_id() const {
  return _impl_.id_;
}
inline int64_t Artifact::id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Artifact.id)
  return _internal_id();
}
inline void Artifact::_internal_set_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.id_ = value;
}
inline void Artifact::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Artifact.id)
}

// optional string name = 7;
inline bool Artifact::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Artifact::has_name() const {
  return _internal_has_name();
}
inline void Artifact::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Artifact::name() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Artifact.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.Artifact.name)
}
inline std::string* Artifact::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Artifact.name)
  return _s;
}
inline const std::string& Artifact::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Artifact::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_name() {
  // @@protoc_insertion_point(field_release:ml_metadata.Artifact.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Artifact::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Artifact.name)
}

// optional int64 type_id = 2;
inline bool Artifact::_internal_has_type_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Artifact::has_type_id() const {
  return _internal_has_type_id();
}
inline void Artifact::clear_type_id() {
  _impl_.type_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t Artifact::_internal_type_id() const {
  return _impl_.type_id_;
}
inline int64_t Artifact::type_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Artifact.type_id)
  return _internal_type_id();
}
inline void Artifact::_internal_set_type_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.type_id_ = value;
}
inline void Artifact::set_type_id(int64_t value) {
  _internal_set_type_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Artifact.type_id)
}

// optional string type = 8;
inline bool Artifact::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Artifact::has_type() const {
  return _internal_has_type();
}
inline void Artifact::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Artifact::type() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Artifact.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.Artifact.type)
}
inline std::string* Artifact::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Artifact.type)
  return _s;
}
inline const std::string& Artifact::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Artifact::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_type() {
  // @@protoc_insertion_point(field_release:ml_metadata.Artifact.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Artifact::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Artifact.type)
}

// optional string uri = 3;
inline bool Artifact::_internal_has_uri() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Artifact::has_uri() const {
  return _internal_has_uri();
}
inline void Artifact::clear_uri() {
  _impl_.uri_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Artifact::uri() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Artifact.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_uri(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.Artifact.uri)
}
inline std::string* Artifact::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Artifact.uri)
  return _s;
}
inline const std::string& Artifact::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void Artifact::_internal_set_uri(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_uri() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_uri() {
  // @@protoc_insertion_point(field_release:ml_metadata.Artifact.uri)
  if (!_internal_has_uri()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.uri_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Artifact::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Artifact.uri)
}

// optional string external_id = 11;
inline bool Artifact::_internal_has_external_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Artifact::has_external_id() const {
  return _internal_has_external_id();
}
inline void Artifact::clear_external_id() {
  _impl_.external_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Artifact::external_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Artifact.external_id)
  return _internal_external_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_external_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.external_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.Artifact.external_id)
}
inline std::string* Artifact::mutable_external_id() {
  std::string* _s = _internal_mutable_external_id();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Artifact.external_id)
  return _s;
}
inline const std::string& Artifact::_internal_external_id() const {
  return _impl_.external_id_.Get();
}
inline void Artifact::_internal_set_external_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.external_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_external_id() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.external_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_external_id() {
  // @@protoc_insertion_point(field_release:ml_metadata.Artifact.external_id)
  if (!_internal_has_external_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.external_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Artifact::set_allocated_external_id(std::string* external_id) {
  if (external_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.external_id_.SetAllocated(external_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Artifact.external_id)
}

// map<string, .ml_metadata.Value> properties = 4;
inline int Artifact::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int Artifact::properties_size() const {
  return _internal_properties_size();
}
inline void Artifact::clear_properties() {
  _impl_.properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
Artifact::_internal_properties() const {
  return _impl_.properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
Artifact::properties() const {
  // @@protoc_insertion_point(field_map:ml_metadata.Artifact.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
Artifact::_internal_mutable_properties() {
  return _impl_.properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
Artifact::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:ml_metadata.Artifact.properties)
  return _internal_mutable_properties();
}

// map<string, .ml_metadata.Value> custom_properties = 5;
inline int Artifact::_internal_custom_properties_size() const {
  return _impl_.custom_properties_.size();
}
inline int Artifact::custom_properties_size() const {
  return _internal_custom_properties_size();
}
inline void Artifact::clear_custom_properties() {
  _impl_.custom_properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
Artifact::_internal_custom_properties() const {
  return _impl_.custom_properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
Artifact::custom_properties() const {
  // @@protoc_insertion_point(field_map:ml_metadata.Artifact.custom_properties)
  return _internal_custom_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
Artifact::_internal_mutable_custom_properties() {
  return _impl_.custom_properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
Artifact::mutable_custom_properties() {
  // @@protoc_insertion_point(field_mutable_map:ml_metadata.Artifact.custom_properties)
  return _internal_mutable_custom_properties();
}

// optional .ml_metadata.Artifact.State state = 6;
inline bool Artifact::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Artifact::has_state() const {
  return _internal_has_state();
}
inline void Artifact::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::ml_metadata::Artifact_State Artifact::_internal_state() const {
  return static_cast< ::ml_metadata::Artifact_State >(_impl_.state_);
}
inline ::ml_metadata::Artifact_State Artifact::state() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Artifact.state)
  return _internal_state();
}
inline void Artifact::_internal_set_state(::ml_metadata::Artifact_State value) {
  assert(::ml_metadata::Artifact_State_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.state_ = value;
}
inline void Artifact::set_state(::ml_metadata::Artifact_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Artifact.state)
}

// optional int64 create_time_since_epoch = 9;
inline bool Artifact::_internal_has_create_time_since_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Artifact::has_create_time_since_epoch() const {
  return _internal_has_create_time_since_epoch();
}
inline void Artifact::clear_create_time_since_epoch() {
  _impl_.create_time_since_epoch_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t Artifact::_internal_create_time_since_epoch() const {
  return _impl_.create_time_since_epoch_;
}
inline int64_t Artifact::create_time_since_epoch() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Artifact.create_time_since_epoch)
  return _internal_create_time_since_epoch();
}
inline void Artifact::_internal_set_create_time_since_epoch(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.create_time_since_epoch_ = value;
}
inline void Artifact::set_create_time_since_epoch(int64_t value) {
  _internal_set_create_time_since_epoch(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Artifact.create_time_since_epoch)
}

// optional int64 last_update_time_since_epoch = 10;
inline bool Artifact::_internal_has_last_update_time_since_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Artifact::has_last_update_time_since_epoch() const {
  return _internal_has_last_update_time_since_epoch();
}
inline void Artifact::clear_last_update_time_since_epoch() {
  _impl_.last_update_time_since_epoch_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t Artifact::_internal_last_update_time_since_epoch() const {
  return _impl_.last_update_time_since_epoch_;
}
inline int64_t Artifact::last_update_time_since_epoch() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Artifact.last_update_time_since_epoch)
  return _internal_last_update_time_since_epoch();
}
inline void Artifact::_internal_set_last_update_time_since_epoch(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.last_update_time_since_epoch_ = value;
}
inline void Artifact::set_last_update_time_since_epoch(int64_t value) {
  _internal_set_last_update_time_since_epoch(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Artifact.last_update_time_since_epoch)
}

// optional .google.protobuf.Any system_metadata = 12;
inline bool Artifact::_internal_has_system_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_metadata_ != nullptr);
  return value;
}
inline bool Artifact::has_system_metadata() const {
  return _internal_has_system_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Artifact::_internal_system_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.system_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Artifact::system_metadata() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Artifact.system_metadata)
  return _internal_system_metadata();
}
inline void Artifact::unsafe_arena_set_allocated_system_metadata(
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  _impl_.system_metadata_ = system_metadata;
  if (system_metadata) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Artifact.system_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Artifact::release_system_metadata() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Artifact::unsafe_arena_release_system_metadata() {
  // @@protoc_insertion_point(field_release:ml_metadata.Artifact.system_metadata)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Artifact::_internal_mutable_system_metadata() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.system_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.system_metadata_ = p;
  }
  return _impl_.system_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Artifact::mutable_system_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_system_metadata();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Artifact.system_metadata)
  return _msg;
}
inline void Artifact::set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  if (system_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_metadata));
    if (message_arena != submessage_arena) {
      system_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.system_metadata_ = system_metadata;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Artifact.system_metadata)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ArtifactType

// optional int64 id = 1;
inline bool ArtifactType::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ArtifactType::has_id() const {
  return _internal_has_id();
}
inline void ArtifactType::clear_id() {
  _impl_.id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t ArtifactType::_internal_id() const {
  return _impl_.id_;
}
inline int64_t ArtifactType::id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactType.id)
  return _internal_id();
}
inline void ArtifactType::_internal_set_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.id_ = value;
}
inline void ArtifactType::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ArtifactType.id)
}

// optional string name = 2;
inline bool ArtifactType::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArtifactType::has_name() const {
  return _internal_has_name();
}
inline void ArtifactType::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ArtifactType::name() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactType.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArtifactType::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ArtifactType.name)
}
inline std::string* ArtifactType::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ArtifactType.name)
  return _s;
}
inline const std::string& ArtifactType::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ArtifactType::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ArtifactType::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ArtifactType::release_name() {
  // @@protoc_insertion_point(field_release:ml_metadata.ArtifactType.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ArtifactType::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ArtifactType.name)
}

// optional string version = 4;
inline bool ArtifactType::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArtifactType::has_version() const {
  return _internal_has_version();
}
inline void ArtifactType::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ArtifactType::version() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactType.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArtifactType::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ArtifactType.version)
}
inline std::string* ArtifactType::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ArtifactType.version)
  return _s;
}
inline const std::string& ArtifactType::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ArtifactType::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ArtifactType::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ArtifactType::release_version() {
  // @@protoc_insertion_point(field_release:ml_metadata.ArtifactType.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ArtifactType::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ArtifactType.version)
}

// optional string description = 5;
inline bool ArtifactType::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ArtifactType::has_description() const {
  return _internal_has_description();
}
inline void ArtifactType::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ArtifactType::description() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactType.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArtifactType::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ArtifactType.description)
}
inline std::string* ArtifactType::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ArtifactType.description)
  return _s;
}
inline const std::string& ArtifactType::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ArtifactType::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ArtifactType::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ArtifactType::release_description() {
  // @@protoc_insertion_point(field_release:ml_metadata.ArtifactType.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ArtifactType::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ArtifactType.description)
}

// optional string external_id = 7;
inline bool ArtifactType::_internal_has_external_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ArtifactType::has_external_id() const {
  return _internal_has_external_id();
}
inline void ArtifactType::clear_external_id() {
  _impl_.external_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ArtifactType::external_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactType.external_id)
  return _internal_external_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArtifactType::set_external_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.external_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ArtifactType.external_id)
}
inline std::string* ArtifactType::mutable_external_id() {
  std::string* _s = _internal_mutable_external_id();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ArtifactType.external_id)
  return _s;
}
inline const std::string& ArtifactType::_internal_external_id() const {
  return _impl_.external_id_.Get();
}
inline void ArtifactType::_internal_set_external_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.external_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ArtifactType::_internal_mutable_external_id() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.external_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ArtifactType::release_external_id() {
  // @@protoc_insertion_point(field_release:ml_metadata.ArtifactType.external_id)
  if (!_internal_has_external_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.external_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ArtifactType::set_allocated_external_id(std::string* external_id) {
  if (external_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.external_id_.SetAllocated(external_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ArtifactType.external_id)
}

// map<string, .ml_metadata.PropertyType> properties = 3;
inline int ArtifactType::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int ArtifactType::properties_size() const {
  return _internal_properties_size();
}
inline void ArtifactType::clear_properties() {
  _impl_.properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >&
ArtifactType::_internal_properties() const {
  return _impl_.properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >&
ArtifactType::properties() const {
  // @@protoc_insertion_point(field_map:ml_metadata.ArtifactType.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >*
ArtifactType::_internal_mutable_properties() {
  return _impl_.properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >*
ArtifactType::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:ml_metadata.ArtifactType.properties)
  return _internal_mutable_properties();
}

// optional .ml_metadata.ArtifactType.SystemDefinedBaseType base_type = 6;
inline bool ArtifactType::_internal_has_base_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ArtifactType::has_base_type() const {
  return _internal_has_base_type();
}
inline void ArtifactType::clear_base_type() {
  _impl_.base_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::ml_metadata::ArtifactType_SystemDefinedBaseType ArtifactType::_internal_base_type() const {
  return static_cast< ::ml_metadata::ArtifactType_SystemDefinedBaseType >(_impl_.base_type_);
}
inline ::ml_metadata::ArtifactType_SystemDefinedBaseType ArtifactType::base_type() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactType.base_type)
  return _internal_base_type();
}
inline void ArtifactType::_internal_set_base_type(::ml_metadata::ArtifactType_SystemDefinedBaseType value) {
  assert(::ml_metadata::ArtifactType_SystemDefinedBaseType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.base_type_ = value;
}
inline void ArtifactType::set_base_type(::ml_metadata::ArtifactType_SystemDefinedBaseType value) {
  _internal_set_base_type(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ArtifactType.base_type)
}

// -------------------------------------------------------------------

// Event_Path_Step

// int64 index = 1;
inline bool Event_Path_Step::_internal_has_index() const {
  return value_case() == kIndex;
}
inline bool Event_Path_Step::has_index() const {
  return _internal_has_index();
}
inline void Event_Path_Step::set_has_index() {
  _impl_._oneof_case_[0] = kIndex;
}
inline void Event_Path_Step::clear_index() {
  if (_internal_has_index()) {
    _impl_.value_.index_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t Event_Path_Step::_internal_index() const {
  if (_internal_has_index()) {
    return _impl_.value_.index_;
  }
  return int64_t{0};
}
inline void Event_Path_Step::_internal_set_index(int64_t value) {
  if (!_internal_has_index()) {
    clear_value();
    set_has_index();
  }
  _impl_.value_.index_ = value;
}
inline int64_t Event_Path_Step::index() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Event.Path.Step.index)
  return _internal_index();
}
inline void Event_Path_Step::set_index(int64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Event.Path.Step.index)
}

// string key = 2;
inline bool Event_Path_Step::_internal_has_key() const {
  return value_case() == kKey;
}
inline bool Event_Path_Step::has_key() const {
  return _internal_has_key();
}
inline void Event_Path_Step::set_has_key() {
  _impl_._oneof_case_[0] = kKey;
}
inline void Event_Path_Step::clear_key() {
  if (_internal_has_key()) {
    _impl_.value_.key_.Destroy();
    clear_has_value();
  }
}
inline const std::string& Event_Path_Step::key() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Event.Path.Step.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline void Event_Path_Step::set_key(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_key()) {
    clear_value();
    set_has_key();
    _impl_.value_.key_.InitDefault();
  }
  _impl_.value_.key_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.Event.Path.Step.key)
}
inline std::string* Event_Path_Step::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Event.Path.Step.key)
  return _s;
}
inline const std::string& Event_Path_Step::_internal_key() const {
  if (_internal_has_key()) {
    return _impl_.value_.key_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Event_Path_Step::_internal_set_key(const std::string& value) {
  if (!_internal_has_key()) {
    clear_value();
    set_has_key();
    _impl_.value_.key_.InitDefault();
  }
  _impl_.value_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* Event_Path_Step::_internal_mutable_key() {
  if (!_internal_has_key()) {
    clear_value();
    set_has_key();
    _impl_.value_.key_.InitDefault();
  }
  return _impl_.value_.key_.Mutable(      GetArenaForAllocation());
}
inline std::string* Event_Path_Step::release_key() {
  // @@protoc_insertion_point(field_release:ml_metadata.Event.Path.Step.key)
  if (_internal_has_key()) {
    clear_has_value();
    return _impl_.value_.key_.Release();
  } else {
    return nullptr;
  }
}
inline void Event_Path_Step::set_allocated_key(std::string* key) {
  if (has_value()) {
    clear_value();
  }
  if (key != nullptr) {
    set_has_key();
    _impl_.value_.key_.InitAllocated(key, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Event.Path.Step.key)
}

inline bool Event_Path_Step::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Event_Path_Step::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Event_Path_Step::ValueCase Event_Path_Step::value_case() const {
  return Event_Path_Step::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event_Path

// repeated .ml_metadata.Event.Path.Step steps = 1;
inline int Event_Path::_internal_steps_size() const {
  return _impl_.steps_.size();
}
inline int Event_Path::steps_size() const {
  return _internal_steps_size();
}
inline void Event_Path::clear_steps() {
  _impl_.steps_.Clear();
}
inline ::ml_metadata::Event_Path_Step* Event_Path::mutable_steps(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.Event.Path.steps)
  return _impl_.steps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Event_Path_Step >*
Event_Path::mutable_steps() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.Event.Path.steps)
  return &_impl_.steps_;
}
inline const ::ml_metadata::Event_Path_Step& Event_Path::_internal_steps(int index) const {
  return _impl_.steps_.Get(index);
}
inline const ::ml_metadata::Event_Path_Step& Event_Path::steps(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.Event.Path.steps)
  return _internal_steps(index);
}
inline ::ml_metadata::Event_Path_Step* Event_Path::_internal_add_steps() {
  return _impl_.steps_.Add();
}
inline ::ml_metadata::Event_Path_Step* Event_Path::add_steps() {
  ::ml_metadata::Event_Path_Step* _add = _internal_add_steps();
  // @@protoc_insertion_point(field_add:ml_metadata.Event.Path.steps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Event_Path_Step >&
Event_Path::steps() const {
  // @@protoc_insertion_point(field_list:ml_metadata.Event.Path.steps)
  return _impl_.steps_;
}

// -------------------------------------------------------------------

// Event

// optional int64 artifact_id = 1;
inline bool Event::_internal_has_artifact_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Event::has_artifact_id() const {
  return _internal_has_artifact_id();
}
inline void Event::clear_artifact_id() {
  _impl_.artifact_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t Event::_internal_artifact_id() const {
  return _impl_.artifact_id_;
}
inline int64_t Event::artifact_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Event.artifact_id)
  return _internal_artifact_id();
}
inline void Event::_internal_set_artifact_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.artifact_id_ = value;
}
inline void Event::set_artifact_id(int64_t value) {
  _internal_set_artifact_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Event.artifact_id)
}

// optional int64 execution_id = 2;
inline bool Event::_internal_has_execution_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Event::has_execution_id() const {
  return _internal_has_execution_id();
}
inline void Event::clear_execution_id() {
  _impl_.execution_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t Event::_internal_execution_id() const {
  return _impl_.execution_id_;
}
inline int64_t Event::execution_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Event.execution_id)
  return _internal_execution_id();
}
inline void Event::_internal_set_execution_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.execution_id_ = value;
}
inline void Event::set_execution_id(int64_t value) {
  _internal_set_execution_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Event.execution_id)
}

// optional .ml_metadata.Event.Path path = 3;
inline bool Event::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.path_ != nullptr);
  return value;
}
inline bool Event::has_path() const {
  return _internal_has_path();
}
inline void Event::clear_path() {
  if (_impl_.path_ != nullptr) _impl_.path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::Event_Path& Event::_internal_path() const {
  const ::ml_metadata::Event_Path* p = _impl_.path_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::Event_Path&>(
      ::ml_metadata::_Event_Path_default_instance_);
}
inline const ::ml_metadata::Event_Path& Event::path() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Event.path)
  return _internal_path();
}
inline void Event::unsafe_arena_set_allocated_path(
    ::ml_metadata::Event_Path* path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.path_);
  }
  _impl_.path_ = path;
  if (path) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Event.path)
}
inline ::ml_metadata::Event_Path* Event::release_path() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::Event_Path* temp = _impl_.path_;
  _impl_.path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::Event_Path* Event::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:ml_metadata.Event.path)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::Event_Path* temp = _impl_.path_;
  _impl_.path_ = nullptr;
  return temp;
}
inline ::ml_metadata::Event_Path* Event::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.path_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::Event_Path>(GetArenaForAllocation());
    _impl_.path_ = p;
  }
  return _impl_.path_;
}
inline ::ml_metadata::Event_Path* Event::mutable_path() {
  ::ml_metadata::Event_Path* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Event.path)
  return _msg;
}
inline void Event::set_allocated_path(::ml_metadata::Event_Path* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.path_;
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(path);
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_ = path;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Event.path)
}

// optional .ml_metadata.Event.Type type = 4;
inline bool Event::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Event::has_type() const {
  return _internal_has_type();
}
inline void Event::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::ml_metadata::Event_Type Event::_internal_type() const {
  return static_cast< ::ml_metadata::Event_Type >(_impl_.type_);
}
inline ::ml_metadata::Event_Type Event::type() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Event.type)
  return _internal_type();
}
inline void Event::_internal_set_type(::ml_metadata::Event_Type value) {
  assert(::ml_metadata::Event_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.type_ = value;
}
inline void Event::set_type(::ml_metadata::Event_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Event.type)
}

// optional int64 milliseconds_since_epoch = 5;
inline bool Event::_internal_has_milliseconds_since_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Event::has_milliseconds_since_epoch() const {
  return _internal_has_milliseconds_since_epoch();
}
inline void Event::clear_milliseconds_since_epoch() {
  _impl_.milliseconds_since_epoch_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t Event::_internal_milliseconds_since_epoch() const {
  return _impl_.milliseconds_since_epoch_;
}
inline int64_t Event::milliseconds_since_epoch() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Event.milliseconds_since_epoch)
  return _internal_milliseconds_since_epoch();
}
inline void Event::_internal_set_milliseconds_since_epoch(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.milliseconds_since_epoch_ = value;
}
inline void Event::set_milliseconds_since_epoch(int64_t value) {
  _internal_set_milliseconds_since_epoch(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Event.milliseconds_since_epoch)
}

// optional .google.protobuf.Any system_metadata = 6;
inline bool Event::_internal_has_system_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_metadata_ != nullptr);
  return value;
}
inline bool Event::has_system_metadata() const {
  return _internal_has_system_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Event::_internal_system_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.system_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Event::system_metadata() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Event.system_metadata)
  return _internal_system_metadata();
}
inline void Event::unsafe_arena_set_allocated_system_metadata(
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  _impl_.system_metadata_ = system_metadata;
  if (system_metadata) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Event.system_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Event::release_system_metadata() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Event::unsafe_arena_release_system_metadata() {
  // @@protoc_insertion_point(field_release:ml_metadata.Event.system_metadata)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Event::_internal_mutable_system_metadata() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.system_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.system_metadata_ = p;
  }
  return _impl_.system_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Event::mutable_system_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_system_metadata();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Event.system_metadata)
  return _msg;
}
inline void Event::set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  if (system_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_metadata));
    if (message_arena != submessage_arena) {
      system_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.system_metadata_ = system_metadata;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Event.system_metadata)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Execution

// optional int64 id = 1;
inline bool Execution::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Execution::has_id() const {
  return _internal_has_id();
}
inline void Execution::clear_id() {
  _impl_.id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t Execution::_internal_id() const {
  return _impl_.id_;
}
inline int64_t Execution::id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Execution.id)
  return _internal_id();
}
inline void Execution::_internal_set_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.id_ = value;
}
inline void Execution::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Execution.id)
}

// optional string name = 6;
inline bool Execution::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Execution::has_name() const {
  return _internal_has_name();
}
inline void Execution::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Execution::name() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Execution.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Execution::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.Execution.name)
}
inline std::string* Execution::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Execution.name)
  return _s;
}
inline const std::string& Execution::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Execution::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Execution::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Execution::release_name() {
  // @@protoc_insertion_point(field_release:ml_metadata.Execution.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Execution::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Execution.name)
}

// optional int64 type_id = 2;
inline bool Execution::_internal_has_type_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Execution::has_type_id() const {
  return _internal_has_type_id();
}
inline void Execution::clear_type_id() {
  _impl_.type_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t Execution::_internal_type_id() const {
  return _impl_.type_id_;
}
inline int64_t Execution::type_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Execution.type_id)
  return _internal_type_id();
}
inline void Execution::_internal_set_type_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.type_id_ = value;
}
inline void Execution::set_type_id(int64_t value) {
  _internal_set_type_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Execution.type_id)
}

// optional string type = 7;
inline bool Execution::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Execution::has_type() const {
  return _internal_has_type();
}
inline void Execution::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Execution::type() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Execution.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Execution::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.Execution.type)
}
inline std::string* Execution::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Execution.type)
  return _s;
}
inline const std::string& Execution::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Execution::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Execution::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Execution::release_type() {
  // @@protoc_insertion_point(field_release:ml_metadata.Execution.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Execution::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Execution.type)
}

// optional string external_id = 10;
inline bool Execution::_internal_has_external_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Execution::has_external_id() const {
  return _internal_has_external_id();
}
inline void Execution::clear_external_id() {
  _impl_.external_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Execution::external_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Execution.external_id)
  return _internal_external_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Execution::set_external_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.external_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.Execution.external_id)
}
inline std::string* Execution::mutable_external_id() {
  std::string* _s = _internal_mutable_external_id();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Execution.external_id)
  return _s;
}
inline const std::string& Execution::_internal_external_id() const {
  return _impl_.external_id_.Get();
}
inline void Execution::_internal_set_external_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.external_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Execution::_internal_mutable_external_id() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.external_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Execution::release_external_id() {
  // @@protoc_insertion_point(field_release:ml_metadata.Execution.external_id)
  if (!_internal_has_external_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.external_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Execution::set_allocated_external_id(std::string* external_id) {
  if (external_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.external_id_.SetAllocated(external_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Execution.external_id)
}

// optional .ml_metadata.Execution.State last_known_state = 3;
inline bool Execution::_internal_has_last_known_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Execution::has_last_known_state() const {
  return _internal_has_last_known_state();
}
inline void Execution::clear_last_known_state() {
  _impl_.last_known_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::ml_metadata::Execution_State Execution::_internal_last_known_state() const {
  return static_cast< ::ml_metadata::Execution_State >(_impl_.last_known_state_);
}
inline ::ml_metadata::Execution_State Execution::last_known_state() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Execution.last_known_state)
  return _internal_last_known_state();
}
inline void Execution::_internal_set_last_known_state(::ml_metadata::Execution_State value) {
  assert(::ml_metadata::Execution_State_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.last_known_state_ = value;
}
inline void Execution::set_last_known_state(::ml_metadata::Execution_State value) {
  _internal_set_last_known_state(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Execution.last_known_state)
}

// map<string, .ml_metadata.Value> properties = 4;
inline int Execution::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int Execution::properties_size() const {
  return _internal_properties_size();
}
inline void Execution::clear_properties() {
  _impl_.properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
Execution::_internal_properties() const {
  return _impl_.properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
Execution::properties() const {
  // @@protoc_insertion_point(field_map:ml_metadata.Execution.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
Execution::_internal_mutable_properties() {
  return _impl_.properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
Execution::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:ml_metadata.Execution.properties)
  return _internal_mutable_properties();
}

// map<string, .ml_metadata.Value> custom_properties = 5;
inline int Execution::_internal_custom_properties_size() const {
  return _impl_.custom_properties_.size();
}
inline int Execution::custom_properties_size() const {
  return _internal_custom_properties_size();
}
inline void Execution::clear_custom_properties() {
  _impl_.custom_properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
Execution::_internal_custom_properties() const {
  return _impl_.custom_properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
Execution::custom_properties() const {
  // @@protoc_insertion_point(field_map:ml_metadata.Execution.custom_properties)
  return _internal_custom_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
Execution::_internal_mutable_custom_properties() {
  return _impl_.custom_properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
Execution::mutable_custom_properties() {
  // @@protoc_insertion_point(field_mutable_map:ml_metadata.Execution.custom_properties)
  return _internal_mutable_custom_properties();
}

// optional int64 create_time_since_epoch = 8;
inline bool Execution::_internal_has_create_time_since_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Execution::has_create_time_since_epoch() const {
  return _internal_has_create_time_since_epoch();
}
inline void Execution::clear_create_time_since_epoch() {
  _impl_.create_time_since_epoch_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t Execution::_internal_create_time_since_epoch() const {
  return _impl_.create_time_since_epoch_;
}
inline int64_t Execution::create_time_since_epoch() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Execution.create_time_since_epoch)
  return _internal_create_time_since_epoch();
}
inline void Execution::_internal_set_create_time_since_epoch(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.create_time_since_epoch_ = value;
}
inline void Execution::set_create_time_since_epoch(int64_t value) {
  _internal_set_create_time_since_epoch(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Execution.create_time_since_epoch)
}

// optional int64 last_update_time_since_epoch = 9;
inline bool Execution::_internal_has_last_update_time_since_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Execution::has_last_update_time_since_epoch() const {
  return _internal_has_last_update_time_since_epoch();
}
inline void Execution::clear_last_update_time_since_epoch() {
  _impl_.last_update_time_since_epoch_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t Execution::_internal_last_update_time_since_epoch() const {
  return _impl_.last_update_time_since_epoch_;
}
inline int64_t Execution::last_update_time_since_epoch() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Execution.last_update_time_since_epoch)
  return _internal_last_update_time_since_epoch();
}
inline void Execution::_internal_set_last_update_time_since_epoch(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.last_update_time_since_epoch_ = value;
}
inline void Execution::set_last_update_time_since_epoch(int64_t value) {
  _internal_set_last_update_time_since_epoch(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Execution.last_update_time_since_epoch)
}

// optional .google.protobuf.Any system_metadata = 11;
inline bool Execution::_internal_has_system_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_metadata_ != nullptr);
  return value;
}
inline bool Execution::has_system_metadata() const {
  return _internal_has_system_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Execution::_internal_system_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.system_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Execution::system_metadata() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Execution.system_metadata)
  return _internal_system_metadata();
}
inline void Execution::unsafe_arena_set_allocated_system_metadata(
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  _impl_.system_metadata_ = system_metadata;
  if (system_metadata) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Execution.system_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Execution::release_system_metadata() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Execution::unsafe_arena_release_system_metadata() {
  // @@protoc_insertion_point(field_release:ml_metadata.Execution.system_metadata)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Execution::_internal_mutable_system_metadata() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.system_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.system_metadata_ = p;
  }
  return _impl_.system_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Execution::mutable_system_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_system_metadata();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Execution.system_metadata)
  return _msg;
}
inline void Execution::set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  if (system_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_metadata));
    if (message_arena != submessage_arena) {
      system_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.system_metadata_ = system_metadata;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Execution.system_metadata)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ExecutionType

// optional int64 id = 1;
inline bool ExecutionType::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ExecutionType::has_id() const {
  return _internal_has_id();
}
inline void ExecutionType::clear_id() {
  _impl_.id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t ExecutionType::_internal_id() const {
  return _impl_.id_;
}
inline int64_t ExecutionType::id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ExecutionType.id)
  return _internal_id();
}
inline void ExecutionType::_internal_set_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.id_ = value;
}
inline void ExecutionType::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ExecutionType.id)
}

// optional string name = 2;
inline bool ExecutionType::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExecutionType::has_name() const {
  return _internal_has_name();
}
inline void ExecutionType::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExecutionType::name() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ExecutionType.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionType::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ExecutionType.name)
}
inline std::string* ExecutionType::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ExecutionType.name)
  return _s;
}
inline const std::string& ExecutionType::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ExecutionType::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecutionType::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecutionType::release_name() {
  // @@protoc_insertion_point(field_release:ml_metadata.ExecutionType.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExecutionType::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ExecutionType.name)
}

// optional string version = 6;
inline bool ExecutionType::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExecutionType::has_version() const {
  return _internal_has_version();
}
inline void ExecutionType::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExecutionType::version() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ExecutionType.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionType::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ExecutionType.version)
}
inline std::string* ExecutionType::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ExecutionType.version)
  return _s;
}
inline const std::string& ExecutionType::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ExecutionType::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecutionType::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecutionType::release_version() {
  // @@protoc_insertion_point(field_release:ml_metadata.ExecutionType.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExecutionType::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ExecutionType.version)
}

// optional string description = 7;
inline bool ExecutionType::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExecutionType::has_description() const {
  return _internal_has_description();
}
inline void ExecutionType::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ExecutionType::description() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ExecutionType.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionType::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ExecutionType.description)
}
inline std::string* ExecutionType::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ExecutionType.description)
  return _s;
}
inline const std::string& ExecutionType::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ExecutionType::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecutionType::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecutionType::release_description() {
  // @@protoc_insertion_point(field_release:ml_metadata.ExecutionType.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExecutionType::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ExecutionType.description)
}

// optional string external_id = 9;
inline bool ExecutionType::_internal_has_external_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExecutionType::has_external_id() const {
  return _internal_has_external_id();
}
inline void ExecutionType::clear_external_id() {
  _impl_.external_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ExecutionType::external_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ExecutionType.external_id)
  return _internal_external_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionType::set_external_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.external_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ExecutionType.external_id)
}
inline std::string* ExecutionType::mutable_external_id() {
  std::string* _s = _internal_mutable_external_id();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ExecutionType.external_id)
  return _s;
}
inline const std::string& ExecutionType::_internal_external_id() const {
  return _impl_.external_id_.Get();
}
inline void ExecutionType::_internal_set_external_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.external_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecutionType::_internal_mutable_external_id() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.external_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecutionType::release_external_id() {
  // @@protoc_insertion_point(field_release:ml_metadata.ExecutionType.external_id)
  if (!_internal_has_external_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.external_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExecutionType::set_allocated_external_id(std::string* external_id) {
  if (external_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.external_id_.SetAllocated(external_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ExecutionType.external_id)
}

// map<string, .ml_metadata.PropertyType> properties = 3;
inline int ExecutionType::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int ExecutionType::properties_size() const {
  return _internal_properties_size();
}
inline void ExecutionType::clear_properties() {
  _impl_.properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >&
ExecutionType::_internal_properties() const {
  return _impl_.properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >&
ExecutionType::properties() const {
  // @@protoc_insertion_point(field_map:ml_metadata.ExecutionType.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >*
ExecutionType::_internal_mutable_properties() {
  return _impl_.properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >*
ExecutionType::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:ml_metadata.ExecutionType.properties)
  return _internal_mutable_properties();
}

// optional .ml_metadata.ArtifactStructType input_type = 4;
inline bool ExecutionType::_internal_has_input_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_type_ != nullptr);
  return value;
}
inline bool ExecutionType::has_input_type() const {
  return _internal_has_input_type();
}
inline void ExecutionType::clear_input_type() {
  if (_impl_.input_type_ != nullptr) _impl_.input_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::ml_metadata::ArtifactStructType& ExecutionType::_internal_input_type() const {
  const ::ml_metadata::ArtifactStructType* p = _impl_.input_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::ArtifactStructType&>(
      ::ml_metadata::_ArtifactStructType_default_instance_);
}
inline const ::ml_metadata::ArtifactStructType& ExecutionType::input_type() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ExecutionType.input_type)
  return _internal_input_type();
}
inline void ExecutionType::unsafe_arena_set_allocated_input_type(
    ::ml_metadata::ArtifactStructType* input_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_type_);
  }
  _impl_.input_type_ = input_type;
  if (input_type) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ExecutionType.input_type)
}
inline ::ml_metadata::ArtifactStructType* ExecutionType::release_input_type() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::ml_metadata::ArtifactStructType* temp = _impl_.input_type_;
  _impl_.input_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::ArtifactStructType* ExecutionType::unsafe_arena_release_input_type() {
  // @@protoc_insertion_point(field_release:ml_metadata.ExecutionType.input_type)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::ml_metadata::ArtifactStructType* temp = _impl_.input_type_;
  _impl_.input_type_ = nullptr;
  return temp;
}
inline ::ml_metadata::ArtifactStructType* ExecutionType::_internal_mutable_input_type() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.input_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::ArtifactStructType>(GetArenaForAllocation());
    _impl_.input_type_ = p;
  }
  return _impl_.input_type_;
}
inline ::ml_metadata::ArtifactStructType* ExecutionType::mutable_input_type() {
  ::ml_metadata::ArtifactStructType* _msg = _internal_mutable_input_type();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ExecutionType.input_type)
  return _msg;
}
inline void ExecutionType::set_allocated_input_type(::ml_metadata::ArtifactStructType* input_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_type_;
  }
  if (input_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input_type);
    if (message_arena != submessage_arena) {
      input_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.input_type_ = input_type;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ExecutionType.input_type)
}

// optional .ml_metadata.ArtifactStructType output_type = 5;
inline bool ExecutionType::_internal_has_output_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_type_ != nullptr);
  return value;
}
inline bool ExecutionType::has_output_type() const {
  return _internal_has_output_type();
}
inline void ExecutionType::clear_output_type() {
  if (_impl_.output_type_ != nullptr) _impl_.output_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::ml_metadata::ArtifactStructType& ExecutionType::_internal_output_type() const {
  const ::ml_metadata::ArtifactStructType* p = _impl_.output_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::ArtifactStructType&>(
      ::ml_metadata::_ArtifactStructType_default_instance_);
}
inline const ::ml_metadata::ArtifactStructType& ExecutionType::output_type() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ExecutionType.output_type)
  return _internal_output_type();
}
inline void ExecutionType::unsafe_arena_set_allocated_output_type(
    ::ml_metadata::ArtifactStructType* output_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_type_);
  }
  _impl_.output_type_ = output_type;
  if (output_type) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ExecutionType.output_type)
}
inline ::ml_metadata::ArtifactStructType* ExecutionType::release_output_type() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::ml_metadata::ArtifactStructType* temp = _impl_.output_type_;
  _impl_.output_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::ArtifactStructType* ExecutionType::unsafe_arena_release_output_type() {
  // @@protoc_insertion_point(field_release:ml_metadata.ExecutionType.output_type)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::ml_metadata::ArtifactStructType* temp = _impl_.output_type_;
  _impl_.output_type_ = nullptr;
  return temp;
}
inline ::ml_metadata::ArtifactStructType* ExecutionType::_internal_mutable_output_type() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.output_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::ArtifactStructType>(GetArenaForAllocation());
    _impl_.output_type_ = p;
  }
  return _impl_.output_type_;
}
inline ::ml_metadata::ArtifactStructType* ExecutionType::mutable_output_type() {
  ::ml_metadata::ArtifactStructType* _msg = _internal_mutable_output_type();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ExecutionType.output_type)
  return _msg;
}
inline void ExecutionType::set_allocated_output_type(::ml_metadata::ArtifactStructType* output_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.output_type_;
  }
  if (output_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(output_type);
    if (message_arena != submessage_arena) {
      output_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.output_type_ = output_type;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ExecutionType.output_type)
}

// optional .ml_metadata.ExecutionType.SystemDefinedBaseType base_type = 8;
inline bool ExecutionType::_internal_has_base_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ExecutionType::has_base_type() const {
  return _internal_has_base_type();
}
inline void ExecutionType::clear_base_type() {
  _impl_.base_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::ml_metadata::ExecutionType_SystemDefinedBaseType ExecutionType::_internal_base_type() const {
  return static_cast< ::ml_metadata::ExecutionType_SystemDefinedBaseType >(_impl_.base_type_);
}
inline ::ml_metadata::ExecutionType_SystemDefinedBaseType ExecutionType::base_type() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ExecutionType.base_type)
  return _internal_base_type();
}
inline void ExecutionType::_internal_set_base_type(::ml_metadata::ExecutionType_SystemDefinedBaseType value) {
  assert(::ml_metadata::ExecutionType_SystemDefinedBaseType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.base_type_ = value;
}
inline void ExecutionType::set_base_type(::ml_metadata::ExecutionType_SystemDefinedBaseType value) {
  _internal_set_base_type(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ExecutionType.base_type)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContextType

// optional int64 id = 1;
inline bool ContextType::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ContextType::has_id() const {
  return _internal_has_id();
}
inline void ContextType::clear_id() {
  _impl_.id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t ContextType::_internal_id() const {
  return _impl_.id_;
}
inline int64_t ContextType::id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ContextType.id)
  return _internal_id();
}
inline void ContextType::_internal_set_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.id_ = value;
}
inline void ContextType::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ContextType.id)
}

// optional string name = 2;
inline bool ContextType::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContextType::has_name() const {
  return _internal_has_name();
}
inline void ContextType::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContextType::name() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ContextType.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextType::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ContextType.name)
}
inline std::string* ContextType::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ContextType.name)
  return _s;
}
inline const std::string& ContextType::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ContextType::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextType::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextType::release_name() {
  // @@protoc_insertion_point(field_release:ml_metadata.ContextType.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContextType::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ContextType.name)
}

// optional string version = 4;
inline bool ContextType::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContextType::has_version() const {
  return _internal_has_version();
}
inline void ContextType::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContextType::version() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ContextType.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextType::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ContextType.version)
}
inline std::string* ContextType::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ContextType.version)
  return _s;
}
inline const std::string& ContextType::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ContextType::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextType::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextType::release_version() {
  // @@protoc_insertion_point(field_release:ml_metadata.ContextType.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContextType::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ContextType.version)
}

// optional string description = 5;
inline bool ContextType::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContextType::has_description() const {
  return _internal_has_description();
}
inline void ContextType::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ContextType::description() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ContextType.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextType::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ContextType.description)
}
inline std::string* ContextType::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ContextType.description)
  return _s;
}
inline const std::string& ContextType::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ContextType::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextType::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextType::release_description() {
  // @@protoc_insertion_point(field_release:ml_metadata.ContextType.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContextType::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ContextType.description)
}

// optional string external_id = 7;
inline bool ContextType::_internal_has_external_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContextType::has_external_id() const {
  return _internal_has_external_id();
}
inline void ContextType::clear_external_id() {
  _impl_.external_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ContextType::external_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ContextType.external_id)
  return _internal_external_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextType::set_external_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.external_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ContextType.external_id)
}
inline std::string* ContextType::mutable_external_id() {
  std::string* _s = _internal_mutable_external_id();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ContextType.external_id)
  return _s;
}
inline const std::string& ContextType::_internal_external_id() const {
  return _impl_.external_id_.Get();
}
inline void ContextType::_internal_set_external_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.external_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextType::_internal_mutable_external_id() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.external_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextType::release_external_id() {
  // @@protoc_insertion_point(field_release:ml_metadata.ContextType.external_id)
  if (!_internal_has_external_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.external_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContextType::set_allocated_external_id(std::string* external_id) {
  if (external_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.external_id_.SetAllocated(external_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ContextType.external_id)
}

// map<string, .ml_metadata.PropertyType> properties = 3;
inline int ContextType::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int ContextType::properties_size() const {
  return _internal_properties_size();
}
inline void ContextType::clear_properties() {
  _impl_.properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >&
ContextType::_internal_properties() const {
  return _impl_.properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >&
ContextType::properties() const {
  // @@protoc_insertion_point(field_map:ml_metadata.ContextType.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >*
ContextType::_internal_mutable_properties() {
  return _impl_.properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::PropertyType >*
ContextType::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:ml_metadata.ContextType.properties)
  return _internal_mutable_properties();
}

// optional .ml_metadata.ContextType.SystemDefinedBaseType base_type = 6;
inline bool ContextType::_internal_has_base_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ContextType::has_base_type() const {
  return _internal_has_base_type();
}
inline void ContextType::clear_base_type() {
  _impl_.base_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::ml_metadata::ContextType_SystemDefinedBaseType ContextType::_internal_base_type() const {
  return static_cast< ::ml_metadata::ContextType_SystemDefinedBaseType >(_impl_.base_type_);
}
inline ::ml_metadata::ContextType_SystemDefinedBaseType ContextType::base_type() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ContextType.base_type)
  return _internal_base_type();
}
inline void ContextType::_internal_set_base_type(::ml_metadata::ContextType_SystemDefinedBaseType value) {
  assert(::ml_metadata::ContextType_SystemDefinedBaseType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.base_type_ = value;
}
inline void ContextType::set_base_type(::ml_metadata::ContextType_SystemDefinedBaseType value) {
  _internal_set_base_type(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ContextType.base_type)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Context

// optional int64 id = 1;
inline bool Context::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Context::has_id() const {
  return _internal_has_id();
}
inline void Context::clear_id() {
  _impl_.id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t Context::_internal_id() const {
  return _impl_.id_;
}
inline int64_t Context::id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Context.id)
  return _internal_id();
}
inline void Context::_internal_set_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.id_ = value;
}
inline void Context::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Context.id)
}

// optional string name = 3;
inline bool Context::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Context::has_name() const {
  return _internal_has_name();
}
inline void Context::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Context::name() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Context.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Context::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.Context.name)
}
inline std::string* Context::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Context.name)
  return _s;
}
inline const std::string& Context::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Context::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Context::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Context::release_name() {
  // @@protoc_insertion_point(field_release:ml_metadata.Context.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Context::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Context.name)
}

// optional int64 type_id = 2;
inline bool Context::_internal_has_type_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Context::has_type_id() const {
  return _internal_has_type_id();
}
inline void Context::clear_type_id() {
  _impl_.type_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t Context::_internal_type_id() const {
  return _impl_.type_id_;
}
inline int64_t Context::type_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Context.type_id)
  return _internal_type_id();
}
inline void Context::_internal_set_type_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.type_id_ = value;
}
inline void Context::set_type_id(int64_t value) {
  _internal_set_type_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Context.type_id)
}

// optional string type = 6;
inline bool Context::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Context::has_type() const {
  return _internal_has_type();
}
inline void Context::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Context::type() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Context.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Context::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.Context.type)
}
inline std::string* Context::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Context.type)
  return _s;
}
inline const std::string& Context::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Context::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Context::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Context::release_type() {
  // @@protoc_insertion_point(field_release:ml_metadata.Context.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Context::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Context.type)
}

// optional string external_id = 9;
inline bool Context::_internal_has_external_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Context::has_external_id() const {
  return _internal_has_external_id();
}
inline void Context::clear_external_id() {
  _impl_.external_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Context::external_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Context.external_id)
  return _internal_external_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Context::set_external_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.external_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.Context.external_id)
}
inline std::string* Context::mutable_external_id() {
  std::string* _s = _internal_mutable_external_id();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Context.external_id)
  return _s;
}
inline const std::string& Context::_internal_external_id() const {
  return _impl_.external_id_.Get();
}
inline void Context::_internal_set_external_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.external_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Context::_internal_mutable_external_id() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.external_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Context::release_external_id() {
  // @@protoc_insertion_point(field_release:ml_metadata.Context.external_id)
  if (!_internal_has_external_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.external_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Context::set_allocated_external_id(std::string* external_id) {
  if (external_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.external_id_.SetAllocated(external_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Context.external_id)
}

// map<string, .ml_metadata.Value> properties = 4;
inline int Context::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int Context::properties_size() const {
  return _internal_properties_size();
}
inline void Context::clear_properties() {
  _impl_.properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
Context::_internal_properties() const {
  return _impl_.properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
Context::properties() const {
  // @@protoc_insertion_point(field_map:ml_metadata.Context.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
Context::_internal_mutable_properties() {
  return _impl_.properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
Context::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:ml_metadata.Context.properties)
  return _internal_mutable_properties();
}

// map<string, .ml_metadata.Value> custom_properties = 5;
inline int Context::_internal_custom_properties_size() const {
  return _impl_.custom_properties_.size();
}
inline int Context::custom_properties_size() const {
  return _internal_custom_properties_size();
}
inline void Context::clear_custom_properties() {
  _impl_.custom_properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
Context::_internal_custom_properties() const {
  return _impl_.custom_properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >&
Context::custom_properties() const {
  // @@protoc_insertion_point(field_map:ml_metadata.Context.custom_properties)
  return _internal_custom_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
Context::_internal_mutable_custom_properties() {
  return _impl_.custom_properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::Value >*
Context::mutable_custom_properties() {
  // @@protoc_insertion_point(field_mutable_map:ml_metadata.Context.custom_properties)
  return _internal_mutable_custom_properties();
}

// optional int64 create_time_since_epoch = 7;
inline bool Context::_internal_has_create_time_since_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Context::has_create_time_since_epoch() const {
  return _internal_has_create_time_since_epoch();
}
inline void Context::clear_create_time_since_epoch() {
  _impl_.create_time_since_epoch_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t Context::_internal_create_time_since_epoch() const {
  return _impl_.create_time_since_epoch_;
}
inline int64_t Context::create_time_since_epoch() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Context.create_time_since_epoch)
  return _internal_create_time_since_epoch();
}
inline void Context::_internal_set_create_time_since_epoch(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.create_time_since_epoch_ = value;
}
inline void Context::set_create_time_since_epoch(int64_t value) {
  _internal_set_create_time_since_epoch(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Context.create_time_since_epoch)
}

// optional int64 last_update_time_since_epoch = 8;
inline bool Context::_internal_has_last_update_time_since_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Context::has_last_update_time_since_epoch() const {
  return _internal_has_last_update_time_since_epoch();
}
inline void Context::clear_last_update_time_since_epoch() {
  _impl_.last_update_time_since_epoch_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t Context::_internal_last_update_time_since_epoch() const {
  return _impl_.last_update_time_since_epoch_;
}
inline int64_t Context::last_update_time_since_epoch() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Context.last_update_time_since_epoch)
  return _internal_last_update_time_since_epoch();
}
inline void Context::_internal_set_last_update_time_since_epoch(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.last_update_time_since_epoch_ = value;
}
inline void Context::set_last_update_time_since_epoch(int64_t value) {
  _internal_set_last_update_time_since_epoch(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Context.last_update_time_since_epoch)
}

// optional .google.protobuf.Any system_metadata = 10;
inline bool Context::_internal_has_system_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_metadata_ != nullptr);
  return value;
}
inline bool Context::has_system_metadata() const {
  return _internal_has_system_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Context::_internal_system_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.system_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Context::system_metadata() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Context.system_metadata)
  return _internal_system_metadata();
}
inline void Context::unsafe_arena_set_allocated_system_metadata(
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  _impl_.system_metadata_ = system_metadata;
  if (system_metadata) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Context.system_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Context::release_system_metadata() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Context::unsafe_arena_release_system_metadata() {
  // @@protoc_insertion_point(field_release:ml_metadata.Context.system_metadata)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Context::_internal_mutable_system_metadata() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.system_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.system_metadata_ = p;
  }
  return _impl_.system_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Context::mutable_system_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_system_metadata();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Context.system_metadata)
  return _msg;
}
inline void Context::set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  if (system_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_metadata));
    if (message_arena != submessage_arena) {
      system_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.system_metadata_ = system_metadata;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Context.system_metadata)
}

// -------------------------------------------------------------------

// Attribution

// optional int64 artifact_id = 1;
inline bool Attribution::_internal_has_artifact_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Attribution::has_artifact_id() const {
  return _internal_has_artifact_id();
}
inline void Attribution::clear_artifact_id() {
  _impl_.artifact_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t Attribution::_internal_artifact_id() const {
  return _impl_.artifact_id_;
}
inline int64_t Attribution::artifact_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Attribution.artifact_id)
  return _internal_artifact_id();
}
inline void Attribution::_internal_set_artifact_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.artifact_id_ = value;
}
inline void Attribution::set_artifact_id(int64_t value) {
  _internal_set_artifact_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Attribution.artifact_id)
}

// optional int64 context_id = 2;
inline bool Attribution::_internal_has_context_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Attribution::has_context_id() const {
  return _internal_has_context_id();
}
inline void Attribution::clear_context_id() {
  _impl_.context_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t Attribution::_internal_context_id() const {
  return _impl_.context_id_;
}
inline int64_t Attribution::context_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Attribution.context_id)
  return _internal_context_id();
}
inline void Attribution::_internal_set_context_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.context_id_ = value;
}
inline void Attribution::set_context_id(int64_t value) {
  _internal_set_context_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Attribution.context_id)
}

// optional .google.protobuf.Any system_metadata = 3;
inline bool Attribution::_internal_has_system_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_metadata_ != nullptr);
  return value;
}
inline bool Attribution::has_system_metadata() const {
  return _internal_has_system_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Attribution::_internal_system_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.system_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Attribution::system_metadata() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Attribution.system_metadata)
  return _internal_system_metadata();
}
inline void Attribution::unsafe_arena_set_allocated_system_metadata(
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  _impl_.system_metadata_ = system_metadata;
  if (system_metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Attribution.system_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Attribution::release_system_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Attribution::unsafe_arena_release_system_metadata() {
  // @@protoc_insertion_point(field_release:ml_metadata.Attribution.system_metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Attribution::_internal_mutable_system_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.system_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.system_metadata_ = p;
  }
  return _impl_.system_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Attribution::mutable_system_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_system_metadata();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Attribution.system_metadata)
  return _msg;
}
inline void Attribution::set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  if (system_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_metadata));
    if (message_arena != submessage_arena) {
      system_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.system_metadata_ = system_metadata;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Attribution.system_metadata)
}

// -------------------------------------------------------------------

// Association

// optional int64 execution_id = 1;
inline bool Association::_internal_has_execution_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Association::has_execution_id() const {
  return _internal_has_execution_id();
}
inline void Association::clear_execution_id() {
  _impl_.execution_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t Association::_internal_execution_id() const {
  return _impl_.execution_id_;
}
inline int64_t Association::execution_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Association.execution_id)
  return _internal_execution_id();
}
inline void Association::_internal_set_execution_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.execution_id_ = value;
}
inline void Association::set_execution_id(int64_t value) {
  _internal_set_execution_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Association.execution_id)
}

// optional int64 context_id = 2;
inline bool Association::_internal_has_context_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Association::has_context_id() const {
  return _internal_has_context_id();
}
inline void Association::clear_context_id() {
  _impl_.context_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t Association::_internal_context_id() const {
  return _impl_.context_id_;
}
inline int64_t Association::context_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Association.context_id)
  return _internal_context_id();
}
inline void Association::_internal_set_context_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.context_id_ = value;
}
inline void Association::set_context_id(int64_t value) {
  _internal_set_context_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.Association.context_id)
}

// optional .google.protobuf.Any system_metadata = 3;
inline bool Association::_internal_has_system_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_metadata_ != nullptr);
  return value;
}
inline bool Association::has_system_metadata() const {
  return _internal_has_system_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Association::_internal_system_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.system_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Association::system_metadata() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Association.system_metadata)
  return _internal_system_metadata();
}
inline void Association::unsafe_arena_set_allocated_system_metadata(
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  _impl_.system_metadata_ = system_metadata;
  if (system_metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Association.system_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Association::release_system_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Association::unsafe_arena_release_system_metadata() {
  // @@protoc_insertion_point(field_release:ml_metadata.Association.system_metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Association::_internal_mutable_system_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.system_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.system_metadata_ = p;
  }
  return _impl_.system_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Association::mutable_system_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_system_metadata();
  // @@protoc_insertion_point(field_mutable:ml_metadata.Association.system_metadata)
  return _msg;
}
inline void Association::set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  if (system_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_metadata));
    if (message_arena != submessage_arena) {
      system_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.system_metadata_ = system_metadata;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.Association.system_metadata)
}

// -------------------------------------------------------------------

// ParentContext

// optional int64 child_id = 1;
inline bool ParentContext::_internal_has_child_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ParentContext::has_child_id() const {
  return _internal_has_child_id();
}
inline void ParentContext::clear_child_id() {
  _impl_.child_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t ParentContext::_internal_child_id() const {
  return _impl_.child_id_;
}
inline int64_t ParentContext::child_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ParentContext.child_id)
  return _internal_child_id();
}
inline void ParentContext::_internal_set_child_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.child_id_ = value;
}
inline void ParentContext::set_child_id(int64_t value) {
  _internal_set_child_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ParentContext.child_id)
}

// optional int64 parent_id = 2;
inline bool ParentContext::_internal_has_parent_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ParentContext::has_parent_id() const {
  return _internal_has_parent_id();
}
inline void ParentContext::clear_parent_id() {
  _impl_.parent_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t ParentContext::_internal_parent_id() const {
  return _impl_.parent_id_;
}
inline int64_t ParentContext::parent_id() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ParentContext.parent_id)
  return _internal_parent_id();
}
inline void ParentContext::_internal_set_parent_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.parent_id_ = value;
}
inline void ParentContext::set_parent_id(int64_t value) {
  _internal_set_parent_id(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ParentContext.parent_id)
}

// optional .google.protobuf.Any system_metadata = 3;
inline bool ParentContext::_internal_has_system_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_metadata_ != nullptr);
  return value;
}
inline bool ParentContext::has_system_metadata() const {
  return _internal_has_system_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ParentContext::_internal_system_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.system_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ParentContext::system_metadata() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ParentContext.system_metadata)
  return _internal_system_metadata();
}
inline void ParentContext::unsafe_arena_set_allocated_system_metadata(
    ::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  _impl_.system_metadata_ = system_metadata;
  if (system_metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ParentContext.system_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ParentContext::release_system_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ParentContext::unsafe_arena_release_system_metadata() {
  // @@protoc_insertion_point(field_release:ml_metadata.ParentContext.system_metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.system_metadata_;
  _impl_.system_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ParentContext::_internal_mutable_system_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.system_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.system_metadata_ = p;
  }
  return _impl_.system_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ParentContext::mutable_system_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_system_metadata();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ParentContext.system_metadata)
  return _msg;
}
inline void ParentContext::set_allocated_system_metadata(::PROTOBUF_NAMESPACE_ID::Any* system_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metadata_);
  }
  if (system_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_metadata));
    if (message_arena != submessage_arena) {
      system_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.system_metadata_ = system_metadata;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ParentContext.system_metadata)
}

// -------------------------------------------------------------------

// LineageGraph

// repeated .ml_metadata.ArtifactType artifact_types = 1;
inline int LineageGraph::_internal_artifact_types_size() const {
  return _impl_.artifact_types_.size();
}
inline int LineageGraph::artifact_types_size() const {
  return _internal_artifact_types_size();
}
inline void LineageGraph::clear_artifact_types() {
  _impl_.artifact_types_.Clear();
}
inline ::ml_metadata::ArtifactType* LineageGraph::mutable_artifact_types(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraph.artifact_types)
  return _impl_.artifact_types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactType >*
LineageGraph::mutable_artifact_types() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.LineageGraph.artifact_types)
  return &_impl_.artifact_types_;
}
inline const ::ml_metadata::ArtifactType& LineageGraph::_internal_artifact_types(int index) const {
  return _impl_.artifact_types_.Get(index);
}
inline const ::ml_metadata::ArtifactType& LineageGraph::artifact_types(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraph.artifact_types)
  return _internal_artifact_types(index);
}
inline ::ml_metadata::ArtifactType* LineageGraph::_internal_add_artifact_types() {
  return _impl_.artifact_types_.Add();
}
inline ::ml_metadata::ArtifactType* LineageGraph::add_artifact_types() {
  ::ml_metadata::ArtifactType* _add = _internal_add_artifact_types();
  // @@protoc_insertion_point(field_add:ml_metadata.LineageGraph.artifact_types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactType >&
LineageGraph::artifact_types() const {
  // @@protoc_insertion_point(field_list:ml_metadata.LineageGraph.artifact_types)
  return _impl_.artifact_types_;
}

// repeated .ml_metadata.ExecutionType execution_types = 2;
inline int LineageGraph::_internal_execution_types_size() const {
  return _impl_.execution_types_.size();
}
inline int LineageGraph::execution_types_size() const {
  return _internal_execution_types_size();
}
inline void LineageGraph::clear_execution_types() {
  _impl_.execution_types_.Clear();
}
inline ::ml_metadata::ExecutionType* LineageGraph::mutable_execution_types(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraph.execution_types)
  return _impl_.execution_types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ExecutionType >*
LineageGraph::mutable_execution_types() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.LineageGraph.execution_types)
  return &_impl_.execution_types_;
}
inline const ::ml_metadata::ExecutionType& LineageGraph::_internal_execution_types(int index) const {
  return _impl_.execution_types_.Get(index);
}
inline const ::ml_metadata::ExecutionType& LineageGraph::execution_types(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraph.execution_types)
  return _internal_execution_types(index);
}
inline ::ml_metadata::ExecutionType* LineageGraph::_internal_add_execution_types() {
  return _impl_.execution_types_.Add();
}
inline ::ml_metadata::ExecutionType* LineageGraph::add_execution_types() {
  ::ml_metadata::ExecutionType* _add = _internal_add_execution_types();
  // @@protoc_insertion_point(field_add:ml_metadata.LineageGraph.execution_types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ExecutionType >&
LineageGraph::execution_types() const {
  // @@protoc_insertion_point(field_list:ml_metadata.LineageGraph.execution_types)
  return _impl_.execution_types_;
}

// repeated .ml_metadata.ContextType context_types = 3;
inline int LineageGraph::_internal_context_types_size() const {
  return _impl_.context_types_.size();
}
inline int LineageGraph::context_types_size() const {
  return _internal_context_types_size();
}
inline void LineageGraph::clear_context_types() {
  _impl_.context_types_.Clear();
}
inline ::ml_metadata::ContextType* LineageGraph::mutable_context_types(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraph.context_types)
  return _impl_.context_types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ContextType >*
LineageGraph::mutable_context_types() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.LineageGraph.context_types)
  return &_impl_.context_types_;
}
inline const ::ml_metadata::ContextType& LineageGraph::_internal_context_types(int index) const {
  return _impl_.context_types_.Get(index);
}
inline const ::ml_metadata::ContextType& LineageGraph::context_types(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraph.context_types)
  return _internal_context_types(index);
}
inline ::ml_metadata::ContextType* LineageGraph::_internal_add_context_types() {
  return _impl_.context_types_.Add();
}
inline ::ml_metadata::ContextType* LineageGraph::add_context_types() {
  ::ml_metadata::ContextType* _add = _internal_add_context_types();
  // @@protoc_insertion_point(field_add:ml_metadata.LineageGraph.context_types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ContextType >&
LineageGraph::context_types() const {
  // @@protoc_insertion_point(field_list:ml_metadata.LineageGraph.context_types)
  return _impl_.context_types_;
}

// repeated .ml_metadata.Artifact artifacts = 4;
inline int LineageGraph::_internal_artifacts_size() const {
  return _impl_.artifacts_.size();
}
inline int LineageGraph::artifacts_size() const {
  return _internal_artifacts_size();
}
inline void LineageGraph::clear_artifacts() {
  _impl_.artifacts_.Clear();
}
inline ::ml_metadata::Artifact* LineageGraph::mutable_artifacts(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraph.artifacts)
  return _impl_.artifacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Artifact >*
LineageGraph::mutable_artifacts() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.LineageGraph.artifacts)
  return &_impl_.artifacts_;
}
inline const ::ml_metadata::Artifact& LineageGraph::_internal_artifacts(int index) const {
  return _impl_.artifacts_.Get(index);
}
inline const ::ml_metadata::Artifact& LineageGraph::artifacts(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraph.artifacts)
  return _internal_artifacts(index);
}
inline ::ml_metadata::Artifact* LineageGraph::_internal_add_artifacts() {
  return _impl_.artifacts_.Add();
}
inline ::ml_metadata::Artifact* LineageGraph::add_artifacts() {
  ::ml_metadata::Artifact* _add = _internal_add_artifacts();
  // @@protoc_insertion_point(field_add:ml_metadata.LineageGraph.artifacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Artifact >&
LineageGraph::artifacts() const {
  // @@protoc_insertion_point(field_list:ml_metadata.LineageGraph.artifacts)
  return _impl_.artifacts_;
}

// repeated .ml_metadata.Execution executions = 5;
inline int LineageGraph::_internal_executions_size() const {
  return _impl_.executions_.size();
}
inline int LineageGraph::executions_size() const {
  return _internal_executions_size();
}
inline void LineageGraph::clear_executions() {
  _impl_.executions_.Clear();
}
inline ::ml_metadata::Execution* LineageGraph::mutable_executions(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraph.executions)
  return _impl_.executions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Execution >*
LineageGraph::mutable_executions() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.LineageGraph.executions)
  return &_impl_.executions_;
}
inline const ::ml_metadata::Execution& LineageGraph::_internal_executions(int index) const {
  return _impl_.executions_.Get(index);
}
inline const ::ml_metadata::Execution& LineageGraph::executions(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraph.executions)
  return _internal_executions(index);
}
inline ::ml_metadata::Execution* LineageGraph::_internal_add_executions() {
  return _impl_.executions_.Add();
}
inline ::ml_metadata::Execution* LineageGraph::add_executions() {
  ::ml_metadata::Execution* _add = _internal_add_executions();
  // @@protoc_insertion_point(field_add:ml_metadata.LineageGraph.executions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Execution >&
LineageGraph::executions() const {
  // @@protoc_insertion_point(field_list:ml_metadata.LineageGraph.executions)
  return _impl_.executions_;
}

// repeated .ml_metadata.Context contexts = 6;
inline int LineageGraph::_internal_contexts_size() const {
  return _impl_.contexts_.size();
}
inline int LineageGraph::contexts_size() const {
  return _internal_contexts_size();
}
inline void LineageGraph::clear_contexts() {
  _impl_.contexts_.Clear();
}
inline ::ml_metadata::Context* LineageGraph::mutable_contexts(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraph.contexts)
  return _impl_.contexts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Context >*
LineageGraph::mutable_contexts() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.LineageGraph.contexts)
  return &_impl_.contexts_;
}
inline const ::ml_metadata::Context& LineageGraph::_internal_contexts(int index) const {
  return _impl_.contexts_.Get(index);
}
inline const ::ml_metadata::Context& LineageGraph::contexts(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraph.contexts)
  return _internal_contexts(index);
}
inline ::ml_metadata::Context* LineageGraph::_internal_add_contexts() {
  return _impl_.contexts_.Add();
}
inline ::ml_metadata::Context* LineageGraph::add_contexts() {
  ::ml_metadata::Context* _add = _internal_add_contexts();
  // @@protoc_insertion_point(field_add:ml_metadata.LineageGraph.contexts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Context >&
LineageGraph::contexts() const {
  // @@protoc_insertion_point(field_list:ml_metadata.LineageGraph.contexts)
  return _impl_.contexts_;
}

// repeated .ml_metadata.Event events = 7;
inline int LineageGraph::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int LineageGraph::events_size() const {
  return _internal_events_size();
}
inline void LineageGraph::clear_events() {
  _impl_.events_.Clear();
}
inline ::ml_metadata::Event* LineageGraph::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraph.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Event >*
LineageGraph::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.LineageGraph.events)
  return &_impl_.events_;
}
inline const ::ml_metadata::Event& LineageGraph::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::ml_metadata::Event& LineageGraph::events(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraph.events)
  return _internal_events(index);
}
inline ::ml_metadata::Event* LineageGraph::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::ml_metadata::Event* LineageGraph::add_events() {
  ::ml_metadata::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:ml_metadata.LineageGraph.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Event >&
LineageGraph::events() const {
  // @@protoc_insertion_point(field_list:ml_metadata.LineageGraph.events)
  return _impl_.events_;
}

// repeated .ml_metadata.Attribution attributions = 8;
inline int LineageGraph::_internal_attributions_size() const {
  return _impl_.attributions_.size();
}
inline int LineageGraph::attributions_size() const {
  return _internal_attributions_size();
}
inline void LineageGraph::clear_attributions() {
  _impl_.attributions_.Clear();
}
inline ::ml_metadata::Attribution* LineageGraph::mutable_attributions(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraph.attributions)
  return _impl_.attributions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Attribution >*
LineageGraph::mutable_attributions() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.LineageGraph.attributions)
  return &_impl_.attributions_;
}
inline const ::ml_metadata::Attribution& LineageGraph::_internal_attributions(int index) const {
  return _impl_.attributions_.Get(index);
}
inline const ::ml_metadata::Attribution& LineageGraph::attributions(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraph.attributions)
  return _internal_attributions(index);
}
inline ::ml_metadata::Attribution* LineageGraph::_internal_add_attributions() {
  return _impl_.attributions_.Add();
}
inline ::ml_metadata::Attribution* LineageGraph::add_attributions() {
  ::ml_metadata::Attribution* _add = _internal_add_attributions();
  // @@protoc_insertion_point(field_add:ml_metadata.LineageGraph.attributions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Attribution >&
LineageGraph::attributions() const {
  // @@protoc_insertion_point(field_list:ml_metadata.LineageGraph.attributions)
  return _impl_.attributions_;
}

// repeated .ml_metadata.Association associations = 9;
inline int LineageGraph::_internal_associations_size() const {
  return _impl_.associations_.size();
}
inline int LineageGraph::associations_size() const {
  return _internal_associations_size();
}
inline void LineageGraph::clear_associations() {
  _impl_.associations_.Clear();
}
inline ::ml_metadata::Association* LineageGraph::mutable_associations(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraph.associations)
  return _impl_.associations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Association >*
LineageGraph::mutable_associations() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.LineageGraph.associations)
  return &_impl_.associations_;
}
inline const ::ml_metadata::Association& LineageGraph::_internal_associations(int index) const {
  return _impl_.associations_.Get(index);
}
inline const ::ml_metadata::Association& LineageGraph::associations(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraph.associations)
  return _internal_associations(index);
}
inline ::ml_metadata::Association* LineageGraph::_internal_add_associations() {
  return _impl_.associations_.Add();
}
inline ::ml_metadata::Association* LineageGraph::add_associations() {
  ::ml_metadata::Association* _add = _internal_add_associations();
  // @@protoc_insertion_point(field_add:ml_metadata.LineageGraph.associations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Association >&
LineageGraph::associations() const {
  // @@protoc_insertion_point(field_list:ml_metadata.LineageGraph.associations)
  return _impl_.associations_;
}

// repeated .ml_metadata.ParentContext parent_contexts = 10;
inline int LineageGraph::_internal_parent_contexts_size() const {
  return _impl_.parent_contexts_.size();
}
inline int LineageGraph::parent_contexts_size() const {
  return _internal_parent_contexts_size();
}
inline void LineageGraph::clear_parent_contexts() {
  _impl_.parent_contexts_.Clear();
}
inline ::ml_metadata::ParentContext* LineageGraph::mutable_parent_contexts(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraph.parent_contexts)
  return _impl_.parent_contexts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ParentContext >*
LineageGraph::mutable_parent_contexts() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.LineageGraph.parent_contexts)
  return &_impl_.parent_contexts_;
}
inline const ::ml_metadata::ParentContext& LineageGraph::_internal_parent_contexts(int index) const {
  return _impl_.parent_contexts_.Get(index);
}
inline const ::ml_metadata::ParentContext& LineageGraph::parent_contexts(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraph.parent_contexts)
  return _internal_parent_contexts(index);
}
inline ::ml_metadata::ParentContext* LineageGraph::_internal_add_parent_contexts() {
  return _impl_.parent_contexts_.Add();
}
inline ::ml_metadata::ParentContext* LineageGraph::add_parent_contexts() {
  ::ml_metadata::ParentContext* _add = _internal_add_parent_contexts();
  // @@protoc_insertion_point(field_add:ml_metadata.LineageGraph.parent_contexts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ParentContext >&
LineageGraph::parent_contexts() const {
  // @@protoc_insertion_point(field_list:ml_metadata.LineageGraph.parent_contexts)
  return _impl_.parent_contexts_;
}

// -------------------------------------------------------------------

// ArtifactStructType

// .ml_metadata.ArtifactType simple = 1;
inline bool ArtifactStructType::_internal_has_simple() const {
  return kind_case() == kSimple;
}
inline bool ArtifactStructType::has_simple() const {
  return _internal_has_simple();
}
inline void ArtifactStructType::set_has_simple() {
  _impl_._oneof_case_[0] = kSimple;
}
inline void ArtifactStructType::clear_simple() {
  if (_internal_has_simple()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.simple_;
    }
    clear_has_kind();
  }
}
inline ::ml_metadata::ArtifactType* ArtifactStructType::release_simple() {
  // @@protoc_insertion_point(field_release:ml_metadata.ArtifactStructType.simple)
  if (_internal_has_simple()) {
    clear_has_kind();
    ::ml_metadata::ArtifactType* temp = _impl_.kind_.simple_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.simple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::ArtifactType& ArtifactStructType::_internal_simple() const {
  return _internal_has_simple()
      ? *_impl_.kind_.simple_
      : reinterpret_cast< ::ml_metadata::ArtifactType&>(::ml_metadata::_ArtifactType_default_instance_);
}
inline const ::ml_metadata::ArtifactType& ArtifactStructType::simple() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactStructType.simple)
  return _internal_simple();
}
inline ::ml_metadata::ArtifactType* ArtifactStructType::unsafe_arena_release_simple() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.ArtifactStructType.simple)
  if (_internal_has_simple()) {
    clear_has_kind();
    ::ml_metadata::ArtifactType* temp = _impl_.kind_.simple_;
    _impl_.kind_.simple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArtifactStructType::unsafe_arena_set_allocated_simple(::ml_metadata::ArtifactType* simple) {
  clear_kind();
  if (simple) {
    set_has_simple();
    _impl_.kind_.simple_ = simple;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ArtifactStructType.simple)
}
inline ::ml_metadata::ArtifactType* ArtifactStructType::_internal_mutable_simple() {
  if (!_internal_has_simple()) {
    clear_kind();
    set_has_simple();
    _impl_.kind_.simple_ = CreateMaybeMessage< ::ml_metadata::ArtifactType >(GetArenaForAllocation());
  }
  return _impl_.kind_.simple_;
}
inline ::ml_metadata::ArtifactType* ArtifactStructType::mutable_simple() {
  ::ml_metadata::ArtifactType* _msg = _internal_mutable_simple();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ArtifactStructType.simple)
  return _msg;
}

// .ml_metadata.UnionArtifactStructType union_type = 2;
inline bool ArtifactStructType::_internal_has_union_type() const {
  return kind_case() == kUnionType;
}
inline bool ArtifactStructType::has_union_type() const {
  return _internal_has_union_type();
}
inline void ArtifactStructType::set_has_union_type() {
  _impl_._oneof_case_[0] = kUnionType;
}
inline void ArtifactStructType::clear_union_type() {
  if (_internal_has_union_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.union_type_;
    }
    clear_has_kind();
  }
}
inline ::ml_metadata::UnionArtifactStructType* ArtifactStructType::release_union_type() {
  // @@protoc_insertion_point(field_release:ml_metadata.ArtifactStructType.union_type)
  if (_internal_has_union_type()) {
    clear_has_kind();
    ::ml_metadata::UnionArtifactStructType* temp = _impl_.kind_.union_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.union_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::UnionArtifactStructType& ArtifactStructType::_internal_union_type() const {
  return _internal_has_union_type()
      ? *_impl_.kind_.union_type_
      : reinterpret_cast< ::ml_metadata::UnionArtifactStructType&>(::ml_metadata::_UnionArtifactStructType_default_instance_);
}
inline const ::ml_metadata::UnionArtifactStructType& ArtifactStructType::union_type() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactStructType.union_type)
  return _internal_union_type();
}
inline ::ml_metadata::UnionArtifactStructType* ArtifactStructType::unsafe_arena_release_union_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.ArtifactStructType.union_type)
  if (_internal_has_union_type()) {
    clear_has_kind();
    ::ml_metadata::UnionArtifactStructType* temp = _impl_.kind_.union_type_;
    _impl_.kind_.union_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArtifactStructType::unsafe_arena_set_allocated_union_type(::ml_metadata::UnionArtifactStructType* union_type) {
  clear_kind();
  if (union_type) {
    set_has_union_type();
    _impl_.kind_.union_type_ = union_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ArtifactStructType.union_type)
}
inline ::ml_metadata::UnionArtifactStructType* ArtifactStructType::_internal_mutable_union_type() {
  if (!_internal_has_union_type()) {
    clear_kind();
    set_has_union_type();
    _impl_.kind_.union_type_ = CreateMaybeMessage< ::ml_metadata::UnionArtifactStructType >(GetArenaForAllocation());
  }
  return _impl_.kind_.union_type_;
}
inline ::ml_metadata::UnionArtifactStructType* ArtifactStructType::mutable_union_type() {
  ::ml_metadata::UnionArtifactStructType* _msg = _internal_mutable_union_type();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ArtifactStructType.union_type)
  return _msg;
}

// .ml_metadata.IntersectionArtifactStructType intersection = 3;
inline bool ArtifactStructType::_internal_has_intersection() const {
  return kind_case() == kIntersection;
}
inline bool ArtifactStructType::has_intersection() const {
  return _internal_has_intersection();
}
inline void ArtifactStructType::set_has_intersection() {
  _impl_._oneof_case_[0] = kIntersection;
}
inline void ArtifactStructType::clear_intersection() {
  if (_internal_has_intersection()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.intersection_;
    }
    clear_has_kind();
  }
}
inline ::ml_metadata::IntersectionArtifactStructType* ArtifactStructType::release_intersection() {
  // @@protoc_insertion_point(field_release:ml_metadata.ArtifactStructType.intersection)
  if (_internal_has_intersection()) {
    clear_has_kind();
    ::ml_metadata::IntersectionArtifactStructType* temp = _impl_.kind_.intersection_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.intersection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::IntersectionArtifactStructType& ArtifactStructType::_internal_intersection() const {
  return _internal_has_intersection()
      ? *_impl_.kind_.intersection_
      : reinterpret_cast< ::ml_metadata::IntersectionArtifactStructType&>(::ml_metadata::_IntersectionArtifactStructType_default_instance_);
}
inline const ::ml_metadata::IntersectionArtifactStructType& ArtifactStructType::intersection() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactStructType.intersection)
  return _internal_intersection();
}
inline ::ml_metadata::IntersectionArtifactStructType* ArtifactStructType::unsafe_arena_release_intersection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.ArtifactStructType.intersection)
  if (_internal_has_intersection()) {
    clear_has_kind();
    ::ml_metadata::IntersectionArtifactStructType* temp = _impl_.kind_.intersection_;
    _impl_.kind_.intersection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArtifactStructType::unsafe_arena_set_allocated_intersection(::ml_metadata::IntersectionArtifactStructType* intersection) {
  clear_kind();
  if (intersection) {
    set_has_intersection();
    _impl_.kind_.intersection_ = intersection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ArtifactStructType.intersection)
}
inline ::ml_metadata::IntersectionArtifactStructType* ArtifactStructType::_internal_mutable_intersection() {
  if (!_internal_has_intersection()) {
    clear_kind();
    set_has_intersection();
    _impl_.kind_.intersection_ = CreateMaybeMessage< ::ml_metadata::IntersectionArtifactStructType >(GetArenaForAllocation());
  }
  return _impl_.kind_.intersection_;
}
inline ::ml_metadata::IntersectionArtifactStructType* ArtifactStructType::mutable_intersection() {
  ::ml_metadata::IntersectionArtifactStructType* _msg = _internal_mutable_intersection();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ArtifactStructType.intersection)
  return _msg;
}

// .ml_metadata.ListArtifactStructType list = 4;
inline bool ArtifactStructType::_internal_has_list() const {
  return kind_case() == kList;
}
inline bool ArtifactStructType::has_list() const {
  return _internal_has_list();
}
inline void ArtifactStructType::set_has_list() {
  _impl_._oneof_case_[0] = kList;
}
inline void ArtifactStructType::clear_list() {
  if (_internal_has_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.list_;
    }
    clear_has_kind();
  }
}
inline ::ml_metadata::ListArtifactStructType* ArtifactStructType::release_list() {
  // @@protoc_insertion_point(field_release:ml_metadata.ArtifactStructType.list)
  if (_internal_has_list()) {
    clear_has_kind();
    ::ml_metadata::ListArtifactStructType* temp = _impl_.kind_.list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::ListArtifactStructType& ArtifactStructType::_internal_list() const {
  return _internal_has_list()
      ? *_impl_.kind_.list_
      : reinterpret_cast< ::ml_metadata::ListArtifactStructType&>(::ml_metadata::_ListArtifactStructType_default_instance_);
}
inline const ::ml_metadata::ListArtifactStructType& ArtifactStructType::list() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactStructType.list)
  return _internal_list();
}
inline ::ml_metadata::ListArtifactStructType* ArtifactStructType::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.ArtifactStructType.list)
  if (_internal_has_list()) {
    clear_has_kind();
    ::ml_metadata::ListArtifactStructType* temp = _impl_.kind_.list_;
    _impl_.kind_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArtifactStructType::unsafe_arena_set_allocated_list(::ml_metadata::ListArtifactStructType* list) {
  clear_kind();
  if (list) {
    set_has_list();
    _impl_.kind_.list_ = list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ArtifactStructType.list)
}
inline ::ml_metadata::ListArtifactStructType* ArtifactStructType::_internal_mutable_list() {
  if (!_internal_has_list()) {
    clear_kind();
    set_has_list();
    _impl_.kind_.list_ = CreateMaybeMessage< ::ml_metadata::ListArtifactStructType >(GetArenaForAllocation());
  }
  return _impl_.kind_.list_;
}
inline ::ml_metadata::ListArtifactStructType* ArtifactStructType::mutable_list() {
  ::ml_metadata::ListArtifactStructType* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ArtifactStructType.list)
  return _msg;
}

// .ml_metadata.NoneArtifactStructType none = 5;
inline bool ArtifactStructType::_internal_has_none() const {
  return kind_case() == kNone;
}
inline bool ArtifactStructType::has_none() const {
  return _internal_has_none();
}
inline void ArtifactStructType::set_has_none() {
  _impl_._oneof_case_[0] = kNone;
}
inline void ArtifactStructType::clear_none() {
  if (_internal_has_none()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.none_;
    }
    clear_has_kind();
  }
}
inline ::ml_metadata::NoneArtifactStructType* ArtifactStructType::release_none() {
  // @@protoc_insertion_point(field_release:ml_metadata.ArtifactStructType.none)
  if (_internal_has_none()) {
    clear_has_kind();
    ::ml_metadata::NoneArtifactStructType* temp = _impl_.kind_.none_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.none_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::NoneArtifactStructType& ArtifactStructType::_internal_none() const {
  return _internal_has_none()
      ? *_impl_.kind_.none_
      : reinterpret_cast< ::ml_metadata::NoneArtifactStructType&>(::ml_metadata::_NoneArtifactStructType_default_instance_);
}
inline const ::ml_metadata::NoneArtifactStructType& ArtifactStructType::none() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactStructType.none)
  return _internal_none();
}
inline ::ml_metadata::NoneArtifactStructType* ArtifactStructType::unsafe_arena_release_none() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.ArtifactStructType.none)
  if (_internal_has_none()) {
    clear_has_kind();
    ::ml_metadata::NoneArtifactStructType* temp = _impl_.kind_.none_;
    _impl_.kind_.none_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArtifactStructType::unsafe_arena_set_allocated_none(::ml_metadata::NoneArtifactStructType* none) {
  clear_kind();
  if (none) {
    set_has_none();
    _impl_.kind_.none_ = none;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ArtifactStructType.none)
}
inline ::ml_metadata::NoneArtifactStructType* ArtifactStructType::_internal_mutable_none() {
  if (!_internal_has_none()) {
    clear_kind();
    set_has_none();
    _impl_.kind_.none_ = CreateMaybeMessage< ::ml_metadata::NoneArtifactStructType >(GetArenaForAllocation());
  }
  return _impl_.kind_.none_;
}
inline ::ml_metadata::NoneArtifactStructType* ArtifactStructType::mutable_none() {
  ::ml_metadata::NoneArtifactStructType* _msg = _internal_mutable_none();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ArtifactStructType.none)
  return _msg;
}

// .ml_metadata.AnyArtifactStructType any = 6;
inline bool ArtifactStructType::_internal_has_any() const {
  return kind_case() == kAny;
}
inline bool ArtifactStructType::has_any() const {
  return _internal_has_any();
}
inline void ArtifactStructType::set_has_any() {
  _impl_._oneof_case_[0] = kAny;
}
inline void ArtifactStructType::clear_any() {
  if (_internal_has_any()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.any_;
    }
    clear_has_kind();
  }
}
inline ::ml_metadata::AnyArtifactStructType* ArtifactStructType::release_any() {
  // @@protoc_insertion_point(field_release:ml_metadata.ArtifactStructType.any)
  if (_internal_has_any()) {
    clear_has_kind();
    ::ml_metadata::AnyArtifactStructType* temp = _impl_.kind_.any_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.any_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::AnyArtifactStructType& ArtifactStructType::_internal_any() const {
  return _internal_has_any()
      ? *_impl_.kind_.any_
      : reinterpret_cast< ::ml_metadata::AnyArtifactStructType&>(::ml_metadata::_AnyArtifactStructType_default_instance_);
}
inline const ::ml_metadata::AnyArtifactStructType& ArtifactStructType::any() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactStructType.any)
  return _internal_any();
}
inline ::ml_metadata::AnyArtifactStructType* ArtifactStructType::unsafe_arena_release_any() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.ArtifactStructType.any)
  if (_internal_has_any()) {
    clear_has_kind();
    ::ml_metadata::AnyArtifactStructType* temp = _impl_.kind_.any_;
    _impl_.kind_.any_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArtifactStructType::unsafe_arena_set_allocated_any(::ml_metadata::AnyArtifactStructType* any) {
  clear_kind();
  if (any) {
    set_has_any();
    _impl_.kind_.any_ = any;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ArtifactStructType.any)
}
inline ::ml_metadata::AnyArtifactStructType* ArtifactStructType::_internal_mutable_any() {
  if (!_internal_has_any()) {
    clear_kind();
    set_has_any();
    _impl_.kind_.any_ = CreateMaybeMessage< ::ml_metadata::AnyArtifactStructType >(GetArenaForAllocation());
  }
  return _impl_.kind_.any_;
}
inline ::ml_metadata::AnyArtifactStructType* ArtifactStructType::mutable_any() {
  ::ml_metadata::AnyArtifactStructType* _msg = _internal_mutable_any();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ArtifactStructType.any)
  return _msg;
}

// .ml_metadata.TupleArtifactStructType tuple = 7;
inline bool ArtifactStructType::_internal_has_tuple() const {
  return kind_case() == kTuple;
}
inline bool ArtifactStructType::has_tuple() const {
  return _internal_has_tuple();
}
inline void ArtifactStructType::set_has_tuple() {
  _impl_._oneof_case_[0] = kTuple;
}
inline void ArtifactStructType::clear_tuple() {
  if (_internal_has_tuple()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.tuple_;
    }
    clear_has_kind();
  }
}
inline ::ml_metadata::TupleArtifactStructType* ArtifactStructType::release_tuple() {
  // @@protoc_insertion_point(field_release:ml_metadata.ArtifactStructType.tuple)
  if (_internal_has_tuple()) {
    clear_has_kind();
    ::ml_metadata::TupleArtifactStructType* temp = _impl_.kind_.tuple_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tuple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::TupleArtifactStructType& ArtifactStructType::_internal_tuple() const {
  return _internal_has_tuple()
      ? *_impl_.kind_.tuple_
      : reinterpret_cast< ::ml_metadata::TupleArtifactStructType&>(::ml_metadata::_TupleArtifactStructType_default_instance_);
}
inline const ::ml_metadata::TupleArtifactStructType& ArtifactStructType::tuple() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactStructType.tuple)
  return _internal_tuple();
}
inline ::ml_metadata::TupleArtifactStructType* ArtifactStructType::unsafe_arena_release_tuple() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.ArtifactStructType.tuple)
  if (_internal_has_tuple()) {
    clear_has_kind();
    ::ml_metadata::TupleArtifactStructType* temp = _impl_.kind_.tuple_;
    _impl_.kind_.tuple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArtifactStructType::unsafe_arena_set_allocated_tuple(::ml_metadata::TupleArtifactStructType* tuple) {
  clear_kind();
  if (tuple) {
    set_has_tuple();
    _impl_.kind_.tuple_ = tuple;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ArtifactStructType.tuple)
}
inline ::ml_metadata::TupleArtifactStructType* ArtifactStructType::_internal_mutable_tuple() {
  if (!_internal_has_tuple()) {
    clear_kind();
    set_has_tuple();
    _impl_.kind_.tuple_ = CreateMaybeMessage< ::ml_metadata::TupleArtifactStructType >(GetArenaForAllocation());
  }
  return _impl_.kind_.tuple_;
}
inline ::ml_metadata::TupleArtifactStructType* ArtifactStructType::mutable_tuple() {
  ::ml_metadata::TupleArtifactStructType* _msg = _internal_mutable_tuple();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ArtifactStructType.tuple)
  return _msg;
}

// .ml_metadata.DictArtifactStructType dict = 8;
inline bool ArtifactStructType::_internal_has_dict() const {
  return kind_case() == kDict;
}
inline bool ArtifactStructType::has_dict() const {
  return _internal_has_dict();
}
inline void ArtifactStructType::set_has_dict() {
  _impl_._oneof_case_[0] = kDict;
}
inline void ArtifactStructType::clear_dict() {
  if (_internal_has_dict()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.dict_;
    }
    clear_has_kind();
  }
}
inline ::ml_metadata::DictArtifactStructType* ArtifactStructType::release_dict() {
  // @@protoc_insertion_point(field_release:ml_metadata.ArtifactStructType.dict)
  if (_internal_has_dict()) {
    clear_has_kind();
    ::ml_metadata::DictArtifactStructType* temp = _impl_.kind_.dict_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.dict_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::DictArtifactStructType& ArtifactStructType::_internal_dict() const {
  return _internal_has_dict()
      ? *_impl_.kind_.dict_
      : reinterpret_cast< ::ml_metadata::DictArtifactStructType&>(::ml_metadata::_DictArtifactStructType_default_instance_);
}
inline const ::ml_metadata::DictArtifactStructType& ArtifactStructType::dict() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ArtifactStructType.dict)
  return _internal_dict();
}
inline ::ml_metadata::DictArtifactStructType* ArtifactStructType::unsafe_arena_release_dict() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.ArtifactStructType.dict)
  if (_internal_has_dict()) {
    clear_has_kind();
    ::ml_metadata::DictArtifactStructType* temp = _impl_.kind_.dict_;
    _impl_.kind_.dict_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArtifactStructType::unsafe_arena_set_allocated_dict(::ml_metadata::DictArtifactStructType* dict) {
  clear_kind();
  if (dict) {
    set_has_dict();
    _impl_.kind_.dict_ = dict;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ArtifactStructType.dict)
}
inline ::ml_metadata::DictArtifactStructType* ArtifactStructType::_internal_mutable_dict() {
  if (!_internal_has_dict()) {
    clear_kind();
    set_has_dict();
    _impl_.kind_.dict_ = CreateMaybeMessage< ::ml_metadata::DictArtifactStructType >(GetArenaForAllocation());
  }
  return _impl_.kind_.dict_;
}
inline ::ml_metadata::DictArtifactStructType* ArtifactStructType::mutable_dict() {
  ::ml_metadata::DictArtifactStructType* _msg = _internal_mutable_dict();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ArtifactStructType.dict)
  return _msg;
}

inline bool ArtifactStructType::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void ArtifactStructType::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline ArtifactStructType::KindCase ArtifactStructType::kind_case() const {
  return ArtifactStructType::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UnionArtifactStructType

// repeated .ml_metadata.ArtifactStructType candidates = 1;
inline int UnionArtifactStructType::_internal_candidates_size() const {
  return _impl_.candidates_.size();
}
inline int UnionArtifactStructType::candidates_size() const {
  return _internal_candidates_size();
}
inline void UnionArtifactStructType::clear_candidates() {
  _impl_.candidates_.Clear();
}
inline ::ml_metadata::ArtifactStructType* UnionArtifactStructType::mutable_candidates(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.UnionArtifactStructType.candidates)
  return _impl_.candidates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType >*
UnionArtifactStructType::mutable_candidates() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.UnionArtifactStructType.candidates)
  return &_impl_.candidates_;
}
inline const ::ml_metadata::ArtifactStructType& UnionArtifactStructType::_internal_candidates(int index) const {
  return _impl_.candidates_.Get(index);
}
inline const ::ml_metadata::ArtifactStructType& UnionArtifactStructType::candidates(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.UnionArtifactStructType.candidates)
  return _internal_candidates(index);
}
inline ::ml_metadata::ArtifactStructType* UnionArtifactStructType::_internal_add_candidates() {
  return _impl_.candidates_.Add();
}
inline ::ml_metadata::ArtifactStructType* UnionArtifactStructType::add_candidates() {
  ::ml_metadata::ArtifactStructType* _add = _internal_add_candidates();
  // @@protoc_insertion_point(field_add:ml_metadata.UnionArtifactStructType.candidates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType >&
UnionArtifactStructType::candidates() const {
  // @@protoc_insertion_point(field_list:ml_metadata.UnionArtifactStructType.candidates)
  return _impl_.candidates_;
}

// -------------------------------------------------------------------

// IntersectionArtifactStructType

// repeated .ml_metadata.ArtifactStructType constraints = 1;
inline int IntersectionArtifactStructType::_internal_constraints_size() const {
  return _impl_.constraints_.size();
}
inline int IntersectionArtifactStructType::constraints_size() const {
  return _internal_constraints_size();
}
inline void IntersectionArtifactStructType::clear_constraints() {
  _impl_.constraints_.Clear();
}
inline ::ml_metadata::ArtifactStructType* IntersectionArtifactStructType::mutable_constraints(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.IntersectionArtifactStructType.constraints)
  return _impl_.constraints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType >*
IntersectionArtifactStructType::mutable_constraints() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.IntersectionArtifactStructType.constraints)
  return &_impl_.constraints_;
}
inline const ::ml_metadata::ArtifactStructType& IntersectionArtifactStructType::_internal_constraints(int index) const {
  return _impl_.constraints_.Get(index);
}
inline const ::ml_metadata::ArtifactStructType& IntersectionArtifactStructType::constraints(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.IntersectionArtifactStructType.constraints)
  return _internal_constraints(index);
}
inline ::ml_metadata::ArtifactStructType* IntersectionArtifactStructType::_internal_add_constraints() {
  return _impl_.constraints_.Add();
}
inline ::ml_metadata::ArtifactStructType* IntersectionArtifactStructType::add_constraints() {
  ::ml_metadata::ArtifactStructType* _add = _internal_add_constraints();
  // @@protoc_insertion_point(field_add:ml_metadata.IntersectionArtifactStructType.constraints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType >&
IntersectionArtifactStructType::constraints() const {
  // @@protoc_insertion_point(field_list:ml_metadata.IntersectionArtifactStructType.constraints)
  return _impl_.constraints_;
}

// -------------------------------------------------------------------

// ListArtifactStructType

// optional .ml_metadata.ArtifactStructType element = 1;
inline bool ListArtifactStructType::_internal_has_element() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.element_ != nullptr);
  return value;
}
inline bool ListArtifactStructType::has_element() const {
  return _internal_has_element();
}
inline void ListArtifactStructType::clear_element() {
  if (_impl_.element_ != nullptr) _impl_.element_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::ArtifactStructType& ListArtifactStructType::_internal_element() const {
  const ::ml_metadata::ArtifactStructType* p = _impl_.element_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::ArtifactStructType&>(
      ::ml_metadata::_ArtifactStructType_default_instance_);
}
inline const ::ml_metadata::ArtifactStructType& ListArtifactStructType::element() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ListArtifactStructType.element)
  return _internal_element();
}
inline void ListArtifactStructType::unsafe_arena_set_allocated_element(
    ::ml_metadata::ArtifactStructType* element) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.element_);
  }
  _impl_.element_ = element;
  if (element) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ListArtifactStructType.element)
}
inline ::ml_metadata::ArtifactStructType* ListArtifactStructType::release_element() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::ArtifactStructType* temp = _impl_.element_;
  _impl_.element_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::ArtifactStructType* ListArtifactStructType::unsafe_arena_release_element() {
  // @@protoc_insertion_point(field_release:ml_metadata.ListArtifactStructType.element)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::ArtifactStructType* temp = _impl_.element_;
  _impl_.element_ = nullptr;
  return temp;
}
inline ::ml_metadata::ArtifactStructType* ListArtifactStructType::_internal_mutable_element() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.element_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::ArtifactStructType>(GetArenaForAllocation());
    _impl_.element_ = p;
  }
  return _impl_.element_;
}
inline ::ml_metadata::ArtifactStructType* ListArtifactStructType::mutable_element() {
  ::ml_metadata::ArtifactStructType* _msg = _internal_mutable_element();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ListArtifactStructType.element)
  return _msg;
}
inline void ListArtifactStructType::set_allocated_element(::ml_metadata::ArtifactStructType* element) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.element_;
  }
  if (element) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(element);
    if (message_arena != submessage_arena) {
      element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.element_ = element;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ListArtifactStructType.element)
}

// -------------------------------------------------------------------

// NoneArtifactStructType

// -------------------------------------------------------------------

// AnyArtifactStructType

// -------------------------------------------------------------------

// TupleArtifactStructType

// repeated .ml_metadata.ArtifactStructType elements = 1;
inline int TupleArtifactStructType::_internal_elements_size() const {
  return _impl_.elements_.size();
}
inline int TupleArtifactStructType::elements_size() const {
  return _internal_elements_size();
}
inline void TupleArtifactStructType::clear_elements() {
  _impl_.elements_.Clear();
}
inline ::ml_metadata::ArtifactStructType* TupleArtifactStructType::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.TupleArtifactStructType.elements)
  return _impl_.elements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType >*
TupleArtifactStructType::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.TupleArtifactStructType.elements)
  return &_impl_.elements_;
}
inline const ::ml_metadata::ArtifactStructType& TupleArtifactStructType::_internal_elements(int index) const {
  return _impl_.elements_.Get(index);
}
inline const ::ml_metadata::ArtifactStructType& TupleArtifactStructType::elements(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.TupleArtifactStructType.elements)
  return _internal_elements(index);
}
inline ::ml_metadata::ArtifactStructType* TupleArtifactStructType::_internal_add_elements() {
  return _impl_.elements_.Add();
}
inline ::ml_metadata::ArtifactStructType* TupleArtifactStructType::add_elements() {
  ::ml_metadata::ArtifactStructType* _add = _internal_add_elements();
  // @@protoc_insertion_point(field_add:ml_metadata.TupleArtifactStructType.elements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::ArtifactStructType >&
TupleArtifactStructType::elements() const {
  // @@protoc_insertion_point(field_list:ml_metadata.TupleArtifactStructType.elements)
  return _impl_.elements_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DictArtifactStructType

// map<string, .ml_metadata.ArtifactStructType> properties = 1;
inline int DictArtifactStructType::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int DictArtifactStructType::properties_size() const {
  return _internal_properties_size();
}
inline void DictArtifactStructType::clear_properties() {
  _impl_.properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::ArtifactStructType >&
DictArtifactStructType::_internal_properties() const {
  return _impl_.properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::ArtifactStructType >&
DictArtifactStructType::properties() const {
  // @@protoc_insertion_point(field_map:ml_metadata.DictArtifactStructType.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::ArtifactStructType >*
DictArtifactStructType::_internal_mutable_properties() {
  return _impl_.properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ml_metadata::ArtifactStructType >*
DictArtifactStructType::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:ml_metadata.DictArtifactStructType.properties)
  return _internal_mutable_properties();
}

// optional bool none_type_not_required = 2;
inline bool DictArtifactStructType::_internal_has_none_type_not_required() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DictArtifactStructType::has_none_type_not_required() const {
  return _internal_has_none_type_not_required();
}
inline void DictArtifactStructType::clear_none_type_not_required() {
  _impl_.none_type_not_required_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DictArtifactStructType::_internal_none_type_not_required() const {
  return _impl_.none_type_not_required_;
}
inline bool DictArtifactStructType::none_type_not_required() const {
  // @@protoc_insertion_point(field_get:ml_metadata.DictArtifactStructType.none_type_not_required)
  return _internal_none_type_not_required();
}
inline void DictArtifactStructType::_internal_set_none_type_not_required(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.none_type_not_required_ = value;
}
inline void DictArtifactStructType::set_none_type_not_required(bool value) {
  _internal_set_none_type_not_required(value);
  // @@protoc_insertion_point(field_set:ml_metadata.DictArtifactStructType.none_type_not_required)
}

// optional .ml_metadata.ArtifactStructType extra_properties_type = 3;
inline bool DictArtifactStructType::_internal_has_extra_properties_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extra_properties_type_ != nullptr);
  return value;
}
inline bool DictArtifactStructType::has_extra_properties_type() const {
  return _internal_has_extra_properties_type();
}
inline void DictArtifactStructType::clear_extra_properties_type() {
  if (_impl_.extra_properties_type_ != nullptr) _impl_.extra_properties_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::ArtifactStructType& DictArtifactStructType::_internal_extra_properties_type() const {
  const ::ml_metadata::ArtifactStructType* p = _impl_.extra_properties_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::ArtifactStructType&>(
      ::ml_metadata::_ArtifactStructType_default_instance_);
}
inline const ::ml_metadata::ArtifactStructType& DictArtifactStructType::extra_properties_type() const {
  // @@protoc_insertion_point(field_get:ml_metadata.DictArtifactStructType.extra_properties_type)
  return _internal_extra_properties_type();
}
inline void DictArtifactStructType::unsafe_arena_set_allocated_extra_properties_type(
    ::ml_metadata::ArtifactStructType* extra_properties_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_properties_type_);
  }
  _impl_.extra_properties_type_ = extra_properties_type;
  if (extra_properties_type) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.DictArtifactStructType.extra_properties_type)
}
inline ::ml_metadata::ArtifactStructType* DictArtifactStructType::release_extra_properties_type() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::ArtifactStructType* temp = _impl_.extra_properties_type_;
  _impl_.extra_properties_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::ArtifactStructType* DictArtifactStructType::unsafe_arena_release_extra_properties_type() {
  // @@protoc_insertion_point(field_release:ml_metadata.DictArtifactStructType.extra_properties_type)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::ArtifactStructType* temp = _impl_.extra_properties_type_;
  _impl_.extra_properties_type_ = nullptr;
  return temp;
}
inline ::ml_metadata::ArtifactStructType* DictArtifactStructType::_internal_mutable_extra_properties_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.extra_properties_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::ArtifactStructType>(GetArenaForAllocation());
    _impl_.extra_properties_type_ = p;
  }
  return _impl_.extra_properties_type_;
}
inline ::ml_metadata::ArtifactStructType* DictArtifactStructType::mutable_extra_properties_type() {
  ::ml_metadata::ArtifactStructType* _msg = _internal_mutable_extra_properties_type();
  // @@protoc_insertion_point(field_mutable:ml_metadata.DictArtifactStructType.extra_properties_type)
  return _msg;
}
inline void DictArtifactStructType::set_allocated_extra_properties_type(::ml_metadata::ArtifactStructType* extra_properties_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.extra_properties_type_;
  }
  if (extra_properties_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(extra_properties_type);
    if (message_arena != submessage_arena) {
      extra_properties_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra_properties_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.extra_properties_type_ = extra_properties_type;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.DictArtifactStructType.extra_properties_type)
}

// -------------------------------------------------------------------

// FakeDatabaseConfig

// -------------------------------------------------------------------

// MySQLDatabaseConfig_SSLOptions

// optional string key = 1;
inline bool MySQLDatabaseConfig_SSLOptions::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MySQLDatabaseConfig_SSLOptions::has_key() const {
  return _internal_has_key();
}
inline void MySQLDatabaseConfig_SSLOptions::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MySQLDatabaseConfig_SSLOptions::key() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.SSLOptions.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySQLDatabaseConfig_SSLOptions::set_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MySQLDatabaseConfig.SSLOptions.key)
}
inline std::string* MySQLDatabaseConfig_SSLOptions::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MySQLDatabaseConfig.SSLOptions.key)
  return _s;
}
inline const std::string& MySQLDatabaseConfig_SSLOptions::_internal_key() const {
  return _impl_.key_.Get();
}
inline void MySQLDatabaseConfig_SSLOptions::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig_SSLOptions::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig_SSLOptions::release_key() {
  // @@protoc_insertion_point(field_release:ml_metadata.MySQLDatabaseConfig.SSLOptions.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySQLDatabaseConfig_SSLOptions::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MySQLDatabaseConfig.SSLOptions.key)
}

// optional string cert = 2;
inline bool MySQLDatabaseConfig_SSLOptions::_internal_has_cert() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MySQLDatabaseConfig_SSLOptions::has_cert() const {
  return _internal_has_cert();
}
inline void MySQLDatabaseConfig_SSLOptions::clear_cert() {
  _impl_.cert_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MySQLDatabaseConfig_SSLOptions::cert() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.SSLOptions.cert)
  return _internal_cert();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySQLDatabaseConfig_SSLOptions::set_cert(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.cert_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MySQLDatabaseConfig.SSLOptions.cert)
}
inline std::string* MySQLDatabaseConfig_SSLOptions::mutable_cert() {
  std::string* _s = _internal_mutable_cert();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MySQLDatabaseConfig.SSLOptions.cert)
  return _s;
}
inline const std::string& MySQLDatabaseConfig_SSLOptions::_internal_cert() const {
  return _impl_.cert_.Get();
}
inline void MySQLDatabaseConfig_SSLOptions::_internal_set_cert(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cert_.Set(value, GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig_SSLOptions::_internal_mutable_cert() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cert_.Mutable(GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig_SSLOptions::release_cert() {
  // @@protoc_insertion_point(field_release:ml_metadata.MySQLDatabaseConfig.SSLOptions.cert)
  if (!_internal_has_cert()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.cert_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cert_.IsDefault()) {
    _impl_.cert_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySQLDatabaseConfig_SSLOptions::set_allocated_cert(std::string* cert) {
  if (cert != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cert_.SetAllocated(cert, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cert_.IsDefault()) {
    _impl_.cert_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MySQLDatabaseConfig.SSLOptions.cert)
}

// optional string ca = 3;
inline bool MySQLDatabaseConfig_SSLOptions::_internal_has_ca() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MySQLDatabaseConfig_SSLOptions::has_ca() const {
  return _internal_has_ca();
}
inline void MySQLDatabaseConfig_SSLOptions::clear_ca() {
  _impl_.ca_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MySQLDatabaseConfig_SSLOptions::ca() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.SSLOptions.ca)
  return _internal_ca();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySQLDatabaseConfig_SSLOptions::set_ca(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.ca_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MySQLDatabaseConfig.SSLOptions.ca)
}
inline std::string* MySQLDatabaseConfig_SSLOptions::mutable_ca() {
  std::string* _s = _internal_mutable_ca();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MySQLDatabaseConfig.SSLOptions.ca)
  return _s;
}
inline const std::string& MySQLDatabaseConfig_SSLOptions::_internal_ca() const {
  return _impl_.ca_.Get();
}
inline void MySQLDatabaseConfig_SSLOptions::_internal_set_ca(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ca_.Set(value, GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig_SSLOptions::_internal_mutable_ca() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.ca_.Mutable(GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig_SSLOptions::release_ca() {
  // @@protoc_insertion_point(field_release:ml_metadata.MySQLDatabaseConfig.SSLOptions.ca)
  if (!_internal_has_ca()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.ca_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ca_.IsDefault()) {
    _impl_.ca_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySQLDatabaseConfig_SSLOptions::set_allocated_ca(std::string* ca) {
  if (ca != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ca_.SetAllocated(ca, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ca_.IsDefault()) {
    _impl_.ca_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MySQLDatabaseConfig.SSLOptions.ca)
}

// optional string capath = 4;
inline bool MySQLDatabaseConfig_SSLOptions::_internal_has_capath() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MySQLDatabaseConfig_SSLOptions::has_capath() const {
  return _internal_has_capath();
}
inline void MySQLDatabaseConfig_SSLOptions::clear_capath() {
  _impl_.capath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MySQLDatabaseConfig_SSLOptions::capath() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.SSLOptions.capath)
  return _internal_capath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySQLDatabaseConfig_SSLOptions::set_capath(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.capath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MySQLDatabaseConfig.SSLOptions.capath)
}
inline std::string* MySQLDatabaseConfig_SSLOptions::mutable_capath() {
  std::string* _s = _internal_mutable_capath();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MySQLDatabaseConfig.SSLOptions.capath)
  return _s;
}
inline const std::string& MySQLDatabaseConfig_SSLOptions::_internal_capath() const {
  return _impl_.capath_.Get();
}
inline void MySQLDatabaseConfig_SSLOptions::_internal_set_capath(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.capath_.Set(value, GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig_SSLOptions::_internal_mutable_capath() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.capath_.Mutable(GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig_SSLOptions::release_capath() {
  // @@protoc_insertion_point(field_release:ml_metadata.MySQLDatabaseConfig.SSLOptions.capath)
  if (!_internal_has_capath()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.capath_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.capath_.IsDefault()) {
    _impl_.capath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySQLDatabaseConfig_SSLOptions::set_allocated_capath(std::string* capath) {
  if (capath != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.capath_.SetAllocated(capath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.capath_.IsDefault()) {
    _impl_.capath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MySQLDatabaseConfig.SSLOptions.capath)
}

// optional string cipher = 5;
inline bool MySQLDatabaseConfig_SSLOptions::_internal_has_cipher() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MySQLDatabaseConfig_SSLOptions::has_cipher() const {
  return _internal_has_cipher();
}
inline void MySQLDatabaseConfig_SSLOptions::clear_cipher() {
  _impl_.cipher_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MySQLDatabaseConfig_SSLOptions::cipher() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.SSLOptions.cipher)
  return _internal_cipher();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySQLDatabaseConfig_SSLOptions::set_cipher(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.cipher_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MySQLDatabaseConfig.SSLOptions.cipher)
}
inline std::string* MySQLDatabaseConfig_SSLOptions::mutable_cipher() {
  std::string* _s = _internal_mutable_cipher();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MySQLDatabaseConfig.SSLOptions.cipher)
  return _s;
}
inline const std::string& MySQLDatabaseConfig_SSLOptions::_internal_cipher() const {
  return _impl_.cipher_.Get();
}
inline void MySQLDatabaseConfig_SSLOptions::_internal_set_cipher(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.cipher_.Set(value, GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig_SSLOptions::_internal_mutable_cipher() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.cipher_.Mutable(GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig_SSLOptions::release_cipher() {
  // @@protoc_insertion_point(field_release:ml_metadata.MySQLDatabaseConfig.SSLOptions.cipher)
  if (!_internal_has_cipher()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.cipher_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cipher_.IsDefault()) {
    _impl_.cipher_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySQLDatabaseConfig_SSLOptions::set_allocated_cipher(std::string* cipher) {
  if (cipher != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.cipher_.SetAllocated(cipher, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cipher_.IsDefault()) {
    _impl_.cipher_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MySQLDatabaseConfig.SSLOptions.cipher)
}

// optional bool verify_server_cert = 6;
inline bool MySQLDatabaseConfig_SSLOptions::_internal_has_verify_server_cert() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MySQLDatabaseConfig_SSLOptions::has_verify_server_cert() const {
  return _internal_has_verify_server_cert();
}
inline void MySQLDatabaseConfig_SSLOptions::clear_verify_server_cert() {
  _impl_.verify_server_cert_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool MySQLDatabaseConfig_SSLOptions::_internal_verify_server_cert() const {
  return _impl_.verify_server_cert_;
}
inline bool MySQLDatabaseConfig_SSLOptions::verify_server_cert() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.SSLOptions.verify_server_cert)
  return _internal_verify_server_cert();
}
inline void MySQLDatabaseConfig_SSLOptions::_internal_set_verify_server_cert(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.verify_server_cert_ = value;
}
inline void MySQLDatabaseConfig_SSLOptions::set_verify_server_cert(bool value) {
  _internal_set_verify_server_cert(value);
  // @@protoc_insertion_point(field_set:ml_metadata.MySQLDatabaseConfig.SSLOptions.verify_server_cert)
}

// -------------------------------------------------------------------

// MySQLDatabaseConfig

// optional string host = 1;
inline bool MySQLDatabaseConfig::_internal_has_host() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MySQLDatabaseConfig::has_host() const {
  return _internal_has_host();
}
inline void MySQLDatabaseConfig::clear_host() {
  _impl_.host_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MySQLDatabaseConfig::host() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySQLDatabaseConfig::set_host(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MySQLDatabaseConfig.host)
}
inline std::string* MySQLDatabaseConfig::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MySQLDatabaseConfig.host)
  return _s;
}
inline const std::string& MySQLDatabaseConfig::_internal_host() const {
  return _impl_.host_.Get();
}
inline void MySQLDatabaseConfig::_internal_set_host(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig::_internal_mutable_host() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig::release_host() {
  // @@protoc_insertion_point(field_release:ml_metadata.MySQLDatabaseConfig.host)
  if (!_internal_has_host()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.host_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySQLDatabaseConfig::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MySQLDatabaseConfig.host)
}

// optional int64 port = 2;
inline bool MySQLDatabaseConfig::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MySQLDatabaseConfig::has_port() const {
  return _internal_has_port();
}
inline void MySQLDatabaseConfig::clear_port() {
  _impl_.port_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t MySQLDatabaseConfig::_internal_port() const {
  return _impl_.port_;
}
inline int64_t MySQLDatabaseConfig::port() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.port)
  return _internal_port();
}
inline void MySQLDatabaseConfig::_internal_set_port(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.port_ = value;
}
inline void MySQLDatabaseConfig::set_port(int64_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:ml_metadata.MySQLDatabaseConfig.port)
}

// optional string database = 3;
inline bool MySQLDatabaseConfig::_internal_has_database() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MySQLDatabaseConfig::has_database() const {
  return _internal_has_database();
}
inline void MySQLDatabaseConfig::clear_database() {
  _impl_.database_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MySQLDatabaseConfig::database() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySQLDatabaseConfig::set_database(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.database_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MySQLDatabaseConfig.database)
}
inline std::string* MySQLDatabaseConfig::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MySQLDatabaseConfig.database)
  return _s;
}
inline const std::string& MySQLDatabaseConfig::_internal_database() const {
  return _impl_.database_.Get();
}
inline void MySQLDatabaseConfig::_internal_set_database(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.database_.Set(value, GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig::_internal_mutable_database() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.database_.Mutable(GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig::release_database() {
  // @@protoc_insertion_point(field_release:ml_metadata.MySQLDatabaseConfig.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.database_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.database_.IsDefault()) {
    _impl_.database_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySQLDatabaseConfig::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.database_.SetAllocated(database, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.database_.IsDefault()) {
    _impl_.database_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MySQLDatabaseConfig.database)
}

// optional string user = 4;
inline bool MySQLDatabaseConfig::_internal_has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MySQLDatabaseConfig::has_user() const {
  return _internal_has_user();
}
inline void MySQLDatabaseConfig::clear_user() {
  _impl_.user_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MySQLDatabaseConfig::user() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySQLDatabaseConfig::set_user(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MySQLDatabaseConfig.user)
}
inline std::string* MySQLDatabaseConfig::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MySQLDatabaseConfig.user)
  return _s;
}
inline const std::string& MySQLDatabaseConfig::_internal_user() const {
  return _impl_.user_.Get();
}
inline void MySQLDatabaseConfig::_internal_set_user(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig::_internal_mutable_user() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig::release_user() {
  // @@protoc_insertion_point(field_release:ml_metadata.MySQLDatabaseConfig.user)
  if (!_internal_has_user()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.user_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySQLDatabaseConfig::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MySQLDatabaseConfig.user)
}

// optional string password = 5;
inline bool MySQLDatabaseConfig::_internal_has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MySQLDatabaseConfig::has_password() const {
  return _internal_has_password();
}
inline void MySQLDatabaseConfig::clear_password() {
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MySQLDatabaseConfig::password() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySQLDatabaseConfig::set_password(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MySQLDatabaseConfig.password)
}
inline std::string* MySQLDatabaseConfig::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MySQLDatabaseConfig.password)
  return _s;
}
inline const std::string& MySQLDatabaseConfig::_internal_password() const {
  return _impl_.password_.Get();
}
inline void MySQLDatabaseConfig::_internal_set_password(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig::_internal_mutable_password() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig::release_password() {
  // @@protoc_insertion_point(field_release:ml_metadata.MySQLDatabaseConfig.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.password_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySQLDatabaseConfig::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MySQLDatabaseConfig.password)
}

// optional string socket = 6;
inline bool MySQLDatabaseConfig::_internal_has_socket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MySQLDatabaseConfig::has_socket() const {
  return _internal_has_socket();
}
inline void MySQLDatabaseConfig::clear_socket() {
  _impl_.socket_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MySQLDatabaseConfig::socket() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.socket)
  return _internal_socket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySQLDatabaseConfig::set_socket(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.socket_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MySQLDatabaseConfig.socket)
}
inline std::string* MySQLDatabaseConfig::mutable_socket() {
  std::string* _s = _internal_mutable_socket();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MySQLDatabaseConfig.socket)
  return _s;
}
inline const std::string& MySQLDatabaseConfig::_internal_socket() const {
  return _impl_.socket_.Get();
}
inline void MySQLDatabaseConfig::_internal_set_socket(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.socket_.Set(value, GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig::_internal_mutable_socket() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.socket_.Mutable(GetArenaForAllocation());
}
inline std::string* MySQLDatabaseConfig::release_socket() {
  // @@protoc_insertion_point(field_release:ml_metadata.MySQLDatabaseConfig.socket)
  if (!_internal_has_socket()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.socket_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.socket_.IsDefault()) {
    _impl_.socket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySQLDatabaseConfig::set_allocated_socket(std::string* socket) {
  if (socket != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.socket_.SetAllocated(socket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.socket_.IsDefault()) {
    _impl_.socket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MySQLDatabaseConfig.socket)
}

// optional .ml_metadata.MySQLDatabaseConfig.SSLOptions ssl_options = 7;
inline bool MySQLDatabaseConfig::_internal_has_ssl_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ssl_options_ != nullptr);
  return value;
}
inline bool MySQLDatabaseConfig::has_ssl_options() const {
  return _internal_has_ssl_options();
}
inline void MySQLDatabaseConfig::clear_ssl_options() {
  if (_impl_.ssl_options_ != nullptr) _impl_.ssl_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::ml_metadata::MySQLDatabaseConfig_SSLOptions& MySQLDatabaseConfig::_internal_ssl_options() const {
  const ::ml_metadata::MySQLDatabaseConfig_SSLOptions* p = _impl_.ssl_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::MySQLDatabaseConfig_SSLOptions&>(
      ::ml_metadata::_MySQLDatabaseConfig_SSLOptions_default_instance_);
}
inline const ::ml_metadata::MySQLDatabaseConfig_SSLOptions& MySQLDatabaseConfig::ssl_options() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.ssl_options)
  return _internal_ssl_options();
}
inline void MySQLDatabaseConfig::unsafe_arena_set_allocated_ssl_options(
    ::ml_metadata::MySQLDatabaseConfig_SSLOptions* ssl_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ssl_options_);
  }
  _impl_.ssl_options_ = ssl_options;
  if (ssl_options) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.MySQLDatabaseConfig.ssl_options)
}
inline ::ml_metadata::MySQLDatabaseConfig_SSLOptions* MySQLDatabaseConfig::release_ssl_options() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::ml_metadata::MySQLDatabaseConfig_SSLOptions* temp = _impl_.ssl_options_;
  _impl_.ssl_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::MySQLDatabaseConfig_SSLOptions* MySQLDatabaseConfig::unsafe_arena_release_ssl_options() {
  // @@protoc_insertion_point(field_release:ml_metadata.MySQLDatabaseConfig.ssl_options)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::ml_metadata::MySQLDatabaseConfig_SSLOptions* temp = _impl_.ssl_options_;
  _impl_.ssl_options_ = nullptr;
  return temp;
}
inline ::ml_metadata::MySQLDatabaseConfig_SSLOptions* MySQLDatabaseConfig::_internal_mutable_ssl_options() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.ssl_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::MySQLDatabaseConfig_SSLOptions>(GetArenaForAllocation());
    _impl_.ssl_options_ = p;
  }
  return _impl_.ssl_options_;
}
inline ::ml_metadata::MySQLDatabaseConfig_SSLOptions* MySQLDatabaseConfig::mutable_ssl_options() {
  ::ml_metadata::MySQLDatabaseConfig_SSLOptions* _msg = _internal_mutable_ssl_options();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MySQLDatabaseConfig.ssl_options)
  return _msg;
}
inline void MySQLDatabaseConfig::set_allocated_ssl_options(::ml_metadata::MySQLDatabaseConfig_SSLOptions* ssl_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ssl_options_;
  }
  if (ssl_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ssl_options);
    if (message_arena != submessage_arena) {
      ssl_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ssl_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.ssl_options_ = ssl_options;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MySQLDatabaseConfig.ssl_options)
}

// optional bool skip_db_creation = 8;
inline bool MySQLDatabaseConfig::_internal_has_skip_db_creation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MySQLDatabaseConfig::has_skip_db_creation() const {
  return _internal_has_skip_db_creation();
}
inline void MySQLDatabaseConfig::clear_skip_db_creation() {
  _impl_.skip_db_creation_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool MySQLDatabaseConfig::_internal_skip_db_creation() const {
  return _impl_.skip_db_creation_;
}
inline bool MySQLDatabaseConfig::skip_db_creation() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MySQLDatabaseConfig.skip_db_creation)
  return _internal_skip_db_creation();
}
inline void MySQLDatabaseConfig::_internal_set_skip_db_creation(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.skip_db_creation_ = value;
}
inline void MySQLDatabaseConfig::set_skip_db_creation(bool value) {
  _internal_set_skip_db_creation(value);
  // @@protoc_insertion_point(field_set:ml_metadata.MySQLDatabaseConfig.skip_db_creation)
}

// -------------------------------------------------------------------

// SqliteMetadataSourceConfig

// optional string filename_uri = 1;
inline bool SqliteMetadataSourceConfig::_internal_has_filename_uri() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SqliteMetadataSourceConfig::has_filename_uri() const {
  return _internal_has_filename_uri();
}
inline void SqliteMetadataSourceConfig::clear_filename_uri() {
  _impl_.filename_uri_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SqliteMetadataSourceConfig::filename_uri() const {
  // @@protoc_insertion_point(field_get:ml_metadata.SqliteMetadataSourceConfig.filename_uri)
  return _internal_filename_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SqliteMetadataSourceConfig::set_filename_uri(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filename_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.SqliteMetadataSourceConfig.filename_uri)
}
inline std::string* SqliteMetadataSourceConfig::mutable_filename_uri() {
  std::string* _s = _internal_mutable_filename_uri();
  // @@protoc_insertion_point(field_mutable:ml_metadata.SqliteMetadataSourceConfig.filename_uri)
  return _s;
}
inline const std::string& SqliteMetadataSourceConfig::_internal_filename_uri() const {
  return _impl_.filename_uri_.Get();
}
inline void SqliteMetadataSourceConfig::_internal_set_filename_uri(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* SqliteMetadataSourceConfig::_internal_mutable_filename_uri() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* SqliteMetadataSourceConfig::release_filename_uri() {
  // @@protoc_insertion_point(field_release:ml_metadata.SqliteMetadataSourceConfig.filename_uri)
  if (!_internal_has_filename_uri()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filename_uri_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_uri_.IsDefault()) {
    _impl_.filename_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SqliteMetadataSourceConfig::set_allocated_filename_uri(std::string* filename_uri) {
  if (filename_uri != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_uri_.SetAllocated(filename_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_uri_.IsDefault()) {
    _impl_.filename_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.SqliteMetadataSourceConfig.filename_uri)
}

// optional .ml_metadata.SqliteMetadataSourceConfig.ConnectionMode connection_mode = 2;
inline bool SqliteMetadataSourceConfig::_internal_has_connection_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SqliteMetadataSourceConfig::has_connection_mode() const {
  return _internal_has_connection_mode();
}
inline void SqliteMetadataSourceConfig::clear_connection_mode() {
  _impl_.connection_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::ml_metadata::SqliteMetadataSourceConfig_ConnectionMode SqliteMetadataSourceConfig::_internal_connection_mode() const {
  return static_cast< ::ml_metadata::SqliteMetadataSourceConfig_ConnectionMode >(_impl_.connection_mode_);
}
inline ::ml_metadata::SqliteMetadataSourceConfig_ConnectionMode SqliteMetadataSourceConfig::connection_mode() const {
  // @@protoc_insertion_point(field_get:ml_metadata.SqliteMetadataSourceConfig.connection_mode)
  return _internal_connection_mode();
}
inline void SqliteMetadataSourceConfig::_internal_set_connection_mode(::ml_metadata::SqliteMetadataSourceConfig_ConnectionMode value) {
  assert(::ml_metadata::SqliteMetadataSourceConfig_ConnectionMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.connection_mode_ = value;
}
inline void SqliteMetadataSourceConfig::set_connection_mode(::ml_metadata::SqliteMetadataSourceConfig_ConnectionMode value) {
  _internal_set_connection_mode(value);
  // @@protoc_insertion_point(field_set:ml_metadata.SqliteMetadataSourceConfig.connection_mode)
}

// -------------------------------------------------------------------

// PostgreSQLDatabaseConfig_SSLOptions

// optional string sslmode = 1;
inline bool PostgreSQLDatabaseConfig_SSLOptions::_internal_has_sslmode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PostgreSQLDatabaseConfig_SSLOptions::has_sslmode() const {
  return _internal_has_sslmode();
}
inline void PostgreSQLDatabaseConfig_SSLOptions::clear_sslmode() {
  _impl_.sslmode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PostgreSQLDatabaseConfig_SSLOptions::sslmode() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslmode)
  return _internal_sslmode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostgreSQLDatabaseConfig_SSLOptions::set_sslmode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sslmode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslmode)
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::mutable_sslmode() {
  std::string* _s = _internal_mutable_sslmode();
  // @@protoc_insertion_point(field_mutable:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslmode)
  return _s;
}
inline const std::string& PostgreSQLDatabaseConfig_SSLOptions::_internal_sslmode() const {
  return _impl_.sslmode_.Get();
}
inline void PostgreSQLDatabaseConfig_SSLOptions::_internal_set_sslmode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sslmode_.Set(value, GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::_internal_mutable_sslmode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sslmode_.Mutable(GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::release_sslmode() {
  // @@protoc_insertion_point(field_release:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslmode)
  if (!_internal_has_sslmode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sslmode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sslmode_.IsDefault()) {
    _impl_.sslmode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostgreSQLDatabaseConfig_SSLOptions::set_allocated_sslmode(std::string* sslmode) {
  if (sslmode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sslmode_.SetAllocated(sslmode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sslmode_.IsDefault()) {
    _impl_.sslmode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslmode)
}

// optional string sslcert = 2;
inline bool PostgreSQLDatabaseConfig_SSLOptions::_internal_has_sslcert() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PostgreSQLDatabaseConfig_SSLOptions::has_sslcert() const {
  return _internal_has_sslcert();
}
inline void PostgreSQLDatabaseConfig_SSLOptions::clear_sslcert() {
  _impl_.sslcert_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PostgreSQLDatabaseConfig_SSLOptions::sslcert() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslcert)
  return _internal_sslcert();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostgreSQLDatabaseConfig_SSLOptions::set_sslcert(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.sslcert_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslcert)
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::mutable_sslcert() {
  std::string* _s = _internal_mutable_sslcert();
  // @@protoc_insertion_point(field_mutable:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslcert)
  return _s;
}
inline const std::string& PostgreSQLDatabaseConfig_SSLOptions::_internal_sslcert() const {
  return _impl_.sslcert_.Get();
}
inline void PostgreSQLDatabaseConfig_SSLOptions::_internal_set_sslcert(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sslcert_.Set(value, GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::_internal_mutable_sslcert() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sslcert_.Mutable(GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::release_sslcert() {
  // @@protoc_insertion_point(field_release:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslcert)
  if (!_internal_has_sslcert()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.sslcert_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sslcert_.IsDefault()) {
    _impl_.sslcert_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostgreSQLDatabaseConfig_SSLOptions::set_allocated_sslcert(std::string* sslcert) {
  if (sslcert != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sslcert_.SetAllocated(sslcert, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sslcert_.IsDefault()) {
    _impl_.sslcert_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslcert)
}

// optional string sslkey = 3;
inline bool PostgreSQLDatabaseConfig_SSLOptions::_internal_has_sslkey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PostgreSQLDatabaseConfig_SSLOptions::has_sslkey() const {
  return _internal_has_sslkey();
}
inline void PostgreSQLDatabaseConfig_SSLOptions::clear_sslkey() {
  _impl_.sslkey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PostgreSQLDatabaseConfig_SSLOptions::sslkey() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslkey)
  return _internal_sslkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostgreSQLDatabaseConfig_SSLOptions::set_sslkey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.sslkey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslkey)
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::mutable_sslkey() {
  std::string* _s = _internal_mutable_sslkey();
  // @@protoc_insertion_point(field_mutable:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslkey)
  return _s;
}
inline const std::string& PostgreSQLDatabaseConfig_SSLOptions::_internal_sslkey() const {
  return _impl_.sslkey_.Get();
}
inline void PostgreSQLDatabaseConfig_SSLOptions::_internal_set_sslkey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sslkey_.Set(value, GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::_internal_mutable_sslkey() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.sslkey_.Mutable(GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::release_sslkey() {
  // @@protoc_insertion_point(field_release:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslkey)
  if (!_internal_has_sslkey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.sslkey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sslkey_.IsDefault()) {
    _impl_.sslkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostgreSQLDatabaseConfig_SSLOptions::set_allocated_sslkey(std::string* sslkey) {
  if (sslkey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.sslkey_.SetAllocated(sslkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sslkey_.IsDefault()) {
    _impl_.sslkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslkey)
}

// optional string sslpassword = 4;
inline bool PostgreSQLDatabaseConfig_SSLOptions::_internal_has_sslpassword() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PostgreSQLDatabaseConfig_SSLOptions::has_sslpassword() const {
  return _internal_has_sslpassword();
}
inline void PostgreSQLDatabaseConfig_SSLOptions::clear_sslpassword() {
  _impl_.sslpassword_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PostgreSQLDatabaseConfig_SSLOptions::sslpassword() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslpassword)
  return _internal_sslpassword();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostgreSQLDatabaseConfig_SSLOptions::set_sslpassword(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.sslpassword_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslpassword)
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::mutable_sslpassword() {
  std::string* _s = _internal_mutable_sslpassword();
  // @@protoc_insertion_point(field_mutable:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslpassword)
  return _s;
}
inline const std::string& PostgreSQLDatabaseConfig_SSLOptions::_internal_sslpassword() const {
  return _impl_.sslpassword_.Get();
}
inline void PostgreSQLDatabaseConfig_SSLOptions::_internal_set_sslpassword(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sslpassword_.Set(value, GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::_internal_mutable_sslpassword() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.sslpassword_.Mutable(GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::release_sslpassword() {
  // @@protoc_insertion_point(field_release:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslpassword)
  if (!_internal_has_sslpassword()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.sslpassword_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sslpassword_.IsDefault()) {
    _impl_.sslpassword_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostgreSQLDatabaseConfig_SSLOptions::set_allocated_sslpassword(std::string* sslpassword) {
  if (sslpassword != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.sslpassword_.SetAllocated(sslpassword, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sslpassword_.IsDefault()) {
    _impl_.sslpassword_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslpassword)
}

// optional string sslrootcert = 5;
inline bool PostgreSQLDatabaseConfig_SSLOptions::_internal_has_sslrootcert() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PostgreSQLDatabaseConfig_SSLOptions::has_sslrootcert() const {
  return _internal_has_sslrootcert();
}
inline void PostgreSQLDatabaseConfig_SSLOptions::clear_sslrootcert() {
  _impl_.sslrootcert_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PostgreSQLDatabaseConfig_SSLOptions::sslrootcert() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslrootcert)
  return _internal_sslrootcert();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostgreSQLDatabaseConfig_SSLOptions::set_sslrootcert(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.sslrootcert_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslrootcert)
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::mutable_sslrootcert() {
  std::string* _s = _internal_mutable_sslrootcert();
  // @@protoc_insertion_point(field_mutable:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslrootcert)
  return _s;
}
inline const std::string& PostgreSQLDatabaseConfig_SSLOptions::_internal_sslrootcert() const {
  return _impl_.sslrootcert_.Get();
}
inline void PostgreSQLDatabaseConfig_SSLOptions::_internal_set_sslrootcert(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sslrootcert_.Set(value, GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::_internal_mutable_sslrootcert() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.sslrootcert_.Mutable(GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig_SSLOptions::release_sslrootcert() {
  // @@protoc_insertion_point(field_release:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslrootcert)
  if (!_internal_has_sslrootcert()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.sslrootcert_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sslrootcert_.IsDefault()) {
    _impl_.sslrootcert_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostgreSQLDatabaseConfig_SSLOptions::set_allocated_sslrootcert(std::string* sslrootcert) {
  if (sslrootcert != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.sslrootcert_.SetAllocated(sslrootcert, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sslrootcert_.IsDefault()) {
    _impl_.sslrootcert_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.SSLOptions.sslrootcert)
}

// -------------------------------------------------------------------

// PostgreSQLDatabaseConfig

// optional string host = 1;
inline bool PostgreSQLDatabaseConfig::_internal_has_host() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PostgreSQLDatabaseConfig::has_host() const {
  return _internal_has_host();
}
inline void PostgreSQLDatabaseConfig::clear_host() {
  _impl_.host_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PostgreSQLDatabaseConfig::host() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostgreSQLDatabaseConfig::set_host(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.PostgreSQLDatabaseConfig.host)
}
inline std::string* PostgreSQLDatabaseConfig::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:ml_metadata.PostgreSQLDatabaseConfig.host)
  return _s;
}
inline const std::string& PostgreSQLDatabaseConfig::_internal_host() const {
  return _impl_.host_.Get();
}
inline void PostgreSQLDatabaseConfig::_internal_set_host(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::_internal_mutable_host() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::release_host() {
  // @@protoc_insertion_point(field_release:ml_metadata.PostgreSQLDatabaseConfig.host)
  if (!_internal_has_host()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.host_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostgreSQLDatabaseConfig::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.host)
}

// optional string hostaddr = 2;
inline bool PostgreSQLDatabaseConfig::_internal_has_hostaddr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PostgreSQLDatabaseConfig::has_hostaddr() const {
  return _internal_has_hostaddr();
}
inline void PostgreSQLDatabaseConfig::clear_hostaddr() {
  _impl_.hostaddr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PostgreSQLDatabaseConfig::hostaddr() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.hostaddr)
  return _internal_hostaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostgreSQLDatabaseConfig::set_hostaddr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.hostaddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.PostgreSQLDatabaseConfig.hostaddr)
}
inline std::string* PostgreSQLDatabaseConfig::mutable_hostaddr() {
  std::string* _s = _internal_mutable_hostaddr();
  // @@protoc_insertion_point(field_mutable:ml_metadata.PostgreSQLDatabaseConfig.hostaddr)
  return _s;
}
inline const std::string& PostgreSQLDatabaseConfig::_internal_hostaddr() const {
  return _impl_.hostaddr_.Get();
}
inline void PostgreSQLDatabaseConfig::_internal_set_hostaddr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.hostaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::_internal_mutable_hostaddr() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.hostaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::release_hostaddr() {
  // @@protoc_insertion_point(field_release:ml_metadata.PostgreSQLDatabaseConfig.hostaddr)
  if (!_internal_has_hostaddr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.hostaddr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostaddr_.IsDefault()) {
    _impl_.hostaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostgreSQLDatabaseConfig::set_allocated_hostaddr(std::string* hostaddr) {
  if (hostaddr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.hostaddr_.SetAllocated(hostaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostaddr_.IsDefault()) {
    _impl_.hostaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.hostaddr)
}

// optional string port = 3;
inline bool PostgreSQLDatabaseConfig::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PostgreSQLDatabaseConfig::has_port() const {
  return _internal_has_port();
}
inline void PostgreSQLDatabaseConfig::clear_port() {
  _impl_.port_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PostgreSQLDatabaseConfig::port() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.port)
  return _internal_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostgreSQLDatabaseConfig::set_port(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.PostgreSQLDatabaseConfig.port)
}
inline std::string* PostgreSQLDatabaseConfig::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:ml_metadata.PostgreSQLDatabaseConfig.port)
  return _s;
}
inline const std::string& PostgreSQLDatabaseConfig::_internal_port() const {
  return _impl_.port_.Get();
}
inline void PostgreSQLDatabaseConfig::_internal_set_port(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.port_.Set(value, GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::_internal_mutable_port() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.port_.Mutable(GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::release_port() {
  // @@protoc_insertion_point(field_release:ml_metadata.PostgreSQLDatabaseConfig.port)
  if (!_internal_has_port()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.port_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.port_.IsDefault()) {
    _impl_.port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostgreSQLDatabaseConfig::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.port_.SetAllocated(port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.port_.IsDefault()) {
    _impl_.port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.port)
}

// optional string user = 4;
inline bool PostgreSQLDatabaseConfig::_internal_has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PostgreSQLDatabaseConfig::has_user() const {
  return _internal_has_user();
}
inline void PostgreSQLDatabaseConfig::clear_user() {
  _impl_.user_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PostgreSQLDatabaseConfig::user() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostgreSQLDatabaseConfig::set_user(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.PostgreSQLDatabaseConfig.user)
}
inline std::string* PostgreSQLDatabaseConfig::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:ml_metadata.PostgreSQLDatabaseConfig.user)
  return _s;
}
inline const std::string& PostgreSQLDatabaseConfig::_internal_user() const {
  return _impl_.user_.Get();
}
inline void PostgreSQLDatabaseConfig::_internal_set_user(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::_internal_mutable_user() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::release_user() {
  // @@protoc_insertion_point(field_release:ml_metadata.PostgreSQLDatabaseConfig.user)
  if (!_internal_has_user()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.user_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostgreSQLDatabaseConfig::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.user)
}

// optional string password = 5;
inline bool PostgreSQLDatabaseConfig::_internal_has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PostgreSQLDatabaseConfig::has_password() const {
  return _internal_has_password();
}
inline void PostgreSQLDatabaseConfig::clear_password() {
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PostgreSQLDatabaseConfig::password() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostgreSQLDatabaseConfig::set_password(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.PostgreSQLDatabaseConfig.password)
}
inline std::string* PostgreSQLDatabaseConfig::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:ml_metadata.PostgreSQLDatabaseConfig.password)
  return _s;
}
inline const std::string& PostgreSQLDatabaseConfig::_internal_password() const {
  return _impl_.password_.Get();
}
inline void PostgreSQLDatabaseConfig::_internal_set_password(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::_internal_mutable_password() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::release_password() {
  // @@protoc_insertion_point(field_release:ml_metadata.PostgreSQLDatabaseConfig.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.password_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostgreSQLDatabaseConfig::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.password)
}

// optional string passfile = 6;
inline bool PostgreSQLDatabaseConfig::_internal_has_passfile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PostgreSQLDatabaseConfig::has_passfile() const {
  return _internal_has_passfile();
}
inline void PostgreSQLDatabaseConfig::clear_passfile() {
  _impl_.passfile_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& PostgreSQLDatabaseConfig::passfile() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.passfile)
  return _internal_passfile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostgreSQLDatabaseConfig::set_passfile(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.passfile_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.PostgreSQLDatabaseConfig.passfile)
}
inline std::string* PostgreSQLDatabaseConfig::mutable_passfile() {
  std::string* _s = _internal_mutable_passfile();
  // @@protoc_insertion_point(field_mutable:ml_metadata.PostgreSQLDatabaseConfig.passfile)
  return _s;
}
inline const std::string& PostgreSQLDatabaseConfig::_internal_passfile() const {
  return _impl_.passfile_.Get();
}
inline void PostgreSQLDatabaseConfig::_internal_set_passfile(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.passfile_.Set(value, GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::_internal_mutable_passfile() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.passfile_.Mutable(GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::release_passfile() {
  // @@protoc_insertion_point(field_release:ml_metadata.PostgreSQLDatabaseConfig.passfile)
  if (!_internal_has_passfile()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.passfile_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passfile_.IsDefault()) {
    _impl_.passfile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostgreSQLDatabaseConfig::set_allocated_passfile(std::string* passfile) {
  if (passfile != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.passfile_.SetAllocated(passfile, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passfile_.IsDefault()) {
    _impl_.passfile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.passfile)
}

// optional string dbname = 7;
inline bool PostgreSQLDatabaseConfig::_internal_has_dbname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PostgreSQLDatabaseConfig::has_dbname() const {
  return _internal_has_dbname();
}
inline void PostgreSQLDatabaseConfig::clear_dbname() {
  _impl_.dbname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& PostgreSQLDatabaseConfig::dbname() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.dbname)
  return _internal_dbname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostgreSQLDatabaseConfig::set_dbname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.dbname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.PostgreSQLDatabaseConfig.dbname)
}
inline std::string* PostgreSQLDatabaseConfig::mutable_dbname() {
  std::string* _s = _internal_mutable_dbname();
  // @@protoc_insertion_point(field_mutable:ml_metadata.PostgreSQLDatabaseConfig.dbname)
  return _s;
}
inline const std::string& PostgreSQLDatabaseConfig::_internal_dbname() const {
  return _impl_.dbname_.Get();
}
inline void PostgreSQLDatabaseConfig::_internal_set_dbname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.dbname_.Set(value, GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::_internal_mutable_dbname() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.dbname_.Mutable(GetArenaForAllocation());
}
inline std::string* PostgreSQLDatabaseConfig::release_dbname() {
  // @@protoc_insertion_point(field_release:ml_metadata.PostgreSQLDatabaseConfig.dbname)
  if (!_internal_has_dbname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.dbname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dbname_.IsDefault()) {
    _impl_.dbname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostgreSQLDatabaseConfig::set_allocated_dbname(std::string* dbname) {
  if (dbname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.dbname_.SetAllocated(dbname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dbname_.IsDefault()) {
    _impl_.dbname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.dbname)
}

// optional bool skip_db_creation = 8;
inline bool PostgreSQLDatabaseConfig::_internal_has_skip_db_creation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PostgreSQLDatabaseConfig::has_skip_db_creation() const {
  return _internal_has_skip_db_creation();
}
inline void PostgreSQLDatabaseConfig::clear_skip_db_creation() {
  _impl_.skip_db_creation_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool PostgreSQLDatabaseConfig::_internal_skip_db_creation() const {
  return _impl_.skip_db_creation_;
}
inline bool PostgreSQLDatabaseConfig::skip_db_creation() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.skip_db_creation)
  return _internal_skip_db_creation();
}
inline void PostgreSQLDatabaseConfig::_internal_set_skip_db_creation(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.skip_db_creation_ = value;
}
inline void PostgreSQLDatabaseConfig::set_skip_db_creation(bool value) {
  _internal_set_skip_db_creation(value);
  // @@protoc_insertion_point(field_set:ml_metadata.PostgreSQLDatabaseConfig.skip_db_creation)
}

// optional .ml_metadata.PostgreSQLDatabaseConfig.SSLOptions ssloption = 9;
inline bool PostgreSQLDatabaseConfig::_internal_has_ssloption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ssloption_ != nullptr);
  return value;
}
inline bool PostgreSQLDatabaseConfig::has_ssloption() const {
  return _internal_has_ssloption();
}
inline void PostgreSQLDatabaseConfig::clear_ssloption() {
  if (_impl_.ssloption_ != nullptr) _impl_.ssloption_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions& PostgreSQLDatabaseConfig::_internal_ssloption() const {
  const ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* p = _impl_.ssloption_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions&>(
      ::ml_metadata::_PostgreSQLDatabaseConfig_SSLOptions_default_instance_);
}
inline const ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions& PostgreSQLDatabaseConfig::ssloption() const {
  // @@protoc_insertion_point(field_get:ml_metadata.PostgreSQLDatabaseConfig.ssloption)
  return _internal_ssloption();
}
inline void PostgreSQLDatabaseConfig::unsafe_arena_set_allocated_ssloption(
    ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* ssloption) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ssloption_);
  }
  _impl_.ssloption_ = ssloption;
  if (ssloption) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.ssloption)
}
inline ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* PostgreSQLDatabaseConfig::release_ssloption() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* temp = _impl_.ssloption_;
  _impl_.ssloption_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* PostgreSQLDatabaseConfig::unsafe_arena_release_ssloption() {
  // @@protoc_insertion_point(field_release:ml_metadata.PostgreSQLDatabaseConfig.ssloption)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* temp = _impl_.ssloption_;
  _impl_.ssloption_ = nullptr;
  return temp;
}
inline ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* PostgreSQLDatabaseConfig::_internal_mutable_ssloption() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.ssloption_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions>(GetArenaForAllocation());
    _impl_.ssloption_ = p;
  }
  return _impl_.ssloption_;
}
inline ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* PostgreSQLDatabaseConfig::mutable_ssloption() {
  ::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* _msg = _internal_mutable_ssloption();
  // @@protoc_insertion_point(field_mutable:ml_metadata.PostgreSQLDatabaseConfig.ssloption)
  return _msg;
}
inline void PostgreSQLDatabaseConfig::set_allocated_ssloption(::ml_metadata::PostgreSQLDatabaseConfig_SSLOptions* ssloption) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ssloption_;
  }
  if (ssloption) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ssloption);
    if (message_arena != submessage_arena) {
      ssloption = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ssloption, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.ssloption_ = ssloption;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.PostgreSQLDatabaseConfig.ssloption)
}

// -------------------------------------------------------------------

// MigrationOptions

// optional bool enable_upgrade_migration = 3;
inline bool MigrationOptions::_internal_has_enable_upgrade_migration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MigrationOptions::has_enable_upgrade_migration() const {
  return _internal_has_enable_upgrade_migration();
}
inline void MigrationOptions::clear_enable_upgrade_migration() {
  _impl_.enable_upgrade_migration_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool MigrationOptions::_internal_enable_upgrade_migration() const {
  return _impl_.enable_upgrade_migration_;
}
inline bool MigrationOptions::enable_upgrade_migration() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MigrationOptions.enable_upgrade_migration)
  return _internal_enable_upgrade_migration();
}
inline void MigrationOptions::_internal_set_enable_upgrade_migration(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enable_upgrade_migration_ = value;
}
inline void MigrationOptions::set_enable_upgrade_migration(bool value) {
  _internal_set_enable_upgrade_migration(value);
  // @@protoc_insertion_point(field_set:ml_metadata.MigrationOptions.enable_upgrade_migration)
}

// optional int64 downgrade_to_schema_version = 2 [default = -1];
inline bool MigrationOptions::_internal_has_downgrade_to_schema_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MigrationOptions::has_downgrade_to_schema_version() const {
  return _internal_has_downgrade_to_schema_version();
}
inline void MigrationOptions::clear_downgrade_to_schema_version() {
  _impl_.downgrade_to_schema_version_ = int64_t{-1};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t MigrationOptions::_internal_downgrade_to_schema_version() const {
  return _impl_.downgrade_to_schema_version_;
}
inline int64_t MigrationOptions::downgrade_to_schema_version() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MigrationOptions.downgrade_to_schema_version)
  return _internal_downgrade_to_schema_version();
}
inline void MigrationOptions::_internal_set_downgrade_to_schema_version(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.downgrade_to_schema_version_ = value;
}
inline void MigrationOptions::set_downgrade_to_schema_version(int64_t value) {
  _internal_set_downgrade_to_schema_version(value);
  // @@protoc_insertion_point(field_set:ml_metadata.MigrationOptions.downgrade_to_schema_version)
}

// -------------------------------------------------------------------

// RetryOptions

// optional int64 max_num_retries = 1;
inline bool RetryOptions::_internal_has_max_num_retries() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RetryOptions::has_max_num_retries() const {
  return _internal_has_max_num_retries();
}
inline void RetryOptions::clear_max_num_retries() {
  _impl_.max_num_retries_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t RetryOptions::_internal_max_num_retries() const {
  return _impl_.max_num_retries_;
}
inline int64_t RetryOptions::max_num_retries() const {
  // @@protoc_insertion_point(field_get:ml_metadata.RetryOptions.max_num_retries)
  return _internal_max_num_retries();
}
inline void RetryOptions::_internal_set_max_num_retries(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.max_num_retries_ = value;
}
inline void RetryOptions::set_max_num_retries(int64_t value) {
  _internal_set_max_num_retries(value);
  // @@protoc_insertion_point(field_set:ml_metadata.RetryOptions.max_num_retries)
}

// -------------------------------------------------------------------

// ConnectionConfig

// .ml_metadata.FakeDatabaseConfig fake_database = 1;
inline bool ConnectionConfig::_internal_has_fake_database() const {
  return config_case() == kFakeDatabase;
}
inline bool ConnectionConfig::has_fake_database() const {
  return _internal_has_fake_database();
}
inline void ConnectionConfig::set_has_fake_database() {
  _impl_._oneof_case_[0] = kFakeDatabase;
}
inline void ConnectionConfig::clear_fake_database() {
  if (_internal_has_fake_database()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.fake_database_;
    }
    clear_has_config();
  }
}
inline ::ml_metadata::FakeDatabaseConfig* ConnectionConfig::release_fake_database() {
  // @@protoc_insertion_point(field_release:ml_metadata.ConnectionConfig.fake_database)
  if (_internal_has_fake_database()) {
    clear_has_config();
    ::ml_metadata::FakeDatabaseConfig* temp = _impl_.config_.fake_database_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.fake_database_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::FakeDatabaseConfig& ConnectionConfig::_internal_fake_database() const {
  return _internal_has_fake_database()
      ? *_impl_.config_.fake_database_
      : reinterpret_cast< ::ml_metadata::FakeDatabaseConfig&>(::ml_metadata::_FakeDatabaseConfig_default_instance_);
}
inline const ::ml_metadata::FakeDatabaseConfig& ConnectionConfig::fake_database() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ConnectionConfig.fake_database)
  return _internal_fake_database();
}
inline ::ml_metadata::FakeDatabaseConfig* ConnectionConfig::unsafe_arena_release_fake_database() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.ConnectionConfig.fake_database)
  if (_internal_has_fake_database()) {
    clear_has_config();
    ::ml_metadata::FakeDatabaseConfig* temp = _impl_.config_.fake_database_;
    _impl_.config_.fake_database_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConnectionConfig::unsafe_arena_set_allocated_fake_database(::ml_metadata::FakeDatabaseConfig* fake_database) {
  clear_config();
  if (fake_database) {
    set_has_fake_database();
    _impl_.config_.fake_database_ = fake_database;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ConnectionConfig.fake_database)
}
inline ::ml_metadata::FakeDatabaseConfig* ConnectionConfig::_internal_mutable_fake_database() {
  if (!_internal_has_fake_database()) {
    clear_config();
    set_has_fake_database();
    _impl_.config_.fake_database_ = CreateMaybeMessage< ::ml_metadata::FakeDatabaseConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.fake_database_;
}
inline ::ml_metadata::FakeDatabaseConfig* ConnectionConfig::mutable_fake_database() {
  ::ml_metadata::FakeDatabaseConfig* _msg = _internal_mutable_fake_database();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ConnectionConfig.fake_database)
  return _msg;
}

// .ml_metadata.MySQLDatabaseConfig mysql = 2;
inline bool ConnectionConfig::_internal_has_mysql() const {
  return config_case() == kMysql;
}
inline bool ConnectionConfig::has_mysql() const {
  return _internal_has_mysql();
}
inline void ConnectionConfig::set_has_mysql() {
  _impl_._oneof_case_[0] = kMysql;
}
inline void ConnectionConfig::clear_mysql() {
  if (_internal_has_mysql()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.mysql_;
    }
    clear_has_config();
  }
}
inline ::ml_metadata::MySQLDatabaseConfig* ConnectionConfig::release_mysql() {
  // @@protoc_insertion_point(field_release:ml_metadata.ConnectionConfig.mysql)
  if (_internal_has_mysql()) {
    clear_has_config();
    ::ml_metadata::MySQLDatabaseConfig* temp = _impl_.config_.mysql_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.mysql_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::MySQLDatabaseConfig& ConnectionConfig::_internal_mysql() const {
  return _internal_has_mysql()
      ? *_impl_.config_.mysql_
      : reinterpret_cast< ::ml_metadata::MySQLDatabaseConfig&>(::ml_metadata::_MySQLDatabaseConfig_default_instance_);
}
inline const ::ml_metadata::MySQLDatabaseConfig& ConnectionConfig::mysql() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ConnectionConfig.mysql)
  return _internal_mysql();
}
inline ::ml_metadata::MySQLDatabaseConfig* ConnectionConfig::unsafe_arena_release_mysql() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.ConnectionConfig.mysql)
  if (_internal_has_mysql()) {
    clear_has_config();
    ::ml_metadata::MySQLDatabaseConfig* temp = _impl_.config_.mysql_;
    _impl_.config_.mysql_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConnectionConfig::unsafe_arena_set_allocated_mysql(::ml_metadata::MySQLDatabaseConfig* mysql) {
  clear_config();
  if (mysql) {
    set_has_mysql();
    _impl_.config_.mysql_ = mysql;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ConnectionConfig.mysql)
}
inline ::ml_metadata::MySQLDatabaseConfig* ConnectionConfig::_internal_mutable_mysql() {
  if (!_internal_has_mysql()) {
    clear_config();
    set_has_mysql();
    _impl_.config_.mysql_ = CreateMaybeMessage< ::ml_metadata::MySQLDatabaseConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.mysql_;
}
inline ::ml_metadata::MySQLDatabaseConfig* ConnectionConfig::mutable_mysql() {
  ::ml_metadata::MySQLDatabaseConfig* _msg = _internal_mutable_mysql();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ConnectionConfig.mysql)
  return _msg;
}

// .ml_metadata.SqliteMetadataSourceConfig sqlite = 3;
inline bool ConnectionConfig::_internal_has_sqlite() const {
  return config_case() == kSqlite;
}
inline bool ConnectionConfig::has_sqlite() const {
  return _internal_has_sqlite();
}
inline void ConnectionConfig::set_has_sqlite() {
  _impl_._oneof_case_[0] = kSqlite;
}
inline void ConnectionConfig::clear_sqlite() {
  if (_internal_has_sqlite()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.sqlite_;
    }
    clear_has_config();
  }
}
inline ::ml_metadata::SqliteMetadataSourceConfig* ConnectionConfig::release_sqlite() {
  // @@protoc_insertion_point(field_release:ml_metadata.ConnectionConfig.sqlite)
  if (_internal_has_sqlite()) {
    clear_has_config();
    ::ml_metadata::SqliteMetadataSourceConfig* temp = _impl_.config_.sqlite_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.sqlite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::SqliteMetadataSourceConfig& ConnectionConfig::_internal_sqlite() const {
  return _internal_has_sqlite()
      ? *_impl_.config_.sqlite_
      : reinterpret_cast< ::ml_metadata::SqliteMetadataSourceConfig&>(::ml_metadata::_SqliteMetadataSourceConfig_default_instance_);
}
inline const ::ml_metadata::SqliteMetadataSourceConfig& ConnectionConfig::sqlite() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ConnectionConfig.sqlite)
  return _internal_sqlite();
}
inline ::ml_metadata::SqliteMetadataSourceConfig* ConnectionConfig::unsafe_arena_release_sqlite() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.ConnectionConfig.sqlite)
  if (_internal_has_sqlite()) {
    clear_has_config();
    ::ml_metadata::SqliteMetadataSourceConfig* temp = _impl_.config_.sqlite_;
    _impl_.config_.sqlite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConnectionConfig::unsafe_arena_set_allocated_sqlite(::ml_metadata::SqliteMetadataSourceConfig* sqlite) {
  clear_config();
  if (sqlite) {
    set_has_sqlite();
    _impl_.config_.sqlite_ = sqlite;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ConnectionConfig.sqlite)
}
inline ::ml_metadata::SqliteMetadataSourceConfig* ConnectionConfig::_internal_mutable_sqlite() {
  if (!_internal_has_sqlite()) {
    clear_config();
    set_has_sqlite();
    _impl_.config_.sqlite_ = CreateMaybeMessage< ::ml_metadata::SqliteMetadataSourceConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.sqlite_;
}
inline ::ml_metadata::SqliteMetadataSourceConfig* ConnectionConfig::mutable_sqlite() {
  ::ml_metadata::SqliteMetadataSourceConfig* _msg = _internal_mutable_sqlite();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ConnectionConfig.sqlite)
  return _msg;
}

// .ml_metadata.PostgreSQLDatabaseConfig postgresql = 5;
inline bool ConnectionConfig::_internal_has_postgresql() const {
  return config_case() == kPostgresql;
}
inline bool ConnectionConfig::has_postgresql() const {
  return _internal_has_postgresql();
}
inline void ConnectionConfig::set_has_postgresql() {
  _impl_._oneof_case_[0] = kPostgresql;
}
inline void ConnectionConfig::clear_postgresql() {
  if (_internal_has_postgresql()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.config_.postgresql_;
    }
    clear_has_config();
  }
}
inline ::ml_metadata::PostgreSQLDatabaseConfig* ConnectionConfig::release_postgresql() {
  // @@protoc_insertion_point(field_release:ml_metadata.ConnectionConfig.postgresql)
  if (_internal_has_postgresql()) {
    clear_has_config();
    ::ml_metadata::PostgreSQLDatabaseConfig* temp = _impl_.config_.postgresql_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.postgresql_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::PostgreSQLDatabaseConfig& ConnectionConfig::_internal_postgresql() const {
  return _internal_has_postgresql()
      ? *_impl_.config_.postgresql_
      : reinterpret_cast< ::ml_metadata::PostgreSQLDatabaseConfig&>(::ml_metadata::_PostgreSQLDatabaseConfig_default_instance_);
}
inline const ::ml_metadata::PostgreSQLDatabaseConfig& ConnectionConfig::postgresql() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ConnectionConfig.postgresql)
  return _internal_postgresql();
}
inline ::ml_metadata::PostgreSQLDatabaseConfig* ConnectionConfig::unsafe_arena_release_postgresql() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.ConnectionConfig.postgresql)
  if (_internal_has_postgresql()) {
    clear_has_config();
    ::ml_metadata::PostgreSQLDatabaseConfig* temp = _impl_.config_.postgresql_;
    _impl_.config_.postgresql_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConnectionConfig::unsafe_arena_set_allocated_postgresql(::ml_metadata::PostgreSQLDatabaseConfig* postgresql) {
  clear_config();
  if (postgresql) {
    set_has_postgresql();
    _impl_.config_.postgresql_ = postgresql;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ConnectionConfig.postgresql)
}
inline ::ml_metadata::PostgreSQLDatabaseConfig* ConnectionConfig::_internal_mutable_postgresql() {
  if (!_internal_has_postgresql()) {
    clear_config();
    set_has_postgresql();
    _impl_.config_.postgresql_ = CreateMaybeMessage< ::ml_metadata::PostgreSQLDatabaseConfig >(GetArenaForAllocation());
  }
  return _impl_.config_.postgresql_;
}
inline ::ml_metadata::PostgreSQLDatabaseConfig* ConnectionConfig::mutable_postgresql() {
  ::ml_metadata::PostgreSQLDatabaseConfig* _msg = _internal_mutable_postgresql();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ConnectionConfig.postgresql)
  return _msg;
}

// optional .ml_metadata.RetryOptions retry_options = 4;
inline bool ConnectionConfig::_internal_has_retry_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.retry_options_ != nullptr);
  return value;
}
inline bool ConnectionConfig::has_retry_options() const {
  return _internal_has_retry_options();
}
inline void ConnectionConfig::clear_retry_options() {
  if (_impl_.retry_options_ != nullptr) _impl_.retry_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::RetryOptions& ConnectionConfig::_internal_retry_options() const {
  const ::ml_metadata::RetryOptions* p = _impl_.retry_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::RetryOptions&>(
      ::ml_metadata::_RetryOptions_default_instance_);
}
inline const ::ml_metadata::RetryOptions& ConnectionConfig::retry_options() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ConnectionConfig.retry_options)
  return _internal_retry_options();
}
inline void ConnectionConfig::unsafe_arena_set_allocated_retry_options(
    ::ml_metadata::RetryOptions* retry_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.retry_options_);
  }
  _impl_.retry_options_ = retry_options;
  if (retry_options) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ConnectionConfig.retry_options)
}
inline ::ml_metadata::RetryOptions* ConnectionConfig::release_retry_options() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::RetryOptions* temp = _impl_.retry_options_;
  _impl_.retry_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::RetryOptions* ConnectionConfig::unsafe_arena_release_retry_options() {
  // @@protoc_insertion_point(field_release:ml_metadata.ConnectionConfig.retry_options)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::RetryOptions* temp = _impl_.retry_options_;
  _impl_.retry_options_ = nullptr;
  return temp;
}
inline ::ml_metadata::RetryOptions* ConnectionConfig::_internal_mutable_retry_options() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.retry_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::RetryOptions>(GetArenaForAllocation());
    _impl_.retry_options_ = p;
  }
  return _impl_.retry_options_;
}
inline ::ml_metadata::RetryOptions* ConnectionConfig::mutable_retry_options() {
  ::ml_metadata::RetryOptions* _msg = _internal_mutable_retry_options();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ConnectionConfig.retry_options)
  return _msg;
}
inline void ConnectionConfig::set_allocated_retry_options(::ml_metadata::RetryOptions* retry_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.retry_options_;
  }
  if (retry_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(retry_options);
    if (message_arena != submessage_arena) {
      retry_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, retry_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.retry_options_ = retry_options;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ConnectionConfig.retry_options)
}

inline bool ConnectionConfig::has_config() const {
  return config_case() != CONFIG_NOT_SET;
}
inline void ConnectionConfig::clear_has_config() {
  _impl_._oneof_case_[0] = CONFIG_NOT_SET;
}
inline ConnectionConfig::ConfigCase ConnectionConfig::config_case() const {
  return ConnectionConfig::ConfigCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GrpcChannelArguments

// optional int64 max_receive_message_length = 1;
inline bool GrpcChannelArguments::_internal_has_max_receive_message_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GrpcChannelArguments::has_max_receive_message_length() const {
  return _internal_has_max_receive_message_length();
}
inline void GrpcChannelArguments::clear_max_receive_message_length() {
  _impl_.max_receive_message_length_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t GrpcChannelArguments::_internal_max_receive_message_length() const {
  return _impl_.max_receive_message_length_;
}
inline int64_t GrpcChannelArguments::max_receive_message_length() const {
  // @@protoc_insertion_point(field_get:ml_metadata.GrpcChannelArguments.max_receive_message_length)
  return _internal_max_receive_message_length();
}
inline void GrpcChannelArguments::_internal_set_max_receive_message_length(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.max_receive_message_length_ = value;
}
inline void GrpcChannelArguments::set_max_receive_message_length(int64_t value) {
  _internal_set_max_receive_message_length(value);
  // @@protoc_insertion_point(field_set:ml_metadata.GrpcChannelArguments.max_receive_message_length)
}

// optional int64 http2_max_ping_strikes = 2;
inline bool GrpcChannelArguments::_internal_has_http2_max_ping_strikes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GrpcChannelArguments::has_http2_max_ping_strikes() const {
  return _internal_has_http2_max_ping_strikes();
}
inline void GrpcChannelArguments::clear_http2_max_ping_strikes() {
  _impl_.http2_max_ping_strikes_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t GrpcChannelArguments::_internal_http2_max_ping_strikes() const {
  return _impl_.http2_max_ping_strikes_;
}
inline int64_t GrpcChannelArguments::http2_max_ping_strikes() const {
  // @@protoc_insertion_point(field_get:ml_metadata.GrpcChannelArguments.http2_max_ping_strikes)
  return _internal_http2_max_ping_strikes();
}
inline void GrpcChannelArguments::_internal_set_http2_max_ping_strikes(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.http2_max_ping_strikes_ = value;
}
inline void GrpcChannelArguments::set_http2_max_ping_strikes(int64_t value) {
  _internal_set_http2_max_ping_strikes(value);
  // @@protoc_insertion_point(field_set:ml_metadata.GrpcChannelArguments.http2_max_ping_strikes)
}

// -------------------------------------------------------------------

// MetadataStoreClientConfig_SSLConfig

// optional string client_key = 1;
inline bool MetadataStoreClientConfig_SSLConfig::_internal_has_client_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MetadataStoreClientConfig_SSLConfig::has_client_key() const {
  return _internal_has_client_key();
}
inline void MetadataStoreClientConfig_SSLConfig::clear_client_key() {
  _impl_.client_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MetadataStoreClientConfig_SSLConfig::client_key() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreClientConfig.SSLConfig.client_key)
  return _internal_client_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetadataStoreClientConfig_SSLConfig::set_client_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.client_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MetadataStoreClientConfig.SSLConfig.client_key)
}
inline std::string* MetadataStoreClientConfig_SSLConfig::mutable_client_key() {
  std::string* _s = _internal_mutable_client_key();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MetadataStoreClientConfig.SSLConfig.client_key)
  return _s;
}
inline const std::string& MetadataStoreClientConfig_SSLConfig::_internal_client_key() const {
  return _impl_.client_key_.Get();
}
inline void MetadataStoreClientConfig_SSLConfig::_internal_set_client_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MetadataStoreClientConfig_SSLConfig::_internal_mutable_client_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.client_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MetadataStoreClientConfig_SSLConfig::release_client_key() {
  // @@protoc_insertion_point(field_release:ml_metadata.MetadataStoreClientConfig.SSLConfig.client_key)
  if (!_internal_has_client_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.client_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_key_.IsDefault()) {
    _impl_.client_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MetadataStoreClientConfig_SSLConfig::set_allocated_client_key(std::string* client_key) {
  if (client_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.client_key_.SetAllocated(client_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_key_.IsDefault()) {
    _impl_.client_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MetadataStoreClientConfig.SSLConfig.client_key)
}

// optional string server_cert = 2;
inline bool MetadataStoreClientConfig_SSLConfig::_internal_has_server_cert() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MetadataStoreClientConfig_SSLConfig::has_server_cert() const {
  return _internal_has_server_cert();
}
inline void MetadataStoreClientConfig_SSLConfig::clear_server_cert() {
  _impl_.server_cert_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MetadataStoreClientConfig_SSLConfig::server_cert() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreClientConfig.SSLConfig.server_cert)
  return _internal_server_cert();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetadataStoreClientConfig_SSLConfig::set_server_cert(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.server_cert_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MetadataStoreClientConfig.SSLConfig.server_cert)
}
inline std::string* MetadataStoreClientConfig_SSLConfig::mutable_server_cert() {
  std::string* _s = _internal_mutable_server_cert();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MetadataStoreClientConfig.SSLConfig.server_cert)
  return _s;
}
inline const std::string& MetadataStoreClientConfig_SSLConfig::_internal_server_cert() const {
  return _impl_.server_cert_.Get();
}
inline void MetadataStoreClientConfig_SSLConfig::_internal_set_server_cert(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.server_cert_.Set(value, GetArenaForAllocation());
}
inline std::string* MetadataStoreClientConfig_SSLConfig::_internal_mutable_server_cert() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.server_cert_.Mutable(GetArenaForAllocation());
}
inline std::string* MetadataStoreClientConfig_SSLConfig::release_server_cert() {
  // @@protoc_insertion_point(field_release:ml_metadata.MetadataStoreClientConfig.SSLConfig.server_cert)
  if (!_internal_has_server_cert()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.server_cert_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_cert_.IsDefault()) {
    _impl_.server_cert_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MetadataStoreClientConfig_SSLConfig::set_allocated_server_cert(std::string* server_cert) {
  if (server_cert != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.server_cert_.SetAllocated(server_cert, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_cert_.IsDefault()) {
    _impl_.server_cert_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MetadataStoreClientConfig.SSLConfig.server_cert)
}

// optional string custom_ca = 3;
inline bool MetadataStoreClientConfig_SSLConfig::_internal_has_custom_ca() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MetadataStoreClientConfig_SSLConfig::has_custom_ca() const {
  return _internal_has_custom_ca();
}
inline void MetadataStoreClientConfig_SSLConfig::clear_custom_ca() {
  _impl_.custom_ca_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MetadataStoreClientConfig_SSLConfig::custom_ca() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreClientConfig.SSLConfig.custom_ca)
  return _internal_custom_ca();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetadataStoreClientConfig_SSLConfig::set_custom_ca(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.custom_ca_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MetadataStoreClientConfig.SSLConfig.custom_ca)
}
inline std::string* MetadataStoreClientConfig_SSLConfig::mutable_custom_ca() {
  std::string* _s = _internal_mutable_custom_ca();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MetadataStoreClientConfig.SSLConfig.custom_ca)
  return _s;
}
inline const std::string& MetadataStoreClientConfig_SSLConfig::_internal_custom_ca() const {
  return _impl_.custom_ca_.Get();
}
inline void MetadataStoreClientConfig_SSLConfig::_internal_set_custom_ca(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.custom_ca_.Set(value, GetArenaForAllocation());
}
inline std::string* MetadataStoreClientConfig_SSLConfig::_internal_mutable_custom_ca() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.custom_ca_.Mutable(GetArenaForAllocation());
}
inline std::string* MetadataStoreClientConfig_SSLConfig::release_custom_ca() {
  // @@protoc_insertion_point(field_release:ml_metadata.MetadataStoreClientConfig.SSLConfig.custom_ca)
  if (!_internal_has_custom_ca()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.custom_ca_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.custom_ca_.IsDefault()) {
    _impl_.custom_ca_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MetadataStoreClientConfig_SSLConfig::set_allocated_custom_ca(std::string* custom_ca) {
  if (custom_ca != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.custom_ca_.SetAllocated(custom_ca, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.custom_ca_.IsDefault()) {
    _impl_.custom_ca_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MetadataStoreClientConfig.SSLConfig.custom_ca)
}

// -------------------------------------------------------------------

// MetadataStoreClientConfig

// optional string host = 1;
inline bool MetadataStoreClientConfig::_internal_has_host() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MetadataStoreClientConfig::has_host() const {
  return _internal_has_host();
}
inline void MetadataStoreClientConfig::clear_host() {
  _impl_.host_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MetadataStoreClientConfig::host() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreClientConfig.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetadataStoreClientConfig::set_host(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MetadataStoreClientConfig.host)
}
inline std::string* MetadataStoreClientConfig::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MetadataStoreClientConfig.host)
  return _s;
}
inline const std::string& MetadataStoreClientConfig::_internal_host() const {
  return _impl_.host_.Get();
}
inline void MetadataStoreClientConfig::_internal_set_host(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* MetadataStoreClientConfig::_internal_mutable_host() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* MetadataStoreClientConfig::release_host() {
  // @@protoc_insertion_point(field_release:ml_metadata.MetadataStoreClientConfig.host)
  if (!_internal_has_host()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.host_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MetadataStoreClientConfig::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MetadataStoreClientConfig.host)
}

// optional int64 port = 2;
inline bool MetadataStoreClientConfig::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MetadataStoreClientConfig::has_port() const {
  return _internal_has_port();
}
inline void MetadataStoreClientConfig::clear_port() {
  _impl_.port_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t MetadataStoreClientConfig::_internal_port() const {
  return _impl_.port_;
}
inline int64_t MetadataStoreClientConfig::port() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreClientConfig.port)
  return _internal_port();
}
inline void MetadataStoreClientConfig::_internal_set_port(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.port_ = value;
}
inline void MetadataStoreClientConfig::set_port(int64_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:ml_metadata.MetadataStoreClientConfig.port)
}

// optional .ml_metadata.MetadataStoreClientConfig.SSLConfig ssl_config = 3;
inline bool MetadataStoreClientConfig::_internal_has_ssl_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ssl_config_ != nullptr);
  return value;
}
inline bool MetadataStoreClientConfig::has_ssl_config() const {
  return _internal_has_ssl_config();
}
inline void MetadataStoreClientConfig::clear_ssl_config() {
  if (_impl_.ssl_config_ != nullptr) _impl_.ssl_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ml_metadata::MetadataStoreClientConfig_SSLConfig& MetadataStoreClientConfig::_internal_ssl_config() const {
  const ::ml_metadata::MetadataStoreClientConfig_SSLConfig* p = _impl_.ssl_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::MetadataStoreClientConfig_SSLConfig&>(
      ::ml_metadata::_MetadataStoreClientConfig_SSLConfig_default_instance_);
}
inline const ::ml_metadata::MetadataStoreClientConfig_SSLConfig& MetadataStoreClientConfig::ssl_config() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreClientConfig.ssl_config)
  return _internal_ssl_config();
}
inline void MetadataStoreClientConfig::unsafe_arena_set_allocated_ssl_config(
    ::ml_metadata::MetadataStoreClientConfig_SSLConfig* ssl_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ssl_config_);
  }
  _impl_.ssl_config_ = ssl_config;
  if (ssl_config) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.MetadataStoreClientConfig.ssl_config)
}
inline ::ml_metadata::MetadataStoreClientConfig_SSLConfig* MetadataStoreClientConfig::release_ssl_config() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ml_metadata::MetadataStoreClientConfig_SSLConfig* temp = _impl_.ssl_config_;
  _impl_.ssl_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::MetadataStoreClientConfig_SSLConfig* MetadataStoreClientConfig::unsafe_arena_release_ssl_config() {
  // @@protoc_insertion_point(field_release:ml_metadata.MetadataStoreClientConfig.ssl_config)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ml_metadata::MetadataStoreClientConfig_SSLConfig* temp = _impl_.ssl_config_;
  _impl_.ssl_config_ = nullptr;
  return temp;
}
inline ::ml_metadata::MetadataStoreClientConfig_SSLConfig* MetadataStoreClientConfig::_internal_mutable_ssl_config() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ssl_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::MetadataStoreClientConfig_SSLConfig>(GetArenaForAllocation());
    _impl_.ssl_config_ = p;
  }
  return _impl_.ssl_config_;
}
inline ::ml_metadata::MetadataStoreClientConfig_SSLConfig* MetadataStoreClientConfig::mutable_ssl_config() {
  ::ml_metadata::MetadataStoreClientConfig_SSLConfig* _msg = _internal_mutable_ssl_config();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MetadataStoreClientConfig.ssl_config)
  return _msg;
}
inline void MetadataStoreClientConfig::set_allocated_ssl_config(::ml_metadata::MetadataStoreClientConfig_SSLConfig* ssl_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ssl_config_;
  }
  if (ssl_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ssl_config);
    if (message_arena != submessage_arena) {
      ssl_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ssl_config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ssl_config_ = ssl_config;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MetadataStoreClientConfig.ssl_config)
}

// optional .ml_metadata.GrpcChannelArguments channel_arguments = 4;
inline bool MetadataStoreClientConfig::_internal_has_channel_arguments() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.channel_arguments_ != nullptr);
  return value;
}
inline bool MetadataStoreClientConfig::has_channel_arguments() const {
  return _internal_has_channel_arguments();
}
inline void MetadataStoreClientConfig::clear_channel_arguments() {
  if (_impl_.channel_arguments_ != nullptr) _impl_.channel_arguments_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ml_metadata::GrpcChannelArguments& MetadataStoreClientConfig::_internal_channel_arguments() const {
  const ::ml_metadata::GrpcChannelArguments* p = _impl_.channel_arguments_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::GrpcChannelArguments&>(
      ::ml_metadata::_GrpcChannelArguments_default_instance_);
}
inline const ::ml_metadata::GrpcChannelArguments& MetadataStoreClientConfig::channel_arguments() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreClientConfig.channel_arguments)
  return _internal_channel_arguments();
}
inline void MetadataStoreClientConfig::unsafe_arena_set_allocated_channel_arguments(
    ::ml_metadata::GrpcChannelArguments* channel_arguments) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.channel_arguments_);
  }
  _impl_.channel_arguments_ = channel_arguments;
  if (channel_arguments) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.MetadataStoreClientConfig.channel_arguments)
}
inline ::ml_metadata::GrpcChannelArguments* MetadataStoreClientConfig::release_channel_arguments() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ml_metadata::GrpcChannelArguments* temp = _impl_.channel_arguments_;
  _impl_.channel_arguments_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::GrpcChannelArguments* MetadataStoreClientConfig::unsafe_arena_release_channel_arguments() {
  // @@protoc_insertion_point(field_release:ml_metadata.MetadataStoreClientConfig.channel_arguments)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ml_metadata::GrpcChannelArguments* temp = _impl_.channel_arguments_;
  _impl_.channel_arguments_ = nullptr;
  return temp;
}
inline ::ml_metadata::GrpcChannelArguments* MetadataStoreClientConfig::_internal_mutable_channel_arguments() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.channel_arguments_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::GrpcChannelArguments>(GetArenaForAllocation());
    _impl_.channel_arguments_ = p;
  }
  return _impl_.channel_arguments_;
}
inline ::ml_metadata::GrpcChannelArguments* MetadataStoreClientConfig::mutable_channel_arguments() {
  ::ml_metadata::GrpcChannelArguments* _msg = _internal_mutable_channel_arguments();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MetadataStoreClientConfig.channel_arguments)
  return _msg;
}
inline void MetadataStoreClientConfig::set_allocated_channel_arguments(::ml_metadata::GrpcChannelArguments* channel_arguments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.channel_arguments_;
  }
  if (channel_arguments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(channel_arguments);
    if (message_arena != submessage_arena) {
      channel_arguments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, channel_arguments, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.channel_arguments_ = channel_arguments;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MetadataStoreClientConfig.channel_arguments)
}

// optional double client_timeout_sec = 5;
inline bool MetadataStoreClientConfig::_internal_has_client_timeout_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MetadataStoreClientConfig::has_client_timeout_sec() const {
  return _internal_has_client_timeout_sec();
}
inline void MetadataStoreClientConfig::clear_client_timeout_sec() {
  _impl_.client_timeout_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double MetadataStoreClientConfig::_internal_client_timeout_sec() const {
  return _impl_.client_timeout_sec_;
}
inline double MetadataStoreClientConfig::client_timeout_sec() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreClientConfig.client_timeout_sec)
  return _internal_client_timeout_sec();
}
inline void MetadataStoreClientConfig::_internal_set_client_timeout_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.client_timeout_sec_ = value;
}
inline void MetadataStoreClientConfig::set_client_timeout_sec(double value) {
  _internal_set_client_timeout_sec(value);
  // @@protoc_insertion_point(field_set:ml_metadata.MetadataStoreClientConfig.client_timeout_sec)
}

// -------------------------------------------------------------------

// MetadataStoreServerConfig_SSLConfig

// optional string server_key = 1;
inline bool MetadataStoreServerConfig_SSLConfig::_internal_has_server_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MetadataStoreServerConfig_SSLConfig::has_server_key() const {
  return _internal_has_server_key();
}
inline void MetadataStoreServerConfig_SSLConfig::clear_server_key() {
  _impl_.server_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MetadataStoreServerConfig_SSLConfig::server_key() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreServerConfig.SSLConfig.server_key)
  return _internal_server_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetadataStoreServerConfig_SSLConfig::set_server_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.server_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MetadataStoreServerConfig.SSLConfig.server_key)
}
inline std::string* MetadataStoreServerConfig_SSLConfig::mutable_server_key() {
  std::string* _s = _internal_mutable_server_key();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MetadataStoreServerConfig.SSLConfig.server_key)
  return _s;
}
inline const std::string& MetadataStoreServerConfig_SSLConfig::_internal_server_key() const {
  return _impl_.server_key_.Get();
}
inline void MetadataStoreServerConfig_SSLConfig::_internal_set_server_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MetadataStoreServerConfig_SSLConfig::_internal_mutable_server_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.server_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MetadataStoreServerConfig_SSLConfig::release_server_key() {
  // @@protoc_insertion_point(field_release:ml_metadata.MetadataStoreServerConfig.SSLConfig.server_key)
  if (!_internal_has_server_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.server_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_key_.IsDefault()) {
    _impl_.server_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MetadataStoreServerConfig_SSLConfig::set_allocated_server_key(std::string* server_key) {
  if (server_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.server_key_.SetAllocated(server_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_key_.IsDefault()) {
    _impl_.server_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MetadataStoreServerConfig.SSLConfig.server_key)
}

// optional string server_cert = 2;
inline bool MetadataStoreServerConfig_SSLConfig::_internal_has_server_cert() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MetadataStoreServerConfig_SSLConfig::has_server_cert() const {
  return _internal_has_server_cert();
}
inline void MetadataStoreServerConfig_SSLConfig::clear_server_cert() {
  _impl_.server_cert_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MetadataStoreServerConfig_SSLConfig::server_cert() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreServerConfig.SSLConfig.server_cert)
  return _internal_server_cert();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetadataStoreServerConfig_SSLConfig::set_server_cert(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.server_cert_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MetadataStoreServerConfig.SSLConfig.server_cert)
}
inline std::string* MetadataStoreServerConfig_SSLConfig::mutable_server_cert() {
  std::string* _s = _internal_mutable_server_cert();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MetadataStoreServerConfig.SSLConfig.server_cert)
  return _s;
}
inline const std::string& MetadataStoreServerConfig_SSLConfig::_internal_server_cert() const {
  return _impl_.server_cert_.Get();
}
inline void MetadataStoreServerConfig_SSLConfig::_internal_set_server_cert(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.server_cert_.Set(value, GetArenaForAllocation());
}
inline std::string* MetadataStoreServerConfig_SSLConfig::_internal_mutable_server_cert() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.server_cert_.Mutable(GetArenaForAllocation());
}
inline std::string* MetadataStoreServerConfig_SSLConfig::release_server_cert() {
  // @@protoc_insertion_point(field_release:ml_metadata.MetadataStoreServerConfig.SSLConfig.server_cert)
  if (!_internal_has_server_cert()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.server_cert_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_cert_.IsDefault()) {
    _impl_.server_cert_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MetadataStoreServerConfig_SSLConfig::set_allocated_server_cert(std::string* server_cert) {
  if (server_cert != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.server_cert_.SetAllocated(server_cert, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_cert_.IsDefault()) {
    _impl_.server_cert_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MetadataStoreServerConfig.SSLConfig.server_cert)
}

// optional string custom_ca = 3;
inline bool MetadataStoreServerConfig_SSLConfig::_internal_has_custom_ca() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MetadataStoreServerConfig_SSLConfig::has_custom_ca() const {
  return _internal_has_custom_ca();
}
inline void MetadataStoreServerConfig_SSLConfig::clear_custom_ca() {
  _impl_.custom_ca_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MetadataStoreServerConfig_SSLConfig::custom_ca() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreServerConfig.SSLConfig.custom_ca)
  return _internal_custom_ca();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetadataStoreServerConfig_SSLConfig::set_custom_ca(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.custom_ca_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.MetadataStoreServerConfig.SSLConfig.custom_ca)
}
inline std::string* MetadataStoreServerConfig_SSLConfig::mutable_custom_ca() {
  std::string* _s = _internal_mutable_custom_ca();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MetadataStoreServerConfig.SSLConfig.custom_ca)
  return _s;
}
inline const std::string& MetadataStoreServerConfig_SSLConfig::_internal_custom_ca() const {
  return _impl_.custom_ca_.Get();
}
inline void MetadataStoreServerConfig_SSLConfig::_internal_set_custom_ca(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.custom_ca_.Set(value, GetArenaForAllocation());
}
inline std::string* MetadataStoreServerConfig_SSLConfig::_internal_mutable_custom_ca() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.custom_ca_.Mutable(GetArenaForAllocation());
}
inline std::string* MetadataStoreServerConfig_SSLConfig::release_custom_ca() {
  // @@protoc_insertion_point(field_release:ml_metadata.MetadataStoreServerConfig.SSLConfig.custom_ca)
  if (!_internal_has_custom_ca()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.custom_ca_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.custom_ca_.IsDefault()) {
    _impl_.custom_ca_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MetadataStoreServerConfig_SSLConfig::set_allocated_custom_ca(std::string* custom_ca) {
  if (custom_ca != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.custom_ca_.SetAllocated(custom_ca, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.custom_ca_.IsDefault()) {
    _impl_.custom_ca_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MetadataStoreServerConfig.SSLConfig.custom_ca)
}

// optional bool client_verify = 4;
inline bool MetadataStoreServerConfig_SSLConfig::_internal_has_client_verify() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MetadataStoreServerConfig_SSLConfig::has_client_verify() const {
  return _internal_has_client_verify();
}
inline void MetadataStoreServerConfig_SSLConfig::clear_client_verify() {
  _impl_.client_verify_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool MetadataStoreServerConfig_SSLConfig::_internal_client_verify() const {
  return _impl_.client_verify_;
}
inline bool MetadataStoreServerConfig_SSLConfig::client_verify() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreServerConfig.SSLConfig.client_verify)
  return _internal_client_verify();
}
inline void MetadataStoreServerConfig_SSLConfig::_internal_set_client_verify(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.client_verify_ = value;
}
inline void MetadataStoreServerConfig_SSLConfig::set_client_verify(bool value) {
  _internal_set_client_verify(value);
  // @@protoc_insertion_point(field_set:ml_metadata.MetadataStoreServerConfig.SSLConfig.client_verify)
}

// -------------------------------------------------------------------

// MetadataStoreServerConfig

// optional .ml_metadata.ConnectionConfig connection_config = 1;
inline bool MetadataStoreServerConfig::_internal_has_connection_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.connection_config_ != nullptr);
  return value;
}
inline bool MetadataStoreServerConfig::has_connection_config() const {
  return _internal_has_connection_config();
}
inline void MetadataStoreServerConfig::clear_connection_config() {
  if (_impl_.connection_config_ != nullptr) _impl_.connection_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::ConnectionConfig& MetadataStoreServerConfig::_internal_connection_config() const {
  const ::ml_metadata::ConnectionConfig* p = _impl_.connection_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::ConnectionConfig&>(
      ::ml_metadata::_ConnectionConfig_default_instance_);
}
inline const ::ml_metadata::ConnectionConfig& MetadataStoreServerConfig::connection_config() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreServerConfig.connection_config)
  return _internal_connection_config();
}
inline void MetadataStoreServerConfig::unsafe_arena_set_allocated_connection_config(
    ::ml_metadata::ConnectionConfig* connection_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connection_config_);
  }
  _impl_.connection_config_ = connection_config;
  if (connection_config) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.MetadataStoreServerConfig.connection_config)
}
inline ::ml_metadata::ConnectionConfig* MetadataStoreServerConfig::release_connection_config() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::ConnectionConfig* temp = _impl_.connection_config_;
  _impl_.connection_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::ConnectionConfig* MetadataStoreServerConfig::unsafe_arena_release_connection_config() {
  // @@protoc_insertion_point(field_release:ml_metadata.MetadataStoreServerConfig.connection_config)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::ConnectionConfig* temp = _impl_.connection_config_;
  _impl_.connection_config_ = nullptr;
  return temp;
}
inline ::ml_metadata::ConnectionConfig* MetadataStoreServerConfig::_internal_mutable_connection_config() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.connection_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::ConnectionConfig>(GetArenaForAllocation());
    _impl_.connection_config_ = p;
  }
  return _impl_.connection_config_;
}
inline ::ml_metadata::ConnectionConfig* MetadataStoreServerConfig::mutable_connection_config() {
  ::ml_metadata::ConnectionConfig* _msg = _internal_mutable_connection_config();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MetadataStoreServerConfig.connection_config)
  return _msg;
}
inline void MetadataStoreServerConfig::set_allocated_connection_config(::ml_metadata::ConnectionConfig* connection_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.connection_config_;
  }
  if (connection_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connection_config);
    if (message_arena != submessage_arena) {
      connection_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.connection_config_ = connection_config;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MetadataStoreServerConfig.connection_config)
}

// optional .ml_metadata.MigrationOptions migration_options = 3;
inline bool MetadataStoreServerConfig::_internal_has_migration_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.migration_options_ != nullptr);
  return value;
}
inline bool MetadataStoreServerConfig::has_migration_options() const {
  return _internal_has_migration_options();
}
inline void MetadataStoreServerConfig::clear_migration_options() {
  if (_impl_.migration_options_ != nullptr) _impl_.migration_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ml_metadata::MigrationOptions& MetadataStoreServerConfig::_internal_migration_options() const {
  const ::ml_metadata::MigrationOptions* p = _impl_.migration_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::MigrationOptions&>(
      ::ml_metadata::_MigrationOptions_default_instance_);
}
inline const ::ml_metadata::MigrationOptions& MetadataStoreServerConfig::migration_options() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreServerConfig.migration_options)
  return _internal_migration_options();
}
inline void MetadataStoreServerConfig::unsafe_arena_set_allocated_migration_options(
    ::ml_metadata::MigrationOptions* migration_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.migration_options_);
  }
  _impl_.migration_options_ = migration_options;
  if (migration_options) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.MetadataStoreServerConfig.migration_options)
}
inline ::ml_metadata::MigrationOptions* MetadataStoreServerConfig::release_migration_options() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ml_metadata::MigrationOptions* temp = _impl_.migration_options_;
  _impl_.migration_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::MigrationOptions* MetadataStoreServerConfig::unsafe_arena_release_migration_options() {
  // @@protoc_insertion_point(field_release:ml_metadata.MetadataStoreServerConfig.migration_options)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ml_metadata::MigrationOptions* temp = _impl_.migration_options_;
  _impl_.migration_options_ = nullptr;
  return temp;
}
inline ::ml_metadata::MigrationOptions* MetadataStoreServerConfig::_internal_mutable_migration_options() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.migration_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::MigrationOptions>(GetArenaForAllocation());
    _impl_.migration_options_ = p;
  }
  return _impl_.migration_options_;
}
inline ::ml_metadata::MigrationOptions* MetadataStoreServerConfig::mutable_migration_options() {
  ::ml_metadata::MigrationOptions* _msg = _internal_mutable_migration_options();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MetadataStoreServerConfig.migration_options)
  return _msg;
}
inline void MetadataStoreServerConfig::set_allocated_migration_options(::ml_metadata::MigrationOptions* migration_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.migration_options_;
  }
  if (migration_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(migration_options);
    if (message_arena != submessage_arena) {
      migration_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, migration_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.migration_options_ = migration_options;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MetadataStoreServerConfig.migration_options)
}

// optional .ml_metadata.MetadataStoreServerConfig.SSLConfig ssl_config = 2;
inline bool MetadataStoreServerConfig::_internal_has_ssl_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ssl_config_ != nullptr);
  return value;
}
inline bool MetadataStoreServerConfig::has_ssl_config() const {
  return _internal_has_ssl_config();
}
inline void MetadataStoreServerConfig::clear_ssl_config() {
  if (_impl_.ssl_config_ != nullptr) _impl_.ssl_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ml_metadata::MetadataStoreServerConfig_SSLConfig& MetadataStoreServerConfig::_internal_ssl_config() const {
  const ::ml_metadata::MetadataStoreServerConfig_SSLConfig* p = _impl_.ssl_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::MetadataStoreServerConfig_SSLConfig&>(
      ::ml_metadata::_MetadataStoreServerConfig_SSLConfig_default_instance_);
}
inline const ::ml_metadata::MetadataStoreServerConfig_SSLConfig& MetadataStoreServerConfig::ssl_config() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MetadataStoreServerConfig.ssl_config)
  return _internal_ssl_config();
}
inline void MetadataStoreServerConfig::unsafe_arena_set_allocated_ssl_config(
    ::ml_metadata::MetadataStoreServerConfig_SSLConfig* ssl_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ssl_config_);
  }
  _impl_.ssl_config_ = ssl_config;
  if (ssl_config) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.MetadataStoreServerConfig.ssl_config)
}
inline ::ml_metadata::MetadataStoreServerConfig_SSLConfig* MetadataStoreServerConfig::release_ssl_config() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ml_metadata::MetadataStoreServerConfig_SSLConfig* temp = _impl_.ssl_config_;
  _impl_.ssl_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::MetadataStoreServerConfig_SSLConfig* MetadataStoreServerConfig::unsafe_arena_release_ssl_config() {
  // @@protoc_insertion_point(field_release:ml_metadata.MetadataStoreServerConfig.ssl_config)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ml_metadata::MetadataStoreServerConfig_SSLConfig* temp = _impl_.ssl_config_;
  _impl_.ssl_config_ = nullptr;
  return temp;
}
inline ::ml_metadata::MetadataStoreServerConfig_SSLConfig* MetadataStoreServerConfig::_internal_mutable_ssl_config() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ssl_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::MetadataStoreServerConfig_SSLConfig>(GetArenaForAllocation());
    _impl_.ssl_config_ = p;
  }
  return _impl_.ssl_config_;
}
inline ::ml_metadata::MetadataStoreServerConfig_SSLConfig* MetadataStoreServerConfig::mutable_ssl_config() {
  ::ml_metadata::MetadataStoreServerConfig_SSLConfig* _msg = _internal_mutable_ssl_config();
  // @@protoc_insertion_point(field_mutable:ml_metadata.MetadataStoreServerConfig.ssl_config)
  return _msg;
}
inline void MetadataStoreServerConfig::set_allocated_ssl_config(::ml_metadata::MetadataStoreServerConfig_SSLConfig* ssl_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ssl_config_;
  }
  if (ssl_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ssl_config);
    if (message_arena != submessage_arena) {
      ssl_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ssl_config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ssl_config_ = ssl_config;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MetadataStoreServerConfig.ssl_config)
}

// -------------------------------------------------------------------

// ListOperationOptions_OrderByField

// optional .ml_metadata.ListOperationOptions.OrderByField.Field field = 1 [default = ID];
inline bool ListOperationOptions_OrderByField::_internal_has_field() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListOperationOptions_OrderByField::has_field() const {
  return _internal_has_field();
}
inline void ListOperationOptions_OrderByField::clear_field() {
  _impl_.field_ = 3;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::ml_metadata::ListOperationOptions_OrderByField_Field ListOperationOptions_OrderByField::_internal_field() const {
  return static_cast< ::ml_metadata::ListOperationOptions_OrderByField_Field >(_impl_.field_);
}
inline ::ml_metadata::ListOperationOptions_OrderByField_Field ListOperationOptions_OrderByField::field() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ListOperationOptions.OrderByField.field)
  return _internal_field();
}
inline void ListOperationOptions_OrderByField::_internal_set_field(::ml_metadata::ListOperationOptions_OrderByField_Field value) {
  assert(::ml_metadata::ListOperationOptions_OrderByField_Field_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.field_ = value;
}
inline void ListOperationOptions_OrderByField::set_field(::ml_metadata::ListOperationOptions_OrderByField_Field value) {
  _internal_set_field(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ListOperationOptions.OrderByField.field)
}

// optional bool is_asc = 2 [default = true];
inline bool ListOperationOptions_OrderByField::_internal_has_is_asc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListOperationOptions_OrderByField::has_is_asc() const {
  return _internal_has_is_asc();
}
inline void ListOperationOptions_OrderByField::clear_is_asc() {
  _impl_.is_asc_ = true;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ListOperationOptions_OrderByField::_internal_is_asc() const {
  return _impl_.is_asc_;
}
inline bool ListOperationOptions_OrderByField::is_asc() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ListOperationOptions.OrderByField.is_asc)
  return _internal_is_asc();
}
inline void ListOperationOptions_OrderByField::_internal_set_is_asc(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.is_asc_ = value;
}
inline void ListOperationOptions_OrderByField::set_is_asc(bool value) {
  _internal_set_is_asc(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ListOperationOptions.OrderByField.is_asc)
}

// -------------------------------------------------------------------

// ListOperationOptions

// optional int32 max_result_size = 1 [default = 20];
inline bool ListOperationOptions::_internal_has_max_result_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ListOperationOptions::has_max_result_size() const {
  return _internal_has_max_result_size();
}
inline void ListOperationOptions::clear_max_result_size() {
  _impl_.max_result_size_ = 20;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t ListOperationOptions::_internal_max_result_size() const {
  return _impl_.max_result_size_;
}
inline int32_t ListOperationOptions::max_result_size() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ListOperationOptions.max_result_size)
  return _internal_max_result_size();
}
inline void ListOperationOptions::_internal_set_max_result_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.max_result_size_ = value;
}
inline void ListOperationOptions::set_max_result_size(int32_t value) {
  _internal_set_max_result_size(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ListOperationOptions.max_result_size)
}

// optional .ml_metadata.ListOperationOptions.OrderByField order_by_field = 2;
inline bool ListOperationOptions::_internal_has_order_by_field() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_by_field_ != nullptr);
  return value;
}
inline bool ListOperationOptions::has_order_by_field() const {
  return _internal_has_order_by_field();
}
inline void ListOperationOptions::clear_order_by_field() {
  if (_impl_.order_by_field_ != nullptr) _impl_.order_by_field_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ml_metadata::ListOperationOptions_OrderByField& ListOperationOptions::_internal_order_by_field() const {
  const ::ml_metadata::ListOperationOptions_OrderByField* p = _impl_.order_by_field_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::ListOperationOptions_OrderByField&>(
      ::ml_metadata::_ListOperationOptions_OrderByField_default_instance_);
}
inline const ::ml_metadata::ListOperationOptions_OrderByField& ListOperationOptions::order_by_field() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ListOperationOptions.order_by_field)
  return _internal_order_by_field();
}
inline void ListOperationOptions::unsafe_arena_set_allocated_order_by_field(
    ::ml_metadata::ListOperationOptions_OrderByField* order_by_field) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_by_field_);
  }
  _impl_.order_by_field_ = order_by_field;
  if (order_by_field) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ListOperationOptions.order_by_field)
}
inline ::ml_metadata::ListOperationOptions_OrderByField* ListOperationOptions::release_order_by_field() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ml_metadata::ListOperationOptions_OrderByField* temp = _impl_.order_by_field_;
  _impl_.order_by_field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::ListOperationOptions_OrderByField* ListOperationOptions::unsafe_arena_release_order_by_field() {
  // @@protoc_insertion_point(field_release:ml_metadata.ListOperationOptions.order_by_field)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ml_metadata::ListOperationOptions_OrderByField* temp = _impl_.order_by_field_;
  _impl_.order_by_field_ = nullptr;
  return temp;
}
inline ::ml_metadata::ListOperationOptions_OrderByField* ListOperationOptions::_internal_mutable_order_by_field() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.order_by_field_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::ListOperationOptions_OrderByField>(GetArenaForAllocation());
    _impl_.order_by_field_ = p;
  }
  return _impl_.order_by_field_;
}
inline ::ml_metadata::ListOperationOptions_OrderByField* ListOperationOptions::mutable_order_by_field() {
  ::ml_metadata::ListOperationOptions_OrderByField* _msg = _internal_mutable_order_by_field();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ListOperationOptions.order_by_field)
  return _msg;
}
inline void ListOperationOptions::set_allocated_order_by_field(::ml_metadata::ListOperationOptions_OrderByField* order_by_field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_by_field_;
  }
  if (order_by_field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order_by_field);
    if (message_arena != submessage_arena) {
      order_by_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order_by_field, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.order_by_field_ = order_by_field;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ListOperationOptions.order_by_field)
}

// optional string next_page_token = 3;
inline bool ListOperationOptions::_internal_has_next_page_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListOperationOptions::has_next_page_token() const {
  return _internal_has_next_page_token();
}
inline void ListOperationOptions::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListOperationOptions::next_page_token() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ListOperationOptions.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOperationOptions::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ListOperationOptions.next_page_token)
}
inline std::string* ListOperationOptions::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ListOperationOptions.next_page_token)
  return _s;
}
inline const std::string& ListOperationOptions::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListOperationOptions::_internal_set_next_page_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListOperationOptions::_internal_mutable_next_page_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListOperationOptions::release_next_page_token() {
  // @@protoc_insertion_point(field_release:ml_metadata.ListOperationOptions.next_page_token)
  if (!_internal_has_next_page_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.next_page_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListOperationOptions::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ListOperationOptions.next_page_token)
}

// optional string filter_query = 4;
inline bool ListOperationOptions::_internal_has_filter_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListOperationOptions::has_filter_query() const {
  return _internal_has_filter_query();
}
inline void ListOperationOptions::clear_filter_query() {
  _impl_.filter_query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ListOperationOptions::filter_query() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ListOperationOptions.filter_query)
  return _internal_filter_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOperationOptions::set_filter_query(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.filter_query_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.ListOperationOptions.filter_query)
}
inline std::string* ListOperationOptions::mutable_filter_query() {
  std::string* _s = _internal_mutable_filter_query();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ListOperationOptions.filter_query)
  return _s;
}
inline const std::string& ListOperationOptions::_internal_filter_query() const {
  return _impl_.filter_query_.Get();
}
inline void ListOperationOptions::_internal_set_filter_query(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.filter_query_.Set(value, GetArenaForAllocation());
}
inline std::string* ListOperationOptions::_internal_mutable_filter_query() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.filter_query_.Mutable(GetArenaForAllocation());
}
inline std::string* ListOperationOptions::release_filter_query() {
  // @@protoc_insertion_point(field_release:ml_metadata.ListOperationOptions.filter_query)
  if (!_internal_has_filter_query()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.filter_query_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_query_.IsDefault()) {
    _impl_.filter_query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListOperationOptions::set_allocated_filter_query(std::string* filter_query) {
  if (filter_query != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.filter_query_.SetAllocated(filter_query, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_query_.IsDefault()) {
    _impl_.filter_query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ListOperationOptions.filter_query)
}

// -------------------------------------------------------------------

// ListOperationNextPageToken

// optional int64 id_offset = 1;
inline bool ListOperationNextPageToken::_internal_has_id_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListOperationNextPageToken::has_id_offset() const {
  return _internal_has_id_offset();
}
inline void ListOperationNextPageToken::clear_id_offset() {
  _impl_.id_offset_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t ListOperationNextPageToken::_internal_id_offset() const {
  return _impl_.id_offset_;
}
inline int64_t ListOperationNextPageToken::id_offset() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ListOperationNextPageToken.id_offset)
  return _internal_id_offset();
}
inline void ListOperationNextPageToken::_internal_set_id_offset(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_offset_ = value;
}
inline void ListOperationNextPageToken::set_id_offset(int64_t value) {
  _internal_set_id_offset(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ListOperationNextPageToken.id_offset)
}

// optional int64 field_offset = 2;
inline bool ListOperationNextPageToken::_internal_has_field_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ListOperationNextPageToken::has_field_offset() const {
  return _internal_has_field_offset();
}
inline void ListOperationNextPageToken::clear_field_offset() {
  _impl_.field_offset_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t ListOperationNextPageToken::_internal_field_offset() const {
  return _impl_.field_offset_;
}
inline int64_t ListOperationNextPageToken::field_offset() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ListOperationNextPageToken.field_offset)
  return _internal_field_offset();
}
inline void ListOperationNextPageToken::_internal_set_field_offset(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.field_offset_ = value;
}
inline void ListOperationNextPageToken::set_field_offset(int64_t value) {
  _internal_set_field_offset(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ListOperationNextPageToken.field_offset)
}

// optional .ml_metadata.ListOperationOptions set_options = 3;
inline bool ListOperationNextPageToken::_internal_has_set_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.set_options_ != nullptr);
  return value;
}
inline bool ListOperationNextPageToken::has_set_options() const {
  return _internal_has_set_options();
}
inline void ListOperationNextPageToken::clear_set_options() {
  if (_impl_.set_options_ != nullptr) _impl_.set_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::ListOperationOptions& ListOperationNextPageToken::_internal_set_options() const {
  const ::ml_metadata::ListOperationOptions* p = _impl_.set_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::ListOperationOptions&>(
      ::ml_metadata::_ListOperationOptions_default_instance_);
}
inline const ::ml_metadata::ListOperationOptions& ListOperationNextPageToken::set_options() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ListOperationNextPageToken.set_options)
  return _internal_set_options();
}
inline void ListOperationNextPageToken::unsafe_arena_set_allocated_set_options(
    ::ml_metadata::ListOperationOptions* set_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.set_options_);
  }
  _impl_.set_options_ = set_options;
  if (set_options) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ListOperationNextPageToken.set_options)
}
inline ::ml_metadata::ListOperationOptions* ListOperationNextPageToken::release_set_options() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::ListOperationOptions* temp = _impl_.set_options_;
  _impl_.set_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::ListOperationOptions* ListOperationNextPageToken::unsafe_arena_release_set_options() {
  // @@protoc_insertion_point(field_release:ml_metadata.ListOperationNextPageToken.set_options)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::ListOperationOptions* temp = _impl_.set_options_;
  _impl_.set_options_ = nullptr;
  return temp;
}
inline ::ml_metadata::ListOperationOptions* ListOperationNextPageToken::_internal_mutable_set_options() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.set_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::ListOperationOptions>(GetArenaForAllocation());
    _impl_.set_options_ = p;
  }
  return _impl_.set_options_;
}
inline ::ml_metadata::ListOperationOptions* ListOperationNextPageToken::mutable_set_options() {
  ::ml_metadata::ListOperationOptions* _msg = _internal_mutable_set_options();
  // @@protoc_insertion_point(field_mutable:ml_metadata.ListOperationNextPageToken.set_options)
  return _msg;
}
inline void ListOperationNextPageToken::set_allocated_set_options(::ml_metadata::ListOperationOptions* set_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.set_options_;
  }
  if (set_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_options);
    if (message_arena != submessage_arena) {
      set_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.set_options_ = set_options;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ListOperationNextPageToken.set_options)
}

// repeated int64 listed_ids = 4;
inline int ListOperationNextPageToken::_internal_listed_ids_size() const {
  return _impl_.listed_ids_.size();
}
inline int ListOperationNextPageToken::listed_ids_size() const {
  return _internal_listed_ids_size();
}
inline void ListOperationNextPageToken::clear_listed_ids() {
  _impl_.listed_ids_.Clear();
}
inline int64_t ListOperationNextPageToken::_internal_listed_ids(int index) const {
  return _impl_.listed_ids_.Get(index);
}
inline int64_t ListOperationNextPageToken::listed_ids(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.ListOperationNextPageToken.listed_ids)
  return _internal_listed_ids(index);
}
inline void ListOperationNextPageToken::set_listed_ids(int index, int64_t value) {
  _impl_.listed_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:ml_metadata.ListOperationNextPageToken.listed_ids)
}
inline void ListOperationNextPageToken::_internal_add_listed_ids(int64_t value) {
  _impl_.listed_ids_.Add(value);
}
inline void ListOperationNextPageToken::add_listed_ids(int64_t value) {
  _internal_add_listed_ids(value);
  // @@protoc_insertion_point(field_add:ml_metadata.ListOperationNextPageToken.listed_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ListOperationNextPageToken::_internal_listed_ids() const {
  return _impl_.listed_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ListOperationNextPageToken::listed_ids() const {
  // @@protoc_insertion_point(field_list:ml_metadata.ListOperationNextPageToken.listed_ids)
  return _internal_listed_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ListOperationNextPageToken::_internal_mutable_listed_ids() {
  return &_impl_.listed_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ListOperationNextPageToken::mutable_listed_ids() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.ListOperationNextPageToken.listed_ids)
  return _internal_mutable_listed_ids();
}

// -------------------------------------------------------------------

// TransactionOptions

// optional string tag = 1;
inline bool TransactionOptions::_internal_has_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransactionOptions::has_tag() const {
  return _internal_has_tag();
}
inline void TransactionOptions::clear_tag() {
  _impl_.tag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransactionOptions::tag() const {
  // @@protoc_insertion_point(field_get:ml_metadata.TransactionOptions.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionOptions::set_tag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.TransactionOptions.tag)
}
inline std::string* TransactionOptions::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:ml_metadata.TransactionOptions.tag)
  return _s;
}
inline const std::string& TransactionOptions::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void TransactionOptions::_internal_set_tag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionOptions::_internal_mutable_tag() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionOptions::release_tag() {
  // @@protoc_insertion_point(field_release:ml_metadata.TransactionOptions.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TransactionOptions::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.TransactionOptions.tag)
}

// -------------------------------------------------------------------

// LineageGraphQueryOptions_BoundaryConstraint

// optional int64 max_num_hops = 1;
inline bool LineageGraphQueryOptions_BoundaryConstraint::_internal_has_max_num_hops() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LineageGraphQueryOptions_BoundaryConstraint::has_max_num_hops() const {
  return _internal_has_max_num_hops();
}
inline void LineageGraphQueryOptions_BoundaryConstraint::clear_max_num_hops() {
  _impl_.max_num_hops_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t LineageGraphQueryOptions_BoundaryConstraint::_internal_max_num_hops() const {
  return _impl_.max_num_hops_;
}
inline int64_t LineageGraphQueryOptions_BoundaryConstraint::max_num_hops() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint.max_num_hops)
  return _internal_max_num_hops();
}
inline void LineageGraphQueryOptions_BoundaryConstraint::_internal_set_max_num_hops(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_num_hops_ = value;
}
inline void LineageGraphQueryOptions_BoundaryConstraint::set_max_num_hops(int64_t value) {
  _internal_set_max_num_hops(value);
  // @@protoc_insertion_point(field_set:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint.max_num_hops)
}

// optional string boundary_artifacts = 2;
inline bool LineageGraphQueryOptions_BoundaryConstraint::_internal_has_boundary_artifacts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LineageGraphQueryOptions_BoundaryConstraint::has_boundary_artifacts() const {
  return _internal_has_boundary_artifacts();
}
inline void LineageGraphQueryOptions_BoundaryConstraint::clear_boundary_artifacts() {
  _impl_.boundary_artifacts_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LineageGraphQueryOptions_BoundaryConstraint::boundary_artifacts() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint.boundary_artifacts)
  return _internal_boundary_artifacts();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LineageGraphQueryOptions_BoundaryConstraint::set_boundary_artifacts(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.boundary_artifacts_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint.boundary_artifacts)
}
inline std::string* LineageGraphQueryOptions_BoundaryConstraint::mutable_boundary_artifacts() {
  std::string* _s = _internal_mutable_boundary_artifacts();
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint.boundary_artifacts)
  return _s;
}
inline const std::string& LineageGraphQueryOptions_BoundaryConstraint::_internal_boundary_artifacts() const {
  return _impl_.boundary_artifacts_.Get();
}
inline void LineageGraphQueryOptions_BoundaryConstraint::_internal_set_boundary_artifacts(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.boundary_artifacts_.Set(value, GetArenaForAllocation());
}
inline std::string* LineageGraphQueryOptions_BoundaryConstraint::_internal_mutable_boundary_artifacts() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.boundary_artifacts_.Mutable(GetArenaForAllocation());
}
inline std::string* LineageGraphQueryOptions_BoundaryConstraint::release_boundary_artifacts() {
  // @@protoc_insertion_point(field_release:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint.boundary_artifacts)
  if (!_internal_has_boundary_artifacts()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.boundary_artifacts_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.boundary_artifacts_.IsDefault()) {
    _impl_.boundary_artifacts_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LineageGraphQueryOptions_BoundaryConstraint::set_allocated_boundary_artifacts(std::string* boundary_artifacts) {
  if (boundary_artifacts != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.boundary_artifacts_.SetAllocated(boundary_artifacts, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.boundary_artifacts_.IsDefault()) {
    _impl_.boundary_artifacts_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint.boundary_artifacts)
}

// optional string boundary_executions = 3;
inline bool LineageGraphQueryOptions_BoundaryConstraint::_internal_has_boundary_executions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LineageGraphQueryOptions_BoundaryConstraint::has_boundary_executions() const {
  return _internal_has_boundary_executions();
}
inline void LineageGraphQueryOptions_BoundaryConstraint::clear_boundary_executions() {
  _impl_.boundary_executions_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LineageGraphQueryOptions_BoundaryConstraint::boundary_executions() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint.boundary_executions)
  return _internal_boundary_executions();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LineageGraphQueryOptions_BoundaryConstraint::set_boundary_executions(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.boundary_executions_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint.boundary_executions)
}
inline std::string* LineageGraphQueryOptions_BoundaryConstraint::mutable_boundary_executions() {
  std::string* _s = _internal_mutable_boundary_executions();
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint.boundary_executions)
  return _s;
}
inline const std::string& LineageGraphQueryOptions_BoundaryConstraint::_internal_boundary_executions() const {
  return _impl_.boundary_executions_.Get();
}
inline void LineageGraphQueryOptions_BoundaryConstraint::_internal_set_boundary_executions(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.boundary_executions_.Set(value, GetArenaForAllocation());
}
inline std::string* LineageGraphQueryOptions_BoundaryConstraint::_internal_mutable_boundary_executions() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.boundary_executions_.Mutable(GetArenaForAllocation());
}
inline std::string* LineageGraphQueryOptions_BoundaryConstraint::release_boundary_executions() {
  // @@protoc_insertion_point(field_release:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint.boundary_executions)
  if (!_internal_has_boundary_executions()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.boundary_executions_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.boundary_executions_.IsDefault()) {
    _impl_.boundary_executions_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LineageGraphQueryOptions_BoundaryConstraint::set_allocated_boundary_executions(std::string* boundary_executions) {
  if (boundary_executions != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.boundary_executions_.SetAllocated(boundary_executions, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.boundary_executions_.IsDefault()) {
    _impl_.boundary_executions_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.LineageGraphQueryOptions.BoundaryConstraint.boundary_executions)
}

// -------------------------------------------------------------------

// LineageGraphQueryOptions

// .ml_metadata.ListOperationOptions artifacts_options = 1;
inline bool LineageGraphQueryOptions::_internal_has_artifacts_options() const {
  return query_nodes_case() == kArtifactsOptions;
}
inline bool LineageGraphQueryOptions::has_artifacts_options() const {
  return _internal_has_artifacts_options();
}
inline void LineageGraphQueryOptions::set_has_artifacts_options() {
  _impl_._oneof_case_[0] = kArtifactsOptions;
}
inline void LineageGraphQueryOptions::clear_artifacts_options() {
  if (_internal_has_artifacts_options()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_nodes_.artifacts_options_;
    }
    clear_has_query_nodes();
  }
}
inline ::ml_metadata::ListOperationOptions* LineageGraphQueryOptions::release_artifacts_options() {
  // @@protoc_insertion_point(field_release:ml_metadata.LineageGraphQueryOptions.artifacts_options)
  if (_internal_has_artifacts_options()) {
    clear_has_query_nodes();
    ::ml_metadata::ListOperationOptions* temp = _impl_.query_nodes_.artifacts_options_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_nodes_.artifacts_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::ListOperationOptions& LineageGraphQueryOptions::_internal_artifacts_options() const {
  return _internal_has_artifacts_options()
      ? *_impl_.query_nodes_.artifacts_options_
      : reinterpret_cast< ::ml_metadata::ListOperationOptions&>(::ml_metadata::_ListOperationOptions_default_instance_);
}
inline const ::ml_metadata::ListOperationOptions& LineageGraphQueryOptions::artifacts_options() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraphQueryOptions.artifacts_options)
  return _internal_artifacts_options();
}
inline ::ml_metadata::ListOperationOptions* LineageGraphQueryOptions::unsafe_arena_release_artifacts_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.LineageGraphQueryOptions.artifacts_options)
  if (_internal_has_artifacts_options()) {
    clear_has_query_nodes();
    ::ml_metadata::ListOperationOptions* temp = _impl_.query_nodes_.artifacts_options_;
    _impl_.query_nodes_.artifacts_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LineageGraphQueryOptions::unsafe_arena_set_allocated_artifacts_options(::ml_metadata::ListOperationOptions* artifacts_options) {
  clear_query_nodes();
  if (artifacts_options) {
    set_has_artifacts_options();
    _impl_.query_nodes_.artifacts_options_ = artifacts_options;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.LineageGraphQueryOptions.artifacts_options)
}
inline ::ml_metadata::ListOperationOptions* LineageGraphQueryOptions::_internal_mutable_artifacts_options() {
  if (!_internal_has_artifacts_options()) {
    clear_query_nodes();
    set_has_artifacts_options();
    _impl_.query_nodes_.artifacts_options_ = CreateMaybeMessage< ::ml_metadata::ListOperationOptions >(GetArenaForAllocation());
  }
  return _impl_.query_nodes_.artifacts_options_;
}
inline ::ml_metadata::ListOperationOptions* LineageGraphQueryOptions::mutable_artifacts_options() {
  ::ml_metadata::ListOperationOptions* _msg = _internal_mutable_artifacts_options();
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraphQueryOptions.artifacts_options)
  return _msg;
}

// optional .ml_metadata.LineageGraphQueryOptions.BoundaryConstraint stop_conditions = 2;
inline bool LineageGraphQueryOptions::_internal_has_stop_conditions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_conditions_ != nullptr);
  return value;
}
inline bool LineageGraphQueryOptions::has_stop_conditions() const {
  return _internal_has_stop_conditions();
}
inline void LineageGraphQueryOptions::clear_stop_conditions() {
  if (_impl_.stop_conditions_ != nullptr) _impl_.stop_conditions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint& LineageGraphQueryOptions::_internal_stop_conditions() const {
  const ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* p = _impl_.stop_conditions_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint&>(
      ::ml_metadata::_LineageGraphQueryOptions_BoundaryConstraint_default_instance_);
}
inline const ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint& LineageGraphQueryOptions::stop_conditions() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraphQueryOptions.stop_conditions)
  return _internal_stop_conditions();
}
inline void LineageGraphQueryOptions::unsafe_arena_set_allocated_stop_conditions(
    ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* stop_conditions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stop_conditions_);
  }
  _impl_.stop_conditions_ = stop_conditions;
  if (stop_conditions) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.LineageGraphQueryOptions.stop_conditions)
}
inline ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* LineageGraphQueryOptions::release_stop_conditions() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* temp = _impl_.stop_conditions_;
  _impl_.stop_conditions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* LineageGraphQueryOptions::unsafe_arena_release_stop_conditions() {
  // @@protoc_insertion_point(field_release:ml_metadata.LineageGraphQueryOptions.stop_conditions)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* temp = _impl_.stop_conditions_;
  _impl_.stop_conditions_ = nullptr;
  return temp;
}
inline ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* LineageGraphQueryOptions::_internal_mutable_stop_conditions() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stop_conditions_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint>(GetArenaForAllocation());
    _impl_.stop_conditions_ = p;
  }
  return _impl_.stop_conditions_;
}
inline ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* LineageGraphQueryOptions::mutable_stop_conditions() {
  ::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* _msg = _internal_mutable_stop_conditions();
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageGraphQueryOptions.stop_conditions)
  return _msg;
}
inline void LineageGraphQueryOptions::set_allocated_stop_conditions(::ml_metadata::LineageGraphQueryOptions_BoundaryConstraint* stop_conditions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stop_conditions_;
  }
  if (stop_conditions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stop_conditions);
    if (message_arena != submessage_arena) {
      stop_conditions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_conditions, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stop_conditions_ = stop_conditions;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.LineageGraphQueryOptions.stop_conditions)
}

// optional int64 max_node_size = 3 [default = 20];
inline bool LineageGraphQueryOptions::_internal_has_max_node_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LineageGraphQueryOptions::has_max_node_size() const {
  return _internal_has_max_node_size();
}
inline void LineageGraphQueryOptions::clear_max_node_size() {
  _impl_.max_node_size_ = int64_t{20};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t LineageGraphQueryOptions::_internal_max_node_size() const {
  return _impl_.max_node_size_;
}
inline int64_t LineageGraphQueryOptions::max_node_size() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageGraphQueryOptions.max_node_size)
  return _internal_max_node_size();
}
inline void LineageGraphQueryOptions::_internal_set_max_node_size(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_node_size_ = value;
}
inline void LineageGraphQueryOptions::set_max_node_size(int64_t value) {
  _internal_set_max_node_size(value);
  // @@protoc_insertion_point(field_set:ml_metadata.LineageGraphQueryOptions.max_node_size)
}

inline bool LineageGraphQueryOptions::has_query_nodes() const {
  return query_nodes_case() != QUERY_NODES_NOT_SET;
}
inline void LineageGraphQueryOptions::clear_has_query_nodes() {
  _impl_._oneof_case_[0] = QUERY_NODES_NOT_SET;
}
inline LineageGraphQueryOptions::QueryNodesCase LineageGraphQueryOptions::query_nodes_case() const {
  return LineageGraphQueryOptions::QueryNodesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LineageSubgraphQueryOptions_StartingNodes

// optional string filter_query = 1;
inline bool LineageSubgraphQueryOptions_StartingNodes::_internal_has_filter_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LineageSubgraphQueryOptions_StartingNodes::has_filter_query() const {
  return _internal_has_filter_query();
}
inline void LineageSubgraphQueryOptions_StartingNodes::clear_filter_query() {
  _impl_.filter_query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LineageSubgraphQueryOptions_StartingNodes::filter_query() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageSubgraphQueryOptions.StartingNodes.filter_query)
  return _internal_filter_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LineageSubgraphQueryOptions_StartingNodes::set_filter_query(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filter_query_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.LineageSubgraphQueryOptions.StartingNodes.filter_query)
}
inline std::string* LineageSubgraphQueryOptions_StartingNodes::mutable_filter_query() {
  std::string* _s = _internal_mutable_filter_query();
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageSubgraphQueryOptions.StartingNodes.filter_query)
  return _s;
}
inline const std::string& LineageSubgraphQueryOptions_StartingNodes::_internal_filter_query() const {
  return _impl_.filter_query_.Get();
}
inline void LineageSubgraphQueryOptions_StartingNodes::_internal_set_filter_query(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filter_query_.Set(value, GetArenaForAllocation());
}
inline std::string* LineageSubgraphQueryOptions_StartingNodes::_internal_mutable_filter_query() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filter_query_.Mutable(GetArenaForAllocation());
}
inline std::string* LineageSubgraphQueryOptions_StartingNodes::release_filter_query() {
  // @@protoc_insertion_point(field_release:ml_metadata.LineageSubgraphQueryOptions.StartingNodes.filter_query)
  if (!_internal_has_filter_query()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filter_query_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_query_.IsDefault()) {
    _impl_.filter_query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LineageSubgraphQueryOptions_StartingNodes::set_allocated_filter_query(std::string* filter_query) {
  if (filter_query != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filter_query_.SetAllocated(filter_query, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_query_.IsDefault()) {
    _impl_.filter_query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.LineageSubgraphQueryOptions.StartingNodes.filter_query)
}

// -------------------------------------------------------------------

// LineageSubgraphQueryOptions_EndingNodes

// optional string filter_query = 1;
inline bool LineageSubgraphQueryOptions_EndingNodes::_internal_has_filter_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LineageSubgraphQueryOptions_EndingNodes::has_filter_query() const {
  return _internal_has_filter_query();
}
inline void LineageSubgraphQueryOptions_EndingNodes::clear_filter_query() {
  _impl_.filter_query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LineageSubgraphQueryOptions_EndingNodes::filter_query() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageSubgraphQueryOptions.EndingNodes.filter_query)
  return _internal_filter_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LineageSubgraphQueryOptions_EndingNodes::set_filter_query(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filter_query_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ml_metadata.LineageSubgraphQueryOptions.EndingNodes.filter_query)
}
inline std::string* LineageSubgraphQueryOptions_EndingNodes::mutable_filter_query() {
  std::string* _s = _internal_mutable_filter_query();
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageSubgraphQueryOptions.EndingNodes.filter_query)
  return _s;
}
inline const std::string& LineageSubgraphQueryOptions_EndingNodes::_internal_filter_query() const {
  return _impl_.filter_query_.Get();
}
inline void LineageSubgraphQueryOptions_EndingNodes::_internal_set_filter_query(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filter_query_.Set(value, GetArenaForAllocation());
}
inline std::string* LineageSubgraphQueryOptions_EndingNodes::_internal_mutable_filter_query() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filter_query_.Mutable(GetArenaForAllocation());
}
inline std::string* LineageSubgraphQueryOptions_EndingNodes::release_filter_query() {
  // @@protoc_insertion_point(field_release:ml_metadata.LineageSubgraphQueryOptions.EndingNodes.filter_query)
  if (!_internal_has_filter_query()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filter_query_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_query_.IsDefault()) {
    _impl_.filter_query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LineageSubgraphQueryOptions_EndingNodes::set_allocated_filter_query(std::string* filter_query) {
  if (filter_query != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filter_query_.SetAllocated(filter_query, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_query_.IsDefault()) {
    _impl_.filter_query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.LineageSubgraphQueryOptions.EndingNodes.filter_query)
}

// optional bool include_ending_nodes = 2 [default = false];
inline bool LineageSubgraphQueryOptions_EndingNodes::_internal_has_include_ending_nodes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LineageSubgraphQueryOptions_EndingNodes::has_include_ending_nodes() const {
  return _internal_has_include_ending_nodes();
}
inline void LineageSubgraphQueryOptions_EndingNodes::clear_include_ending_nodes() {
  _impl_.include_ending_nodes_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool LineageSubgraphQueryOptions_EndingNodes::_internal_include_ending_nodes() const {
  return _impl_.include_ending_nodes_;
}
inline bool LineageSubgraphQueryOptions_EndingNodes::include_ending_nodes() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageSubgraphQueryOptions.EndingNodes.include_ending_nodes)
  return _internal_include_ending_nodes();
}
inline void LineageSubgraphQueryOptions_EndingNodes::_internal_set_include_ending_nodes(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.include_ending_nodes_ = value;
}
inline void LineageSubgraphQueryOptions_EndingNodes::set_include_ending_nodes(bool value) {
  _internal_set_include_ending_nodes(value);
  // @@protoc_insertion_point(field_set:ml_metadata.LineageSubgraphQueryOptions.EndingNodes.include_ending_nodes)
}

// -------------------------------------------------------------------

// LineageSubgraphQueryOptions

// .ml_metadata.LineageSubgraphQueryOptions.StartingNodes starting_artifacts = 1;
inline bool LineageSubgraphQueryOptions::_internal_has_starting_artifacts() const {
  return starting_nodes_case() == kStartingArtifacts;
}
inline bool LineageSubgraphQueryOptions::has_starting_artifacts() const {
  return _internal_has_starting_artifacts();
}
inline void LineageSubgraphQueryOptions::set_has_starting_artifacts() {
  _impl_._oneof_case_[0] = kStartingArtifacts;
}
inline void LineageSubgraphQueryOptions::clear_starting_artifacts() {
  if (_internal_has_starting_artifacts()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.starting_nodes_.starting_artifacts_;
    }
    clear_has_starting_nodes();
  }
}
inline ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* LineageSubgraphQueryOptions::release_starting_artifacts() {
  // @@protoc_insertion_point(field_release:ml_metadata.LineageSubgraphQueryOptions.starting_artifacts)
  if (_internal_has_starting_artifacts()) {
    clear_has_starting_nodes();
    ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* temp = _impl_.starting_nodes_.starting_artifacts_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.starting_nodes_.starting_artifacts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes& LineageSubgraphQueryOptions::_internal_starting_artifacts() const {
  return _internal_has_starting_artifacts()
      ? *_impl_.starting_nodes_.starting_artifacts_
      : reinterpret_cast< ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes&>(::ml_metadata::_LineageSubgraphQueryOptions_StartingNodes_default_instance_);
}
inline const ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes& LineageSubgraphQueryOptions::starting_artifacts() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageSubgraphQueryOptions.starting_artifacts)
  return _internal_starting_artifacts();
}
inline ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* LineageSubgraphQueryOptions::unsafe_arena_release_starting_artifacts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.LineageSubgraphQueryOptions.starting_artifacts)
  if (_internal_has_starting_artifacts()) {
    clear_has_starting_nodes();
    ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* temp = _impl_.starting_nodes_.starting_artifacts_;
    _impl_.starting_nodes_.starting_artifacts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LineageSubgraphQueryOptions::unsafe_arena_set_allocated_starting_artifacts(::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* starting_artifacts) {
  clear_starting_nodes();
  if (starting_artifacts) {
    set_has_starting_artifacts();
    _impl_.starting_nodes_.starting_artifacts_ = starting_artifacts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.LineageSubgraphQueryOptions.starting_artifacts)
}
inline ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* LineageSubgraphQueryOptions::_internal_mutable_starting_artifacts() {
  if (!_internal_has_starting_artifacts()) {
    clear_starting_nodes();
    set_has_starting_artifacts();
    _impl_.starting_nodes_.starting_artifacts_ = CreateMaybeMessage< ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes >(GetArenaForAllocation());
  }
  return _impl_.starting_nodes_.starting_artifacts_;
}
inline ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* LineageSubgraphQueryOptions::mutable_starting_artifacts() {
  ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* _msg = _internal_mutable_starting_artifacts();
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageSubgraphQueryOptions.starting_artifacts)
  return _msg;
}

// .ml_metadata.LineageSubgraphQueryOptions.StartingNodes starting_executions = 2;
inline bool LineageSubgraphQueryOptions::_internal_has_starting_executions() const {
  return starting_nodes_case() == kStartingExecutions;
}
inline bool LineageSubgraphQueryOptions::has_starting_executions() const {
  return _internal_has_starting_executions();
}
inline void LineageSubgraphQueryOptions::set_has_starting_executions() {
  _impl_._oneof_case_[0] = kStartingExecutions;
}
inline void LineageSubgraphQueryOptions::clear_starting_executions() {
  if (_internal_has_starting_executions()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.starting_nodes_.starting_executions_;
    }
    clear_has_starting_nodes();
  }
}
inline ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* LineageSubgraphQueryOptions::release_starting_executions() {
  // @@protoc_insertion_point(field_release:ml_metadata.LineageSubgraphQueryOptions.starting_executions)
  if (_internal_has_starting_executions()) {
    clear_has_starting_nodes();
    ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* temp = _impl_.starting_nodes_.starting_executions_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.starting_nodes_.starting_executions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes& LineageSubgraphQueryOptions::_internal_starting_executions() const {
  return _internal_has_starting_executions()
      ? *_impl_.starting_nodes_.starting_executions_
      : reinterpret_cast< ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes&>(::ml_metadata::_LineageSubgraphQueryOptions_StartingNodes_default_instance_);
}
inline const ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes& LineageSubgraphQueryOptions::starting_executions() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageSubgraphQueryOptions.starting_executions)
  return _internal_starting_executions();
}
inline ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* LineageSubgraphQueryOptions::unsafe_arena_release_starting_executions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.LineageSubgraphQueryOptions.starting_executions)
  if (_internal_has_starting_executions()) {
    clear_has_starting_nodes();
    ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* temp = _impl_.starting_nodes_.starting_executions_;
    _impl_.starting_nodes_.starting_executions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LineageSubgraphQueryOptions::unsafe_arena_set_allocated_starting_executions(::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* starting_executions) {
  clear_starting_nodes();
  if (starting_executions) {
    set_has_starting_executions();
    _impl_.starting_nodes_.starting_executions_ = starting_executions;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.LineageSubgraphQueryOptions.starting_executions)
}
inline ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* LineageSubgraphQueryOptions::_internal_mutable_starting_executions() {
  if (!_internal_has_starting_executions()) {
    clear_starting_nodes();
    set_has_starting_executions();
    _impl_.starting_nodes_.starting_executions_ = CreateMaybeMessage< ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes >(GetArenaForAllocation());
  }
  return _impl_.starting_nodes_.starting_executions_;
}
inline ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* LineageSubgraphQueryOptions::mutable_starting_executions() {
  ::ml_metadata::LineageSubgraphQueryOptions_StartingNodes* _msg = _internal_mutable_starting_executions();
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageSubgraphQueryOptions.starting_executions)
  return _msg;
}

// optional int64 max_num_hops = 3;
inline bool LineageSubgraphQueryOptions::_internal_has_max_num_hops() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LineageSubgraphQueryOptions::has_max_num_hops() const {
  return _internal_has_max_num_hops();
}
inline void LineageSubgraphQueryOptions::clear_max_num_hops() {
  _impl_.max_num_hops_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t LineageSubgraphQueryOptions::_internal_max_num_hops() const {
  return _impl_.max_num_hops_;
}
inline int64_t LineageSubgraphQueryOptions::max_num_hops() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageSubgraphQueryOptions.max_num_hops)
  return _internal_max_num_hops();
}
inline void LineageSubgraphQueryOptions::_internal_set_max_num_hops(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_num_hops_ = value;
}
inline void LineageSubgraphQueryOptions::set_max_num_hops(int64_t value) {
  _internal_set_max_num_hops(value);
  // @@protoc_insertion_point(field_set:ml_metadata.LineageSubgraphQueryOptions.max_num_hops)
}

// optional .ml_metadata.LineageSubgraphQueryOptions.Direction direction = 4;
inline bool LineageSubgraphQueryOptions::_internal_has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LineageSubgraphQueryOptions::has_direction() const {
  return _internal_has_direction();
}
inline void LineageSubgraphQueryOptions::clear_direction() {
  _impl_.direction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::ml_metadata::LineageSubgraphQueryOptions_Direction LineageSubgraphQueryOptions::_internal_direction() const {
  return static_cast< ::ml_metadata::LineageSubgraphQueryOptions_Direction >(_impl_.direction_);
}
inline ::ml_metadata::LineageSubgraphQueryOptions_Direction LineageSubgraphQueryOptions::direction() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageSubgraphQueryOptions.direction)
  return _internal_direction();
}
inline void LineageSubgraphQueryOptions::_internal_set_direction(::ml_metadata::LineageSubgraphQueryOptions_Direction value) {
  assert(::ml_metadata::LineageSubgraphQueryOptions_Direction_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.direction_ = value;
}
inline void LineageSubgraphQueryOptions::set_direction(::ml_metadata::LineageSubgraphQueryOptions_Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:ml_metadata.LineageSubgraphQueryOptions.direction)
}

// optional .ml_metadata.LineageSubgraphQueryOptions.EndingNodes ending_artifacts = 5;
inline bool LineageSubgraphQueryOptions::_internal_has_ending_artifacts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ending_artifacts_ != nullptr);
  return value;
}
inline bool LineageSubgraphQueryOptions::has_ending_artifacts() const {
  return _internal_has_ending_artifacts();
}
inline void LineageSubgraphQueryOptions::clear_ending_artifacts() {
  if (_impl_.ending_artifacts_ != nullptr) _impl_.ending_artifacts_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes& LineageSubgraphQueryOptions::_internal_ending_artifacts() const {
  const ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* p = _impl_.ending_artifacts_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes&>(
      ::ml_metadata::_LineageSubgraphQueryOptions_EndingNodes_default_instance_);
}
inline const ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes& LineageSubgraphQueryOptions::ending_artifacts() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageSubgraphQueryOptions.ending_artifacts)
  return _internal_ending_artifacts();
}
inline void LineageSubgraphQueryOptions::unsafe_arena_set_allocated_ending_artifacts(
    ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* ending_artifacts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ending_artifacts_);
  }
  _impl_.ending_artifacts_ = ending_artifacts;
  if (ending_artifacts) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.LineageSubgraphQueryOptions.ending_artifacts)
}
inline ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* LineageSubgraphQueryOptions::release_ending_artifacts() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* temp = _impl_.ending_artifacts_;
  _impl_.ending_artifacts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* LineageSubgraphQueryOptions::unsafe_arena_release_ending_artifacts() {
  // @@protoc_insertion_point(field_release:ml_metadata.LineageSubgraphQueryOptions.ending_artifacts)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* temp = _impl_.ending_artifacts_;
  _impl_.ending_artifacts_ = nullptr;
  return temp;
}
inline ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* LineageSubgraphQueryOptions::_internal_mutable_ending_artifacts() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ending_artifacts_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::LineageSubgraphQueryOptions_EndingNodes>(GetArenaForAllocation());
    _impl_.ending_artifacts_ = p;
  }
  return _impl_.ending_artifacts_;
}
inline ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* LineageSubgraphQueryOptions::mutable_ending_artifacts() {
  ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* _msg = _internal_mutable_ending_artifacts();
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageSubgraphQueryOptions.ending_artifacts)
  return _msg;
}
inline void LineageSubgraphQueryOptions::set_allocated_ending_artifacts(::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* ending_artifacts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ending_artifacts_;
  }
  if (ending_artifacts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ending_artifacts);
    if (message_arena != submessage_arena) {
      ending_artifacts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ending_artifacts, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ending_artifacts_ = ending_artifacts;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.LineageSubgraphQueryOptions.ending_artifacts)
}

// optional .ml_metadata.LineageSubgraphQueryOptions.EndingNodes ending_executions = 6;
inline bool LineageSubgraphQueryOptions::_internal_has_ending_executions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ending_executions_ != nullptr);
  return value;
}
inline bool LineageSubgraphQueryOptions::has_ending_executions() const {
  return _internal_has_ending_executions();
}
inline void LineageSubgraphQueryOptions::clear_ending_executions() {
  if (_impl_.ending_executions_ != nullptr) _impl_.ending_executions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes& LineageSubgraphQueryOptions::_internal_ending_executions() const {
  const ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* p = _impl_.ending_executions_;
  return p != nullptr ? *p : reinterpret_cast<const ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes&>(
      ::ml_metadata::_LineageSubgraphQueryOptions_EndingNodes_default_instance_);
}
inline const ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes& LineageSubgraphQueryOptions::ending_executions() const {
  // @@protoc_insertion_point(field_get:ml_metadata.LineageSubgraphQueryOptions.ending_executions)
  return _internal_ending_executions();
}
inline void LineageSubgraphQueryOptions::unsafe_arena_set_allocated_ending_executions(
    ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* ending_executions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ending_executions_);
  }
  _impl_.ending_executions_ = ending_executions;
  if (ending_executions) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.LineageSubgraphQueryOptions.ending_executions)
}
inline ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* LineageSubgraphQueryOptions::release_ending_executions() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* temp = _impl_.ending_executions_;
  _impl_.ending_executions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* LineageSubgraphQueryOptions::unsafe_arena_release_ending_executions() {
  // @@protoc_insertion_point(field_release:ml_metadata.LineageSubgraphQueryOptions.ending_executions)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* temp = _impl_.ending_executions_;
  _impl_.ending_executions_ = nullptr;
  return temp;
}
inline ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* LineageSubgraphQueryOptions::_internal_mutable_ending_executions() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ending_executions_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::LineageSubgraphQueryOptions_EndingNodes>(GetArenaForAllocation());
    _impl_.ending_executions_ = p;
  }
  return _impl_.ending_executions_;
}
inline ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* LineageSubgraphQueryOptions::mutable_ending_executions() {
  ::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* _msg = _internal_mutable_ending_executions();
  // @@protoc_insertion_point(field_mutable:ml_metadata.LineageSubgraphQueryOptions.ending_executions)
  return _msg;
}
inline void LineageSubgraphQueryOptions::set_allocated_ending_executions(::ml_metadata::LineageSubgraphQueryOptions_EndingNodes* ending_executions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ending_executions_;
  }
  if (ending_executions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ending_executions);
    if (message_arena != submessage_arena) {
      ending_executions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ending_executions, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ending_executions_ = ending_executions;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.LineageSubgraphQueryOptions.ending_executions)
}

inline bool LineageSubgraphQueryOptions::has_starting_nodes() const {
  return starting_nodes_case() != STARTING_NODES_NOT_SET;
}
inline void LineageSubgraphQueryOptions::clear_has_starting_nodes() {
  _impl_._oneof_case_[0] = STARTING_NODES_NOT_SET;
}
inline LineageSubgraphQueryOptions::StartingNodesCase LineageSubgraphQueryOptions::starting_nodes_case() const {
  return LineageSubgraphQueryOptions::StartingNodesCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ml_metadata

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ml_metadata::Artifact_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::Artifact_State>() {
  return ::ml_metadata::Artifact_State_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::ArtifactType_SystemDefinedBaseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::ArtifactType_SystemDefinedBaseType>() {
  return ::ml_metadata::ArtifactType_SystemDefinedBaseType_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::Event_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::Event_Type>() {
  return ::ml_metadata::Event_Type_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::Execution_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::Execution_State>() {
  return ::ml_metadata::Execution_State_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::ExecutionType_SystemDefinedBaseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::ExecutionType_SystemDefinedBaseType>() {
  return ::ml_metadata::ExecutionType_SystemDefinedBaseType_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::ContextType_SystemDefinedBaseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::ContextType_SystemDefinedBaseType>() {
  return ::ml_metadata::ContextType_SystemDefinedBaseType_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::SqliteMetadataSourceConfig_ConnectionMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::SqliteMetadataSourceConfig_ConnectionMode>() {
  return ::ml_metadata::SqliteMetadataSourceConfig_ConnectionMode_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::ListOperationOptions_OrderByField_Field> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::ListOperationOptions_OrderByField_Field>() {
  return ::ml_metadata::ListOperationOptions_OrderByField_Field_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::LineageSubgraphQueryOptions_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::LineageSubgraphQueryOptions_Direction>() {
  return ::ml_metadata::LineageSubgraphQueryOptions_Direction_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::PropertyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::PropertyType>() {
  return ::ml_metadata::PropertyType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ml_5fmetadata_2fproto_2fmetadata_5fstore_2eproto
